{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Get the part of the array before the index\n    part1 = arr.get_part(0, index)\n    \n    # Get the part of the array after the index\n    part2 = arr.get_part(index + 1, arr.size() - index - 1)\n    \n    # Concatenate part1 and part2\n    new_arr = part1.concat(part2)\n    \n    # Append the element at the original index to the end\n    new_arr = new_arr.concat(arr.get_part(index, 1))\n    \n    return new_arr\n", "response_1": "def move_to_end(arr, index):\n    # Extract parts of the array\n    part1 = arr.get_part(0, index)\n    part2 = arr.get_part(index + 1, len(arr) - (index + 1))\n    part3 = arr.get_part(index, 1)\n    \n    # Concatenate the parts to form the new array\n    new_arr = part1.concat(part2).concat(part3)\n    \n    return new_arr\n", "model_name": "qwen-qwq"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint, Array\n", "response_1": "def second_largest(arr):\n    length = len(arr)\n    for i in for_range(start=2, end=length):\n        is_arr0_smaller = arr[0] < arr[1]\n        min_val = is_arr0_smaller.if_else(arr[0], arr[1])\n        update_condition = arr[i] > min_val\n        update_val = update_condition.if_else(arr[i], min_val)\n        update_arr0 = is_arr0_smaller.if_else(update_val, arr[0])\n        update_arr1 = is_arr0_smaller.if_else(arr[1], update_val)\n        arr[0] = update_arr0\n        arr[1] = update_arr1\n    is_arr0_smaller = arr[0] < arr[1]\n    result = is_arr0_smaller.if_else(arr[0], arr[1])\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "exists_true", "response_0": "from Compiler.GC.types import sbitint\nfrom Compiler.library import tree_reduce\n\ndef exists_true(arr):\n    ret = tree_reduce(lambda x, y: x.bit_or(y), arr)\n    return ret\n", "response_1": "def exists_true(arr):\n    ret = tree_reduce(lambda x, y: x.bit_or(y), arr)\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr: Array, predicator: Callable[[sint], sbit]) -> Array:\n    length = len(arr)\n    ret = Array(length, sbit)\n    for i in range(length):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, pred):\n    n = len(arr)\n    # Assuming pred returns sbitint\n    result = Array(n, sbitint)\n    for i in for_range(n):\n        result[i] = pred(arr[i])\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "inner_product", "response_0": "", "response_1": "def inner_product(vec1, vec2):\n    lst = vec1 * vec2\n    summation = tree_reduce(lambda x, y: x + y, lst)\n    return summation\n", "model_name": "qwen-qwq"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    return a[1:].concat(a[0:1])\n", "response_1": "def array_shift(a):\n    n = a.size\n    if n <= 1:\n        return a\n    else:\n        # Get the part from index 1 to n-1 and concatenate with the part from index 0 to 1\n        return a.get_part(1, n-1).concat(a.get_part(0,1))\n", "model_name": "qwen-qwq"}
{"test_name": "array_greater_than_scalar", "response_0": "", "response_1": "def array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = Array(n, sbitint)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "count_rises_2", "response_0": "", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef count_rises(arr):\n    n = len(arr) - 1\n    flag = Array(n, sint)\n    for i in range(n):\n        flag[i] = (arr[i] < arr[i+1]).bit_or(0)  # Convert comparison to sintbit and then to sint\n    count = tree_reduce(lambda x, y: x + y, flag)\n    return count\n", "model_name": "qwen-qwq"}
{"test_name": "choppy_plus_minus", "response_0": "", "response_1": "if i % 2 == 1:\n\nresult[i] = arr[i] + 1\n\nelse:\n\nresult[i] = arr[i] - 1\n\n", "model_name": "qwen-qwq"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    # Given coefficients a, b and c of a quadratic function,\n    # return the number of its roots.\n    # a, b and c can be zero, but they will not all be zero.\n\n    is_a_zero = (a == 0)\n    is_b_zero = (b == 0)\n    discriminant = b*b - 4*a*c\n    is_d_positive = (discriminant > 0)\n    is_d_zero = (discriminant == 0)\n\n    result_when_a_zero = is_b_zero * 0 + (1 - is_b_zero) * 1\n\n    temp = is_d_positive * 2 + (1 - is_d_positive) * (is_d_zero * 1 + (1 - is_d_zero) * 0)\n\n    result = is_a_zero * result_when_a_zero + (1 - is_a_zero) * temp\n\n    return result\n", "response_1": "def how_many_roots(a, b, c):\n    is_a_zero = (a == sint(0))\n    if_a_zero_result = (b == sint(0)).if_else(sint(0), sint(1))\n    discriminant = b*b - 4*a*c\n    is_discriminant_positive = (discriminant > 0)\n    is_discriminant_zero = (discriminant == 0)\n    if_not_a_zero_result = is_discriminant_positive.if_else(\n        sint(2),\n        is_discriminant_zero.if_else(sint(1), sint(0))\n    )\n    result = is_a_zero.if_else(if_a_zero_result, if_not_a_zero_result)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.util import for_range\nfrom Compiler.array import sum\n\ndef count_satisfied(arr, predicator):\n    n = len(arr)\n    flag = Array(n, sint)\n    for i in range(n):\n        flag[i] = predicator(arr[i])\n    summation = sum(flag)\n    return summation\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.library import tree_reduce\n\ndef traverse_and_sum(arr1, arr2):\n    assert arr1.size == arr2.size, \"Arrays must be of the same length\"\n    products = arr1 * arr2\n    return tree_reduce(lambda x, y: x + y, products)\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    # Assuming arr1 and arr2 are sint.Array instances of the same length\n    products = arr1 * arr2  # Element-wise multiplication\n    total = products.reduce_sum()  # Summing up the products\n    return total\n", "model_name": "qwen-qwq"}
{"test_name": "array_round", "response_0": "def array_round(arr, f):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n\n    Parameters:\n    - arr: Array of sfix elements\n    - f: Number of fractional bits in the sfix type\n\n    Returns:\n    - Array of sint elements representing the rounded values\n    \"\"\"\n    # Create the rounding constant\n    const = sfix(1 << (f - 1))\n    \n    # Perform the rounding operation\n    rounded_arr = (arr + const) >> f\n    \n    return rounded_arr\n", "response_1": "from Compiler.types import sfix, Array\n\ndef array_round(arr):\n\n    \"\"\"\n\n    Round every element in the array to the nearest integer.\n\n    \"\"\"\n\n    rounded_arr = arr.same_shape()\n\n    for i in range(len(arr)):\n\n        rounded_arr[i] = arr[i].round()\n\n    return rounded_arr\n\n", "model_name": "qwen-qwq"}
{"test_name": "array_greater_eq", "response_0": "from Compiler.types import sfix, sint, Array\n\ndef array_greater_eq(arr, brr):\n    ret = (arr >= brr).to_sint()\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    arr = sint.Array.create_from(arr)\n    brr = sint.Array.create_from(brr)\n    ret = arr >= brr\n    ret = ret + sint(0)\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(a):\n    return a < 0\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_subtract_2", "response_0": "", "response_1": "def array_subtract(a, b):\n    result = sint.Array(len(a))\n    result.assign(a - b)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    result = arr.same_shape()\n    for i in range(len(arr)):\n        result[i] = func(arr[i])\n    return result\n", "response_1": "from typing import TypeVar, Callable\nfrom Compiler.types import Array, sint, sfix\n\nT = TypeVar('T', sint, sfix)\n\ndef array_process(arr: Array[T], func: Callable[[T], T]) -> Array[T]:\n    n = arr.size\n    new_arr = Array(n, arr.value_type)\n    for i in mpc.for_range(n):\n        new_arr[i] = func(arr[i])\n    return new_arr\n", "model_name": "qwen-qwq"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    n = a.size()\n    last = a.get_part(n - 1, 1)\n    first_part = a.get_part(0, n - 1)\n    new_a = last.concat(first_part)\n    a.assign(new_a)\n", "response_1": "a = sint.Array([0,1,2])\nshifted_a = array_shift(a)\nprint(shifted_a.reveal())\n", "model_name": "qwen-qwq"}
{"test_name": "compare_and_select", "response_0": "from Compiler.types import sfix, Array\n\ndef compare_and_select(a, b):\n    ret_array = a.max(b)\n    return ret_array\n", "response_1": "from Compiler.types import sint, Array\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    # Ensure a and b are arrays of sint\n    if not isinstance(a, Array) or not isinstance(b, Array):\n        raise TypeError(\"Both a and b must be Array types.\")\n    if a.value_type != b.value_type or not issubclass(a.value_type, sint):\n        raise TypeError(\"Both a and b must be arrays of sint.\")\n    if len(a) != len(b):\n        raise ValueError(\"Arrays a and b must be of the same length.\")\n\n    # Perform element-wise comparison and selection\n    result = a.same_shape()\n    for i in range(len(a)):\n        condition = a[i] > b[i]\n        result[i] = condition.if_else(a[i], b[i])\n\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    assert len(a) == len(b), \"Arrays must be of the same length\"\n    ret = sfix.Array(len(a))\n    for i in range(len(a)):\n        ret[i] = a[i] - b[i]\n    return ret\n", "response_1": "def array_subtract(a, b):\n\n    len_a = len(a)\n\n    len_b = len(b)\n\n    max_len = len_a if len_a > len_b else len_b\n\n    a_padded = sfix.Array(max_len)\n\n    b_padded = sfix.Array(max_len)\n\n    a_padded[0:len_a] = a[:]\n\n    b_padded[0:len_b] = b[:]\n\n    result = a_padded - b_padded\n\n    return result\n\n", "model_name": "qwen-qwq"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c.concat(c)\n", "response_1": "def repeat_array(c):\n    return c.concat(c)\n", "model_name": "qwen-qwq"}
{"test_name": "zeros", "response_0": "from Compiler.types import cfix\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = cfix.Array(num)\n    array.assign_all(0)\n    return array\n", "response_1": "from Compiler.types import Array, cfix\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = Array(num, cfix)\n    array.assign_all(0)\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "clip", "response_0": "", "response_1": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    # Assuming arr is an Array of sfix\n    n = len(arr)\n    result = sfix.Array(n)\n    \n    for i in range(n):\n        x = arr[i]\n        cond_upper = x >= upper_bound\n        temp = cond_upper.if_else(upper_bound, x)\n        cond_lower = temp > lower_bound\n        final_val = cond_lower.if_else(temp, lower_bound)\n        result[i] = final_val\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicator):\n    flags = predicator(arr)\n    summation = flags.sum()\n    return summation\n", "response_1": "arr = sint.Array([1, 2, 3, 4, 5])\nthreshold = sint(3)\ncount = count_satisfied(arr, lambda x: x > threshold)\ncount_revealed = count.reveal()\nprint(count_revealed)\n", "model_name": "qwen-qwq"}
{"test_name": "reverse_order_pair", "response_0": "", "response_1": "from Compiler.types import Array, sint\nfrom Compiler.library import tree_reduce\n\ndef reverse_order_pair(arr):\n    n = len(arr)\n    count = sint(0)\n    for i in range(n):\n        # Create a temporary array filled with arr[i]\n        temp = Array(n - i -1, sint)\n        temp.assign_all(arr[i])\n        # Get the suffix array arr[i+1:]\n        suffix = arr.get_vector(i+1, n - i -1)\n        # Perform element-wise comparison temp > suffix\n        comparisons = temp > suffix\n        # Sum the number of True comparisons\n        sum_comparisons = tree_reduce(lambda x, y: x + y, comparisons.get_vector())\n        # Accumulate into count\n        count += sum_comparisons\n    return count\n", "model_name": "qwen-qwq"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    arr += 1\n    return arr\n", "response_1": "from Compiler.types import Array, sint\n\ndef array_inc(arr):\n    for i in range(len(arr)):\n        arr[i] += 1\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    diff = arr[1:] - arr[:-1]\n    positive_diff = diff > 0\n    count = positive_diff.sum()\n    return count\n", "response_1": "from Compiler.library import tree_reduce\n\ndef count_rises(arr):\n\nn = arr.length\n\nif n < 2:\n\nreturn sint(0)\n\ncomparisons = [arr[i+1] > arr[i] for i in range(n-1)]\n\ncount = tree_reduce(lambda x, y: x + y, comparisons)\n\nreturn count\n\n", "model_name": "qwen-qwq"}
{"test_name": "array_process_2", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    return [func(x) for x in arr]\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Compute the two-norm of a vector.\n\n    Parameters:\n    vec (Array of sfix): The input vector.\n\n    Returns:\n    sfix: The two-norm of the vector.\n    \"\"\"\n    # Step 1: Square each element of the vector\n    squared = vec * vec\n    \n    # Step 2: Sum the squared elements using tree reduction\n    summed = tree_reduce(lambda x, y: x + y, squared.get_vector())\n    \n    # Step 3: Compute the square root of the summed value\n    norm = mpc_math.sqrt(summed)\n    \n    return norm\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Square each element in the vector\n    squared_vec = [item**2 for item in vec]\n    \n    # Sum the squared elements\n    sum_squared = sum(squared_vec)\n    \n    # Compute the square root of the sum\n    norm = mpc_math.sqrt(sum_squared)\n    \n    return norm\n", "model_name": "qwen-qwq"}
{"test_name": "totally_dominate", "response_0": "from Compiler.types import sfix, sbitint\nfrom Compiler.library import tree_reduce\n\ndef totally_dominate(a, b, result):\n    amin = tree_reduce(lambda x, y: x.min(y), a)\n    bmax = tree_reduce(lambda x, y: x.max(y), b)\n    result.assign(amin >= bmax)\n", "response_1": "def totally_dominate(a, b):\n    amin = tree_reduce(lambda x, y: x.min(y), a)\n    bmax = tree_reduce(lambda x, y: x.max(y), b)\n    return amin >= bmax\n", "model_name": "qwen-qwq"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    product = vec1 * vec2\n    summation = tree_reduce(lambda x, y: x + y, product)\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    # Compute element-wise product\n    products = vec1 * vec2\n    \n    # Initialize summation to zero\n    summation = sint(0)\n    \n    # Loop through the products and sum them up\n    for p in products:\n        summation += p\n    \n    return summation\n", "model_name": "qwen-qwq"}
{"test_name": "get_subarr_by_indices", "response_0": "from Compiler.oram import OptimalORAM\nfrom Compiler.types import sint, Array\nfrom Compiler.util import for_range\n\ndef get_subarr_by_indices(a, indices):\n    # Create an ORAM instance initialized with the array 'a'\n    a_oram = OptimalORAM(len(a), value_type=sint)\n    a_oram.assign(a)\n    \n    # Create an array to hold the result\n    ret = sint.Array(len(indices))\n    \n    # Loop over the indices and fetch the corresponding elements from ORAM\n    for j in for_range(len(indices)):\n        i = indices[j]\n        ret[j] = a_oram[i]\n    \n    return ret\n", "response_1": "from Compiler import types, for_range\n\ndef get_subarr_by_indices(a, indices):\n    value_type = type(a[0])\n    ret = types.Array(len(indices), value_type)\n    for i in for_range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.library import tree_reduce\n\ndef exists_5_or_7(arr):\n    # Create flags array: True if element is 5 or 7, else False\n    flags = (arr == 5).bit_or(arr == 7)\n    \n    # Reduce the flags array using bit_or to get a single secret bit\n    result = tree_reduce(lambda x, y: x.bit_or(y), flags)\n    \n    return result\n", "response_1": "def exists_5_or_7(arr):\n    arr_sint = sint.Array(len(arr), arr)\n    flags_5 = arr_sint == 5\n    flags_7 = arr_sint == 7\n    flags = flags_5.bit_or(flags_7)\n    result = tree_reduce(lambda x, y: x.bit_or(y), flags)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    before = arr.get_vector(0, index)\n    after = arr.get_vector(index + 1, len(arr) - index - 1)\n    ret_vector = before.concat(after)\n    new_length = len(arr) - 1\n    ret = Array(new_length, arr.value_type)\n    ret.assign_vector(ret_vector, base=0)\n    return ret\n", "response_1": "def remove_by_index(arr: Compiler.types.Array, index: Compiler.types.cint):\n    ...\n", "model_name": "qwen-qwq"}
{"test_name": "average", "response_0": "def average(arr):\n    summmation = tree_reduce(lambda x, y: x + y, arr)\n    length = cfix(len(arr))\n    ret = summmation / length\n    return ret\n", "response_1": "", "model_name": "qwen-qwq"}
