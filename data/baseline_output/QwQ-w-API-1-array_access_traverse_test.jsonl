{"test_name": "indicate_positive", "response_0": "", "response_1": "def indicate_positive(arr):\n    compare_result = arr > 0  # This returns an array of sbitint\n    result = sint.Array(len(arr))  # Create an sint array to store the results\n    result.assign(compare_result)  # Assign the comparison results directly\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "array_xor", "response_0": "def array_xor(a, b):\n    return a ^ b\n", "response_1": "def array_xor(a, b):\n    n = len(a)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = a[i].bit_xor(b[i])\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "interlaced_placement", "response_0": "from Compiler.types import Array, sint\n\ndef interlaced_placement(a, b):\n    n = len(a)\n    ret = Array(2 * n, a.value_type)\n    for i in range(2 * n):\n        if i % 2 == 0:\n            idx_a = i // 2\n            ret[i] = a[idx_a]\n        else:\n            idx_b = (i - 1) // 2\n            ret[i] = b[idx_b]\n    return ret\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_and", "response_0": "def array_and(a, b):\n    assert a.size == b.size\n    return (a != 0).schur(b != 0)\n", "response_1": "def array_and(a, b):\n    assert len(a) == len(b), \"Arrays must be of the same length\"\n    return (a != 0).bit_and(b != 0)\n", "model_name": "qwen-qwq"}
{"test_name": "array_indicator", "response_0": "def array_indicator(size, arr, predicator):\n    ret = Array(size, value_type=sint)\n    ret.assign_all(0)\n    for i in range(size):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator, size):\n    ret = Array(size, sbitint)\n    for i in range(size):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.types import sfix, Array\n\ndef array_greater_than_scalar(arr, bound):\n    return arr > bound\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in mpc.for_range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "array_no_greater_than_scalar", "response_0": "import Compiler.types as types\nfrom Compiler.library import for_range\n\ndef array_no_greater_than_scalar(arr: types.Array, bound: types.sint) -> types.Array:\n    return arr <= bound\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    b = a.get_reverse_vector()\n    c = a.concat(b)\n    return c\n", "response_1": "def reverse_and_concat(a):\n    \"\"\"\n    Reverse the input array and concatenate it to the original array.\n    \"\"\"\n    # Reverse the array\n    b = a.get_reverse_vector()\n    \n    # Concatenate the original array with the reversed array\n    result = a.concat(b)\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "array_round", "response_0": "", "response_1": "from Compiler.types import sfix, Array\nfrom Compiler.library import mpc_math\n\ndef array_round(arr):\n    n = arr.size()\n    result = Array(n, sfix)\n    half = sfix(0.5)\n    for i in range(n):\n        element = arr[i]\n        floor_value = mpc_math.floor(element)\n        difference = element - floor_value\n        condition = (difference < half)\n        result[i] = condition.if_else(floor_value, floor_value + 1)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "array_greater_eq", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.util import for_range\n\ndef array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    length = len(arr)\n    ret = Array(length, sint)\n    ret.assign_all(0)\n    for i in for_range(length):\n        ret[i] = arr[i] >= brr[i]\n    return ret\n", "response_1": "def array_greater_eq_sint(arr, brr):\n    assert isinstance(arr, sint.Array) and isinstance(brr, sint.Array)\n    assert len(arr) == len(brr)\n    ret_bits = arr >= brr\n    ret = ret_bits * sint(1)\n    return ret\n\ndef array_greater_eq_sfix(arr, brr):\n    assert isinstance(arr, sfix.Array) and isinstance(brr, sfix.Array)\n    assert len(arr) == len(brr)\n    ret_bits = arr >= brr\n    ret = ret_bits * sfix(1.0)\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "reverse", "response_0": "from Compiler.types import Array\nfrom Compiler.library import tree_reduce\n\ndef reverse(arr):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n)\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "response_1": "def reverse(arr):\n    reversed_vec = arr.get_reverse_vector()\n    ret = arr.same_shape()\n    ret.assign_vector(reversed_vec)\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n\n    ret = sint.Array(len(arr))\n\n    ret.assign_all(0)\n\n    for i in range(len(arr)):\n\n        condition = arr[i] < 0\n\n        ret[i] = condition.if_else(1, 0)\n\n    return ret\n\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "max_sub_sequence", "response_0": "", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef max_sub_sequence(arr):\n    n = len(arr)\n    partial_max = Array(n, sint)\n    suffix_max = Array(n, sint)\n    \n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    \n    for i in range(1, n):\n        # Compute suffix_max[i]\n        condition = suffix_max[i-1] >= 0\n        suffix_max[i] = suffix_max[i-1] + arr[i] if condition else arr[i]\n        \n        # Compute partial_max[i]\n        condition = partial_max[i-1] >= suffix_max[i]\n        partial_max[i] = partial_max[i-1] if condition else suffix_max[i]\n    \n    return partial_max[n-1]\n", "model_name": "qwen-qwq"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays element-wise,\n    and save the larger value into the returned array.\n    \"\"\"\n    n = len(a)\n    ret_array = sint.Array(n)\n    for i in range(n):\n        condition = a[i] > b[i]\n        ret_array[i] = a[i].if_else(b[i], a[i], condition)\n    return ret_array\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef compare_and_select(a, b):\n    n = len(a)\n    ret_array = Array(n, sint)\n    for i in for_range(n):\n        cmp = (a[i] > b[i])\n        ret_array[i] = cmp.if_else(a[i], b[i])\n    return ret_array\n", "model_name": "qwen-qwq"}
{"test_name": "count_element_frequency", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef count_element_frequency(l):\n    N = len(l)\n    ret = Array(N, sint)\n    ret.assign_all(0)\n    for i in for_range(N):\n        for j in for_range(N):\n            ret[i] += (l[j] == l[i])\n    return ret\n", "response_1": "def count_element_frequency(l):\n    n = len(l)\n    # Create MP-SPDZ array for input list\n    input_array = sint.Array(n)\n    # Assign the input list to the MP-SPDZ array\n    for i in range(n):\n        input_array[i] = l[i]\n\n    # Create result array initialized to zero\n    result_array = sint.Array(n)\n    for i in range(n):\n        result_array[i] = 0\n\n    # Nested loops to count frequencies\n    for i in range(n):\n        for j in range(n):\n            # Compare input_array[j] == input_array[i]\n            comparison_result = (input_array[j] == input_array[i]).bitint()\n            # Add to result_array[i]\n            result_array[i] += comparison_result\n\n    # Collect the results\n    ret = []\n    for i in range(n):\n        ret.append(result_array[i].reveal())\n\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "array_or", "response_0": "def array_or(a, b):\n    \"\"\"\n    Compute the elementwise OR of the two input vectors.\n    \"\"\"\n    length = len(a)\n    ret = a.same_shape()\n    for i in range(length):\n        ret[i] = a[i].bit_or(b[i])\n    return ret\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler import for_range\n\ndef array_or(a, b):\n    assert a.size == b.size\n    ret = Array(a.size, sint)\n    for i in for_range(a.size):\n        ret[i] = a[i].bit_or(b[i])\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "stock_predicator", "response_0": "from Compiler.types import sfix, Array\n\ndef stock_predicator(days):\n    n = len(days)\n    lowest = sfix.Array(n)\n    partial_max = sfix.Array(n)\n    lowest[0] = days[0]\n    partial_max[0] = sfix(0)\n    for i in range(1, n):\n        prev_lowest = lowest[i-1]\n        current = days[i]\n        condition = prev_lowest <= current\n        lowest[i] = condition.if_else(prev_lowest, current)\n        diff = current - prev_lowest\n        prev_partial = partial_max[i-1]\n        condition2 = prev_partial >= diff\n        partial_max[i] = condition2.if_else(prev_partial, diff)\n    result = partial_max[n-1]\n    condition3 = result >= sfix(0)\n    final_result = condition3.if_else(result, sfix(0))\n    return final_result\n", "response_1": "from Compiler.types import Array, sfix\nfrom Compiler.util import for_range\n\ndef stock_predicator(days):\n    n = len(days)\n    lowest = Array(n, sfix)\n    partial_max = Array(n, sfix)\n    \n    lowest[0] = days[0]\n    partial_max[0] = sfix(0)\n    \n    for i in for_range(1, n):\n        lowest[i] = sfix.min(lowest[i-1], days[i])\n        partial_max[i] = sfix.max(partial_max[i-1], days[i] - lowest[i-1])\n    \n    profit = partial_max[n-1]\n    condition = profit < sfix(0)\n    result = condition.if_else(sfix(0), profit)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "len5_inc_array", "response_0": "def len5_inc_array(init):\n    # Create an array of 5 secret integers\n    a = sint.Array(5)\n    # Assign the initial value to all elements of the array\n    a.assign_all(init)\n    # Create an array of clear integers with values 0 to 4\n    indices = cint.Array(5)\n    for i in range(5):\n        indices[i] = i\n    # Add the indices array to the initial array element-wise\n    a += indices\n    # Return the resulting array\n    return a\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "cut_first_five", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef cut_first_five(arr):\n    n = len(arr)\n    ret = Array(5, sint)\n    ret.assign_all(sint(0))\n    for i in range(5):\n        if i < n:\n            ret[i] = arr[i]\n    return ret\n", "response_1": "def cut_first_five(arr):\n    N = arr.size\n    ret = sint.Array(5)\n    ret.assign_all(0)\n    ret[0:min(5, N)] = arr[0:min(5, N)]\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "max_pooling_1d", "response_0": "def max_pooling_1d(vec, step):\n    \"\"\"\n    Perform 1-dimensional max pooling on a secret integer array with a given step size.\n    \n    Parameters:\n    - vec: sint.Array, the input array of secret integers.\n    - step: int, the step size for pooling.\n    \n    Returns:\n    - ret: sint.Array, the result array containing the maximum values of each pooling segment.\n    \"\"\"\n    n = vec.size  # Length of the input array\n    ret_length = n // step  # Number of pooling segments\n    ret = sint.Array(ret_length)  # Initialize result array\n    \n    for i in range(ret_length):\n        max_val = vec[i * step]  # Initialize max with the first element of the segment\n        for j in range(1, step):\n            index = i * step + j\n            if index < n:\n                # Compare and update max_val if the current element is greater\n                cond = vec[index] > max_val\n                max_val = cond.if_else(vec[index], max_val)\n        ret[i] = max_val  # Assign the maximum value to the result array\n    \n    return ret\n", "response_1": "def max_pooling_1d(vec, step):\n    n = len(vec)\n    ret_length = n // step\n    ret = Array(ret_length, sint)\n    for i in range(ret_length):\n        max_val = vec[i * step]\n        for j in range(1, step):\n            if i * step + j < n:\n                candidate = vec[i * step + j]\n                max_val = max_val.max(candidate)\n        ret[i] = max_val\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "array_greater", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef array_greater(arr, brr):\n    n = len(arr)\n    ret = Array(n, sint)\n    ret.assign_all(sint(0))\n    for i in range(n):\n        condition = arr[i] > brr[i]\n        ret[i] = sint(condition)\n    return ret\n", "response_1": "def array_greater(arr, brr):\n    ret = arr > brr\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "dumb_concat", "response_0": "def dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    # Determine the types of the arrays\n    if not isinstance(arr, Array) or not isinstance(brr, Array):\n        raise TypeError(\"Both arr and brr must be Array instances.\")\n    if arr.value_type != brr.value_type:\n        raise TypeError(\"Both arrays must have the same value type.\")\n    \n    # Calculate the total length\n    total_length = arr.length + brr.length\n    \n    # Create the result array\n    ret = Array(total_length, arr.value_type)\n    \n    # Assign values from arr and brr to ret\n    ret.assign(arr, base=0)\n    ret.assign(brr, base=arr.length)\n    \n    return ret\n", "response_1": "def dumb_concat(arr, brr, len_arr, len_brr):\n    total_length = len_arr + len_brr\n    ret = Array(total_length, arr.value_type)\n    ret.assign_all(0)\n    ret.assign_vector(arr.get_vector(), base=0)\n    ret.assign_vector(brr.get_vector(), base=len_arr)\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "indicator_if_else", "response_0": "def indicator_if_else(a, b, ind):\n    return ind.if_else(a, b)\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "elementwise_multiplication", "response_0": "from Compiler.types import Array, sint\n\ndef elementwise_multiplication(a, b, length):\n    \"\"\"\n    Compute the element-wise multiplication of two input vectors.\n\n    Parameters:\n    a (Array[sint]): The first input vector.\n    b (Array[sint]): The second input vector.\n    length (int): The length of the vectors.\n\n    Returns:\n    Array[sint]: A new vector containing the element-wise products.\n    \"\"\"\n    result = a * b\n    return result\n", "response_1": "def elementwise_multiplication(a, b):\n    return a * b\n", "model_name": "qwen-qwq"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    a_oram = OptimalORAM(len(a), value_type=type(a[0]), data=a)\n    ret = Array(len(indices), value_type=type(a[0]))\n    for i in range(len(indices)):\n        idx = indices[i]\n        element = a_oram[idx]\n        ret[i] = element\n    return ret\n", "response_1": "from Compiler.library import gather\n\ndef get_subarr_by_indices(a, indices):\n    return gather(a, indices)\n", "model_name": "qwen-qwq"}
{"test_name": "inc_array", "response_0": "", "response_1": "def inc_array(num):\n    array = cint.Array(num)\n    for i in for_range(num):\n        array[i] = i + 1\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "cut_last_five", "response_0": "", "response_1": "ret = [0 for i in range(5)]\nfor i in range(min(5, len(arr))):\n    ret[4 - i] = arr[len(arr) - 1 - i]\nreturn ret\n", "model_name": "qwen-qwq"}
{"test_name": "average_pooling_1d", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_relu", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "move_to_end", "response_0": "def move_to_end(arr: sint.Array, index: cint):\n    temp = arr[index]\n    for i in range(index + 1, len(arr)):\n        arr[i - 1] = arr[i]\n    arr[len(arr) - 1] = temp\n    return arr\n", "response_1": "def move_to_end(arr, index):\n    before = arr.get_part(0, index)\n    after = arr.get_part(index + 1, len(arr) - index - 1)\n    middle = arr.get_part(index, 1)\n    new_arr = before.concat(after).concat(middle)\n    arr.assign(new_arr)\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "set_to_zero", "response_0": "def set_to_zero(arr, index):\n    zero = arr.value_type(0)\n    arr[index] = zero\n    return arr\n", "response_1": "def set_to_zero(arr, index):\n    zero = sint(0)\n    arr[index] = zero\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "last_partial_sum", "response_0": "def last_partial_sum(arr, n):\n    last_n_elements = arr.get_vector(arr.length - n, n)\n    ret = last_n_elements.sum()\n    return ret\n", "response_1": "def last_partial_sum(arr, n):\n    v = arr.get_vector()\n    length = v.size()\n    start = (length - n).regint()\n    size = n.regint()\n    sub_v = v.slice(start, size)\n    sum = sub_v.sum()\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "permute_by_indices", "response_0": "from Compiler.types import Array, cint, sint, sfix, cfix\n\ndef permute_by_indices(a, indices):\n    ret = a.same_shape()\n    for i in range(len(a)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def permute_by_indices(a, indices):\n    \"\"\"\n    Permute the input array a by the indices.\n    The i'th element in the returned array will be a[indices[i]].\n    The input indices are guaranteed to be a legal permutation.\n    \"\"\"\n    n = len(a)\n    ret = a.same_shape()\n    for i in range(n):\n        idx = indices[i]\n        ret[i] = a[idx]\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "get_rank", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "interchange_by_indices", "response_0": "", "response_1": "def interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange the two elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "increase_by", "response_0": "def increase_by(arr, index, k):\n    temp = arr.get_vector(index, 1)\n    temp += k\n    arr.assign_vector(temp, index)\n    return arr\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "retrieve_by_index", "response_0": "def retrieve_by_index(arr, index):\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    return arr[index]\n", "response_1": "def retrieve_by_index(arr, index):\n    # arr: Array of any type\n    # index: cint\n    return arr[index]\n", "model_name": "qwen-qwq"}
{"test_name": "scale_by", "response_0": "# Assuming we're in a MP-SPDZ program\n\n# Initialize array with secret integers\narr = sint.Array(10)\n# Assign some values to arr\narr.assign([sint(i) for i in range(10)])\n\n# Define index and scaling factor\nindex = 3  # public index\nk = cint(2)  # clear integer scaling factor\n\n# Call the subroutine\nscale_by(arr, index, k)\n\n# Verify the result\n# For example, print arr[3] to see if it's doubled\nprint(arr[3])\n", "response_1": "from Compiler.types import sfix, cfix, Array\n\ndef scale_by(arr, index, k):\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "take_opposite_to", "response_0": "def take_opposite_to(arr, index):\n\n    arr[index] = -arr[index]\n\n    return arr\n\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_rank", "response_0": "", "response_1": "from Compiler.types import sint, cint, Array\nfrom Compiler.sorting import radix_sort\n\ndef array_rank(l):\n    n = len(l)\n    # Create an array of public indices\n    indices = Array.create_from(range(n))\n    # Sort indices based on the values in l\n    radix_sort(l, indices)\n    # Create an array to hold the ranks\n    ret = Array(n, sint)\n    # Assign ranks based on the sorted indices\n    for k in range(n):\n        ret[indices[k]] = k\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "remove_by_index", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.util import for_range\n\ndef remove_by_index(arr, index):\n    n = len(arr)\n    new_arr = Array(n - 1, sint)\n    for i in range(n - 1):\n        condition = (i < index)\n        new_arr[i] = condition.if_else(arr[i], arr[i + 1])\n    return new_arr\n", "response_1": "def remove_by_index(arr, index):\n    n = len(arr)\n    if index == 0:\n        # Copy arr[1:n] to new_arr[0:n-1]\n        new_arr = arr.value_type.Array(n-1)\n        new_arr.assign_vector(arr.get_vector(1, n-1), 0)\n    elif index == n-1:\n        # Copy arr[0:n-1] to new_arr[0:n-1]\n        new_arr = arr.value_type.Array(n-1)\n        new_arr.assign_vector(arr.get_vector(0, n-1), 0)\n    else:\n        # Copy arr[0:index] to new_arr[0:index]\n        # and arr[index+1:n] to new_arr[index:n-1]\n        new_arr = arr.value_type.Array(n-1)\n        new_arr.assign_vector(arr.get_vector(0, index), 0)\n        new_arr.assign_vector(arr.get_vector(index+1, n-index-1), index)\n    return new_arr\n", "model_name": "qwen-qwq"}
{"test_name": "process_by_index", "response_0": "def process_by_index(arr, index, func):\n    arr[index] = func(arr[index])\n    return arr\n", "response_1": "def process_by_index(arr, index, func):\n    arr[index] = func(arr[index])\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "sum_by_indices", "response_0": "", "response_1": "def sum_by_indices(arr, indices):\n\n    element_type = type(arr[0])\n\n    if issubclass(element_type, (sint, cint)):\n\n        sum = element_type(0)\n\n    elif issubclass(element_type, (sfix, cfix)):\n\n        sum = element_type(0.0)\n\n    else:\n\n        raise TypeError(\"Unsupported array element type\")\n\n    for index in indices:\n\n        sum += arr[index]\n\n    return sum\n\n", "model_name": "qwen-qwq"}
