{"test_name": "multiply_first_five", "response_0": "def multiply_first_five(array):\n\nslice = array[0:min(5, array.length)]\n\nvector = slice.get_vector()\n\nprod = vector.prod()\n\nreturn prod\n\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n\n    \"\"\"\n\n    Return the second largest element in the array.\n\n    \"\"\"\n\n    # Initial comparison between arr[0] and arr[1]\n\n    comparison = arr[0] >= arr[1]\n\n    largest = comparison.if_else(arr[0], arr[1])\n\n    second = comparison.if_else(arr[1], arr[0])\n\n\n\n    # Loop starting from i=2 to len(arr)-1\n\n    for i in range(2, len(arr)):\n\n        is_greater_or_equal = arr[i] >= largest\n\n        second = is_greater_or_equal.if_else(largest, second)\n\n        largest = is_greater_or_equal.if_else(arr[i], largest)\n\n        is_greater_or_equal_second = arr[i] >= second\n\n        second = is_greater_or_equal_second.if_else(arr[i], second)\n\n    \n\n    return second\n\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    # Initialize largest and second with the first two elements\n    largest = arr[0].max(arr[1])\n    second = arr[0].min(arr[1])\n    \n    for i in range(2, len(arr)):\n        current = arr[i]\n        if current >= largest:\n            second = largest\n            largest = current\n        else:\n            if current >= second:\n                second = current\n    \n    return second\n", "model_name": "qwen-qwq"}
{"test_name": "partial_sum", "response_0": "from Compiler.types import sint, Array\n\ndef partial_sum(arr):\n    assert isinstance(arr, Array)\n    assert arr.value_type == sint\n    partial = sint(0)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "def partial_sum(arr):\n    partial = sfix(0)\n    for i in for_range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "max_adjacent_product", "response_0": "", "response_1": "def max_adjacent_product():\n\nlength = 10  # Example length; assume it's known at compile-time\n\narr = sint.Array(length)\n\nfor i in range(length):\n\narr[i] = sint.get_input_from(0)\n\ncur = arr[0] * arr[1]\n\nfor i in for_range(length - 1):\n\nprod = arr[i] * arr[i + 1]\n\nis_greater = prod > cur\n\ncur = is_greater.if_else(prod, cur)\n\nreturn cur\n\n", "model_name": "qwen-qwq"}
{"test_name": "argmax", "response_0": "# Assuming 'a' is already defined as an Array of sint\n\ncurrent = a[0]\nindex = sint(0)\n\nfor i in range(len(a)):\n    cmp = current >= a[i]\n    index.update(cmp.if_else(index, i))\n    current.update(current.max(a[i]))\n\nindex.output(0)\n", "response_1": "def argmax(a):\n\n    current = a[0]\n\n    index = cint(0)\n\n    n = cint(len(a))\n\n    for i in for_range(n):\n\n        cond = current >= a[i]\n\n        index = cond.if_else(index, i)\n\n        current = cond.if_else(current, a[i])\n\n    return index\n\n", "model_name": "qwen-qwq"}
{"test_name": "count_distinct", "response_0": "def count_distinct(arr):\n    counter = 0\n    for i in range(len(arr)):\n        unique = True\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = False\n        if unique:\n            counter += 1\n    return counter\n", "response_1": "def count_distinct(arr):\n\n    n = len(arr)\n\n    if n == 0:\n\n        return sint(0)\n\n    radix_sort(arr, arr)\n\n    counter = sint(1)\n\n    for i in range(1, n):\n\n        diff = arr[i] != arr[i-1]\n\n        counter += diff\n\n    return counter\n\n", "model_name": "qwen-qwq"}
{"test_name": "exists_true", "response_0": "from Compiler.library import tree_reduce\n\ndef exists_true(arr):\n    return tree_reduce(lambda x, y: x.bit_or(y), arr)\n", "response_1": "def exists_true(arr):\n    return mpc.tree_reduce(lambda x, y: x | y, arr)\n", "model_name": "qwen-qwq"}
{"test_name": "range", "response_0": "def range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    # Initialize max_value and min_value to the first element of the array\n    max_value = arr[0]\n    min_value = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        item = arr[i]\n        # Update max_value if item is greater\n        cmp_max = max_value >= item\n        max_value = cmp_max.if_else(max_value, item)\n        # Update min_value if item is smaller\n        cmp_min = min_value <= item\n        min_value = cmp_min.if_else(min_value, item)\n    \n    # Compute and return the range\n    return max_value - min_value\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "count_larger_than_5", "response_0": "def count_larger_than_5(arr):\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        item = arr[i]\n        is_larger = item > 5\n        counter += is_larger\n    return counter\n", "response_1": "from Compiler.types import sint, cint, Array\nfrom Compiler.library import tree_reduce\n\ndef count_larger_than_5(arr):\n    five = cint(5)\n    is_larger = arr > five\n    counter = tree_reduce(lambda x, y: x + y, is_larger.reveal())\n    return counter\n", "model_name": "qwen-qwq"}
{"test_name": "exists_dominator", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sfix\n\ndef exists_dominator(arr):\n    abs_arr = abs(arr[:])\n    max_val = tree_reduce(lambda x, y: x.max(y), abs_arr)\n    sum_val = sum(abs_arr)\n    return (2 * max_val) > sum_val\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "greedy_picker", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef main():\n    N = 10  # Assuming a fixed number of items\n    items = sint.Array(N)\n    items[:] = sint.get_input_from(0, size=N)\n    captivity = sint.get_input_from(0)\n    num = sint(0)\n    \n    for i in range(N):\n        item = items[i]\n        condition = (item <= captivity)\n        new_cap = captivity - item\n        captivity = condition.if_else(new_cap, captivity)\n        new_num = num + 1\n        num = condition.if_else(new_num, num)\n    \n    revealed_num = num.reveal()\n    print(\"Number of items picked:\", revealed_num)\n\nif __name__ == \"__main__\":\n    main()\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "scalar_add_array", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sint, Array\n\ndef scalar_add_array(s, l):\n    # s: sint, l: Array of sint\n    sum_l = tree_reduce(lambda x, y: x + y, l)\n    return s + sum_l\n", "response_1": "from Compiler.library import tree_reduce\n\ndef scalar_add_array(s, l):\n    if len(l) == 0:\n        return s\n    else:\n        return s + tree_reduce(lambda x, y: x + y, l)\n", "model_name": "qwen-qwq"}
{"test_name": "is_equidistant_seq", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sint, Array, sbitint\n\ndef is_equidistant_seq(arr):\n    n = len(arr)\n    if n <= 1:\n        return sbitint(1)\n    diffs = arr[1:] - arr[:-1]\n    equalities = diffs == diffs[0]\n    all_equal = tree_reduce(lambda x, y: x.bit_and(y), equalities)\n    return all_equal\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    assert vec1.size == vec2.size, \"Vectors must be of the same length\"\n    product = vec1.schur(vec2)\n    sum = product.get_vector().sum()\n    return sum\n", "response_1": "def inner_product(vec1, vec2, size):\n    sum = sfix(0)\n    for i in for_range(size):\n        sum += vec1[i] * vec2[i]\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "more_distinct_nonnegative", "response_0": "", "response_1": "from Compiler.types import Array, sint, regint\nfrom Compiler.library import tree_reduce\n\ndef more_distinct_nonnegative(arr):\n    n = regint(len(arr))\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    \n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            is_equal = (arr[j] == arr[i])\n            unique = unique.bit_and(is_equal.bit_not())\n        is_nonnegative = arr[i] >= 0\n        unique_and_nonnegative = unique.bit_and(is_nonnegative)\n        unique_and_negative = unique.bit_and(is_nonnegative.bit_not())\n        nonnegative_counter += sint(1) * unique_and_nonnegative\n        negative_counter += sint(1) * unique_and_negative\n    result = nonnegative_counter > negative_counter\n    public_result = result.reveal()\n    return public_result\n", "model_name": "qwen-qwq"}
{"test_name": "flip_positives", "response_0": "def flip_positives(array):\n    from Compiler.types import sint, Array\n    from Compiler.util import for_range\n\n    n = array.size\n    for i in for_range(0, n):\n        mask = array[i] > sint(0)\n        array[i] = array[i] * (sint(1) - sint(2) * mask)\n", "response_1": "from Compiler.types import Array, sint\n\ndef flip_positives(array):\n    for i in range(len(array)):\n        cond = array[i] <= 0\n        negated = -array[i]\n        to_assign = cond.if_else(array[i], negated)\n        array[i] = to_assign\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "divide_and_plus", "response_0": "", "response_1": "def divide_and_plus(x):\n    # x should be an sfix type\n    for i in for_range(4):\n        x.update(x / 2 + 1)\n    return x\n", "model_name": "qwen-qwq"}
{"test_name": "array_log2", "response_0": "", "response_1": "from mpc_math import log2\nfrom Compiler.types import Array, sfix\n\ndef array_log2(arr):\n    for i in range(len(arr)):\n        arr[i] = log2(arr[i])\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "sum_to_ten", "response_0": "", "response_1": "def sum_to_ten(array):\n    from Compiler.types import sint, Array\n    from Compiler.library import tree_reduce\n    from Compiler.types import sbit\n\n    n = len(array)\n    if n == 0:\n        return 0\n\n    # Compute prefix sums\n    prefix_sums = array.scan(lambda x, y: x + y)\n\n    # Compute mask where prefix sums are >= 10\n    mask = prefix_sums >= 10\n\n    # Check if any prefix sum is >= 10\n    condition = mask.or_reduce()\n\n    # Compute shifted prefix_or\n    prefix_or = mask.scan(lambda x, y: x | y)\n    shifted_prefix_or = Array(prefix_or[1:] + [sbit(0)])  # Shift right by one with 0 appended\n\n    # Find the first set bit\n    first_set = mask & (~shifted_prefix_or)\n\n    # Convert first_set to sint for multiplication\n    first_set_int = first_set.conv(sint)\n\n    # Sum if condition holds\n    sum_if_condition = (prefix_sums * first_set_int).sum()\n\n    # Total sum\n    total_sum = prefix_sums[-1]\n\n    # Select the appropriate sum based on the condition\n    result = condition.if_else(sum_if_condition, total_sum)\n\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "choppy_plus_minus", "response_0": "", "response_1": "def choppy_plus_minus(arr):\n    n = len(arr)\n    for i in mpc.for_range(n):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "min_element", "response_0": "def min_element_tree_reduce(a):\n    return tree_reduce(lambda x, y: x if x <= y else y, a)\n", "response_1": "from Compiler.library import tree_reduce\n\ndef min_element(a):\n    return tree_reduce(lambda x, y: (x <= y).if_else(y, x), a)\n", "model_name": "qwen-qwq"}
{"test_name": "soft_max", "response_0": "", "response_1": "def soft_max(arr):\n    from Compiler.library import tree_reduce\n    from Compiler import mpc_math\n\n    # Compute the exponential of each element in the array\n    exp_arr = arr.map(lambda x: mpc_math.exp(x))\n\n    # Sum all the exponential values\n    denominator = tree_reduce(lambda x, y: x + y, exp_arr)\n\n    # Normalize each exponential value by the sum\n    brr = exp_arr.map(lambda x: x / denominator)\n\n    return brr\n", "model_name": "qwen-qwq"}
{"test_name": "count_reverse_pair_with_break", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "sum_unique", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "check_sum", "response_0": "from Compiler.types import sint, cint, Array\nfrom Compiler.library import tree_reduce\n\ndef check_sum(array, target):\n    sum = tree_reduce(lambda x, y: x + y, array)\n    result = sum == target\n    return result\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "prod", "response_0": "from Compiler.library import tree_reduce\n\ndef prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    return tree_reduce(lambda x, y: x * y, array)\n", "response_1": "from Compiler.library import tree_reduce\n\ndef prod(array):\n    return tree_reduce(lambda x, y: x * y, array)\n", "model_name": "qwen-qwq"}
{"test_name": "sum_till_negative", "response_0": "def sum_till_negative(array):\n    sum = sint(0)\n    flag = sbitint(0)\n    for i in range(len(array)):\n        element = array[i]\n        is_negative = element < 0\n        flag = flag.bit_or(is_negative)\n        mask = sbitint(1) - flag\n        sum += element * mask\n    return sum\n", "response_1": "def sum_till_negative(array):\n    a = sint.Array(len(array))\n    a.assign(array)\n    mask = sint(1)\n    s = sint(0)\n    for i in range(len(array)):\n        include = mask & (a[i] >= 0)\n        s += a[i] * include\n        mask &= include\n    return s\n", "model_name": "qwen-qwq"}
{"test_name": "count_satisfied", "response_0": "", "response_1": "from Compiler.library import tree_reduce\n\ndef count_satisfied(arr, predicator):\n    preds = [predicator(x) for x in arr]\n    sum = tree_reduce(lambda x, y: x + y, preds)\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "standard_deviation", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "dominate", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "rescale", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sfix, Array\n\n@mpc.coroutine\ndef rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    abs_brr = brr.map(abs)\n    max_abs = tree_reduce(lambda x, y: (x > y).if_else(x, y), abs_brr)\n    brr = brr / max_abs\n    return brr\n", "response_1": "from Compiler.library import tree_reduce\n\ndef rescale(brr):\n    # Compute absolute values\n    abs_brr = sfix.Array(len(brr))\n    for i in range(len(brr)):\n        abs_brr[i] = brr[i].abs()\n    \n    # Find maximum absolute value\n    max_abs = tree_reduce(lambda x, y: x.max(y), abs_brr)\n    \n    # Divide each element by max_abs\n    for i in range(len(brr)):\n        brr[i] /= max_abs\n    \n    return brr\n", "model_name": "qwen-qwq"}
{"test_name": "array_minus7", "response_0": "", "response_1": "def array_minus7(arr):\n    arr -= 7\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "traverse_and_sum", "response_0": "", "response_1": "from Compiler.types import sint, Array\n\ndef traverse_and_sum(arr1, arr2):\n    sum_arr1 = arr1.sum()\n    sum_arr2 = arr2.sum()\n    result = sum_arr1 * sum_arr2\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler import mpc\n\ndef longest_nondec_subseq(a, n):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    if n == 0:\n        return sint(0)\n    \n    max_length = sint(0)\n    cur_length = sint(1)\n    \n    for i in range(1, n):\n        cond = (a[i] >= a[i-1])\n        increment = cond\n        cur_length = cur_length + increment\n        \n        new_max_length = mpc.max(max_length, cur_length)\n        max_length = cond * max_length + (1 - cond) * new_max_length\n    \n    max_length = mpc.max(max_length, cur_length)\n    return max_length\n", "response_1": "def longest_nondec_subseq(a):\n    max_length = sint(0)\n    cur_length = sint(1)  # Start with 1 for the first element\n\n    for i in range(1, len(a)):\n        cmp = (a[i] >= a[i-1])\n        cur_length = cmp.if_else(cur_length + 1, 1)\n        update_max = cmp.not_()\n        max_length = update_max.if_else(max_length.max(cur_length), max_length)\n\n    max_length = max_length.max(cur_length)\n    return max_length\n", "model_name": "qwen-qwq"}
{"test_name": "sum_but_skip_biggest", "response_0": "def sum_but_skip_biggest(array):\n    total_sum = sint(0)\n    current_biggest = array[0]\n    for i in for_range(len(array)):\n        is_bigger = array[i] >= current_biggest\n        current_biggest = is_bigger.if_else(array[i], current_biggest)\n        total_sum += is_bigger.bit_not().if_else(array[i], sint(0))\n    return total_sum\n", "response_1": "def sum_but_skip_biggest(array):\n    sum = sint(0)\n    biggest = array[0]\n    for i in for_range(len(array)):\n        condition = array[i] >= biggest\n        to_add = array[i] * (1 - condition)\n        sum += to_add\n        biggest = biggest.max(array[i])\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "second_test", "response_0": "", "response_1": "from Compiler.types import sint, Array, sbitint\n\ndef second_test(arr: Array):\n    n = arr.size - 1\n    if n == 0:\n        return sbitint(0)\n    sub_arr = arr.get_part(1, n)\n    broadcast_arr = arr[0].same_shape(sub_arr)\n    diff = sub_arr > broadcast_arr\n    count = diff.sum()\n    result = (count == 1)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "Manhattan_distance", "response_0": "def Manhattan_distance(a, b):\n    diff = a - b\n    abs_diff = abs(diff)\n    ret = abs_diff.sum()\n    return ret\n", "response_1": "def Manhattan_distance(a, b):\n\n    \"\"\"\n\n    Compute the Manhattan distance of the two vectors.\n\n    \"\"\"\n\n    diff = a[:] - b[:]\n\n    abs_diff = abs(diff)\n\n    ret = tree_reduce(lambda x, y: x + y, abs_diff)\n\n    return ret\n\n", "model_name": "qwen-qwq"}
{"test_name": "deal_with_only_positive", "response_0": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = 1\n    sum = 0\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        sum = sum + sign * array[i]\n        sign = (-1) * sign\n    return sum\n", "response_1": "def deal_with_only_positive(array):\n    # Define the length of the array\n    length = len(array)\n    \n    # Compute masks for positive elements\n    masks = array > 0\n    \n    # Compute prefix sum of masks to determine the number of positive elements before each position\n    prefix_sums = [0] * length\n    prefix_sums[0] = masks[0]\n    for i in range(1, length):\n        prefix_sums[i] = prefix_sums[i-1] + masks[i]\n    \n    # Compute signs for each positive element\n    signs = [(-1)**prefix_sum for prefix_sum in prefix_sums]\n    \n    # Adjust elements by their corresponding sign and mask\n    adjusted_elements = array * masks * signs\n    \n    # Sum all adjusted elements\n    sum_result = sum(adjusted_elements)\n    \n    return sum_result\n", "model_name": "qwen-qwq"}
{"test_name": "compare_and_return", "response_0": "", "response_1": "def compare_and_return(arr, brr):\n    n = len(arr)\n    ret = sint(n)  # Initialize ret to n\n    for i in range(n):\n        comparison = (arr[i] == brr[i])\n        new_ret = ret.min(i)\n        ret = comparison.if_else(new_ret, ret)\n    mask = (ret == n)\n    ret = mask * (-1) + (1 - mask) * ret\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "sum_odd_positive", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef sum_odd_positive(arr):\n    sum = sint(0)\n    n = len(arr)\n    \n    def loop_body(i):\n        item = arr[i]\n        is_odd = (item % 2) == 1\n        is_positive = item > 0\n        condition = is_odd.bit_and(is_positive)\n        sum += condition.if_else(item, 0)\n    \n    for_range(n, loop_body)\n    return sum\n", "response_1": "from Compiler.types import Array, sint\n\ndef sum_odd_positive(arr):\n    # Compute the condition for odd numbers\n    cond_odd = arr % 2\n    # Compute the condition for positive numbers\n    cond_positive = arr > 0\n    # Combine the conditions using element-wise multiplication (logical AND)\n    conditions = cond_odd * cond_positive\n    # Multiply the combined conditions with the original array\n    temp = conditions * arr\n    # Sum up the temporary array to get the result\n    sum_result = temp.sum()\n    return sum_result\n", "model_name": "qwen-qwq"}
{"test_name": "two_sum", "response_0": "from Compiler.types import sint, sbitint\nfrom Compiler.util import for_range\n\ndef two_sum(arr, target):\n    \"\"\"\n    Check if there are two elements in the array that sum up to the target value.\n    \n    Parameters:\n    - arr: Array of sint (secret integers)\n    - target: sint (secret integer)\n    \n    Returns:\n    - regint: 1 if such a pair exists, 0 otherwise\n    \"\"\"\n    n = len(arr)\n    found = sbitint(0)\n    for i in for_range(0, n):\n        for j in for_range(0, n):\n            sum_ij = arr[i] + arr[j]\n            found = found.bit_or(sum_ij == target)\n    return found.reveal()\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "seq_search", "response_0": "def seq_search(arr, target):\n    n = len(arr)\n    indices = cint.Array.create_from(range(n))\n    matches = arr == target  # This results in an array of sbit\n    sum_indices = matches.schur(indices).sum()\n    zero_check = sum_indices == 0  # This is an sbit\n    sint_one = sint(1)\n    sint_zero_check = zero_check * sint_one  # Cast sbit to sint\n    result = sum_indices - sint_zero_check  # If no match, result is -1\n    return result\n", "response_1": "from Compiler.types import cint, Array, MemValue\nfrom Compiler.library import for_range\n\ndef main():\n    length = 10  # or whatever the length is\n    arr = Array(length, cint)\n    for i in for_range(length):\n        arr[i] = cint.input_from(0)\n    target = cint.input_from(0)\n    index = MemValue(cint(-1))\n    for i in for_range(length):\n        if arr[i] == target:\n            index.assign(cint(i))\n    index.get().output()\n\nif __name__ == '__main__':\n    main()\n", "model_name": "qwen-qwq"}
{"test_name": "choppy_array", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_process", "response_0": "from Compiler.types import Array, sint\n\ndef array_process(arr, func):\n    for i in range(arr.length):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "def array_process(arr, func):\n    for i in for_range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "normalize", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler import mpc_math\n\ndef normalize(vec):\n    sum_squares = tree_reduce(lambda x, y: x + y, vec**2)\n    base = mpc_math.sqrt(sum_squares)\n    vec.update(vec / base)\n", "response_1": "from Compiler.types import sfix, Array\nfrom Compiler.library import tree_reduce\nimport mpc_math\n\ndef normalize(vec):\n    sum_squares = tree_reduce(lambda x, y: x + y, vec * vec)\n    base = mpc_math.sqrt(sum_squares)\n    normalized_vec = vec / base\n    vec.assign_vector(normalized_vec)\n    return vec\n", "model_name": "qwen-qwq"}
{"test_name": "impatient_merchant", "response_0": "def impatient_merchant(days):\n    can_buy = sint(1)  # Initially, can buy\n    net = sint(0)\n    orig_price = sint(0)\n    \n    n = len(days)\n    for i in range(n):\n        buy_today = can_buy\n        sell_today = can_buy.bit_not() & (days[i] > orig_price)\n        \n        # Handle buy logic\n        net_buy = net - days[i]\n        orig_price_buy = days[i]\n        can_buy_buy = sint(0)\n        \n        net_no_buy = net\n        orig_price_no_buy = orig_price\n        can_buy_no_buy = can_buy\n        \n        # Select based on buy_today\n        net = buy_today.if_else(net_buy, net_no_buy)\n        orig_price = buy_today.if_else(orig_price_buy, orig_price_no_buy)\n        can_buy = buy_today.if_else(can_buy_buy, can_buy_no_buy)\n        \n        # Handle sell logic\n        net_sell = net + days[i]\n        can_buy_sell = sint(1)\n        \n        net_no_sell = net\n        can_buy_no_sell = can_buy\n        \n        # Select based on sell_today\n        net = sell_today.if_else(net_sell, net_no_sell)\n        can_buy = sell_today.if_else(can_buy_sell, can_buy_no_sell)\n    \n    return net\n", "response_1": "def impatient_merchant(days):\n\n    can_buy = sint(1)  # True\n\n    net = sint(0)\n\n    orig_price = sint(0)\n\n    for i in range(len(days)):\n\n        # If can_buy:\n\n        #     net = net - days[i]\n\n        #     orig_price = days[i]\n\n        #     can_buy = False\n\n        # Else:\n\n        #     if days[i] > orig_price:\n\n        #         net = net + days[i]\n\n        #         can_buy = True\n\n        # Implementing the above logic using secure conditionals\n\n        # ...\n\n    return net\n\n", "model_name": "qwen-qwq"}
{"test_name": "array_shift", "response_0": "a = sint.Array(3)\n# Assign some values to a\narray_shift(a, 3)\n", "response_1": "def array_shift(a):\n    v = a.get_vector()\n    v = v.circ_shift(1)\n    a.assign_vector(v)\n    return a\n", "model_name": "qwen-qwq"}
{"test_name": "array_double", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    n = len(arr)\n    for i in for_range(n):\n        arr[i] = arr[i] * 2\n", "response_1": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] *= 2\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef stop_at_zero(array):\n    n = len(array)\n    stop_index = n  # Initialize stop index to the end of the array\n\n    # Find the first index where array[i] == 0\n    for i in range(n):\n        is_zero = (array[i] == 0)\n        # If is_zero is 1, set stop_index to i and break\n        stop_index = tree_reduce(lambda x, y: x.min(y), [stop_index, i * is_zero])\n\n    # Now, for each index before stop_index, add 1 to array[i]\n    for i in range(n):\n        should_add = (i < stop_index)\n        array[i] += should_add\n\n    return array\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_not", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_process_then_clip", "response_0": "from Compiler.types import Array, sfix\n\ndef array_process_then_clip(arr, func):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = func(arr[i])\n        greater_than_10 = arr[i] > 10\n        less_than_neg10 = arr[i] < -10\n        arr[i] = greater_than_10.if_else(10, arr[i])\n        arr[i] = less_than_neg10.if_else(-10, arr[i])\n    return arr\n", "response_1": "def array_process_then_clip(arr, func):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = func(arr[i])\n        cond_high = arr[i] > 10\n        cond_low = arr[i] < -10\n        arr[i] = cond_high.if_else(10, arr[i])\n        arr[i] = cond_low.if_else(-10, arr[i])\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "add_and_count_positive", "response_0": "def add_and_count_positive(array, k):\n    # Add k to each element in the array\n    new_array = array + k\n    # Create an array of secret bits indicating which elements are greater than zero\n    positives = new_array > 0\n    # Sum the secret bits to get the count of positive elements\n    count = positives.sum()\n    # Return the new array and the count\n    return new_array, count\n", "response_1": "def add_and_count_positive(array, k):\n    array.iadd(k)\n    positive_bits = array > 0\n    count = tree_reduce(lambda x, y: x + y, positive_bits)\n    return array, count\n", "model_name": "qwen-qwq"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    len_a = len(a)\n    len_b = len(b)\n    if len_a > len_b:\n        ret = a.same_shape()\n        min_len = len_b\n        ret[:min_len] = a[:min_len] - b[:min_len]\n        ret[min_len:] = a[min_len:]\n    else:\n        ret = b.same_shape()\n        min_len = len_a\n        ret[:min_len] = a[:min_len] - b[:min_len]\n        ret[min_len:] = -b[min_len:]\n    return ret\n", "response_1": "def array_subtract(a, b):\n\n    va = a[:]\n\n    vb = b[:]\n\n    len_a = len(va)\n\n    len_b = len(vb)\n\n    max_len = max(len_a, len_b)\n\n    if len_a > len_b:\n\n        vb.extend([sint(0)] * (max_len - len_b))\n\n    else:\n\n        va.extend([sint(0)] * (max_len - len_a))\n\n    result = va - vb\n\n    value_type = type(a[0])\n\n    ret = Array(max_len, value_type)\n\n    ret.assign_vector(result)\n\n    return ret\n\n", "model_name": "qwen-qwq"}
{"test_name": "lower_bound", "response_0": "from Compiler.types import Array, sint, cint\nfrom Compiler.library import tree_reduce\n\ndef lower_bound(arr, x):\n    n = len(arr)\n    ret = cint(-1)\n    distance = sint(0)\n    found = sint(0)\n    \n    for i in range(n):\n        condition1 = (arr[i] <= x)\n        new_distance = x - arr[i]\n        \n        condition2 = found.bit_not().bit_or(new_distance < distance)\n        condition = condition1.bit_and(condition2)\n        \n        ret = condition.if_else(i, ret)\n        distance = condition.if_else(new_distance, distance)\n        found = condition.if_else(sint(1), found)\n    \n    return ret.reveal()\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "argmin", "response_0": "from Compiler.types import Array, sint, regint\n\nfrom Compiler.library import for_range\n\ndef argmin(a):\n\n    current = a[0]\n\n    index = regint(0)\n\n    for i in for_range(1, len(a)):\n\n        is_less = a[i] < current\n\n        current = is_less.if_else(a[i], current)\n\n        index = is_less.if_else(i, index)\n\n    return index\n\nif __name__ == '__main__':\n\n    # Example usage\n\n    a = sint.Array(10)\n\n    # Populate a with secret values\n\n    # ...\n\n    min_index = argmin(a)\n\n    # Reveal or use min_index\n\n    # ...\n\n", "response_1": "def argmin(a):\n\n    current = a[0]\n\n    index = sint(0)\n\n    for i in range(len(a)):\n\n        cond = current <= a[i]\n\n        index = cond.if_else(index, sint(i))\n\n        current = cond.if_else(current, a[i])\n\n    return index\n\n", "model_name": "qwen-qwq"}
{"test_name": "independent_robbery", "response_0": "def independent_robbery(houses):\n    n = len(houses)\n    dp = sint.Array(n)\n    dp.assign_all(0)\n\n    dp[0] = houses[0]\n    dp[1] = dp[1] if dp[1] >= dp[0] else dp[0]\n\n    for i in range(2, n):\n        option1 = dp[i-2] + houses[i]\n        option2 = dp[i-1]\n        dp[i] = option1 if option1 >= option2 else option2\n\n    return dp[-1]\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "sum_odd_and_odd", "response_0": "def sum_odd_and_odd(arr):\n    sum = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            sum += arr[j]\n    return sum\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "is_monotonous", "response_0": "", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef is_monotonous(arr):\n    n = len(arr)\n    if n <= 1:\n        return 1  # Always monotonous if only one element\n    d = [arr[i+1] - arr[i] for i in range(n-1)]\n    sign_d = [(di > 0) - (di < 0) for di in d]\n    sign_d_0 = sign_d[0]\n    eq = [(si == sign_d_0) for si in sign_d[1:]]\n    all_eq = tree_reduce(lambda x, y: x & y, eq)\n    non_zero = (sign_d_0 != 0)\n    result = all_eq & non_zero\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sint, Array\n\ndef positive_count_negative_sum(arr):\n    # Create mask for positive elements\n    positive_mask = arr > 0\n    # Sum the positive mask to get the count\n    count = tree_reduce(lambda x, y: x + y, positive_mask)\n    \n    # Create mask for negative elements\n    negative_mask = arr < 0\n    # Multiply array by negative mask to zero out non-negative elements\n    negative_values = arr * negative_mask\n    # Sum the negative values\n    sum_negatives = tree_reduce(lambda x, y: x + y, negative_values)\n    \n    return count, sum_negatives\n", "response_1": "from Compiler.library import tree_reduce\nfrom Compiler.types import sfix, sint\n\ndef positive_count_negative_sum(arr):\n    assert isinstance(arr, sfix.Array)\n    \n    # Compute mask for positive elements and sum to get count\n    positive_mask = arr > 0\n    count = tree_reduce(lambda x, y: x + y, positive_mask)\n    \n    # Compute mask for negative elements and sum the negative elements\n    negative_mask = arr < 0\n    negative_elements = arr * negative_mask\n    sum_negative = tree_reduce(lambda x, y: x + y, negative_elements)\n    \n    return count, sum_negative\n", "model_name": "qwen-qwq"}
{"test_name": "sum_even", "response_0": "def sum_even(arr):\n    sum = sint(0)\n    \n    def loop_body(i, sum):\n        item = arr[i]\n        is_even = (item % 2) == 0\n        sum.iadd(item * is_even)\n    \n    for_range(arr.length, loop_body, args=(sum,))\n    return sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    # Initialize sum to zero\n    sum = sint(0)\n    \n    # Determine the length of the array\n    n = len(arr)\n    \n    # Iterate over the array\n    for i in for_range(n):\n        # Access the array element\n        item = arr[i]\n        \n        # Check if the item is even\n        is_even = (item % 2) == 0\n        \n        # Conditionally add the item to the sum if it is even\n        sum += is_even.if_else(item, 0)\n    \n    # Return the sum\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    abs_vec = vec.abs()\n    sum = tree_reduce(lambda x, y: x + y, abs_vec)\n    return sum\n", "response_1": "from Compiler.library import tree_reduce\n\ndef one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \n    Parameters:\n    vec (sfix.Array): An array of secret fixed-point numbers.\n    \"\"\"\n    abs_vec = abs(vec)\n    sum = tree_reduce(lambda x, y: x + y, abs_vec)\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "array_floor", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import mpc_math\n\ndef array_floor(arr):\n    ret = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        ret[i] = mpc_math.floor(arr[i])\n    return ret\n", "response_1": "from mpc import *\nfrom mpc_math import *\n\ndef array_floor(arr):\n    ret = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = floor_fx(arr[i])\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "three_five", "response_0": "def three_five(arr):\n    has3 = sint(0)\n    has5 = sint(0)\n    for i in range(arr.size):\n        item = arr[i]\n        has3 = has3.bit_or(item == 3)\n        has5 = has5.bit_or(item == 5)\n    part1 = has3.bit_and(has5)\n    part2 = has3.bit_not().bit_and(has5.bit_not())\n    result = part1.bit_or(part2)\n    return result\n", "response_1": "def three_five(arr):\n\n    is_3 = arr == 3\n\n    is_5 = arr == 5\n\n    has3 = tree_reduce(lambda x, y: x.bit_or(y), is_3)\n\n    has5 = tree_reduce(lambda x, y: x.bit_or(y), is_5)\n\n    part1 = has3.bit_and(has5)\n\n    part2 = has3.bit_not().bit_and(has5.bit_not())\n\n    result = part1.bit_or(part2)\n\n    return result\n\n", "model_name": "qwen-qwq"}
{"test_name": "num_above_average", "response_0": "def num_above_average(arr):\n    sum = tree_reduce(lambda x, y: x + y, arr)\n    avg = sum / len(arr)\n    count = sint(0)\n    for item in arr:\n        count += (item >= avg)\n    return count\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef num_above_average(arr):\n    n = len(arr)\n    sum = tree_reduce(lambda x, y: x + y, arr)\n    avg = sum / n\n    count = tree_reduce(lambda x, y: x + y, [1 if item >= avg else 0 for item in arr])\n    return count\n", "model_name": "qwen-qwq"}
{"test_name": "clip", "response_0": "def clip(a, upper_bound=1, lower_bound=-1):\n    lower = cfix(lower_bound)\n    upper = cfix(upper_bound)\n    below_lower = a < lower\n    above_upper = a > upper\n    clipped = below_lower.if_else(lower, above_upper.if_else(upper, a))\n    a.assign(clipped)\n    return a\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "def sum_with_certain_element_skipped(array):\n    sum = sfix(0)\n    five = sfix(5)\n    ten = sfix(10)\n    for i in range(len(array)):\n        condition = (five <= sum + array[i]).bit_and(sum + array[i] <= ten)\n        condition_sint = condition.to_sint()\n        mask = 1 - condition_sint\n        sum += array[i] * mask\n    return sum\n", "response_1": "def sum_with_certain_element_skipped(array):\n    sum = sint(0)\n    for i in range(len(array)):\n        temp_sum = sum + array[i]\n        cond1 = temp_sum >= 5\n        cond2 = temp_sum <= 10\n        condition = cond1.bit_and(cond2)\n        increment = array[i] * (1 - condition)\n        sum = sum + increment\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.types import sint, Array\n\ndef sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        is_odd = item % 2\n        odd_sum += item * is_odd\n        even_sum += item * (1 - is_odd)\n    return odd_sum, even_sum\n", "response_1": "def sum_of_odd_and_even(arr):\n    from Compiler.types import sint, Array\n    from Compiler.loop import for_range\n\n    size = len(arr)\n    odd_sum = sint(0)\n    even_sum = sint(0)\n\n    for i in for_range(size):\n        item = arr[i]\n        parity = item % 2\n        odd_sum += parity * item\n        even_sum += (sint(1) - parity) * item\n\n    return odd_sum, even_sum\n", "model_name": "qwen-qwq"}
{"test_name": "distance", "response_0": "def distance(vec1, vec2):\n    diff = vec1 - vec2\n    squared_diff = diff ** 2\n    sum_squared = squared_diff.reduce()\n    distance = mpc_math.sqrt(sum_squared)\n    return distance\n", "response_1": "def distance(vec1, vec2):\n    # Assuming vec1 and vec2 are sfix vectors of the same length\n    diff = vec1 - vec2  # Element-wise subtraction\n    squared_diff = diff ** 2  # Element-wise squaring\n    sum_squared = squared_diff.reduce_sum()  # Summing up the squared differences\n    dist = mpc_math.sqrt(sum_squared)  # Taking the square root\n    return dist\n", "model_name": "qwen-qwq"}
{"test_name": "num_occurrence", "response_0": "from Compiler.types import sint, Array\n\nfrom Compiler.library import tree_reduce\n\ndef num_occurrence(arr, target):\n\n    eq = arr == target\n\n    eq_vec = eq.get_vector()\n\n    count = tree_reduce(lambda x, y: x + y, eq_vec)\n\n    return count\n\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "palindrome", "response_0": "def palindrome(arr):\n    flag = sint(1)  # Initialize flag to True (1)\n    n = arr.size   # Get the size of the array\n    for i in range(n // 2):  # Loop from 0 to n//2\n        flag = flag & (arr[i] == arr[n - 1 - i])  # Update flag if elements match\n    return flag  # Return the final flag\n", "response_1": "def check_palindrome(arr, n):\n    \"\"\"\n    Check whether the array is a palindrome.\n\n    Parameters:\n    arr (Array of sint): The array to check.\n    n (regint): The length of the array.\n\n    Returns:\n    regint: 1 if the array is a palindrome, 0 otherwise.\n    \"\"\"\n    flag = sint(1)\n    for i in smpc.for_range(n // 2):\n        flag = flag.bit_and(arr[i] == arr[n - 1 - i])\n    is_palindrome = smpc.open(flag)\n    return is_palindrome\n", "model_name": "qwen-qwq"}
{"test_name": "reverse_order_pair", "response_0": "", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef reverse_order_pair(arr):\n    n = arr.size\n    num = sint(0)\n    for i in for_range(0, n-1):\n        for j in for_range(i+1, n):\n            if arr[i] > arr[j]:\n                num += 1\n    return num\n", "model_name": "qwen-qwq"}
{"test_name": "sum_of_cubes", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_of_cubes(arr):\n    n = arr.size\n    total = sint(0)\n    for i in for_range(0, n):\n        total += arr[i] ** 3\n    return total\n", "response_1": "from Compiler.library import tree_reduce\n\ndef sum_of_cubes(arr):\n    \"\"\"\n    Compute the sum of cubes of elements in the array.\n    \n    Parameters:\n    arr (Array of sint): The input array of secret integers.\n    \n    Returns:\n    sint: The sum of cubes of the elements.\n    \"\"\"\n    # Compute the cube of each element in the array\n    cubes = arr * arr * arr\n    # Use tree_reduce to sum up the cubed elements efficiently\n    sum_cubes = tree_reduce(lambda x, y: x + y, cubes)\n    return sum_cubes\n", "model_name": "qwen-qwq"}
{"test_name": "max_element", "response_0": "def max_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    current = a[0]\n    for i in range(1, len(a)):\n        item = a[i]\n        # Compare current and item, and select the larger one\n        condition = current >= item\n        current = condition.if_else(current, item)\n    return current\n", "response_1": "def max_func(x, y):\n    ge = x >= y\n    return ge.if_else(x, y)\n\ndef max_element(a):\n    return tree_reduce(max_func, a)\n", "model_name": "qwen-qwq"}
{"test_name": "array_if_else", "response_0": "def array_if_else(arr, predicator, if_func, else_func):\n    n = len(arr)\n    # Create arrays for conditions, if_results, and else_results\n    conds = Array(n, lambda i: predicator(arr[i]))\n    if_results = Array(n, lambda i: if_func(arr[i]))\n    else_results = Array(n, lambda i: else_func(arr[i]))\n    # Compute the conditional values\n    arr.assign(conds * if_results + (1 - conds) * else_results)\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "inf_norm", "response_0": "from Compiler.library import tree_reduce\n\ndef inf_norm(vec):\n    abs_vec = abs(vec.get_vector())\n    max_val = tree_reduce(lambda x, y: x.max(y), abs_vec)\n    return max_val\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_inc", "response_0": "", "response_1": "def array_inc(arr):\n    arr.iadd(1)\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "count_rises", "response_0": "class Compiler.types.Array(length, value_type)\n\n   ...\n\n   get_vector(base=0, size=None)\n\n      Return vector with content.\n\n      Parameters:\n\n         * **base** -- starting point (int)\n\n         * **size** -- length (compile-time int)\n\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "skip_at_zero", "response_0": "N = 10  # array size, assumed to be known at compile-time\n\na = sint.Array(N)\n\na.assign_vector(sint.get_input_from(0, size=N))\n\nfor i in range(N):\n\n    condition = (a[i] == 0)\n\n    mask = 1 - condition\n\n    a[i] += mask * 1\n\nresult_vector = a.get_vector()\n\nresult_vector.output(0)\n\n", "response_1": "def skip_at_zero(array):\n    # Compute mask where mask[i] = 1 if array[i] != 0, else 0\n    mask = (array != 0)\n    \n    # Compute array + 1 for all elements\n    add_one = array + 1\n    \n    # Compute the result using the mask\n    result = array * (1 - mask) + add_one * mask\n    \n    # Assign the result back to the array\n    array.assign(result)\n    \n    # Return the modified array\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "array_intersect", "response_0": "def array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element.\n    \"\"\"\n    # Assuming p and q are lists of sint\n    len_p = len(p)\n    len_q = len(q)\n    \n    # Create arrays from p and q\n    arr_p = sint.Array(len_p)\n    arr_p.assign(p)\n    \n    arr_q = sint.Array(len_q)\n    arr_q.assign(q)\n    \n    # Create a matrix to hold all comparisons\n    comparisons = sint.Matrix(len_p, len_q)\n    for i in range(len_p):\n        for j in range(len_q):\n            comparisons[i][j] = (arr_p[i] == arr_q[j])\n    \n    # Flatten the matrix and check if any comparison is True\n    flat_comparisons = comparisons.get_vector()\n    any_true = tree_reduce(lambda x, y: x.bit_or(y), flat_comparisons)\n    \n    return any_true\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef array_intersect(p, q):\n    # Create a flattened array for comparisons\n    num_elements = len(p) * len(q)\n    comparison_flattened = Array(num_elements, sint)\n    \n    # Populate the flattened array with comparisons\n    index = 0\n    for i in range(len(p)):\n        for j in range(len(q)):\n            comparison_flattened[index] = p[i] == q[j]\n            index += 1\n    \n    # Perform tree-reduced OR to check for any True in comparisons\n    result = tree_reduce(lambda x, y: x.bit_or(y), comparison_flattened)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "two_norm", "response_0": "", "response_1": "from Compiler import mpc\nfrom Compiler.types import sfix, Array\nfrom Compiler.library import tree_reduce\nfrom Compiler import mpc_math\n\n@mpc.coroutine\ndef two_norm(vec):\n    \"\"\"\n    Compute the two-norm of a vector.\n\n    Parameters:\n    - vec: Array of sfix representing the vector.\n\n    Returns:\n    - sfix: The two-norm of the vector.\n    \"\"\"\n    # Square each element of the vector\n    squares = vec ** 2\n    \n    # Sum the squares using tree reduction\n    sum_squares = tree_reduce(lambda x, y: x + y, squares)\n    \n    # Compute the square root of the sum\n    norm = mpc_math.sqrt(sum_squares)\n    \n    return norm\n", "model_name": "qwen-qwq"}
{"test_name": "sum_between", "response_0": "def sum_between(arr, l, u):\n    condition = (l <= arr).bit_and(arr <= u)\n    masked_arr = arr * condition\n    sum = tree_reduce(lambda x, y: x + y, masked_arr)\n    return sum\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef sum_between(arr, l, u):\n    condition = (l <= arr).bit_and(arr <= u)\n    temp = arr.schur(condition)\n    sum_result = tree_reduce(lambda x, y: x + y, temp.get_vector())\n    return sum_result\n", "model_name": "qwen-qwq"}
{"test_name": "largest_gap", "response_0": "def largest_gap(arr):\n    cur = sint(0)\n    n = arr.size - 1\n    for i in for_range(n):\n        diff = arr[i+1] - arr[i]\n        abs_diff = abs(diff)\n        condition = abs_diff > cur\n        cur = condition.if_else(abs_diff, cur)\n    return cur\n", "response_1": "from Compiler.types import Array, sfix\nfrom Compiler.library import tree_reduce\n\ndef largest_gap(arr):\n    differences = (arr[1:] - arr[:-1]).abs()\n    max_diff = tree_reduce(lambda x, y: x.max(y), differences)\n    return max_diff\n", "model_name": "qwen-qwq"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    amin = tree_reduce(lambda x, y: x.min(y), a)\n    bmax = tree_reduce(lambda x, y: x.max(y), b)\n    return amin >= bmax\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "element_count", "response_0": "from Compiler.library import tree_reduce\n\ndef element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \n    Parameters:\n    arr (Array of sint or sfix): The array to search within.\n    target (sint or sfix): The element to count in the array.\n    \n    Returns:\n    sint: The count of how many times the target appears in the array.\n    \"\"\"\n    # Perform element-wise comparison\n    comp = arr == target\n    \n    # Convert the comparison result to a vector\n    vec = comp.get_vector()\n    \n    # Sum the vector using tree reduction\n    sum = tree_reduce(lambda x, y: x + y, vec)\n    \n    return sum\n", "response_1": "def element_count(arr, target):\n    n = arr.size\n    conditions = sint.Array(n)\n    for i in range(n):\n        conditions[i] = (arr[i] == target).to_sint()\n    return tree_reduce(lambda x, y: x + y, conditions)\n", "model_name": "qwen-qwq"}
{"test_name": "is_subarray", "response_0": "from Compiler.types import Array, sint, sbitint\nfrom Compiler.library import for_range\n\ndef is_subarray(c, d):\n    len_c = len(c)\n    len_d = len(d)\n    result = sbitint(0)\n    for i in for_range(len_d - len_c + 1):\n        flag = sbitint(1)\n        for j in for_range(len_c):\n            flag = flag.bit_and(d[i + j] == c[j])\n        result = result.bit_or(flag)\n    return result.Reveal()\n", "response_1": "def is_subarray(c, d):\n    m = len(c)\n    n = len(d)\n    potential_starts = n - m + 1  # Number of possible starting indices\n\n    # Initialize result to False\n    result = sint(0)\n\n    for i in range(potential_starts):\n        # Assume match at this start index\n        match = sint(1)\n        for j in range(m):\n            # If any element doesn't match, set match to False\n            match = match.bit_and(d[i + j] == c[j])\n        # Accumulate the match result\n        result = result.bit_or(match)\n\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.library import tree_reduce\n\ndef exists_5_or_7(arr):\n    comparisons = (arr == 5) | (arr == 7)\n    result = tree_reduce(lambda x, y: x | y, comparisons)\n    return result\n", "response_1": "from Compiler.library import tree_reduce\n\ndef exists_5_or_7(arr):\n    fives = arr == 5\n    sevens = arr == 7\n    or_result = fives.bit_or(sevens)\n    result = tree_reduce(lambda x, y: x.bit_or(y), or_result)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "variance", "response_0": "def variance(arr):\n    sum_arr = tree_reduce(lambda x, y: x + y, arr.get_vector())\n    n = cfix(len(arr))\n    average = sum_arr / n\n    squared_diff = (arr - average).schur(arr - average)\n    sum_squared_diff = tree_reduce(lambda x, y: x + y, squared_diff.get_vector())\n    variance = sum_squared_diff / n\n    return variance\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "is_ascending", "response_0": "", "response_1": "from Compiler.library import tree_reduce\nfrom Compiler.types import sint, sbit\n\ndef is_ascending(arr):\n    n = len(arr)\n    if n == 1:\n        return sbit(1)\n    else:\n        comparisons = [arr[i] < arr[i + 1] for i in range(n - 1)]\n        result = tree_reduce(lambda x, y: x & y, comparisons)\n        return result\n", "model_name": "qwen-qwq"}
{"test_name": "xor_all", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sint\n\ndef xor_all(arr):\n    return tree_reduce(lambda x, y: x.bit_xor(y), arr)\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "upper_bound", "response_0": "def upper_bound(arr, x):\n    n = len(arr)\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n\n    for i in range(n):\n        is_greater = arr[i] > x\n        new_distance = arr[i] - x\n\n        condition = is_greater\n        if found:\n            condition = condition.and_(new_distance < distance)\n\n        ret = condition.if_else(i, ret)\n        distance = condition.if_else(new_distance, distance)\n        found = condition.or_(found)\n\n    return ret\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler.types import Array\n\ndef array_process_then_sum(arr, func):\n    if len(arr) == 0:\n        zero = arr.value_type(0)\n        return zero\n    sum_result = func(arr[0])\n    for v in arr[1:]:\n        processed_v = func(v)\n        sum_result += processed_v\n    return sum_result\n", "response_1": "def array_process_then_sum(arr, func):\n    # Initialize sum to zero\n    sum = 0\n    # Determine the length of the array\n    n = len(arr)\n    # Iterate over the array\n    for i in range(n):\n        # Process the element using the given function\n        arr[i] = func(arr[i])\n        # Add the processed element to the sum\n        sum += arr[i]\n    # Return the sum\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "average", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\ndef average(arr):\n    length = arr.size\n    sum = sfix(0)\n    for i in for_range(length):\n        sum += arr[i]\n    average = sum / length\n    return average\n", "response_1": "from Compiler.types import Array, sfix\nfrom Compiler.library import tree_reduce\n\ndef average(arr):\n    sum = tree_reduce(lambda x, y: x + y, arr)\n    length = len(arr)\n    avg = sum / length\n    return avg\n", "model_name": "qwen-qwq"}
{"test_name": "array_filter", "response_0": "def array_filter(arr, predicator):\n    n = len(arr)\n    for i in range(n):\n        bit = predicator(arr[i])\n        arr[i] = arr[i] * bit\n    return arr\n", "response_1": "from Compiler.types import sint, Array, cint\nfrom Compiler.library import for_range\n\ndef array_filter(arr, pred):\n    n = len(arr)\n    for i in for_range(n):\n        x = arr[i]\n        cond = pred(x)\n        arr[i] = cond.if_else(x, sint(0))\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "sum_up", "response_0": "def sum_up(array: Array[sint], size: 'int') -> sint:\n    sum = sint(0)\n    for i in for_range(size):\n        sum.iadd(array[i])\n    return sum\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "negative_to_zero", "response_0": "from Compiler.types import Array, sint\nfrom Compiler.library import for_range\n\ndef negative_to_zero(array):\n    n = array.size\n    for i in for_range(n):\n        array[i] = array[i].max(0)\n    return array\n", "response_1": "def negative_to_zero(array):\n    return array.max(0)\n", "model_name": "qwen-qwq"}
{"test_name": "sum_only_positive_to_ten", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "bubble_sort", "response_0": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-1-i):\n            # Compare arr[j] and arr[j+1]\n            condition = arr[j] >= arr[j+1]\n            # Conditionally swap if arr[j] >= arr[j+1]\n            arr[j], arr[j+1] = condition.cond_swap(arr[j], arr[j+1])\n    return arr\n", "response_1": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-1-i):\n            condition = arr[j] >= arr[j+1]\n            arr[j], arr[j+1] = arr[j].cond_swap(arr[j+1], condition)\n", "model_name": "qwen-qwq"}
