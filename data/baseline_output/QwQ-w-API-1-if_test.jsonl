{"test_name": "sin_or_cos", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import sfix, sintbit\n\ndef sin_or_cos(x):\n    # Determine if x is non-negative\n    is_nonneg = x >= 0\n    \n    # Compute sine and cosine of x\n    sin_x = mpc_math.sin(x)\n    cos_x = mpc_math.cos(x)\n    \n    # Select sin(x) if x is non-negative, else cos(x)\n    result = is_nonneg.if_else(sin_x, cos_x)\n    \n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef sin_or_cos(x):\n    sin_x = mpc_math.sin(x)\n    cos_x = mpc_math.cos(x)\n    condition = x >= 0\n    result = condition.if_else(sin_x, cos_x)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    condition = input < 0\n    return condition.if_else(input, sfix(0))\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return input.min(sfix(0))\n", "model_name": "qwen-qwq"}
{"test_name": "is_close", "response_0": "from Compiler.types import sfix\n\ndef is_close(a, b):\n    diff = a - b\n    abs_diff = abs(diff)\n    result = abs_diff <= sfix(1)\n    return result\n", "response_1": "def is_close(a, b):\n    diff = a - b\n    abs_diff = abs(diff)\n    result = abs_diff <= 1\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "hardswish", "response_0": "", "response_1": "def hardswish(x):\n    cond1 = x < -3\n    cond2 = x > 3\n    return cond1.if_else(0, cond2.if_else(x, x * (x + 3) / 6))\n", "model_name": "qwen-qwq"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    # Check if x is greater than 6\n    greater_than_6 = x > 6\n    # Check if x is less than -6\n    less_than_neg6 = x < -6\n    # If x > 6, return 6; else if x < -6, return -6; else return x\n    result = greater_than_6.if_else(6, less_than_neg6.if_else(-6, x))\n    return result\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    mask1 = (x > sint(1))\n    mask2 = (x < sint(-1))\n    mask3 = (x > sint(0)) & (~mask1)\n    mask4 = (x < sint(0)) & (~mask2)\n    \n    one = sint(1)\n    m_one = sint(-1)\n    zero = sint(0)\n    \n    ret = (mask1 * x) + (mask2 * x) + (mask3 * one) + (mask4 * m_one)\n    return ret\n", "response_1": "def piecewise_function(x):\n\n    ret = sint(0)\n\n    cond1 = x > 1\n\n    ret = cond1.if_else(x, ret)\n\n    not_cond1 = ~cond1\n\n    cond2 = x < -1\n\n    ret = not_cond1.if_else(cond2.if_else(x, ret), ret)\n\n    not_cond1_and_not_cond2 = not_cond1 & ~cond2\n\n    cond3 = x > 0\n\n    ret = not_cond1_and_not_cond2.if_else(cond3.if_else(sint(1), ret), ret)\n\n    not_cond1_and_not_cond2_and_not_cond3 = not_cond1_and_not_cond2 & ~cond3\n\n    cond4 = x < 0\n\n    ret = not_cond1_and_not_cond2_and_not_cond3.if_else(cond4.if_else(sint(-1), ret), ret)\n\n    return ret\n\n", "model_name": "qwen-qwq"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    min_val = tree_reduce(lambda x, y: x.min(y), [a, b, c])\n    max_val = tree_reduce(lambda x, y: x.max(y), [a, b, c])\n    sum = a + b + c\n    middle = sum - min_val - max_val\n    return middle\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler import mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    sin_x = mpc_math.sin(x)\n    cos_x = mpc_math.cos(x)\n    result = ind.if_else(sin_x, cos_x)\n    return result\n", "response_1": "def indicated_sin_or_cos(x, ind):\n    # Assuming x is of type sfix and ind is of type sintbit\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n    result = sin_val if ind else cos_val\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "minus2_if_else", "response_0": "from Compiler.types import sint\n\ndef minus2_if_else(x):\n    c = x >= 2\n    y = x - 2\n    return c.if_else(y, x)\n", "response_1": "def minus2_if_else(x):\n    two = cint(2)\n    y = x - two\n    c = y >= 0\n    return c.if_else(y, x)\n", "model_name": "qwen-qwq"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    zero = sfix(0)\n    six = sfix(6)\n    mask_neg = x < zero\n    mask_pos = x > six\n    temp = mask_pos.if_else(six, x)\n    result = mask_neg.if_else(zero, temp)\n    return result\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function for secret fixed-point numbers.\n    \"\"\"\n    zero = sfix(0)\n    six = sfix(6)\n    \n    # Check if x < 0\n    is_negative = x < zero\n    # Check if x > 6\n    is_greater_than_six = x > six\n    \n    # If x < 0, return 0\n    # Else, if x > 6, return 6\n    # Else, return x\n    result = is_negative.if_else(zero, is_greater_than_six.if_else(six, x))\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "exp_slide", "response_0": "log2_e_fix = cfix(math.log2(math.e))\nexp_arg_fix = (x_fix * log2_e_fix) >> k\nresult = mpc_math.pow_fx(cfix(2), exp_arg_fix)\n", "response_1": "from Compiler.types import sfix\nfrom mpc_math import exp\n\ndef exp_slide(x):\n    is_nonnegative = (x >= 0).to_sint()\n    exp_part = exp(x)\n    linear_part = x + 1\n    result = is_nonnegative * exp_part + (1 - is_nonnegative) * linear_part\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "pass_or_not", "response_0": "from Compiler.types import sint, sbitint\n\ndef pass_or_not(score):\n    # Compare score to 60, returns sbitint\n    passed_bit = score >= 60\n    \n    # Select actual score if passed, else 59\n    selected_score = passed_bit.if_else(score, sint(59))\n    \n    # Select 1 (True) if passed, else 0 (False)\n    passed = passed_bit.if_else(sbitint(1), sbitint(0))\n    \n    return selected_score, passed\n", "response_1": "def pass_or_not(score):\n    threshold = sint(60)\n    is_passed = (score >= threshold)\n    adjusted_score = is_passed.if_else(score, sint(59))\n    passed = is_passed.if_else(sint(1), sint(0))\n    return adjusted_score, passed\n", "model_name": "qwen-qwq"}
{"test_name": "how_many_roots", "response_0": "", "response_1": "def how_many_roots(a, b, c):\n    # Define constants as sint types\n    zero = sint(0)\n    one = sint(1)\n    two = sint(2)\n    \n    # Check if a is zero\n    is_a_zero = (a == zero)\n    \n    # Check if b is zero\n    is_b_zero = (b == zero)\n    \n    # Compute discriminant\n    discriminant = b ** 2 - 4 * a * c\n    \n    # Check if discriminant > 0\n    is_discr_greater_than_zero = (discriminant > zero)\n    \n    # Check if discriminant == 0\n    is_discr_zero = (discriminant == zero)\n    \n    # Determine the number of roots based on conditions\n    result = is_a_zero.if_else(\n        is_b_zero.if_else(zero, one),\n        is_discr_greater_than_zero.if_else(\n            two,\n            is_discr_zero.if_else(one, zero)\n        )\n    )\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "elu", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef elu(x):\n    # Compute the condition x > 0\n    cond = x > 0\n\n    # Compute e^x - 1\n    e_x_minus_1 = mpc_math.exp(x) - 1\n\n    # Select between x and e^x - 1 based on the condition\n    result = cond.if_else(x, e_x_minus_1)\n\n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef elu(x):\n    positive = x > 0\n    branch1 = x\n    branch2 = mpc_math.exp(x) - 1\n    return positive.if_else(branch1, branch2)\n", "model_name": "qwen-qwq"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function for secret fixed-point numbers.\n    \"\"\"\n    # Compare x with 0\n    condition = x > 0\n    # Use the condition to select between x and 0\n    return condition.if_else(x, 0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    zero = sfix(0)\n    return x.max(zero)\n", "model_name": "qwen-qwq"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    return x.max(alpha * x)\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "max", "response_0": "", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    cond = a >= b\n    return cond.if_else(a, b)\n", "model_name": "qwen-qwq"}
{"test_name": "bowl_shape", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "rounded_kinetic_energy", "response_0": "def rounded_kinetic_energy(m, v):\n    k = m * v * v / 2\n    k_int = k.floor()\n    fractional = k - k_int\n    round_up = fractional >= 0.5\n    result = k_int + round_up.if_else(1, 0)\n    return result\n", "response_1": "def rounded_kinetic_energy(m, v):\n\n    f = 16  # number of fractional bits in sfix\n\n    k = (m * v ** 2) / 2\n\n    k_rounded = (k + sfix(0.5)) >> f\n\n    return k_rounded\n\n", "model_name": "qwen-qwq"}
{"test_name": "danger_test", "response_0": "from Compiler.types import sint\n\n# Securely get input for origin and damage from party 0\norigin = sint.get_input_from(0)\ndamage = sint.get_input_from(0)\n\n# Compute health after damage\nhealth_after_damage = origin - damage\n\n# Check if health after damage is less than or equal to 10\nis_dangerous = health_after_damage <= 10\n\n# Output the result to party 0\nis_dangerous.output(0)\n", "response_1": "def danger_test(origin, damage):\n    return origin - damage <= 10\n", "model_name": "qwen-qwq"}
{"test_name": "indicated_sum_or_multiply", "response_0": "", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    sum_result = x + y\n    product_result = x * y\n    return ind.if_else(sum_result, product_result)\n", "model_name": "qwen-qwq"}
{"test_name": "median", "response_0": "", "response_1": "def median(arr):\n    n = arr.size()\n    if n == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    arr.sort()\n    mid = n // 2\n    is_odd = n % 2\n    if is_odd:\n        return arr[mid]\n    else:\n        return (arr[mid] + arr[mid - 1]) / 2\n", "model_name": "qwen-qwq"}
{"test_name": "add_upto_10", "response_0": "from Compiler.types import sint\n\ndef add_upto_10(a: sint, b: sint):\n    sum_ab = a + b\n    is_greater = sum_ab > 10\n    return is_greater.if_else(10, sum_ab)\n", "response_1": "def add_upto_10(a, b):\n    sum_ab = a + b\n    result = sum_ab.min(sint(10))\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    # Define constants\n    base_fare = sfix(5.0)\n    threshold1 = sfix(5.0)\n    threshold2 = sfix(10.0)\n    rate1 = sfix(1.2)\n    rate2 = sfix(1.5)\n    \n    # Compute the fare\n    part1 = base_fare\n    part2 = rate1 * (m - threshold1)\n    part3 = rate2 * (m - threshold2)\n    \n    # Determine the conditions\n    cond1 = m <= threshold1\n    cond2 = (m > threshold1) & (m <= threshold2)\n    cond3 = m > threshold2\n    \n    # Compute the total fare using conditional operations\n    fare = (cond1 * part1) + (cond2 * (part1 + part2)) + (cond3 * (part1 + part2 + part3))\n    \n    return fare\n", "response_1": "def taxi_fare(m):\n    # Define constants as sfix for fixed-point arithmetic\n    five = sfix(5)\n    ten = sfix(10)\n    fare_base = sfix(5)\n    rate_mid = sfix(1.2)\n    rate_high = sfix(1.5)\n    fare_step = sfix(11)\n    \n    # Compute conditions\n    is_m_le_5 = m <= five\n    is_m_le_10 = m <= ten\n    \n    # Compute fares for each case\n    fare1 = fare_base\n    fare2 = fare_base + rate_mid * (m - five)\n    fare3 = fare_step + rate_high * (m - ten)\n    \n    # Select the correct fare based on conditions\n    fare = is_m_le_5.if_else(fare1, is_m_le_10.if_else(fare2, fare3))\n    \n    return fare\n", "model_name": "qwen-qwq"}
{"test_name": "round", "response_0": "def round(x):\n    f = x.f  # Number of fractional bits in x\n    x_int_sint = x.v >> f\n    x_int = sfix(x_int_sint)\n    fraction = x - x_int\n    half = sfix(0.5)\n    condition = fraction < half\n    result = condition.if_else(x_int + 1, x_int)\n    return result\n", "response_1": "def round(x):\n    x_int = x.floor()\n    decimal_part = x - x_int\n    round_up = decimal_part >= sfix(0.5)\n    round_up_int = round_up.to_sint()\n    result = x_int + round_up_int\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    # Compute masks for each GPA range\n    mask1 = (score >= 90)\n    mask2 = (score >= 85).bit_and(score < 90)\n    mask3 = (score >= 80).bit_and(score < 85)\n    mask4 = (score >= 75).bit_and(score < 80)\n    mask5 = (score >= 70).bit_and(score < 75)\n    mask6 = (score < 70)\n    \n    # Define GPA values as sfix\n    gpa1 = sfix(4.0)\n    gpa2 = sfix(3.6)\n    gpa3 = sfix(3.3)\n    gpa4 = sfix(3.0)\n    gpa5 = sfix(2.6)\n    gpa6 = sfix(2.3)\n    \n    # Compute the final GPA\n    gpa = (gpa1 * mask1 + gpa2 * mask2 +\n           gpa3 * mask3 + gpa4 * mask4 +\n           gpa5 * mask5 + gpa6 * mask6)\n    \n    return gpa\n", "response_1": "def gpa_calculator(score):\n    # Define the GPA values\n    gpa4 = sfix(4.0)\n    gpa3_6 = sfix(3.6)\n    gpa3_3 = sfix(3.3)\n    gpa3_0 = sfix(3.0)\n    gpa2_6 = sfix(2.6)\n    gpa2_3 = sfix(2.3)\n\n    # Define the score thresholds\n    threshold90 = sfix(90.0)\n    threshold85 = sfix(85.0)\n    threshold80 = sfix(80.0)\n    threshold75 = sfix(75.0)\n    threshold70 = sfix(70.0)\n\n    # Compute the GPA based on score using conditional selection\n    gpa = sfix(0.0)  # Initialize GPA\n\n    # 90 <= score: 4.0\n    cond1 = score >= threshold90\n    gpa = cond1.if_else(gpa4, gpa)\n\n    # 85 <= score < 90: 3.6\n    cond2 = (score >= threshold85) & (score < threshold90)\n    gpa = cond2.if_else(gpa3_6, gpa)\n\n    # 80 <= score < 85: 3.3\n    cond3 = (score >= threshold80) & (score < threshold85)\n    gpa = cond3.if_else(gpa3_3, gpa)\n\n    # 75 <= score < 80: 3.0\n    cond4 = (score >= threshold75) & (score < threshold80)\n    gpa = cond4.if_else(gpa3_0, gpa)\n\n    # 70 <= score < 75: 2.6\n    cond5 = (score >= threshold70) & (score < threshold75)\n    gpa = cond5.if_else(gpa2_6, gpa)\n\n    # 0 <= score < 70: 2.3\n    cond6 = (score < threshold70)\n    gpa = cond6.if_else(gpa2_3, gpa)\n\n    return gpa\n", "model_name": "qwen-qwq"}
{"test_name": "sign", "response_0": "def sign(x):\n    is_zero = (x == 0)\n    is_positive = (x > 0)\n    sign = is_positive * 1 + (1 - is_positive - is_zero) * (-1)\n    return sign\n", "response_1": "def sign(x):\n    is_zero = (x == 0)\n    is_positive = (x > 0)\n    zero = x.__class__(0)\n    one = x.__class__(1)\n    neg_one = x.__class__(-1)\n    temp = is_positive.if_else(one, neg_one)\n    result = is_zero.if_else(zero, temp)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "sum_or_difference", "response_0": "from Compiler.types import sint\n\ndef sum_or_difference(a, b):\n    condition = a <= b\n    sum_result = a + b\n    difference = a - b\n    result = condition.if_else(sum_result, difference)\n    return result\n", "response_1": "def sum_or_difference(a, b):\n    cond = a <= b  # This will be a sbitint\n    sum_result = a + b\n    difference = a - b\n    result = sum_result * cond + difference * (1 - cond)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    flip_bit.update(control_bit.bit_xor(flip_bit))\n", "response_1": "def CNOT(control_bit, flip_bit):\n    return control_bit.bit_xor(flip_bit)\n", "model_name": "qwen-qwq"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    condition = y < 0\n    result = condition.if_else(y + 1, y)\n    return result\n", "response_1": "def negative_plus1(y):\n    cond = y < 0\n    result = (y + 1) * cond + y * (1 - cond)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler.types import sfix, sbitint\n\ndef is_a_parallelogram(a, b, c, d):\n    # Check if any two points are the same\n    same_ab = (a[0] == b[0]) & (a[1] == b[1])\n    same_ac = (a[0] == c[0]) & (a[1] == c[1])\n    same_ad = (a[0] == d[0]) & (a[1] == d[1])\n    same_bc = (b[0] == c[0]) & (b[1] == c[1])\n    same_bd = (b[0] == d[0]) & (b[1] == d[1])\n    same_cd = (c[0] == d[0]) & (c[1] == d[1])\n    any_same = same_ab | same_ac | same_ad | same_bc | same_bd | same_cd\n    \n    # If any two points are the same, return False\n    if any_same:\n        return 0\n    \n    # Check the three conditions for parallelogram\n    cond1 = (a[0] + b[0] == c[0] + d[0]) & (a[1] + b[1] == c[1] + d[1])\n    cond2 = (a[0] + c[0] == b[0] + d[0]) & (a[1] + c[1] == b[1] + d[1])\n    cond3 = (a[0] + d[0] == b[0] + c[0]) & (a[1] + d[1] == b[1] + c[1])\n    \n    # Return True if any condition is met\n    return cond1 | cond2 | cond3\n", "response_1": "def same(x, y):\n    return (x[0] == y[0]).bit_and(x[1] == y[1])\n\ndef is_a_parallelogram(a, b, c, d):\n    # Check if any two vertices are the same\n    same_ab = same(a, b)\n    same_ac = same(a, c)\n    same_ad = same(a, d)\n    same_bc = same(b, c)\n    same_bd = same(b, d)\n    same_cd = same(c, d)\n    any_same = same_ab.bit_or(same_ac).bit_or(same_ad).bit_or(same_bc).bit_or(same_bd).bit_or(same_cd)\n    \n    # Check the parallelogram conditions\n    cond1 = (a[0] + b[0] == c[0] + d[0]).bit_and(a[1] + b[1] == c[1] + d[1])\n    cond2 = (a[0] + c[0] == b[0] + d[0]).bit_and(a[1] + c[1] == b[1] + d[1])\n    cond3 = (a[0] + d[0] == b[0] + c[0]).bit_and(a[1] + d[1] == b[1] + c[1])\n    any_cond = cond1.bit_or(cond2).bit_or(cond3)\n    \n    # Final result: not any_same and any_cond\n    result = any_cond.bit_and(any_same.bit_not())\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "min", "response_0": "from Compiler.types import sint, sfix, cint, cfix\n\ndef min_sint(a, b):\n    c = a <= b\n    return c.if_else(a, b)\n\ndef min_sfix(a, b):\n    c = a <= b\n    return c.if_else(a, b)\n\ndef min_cint(a, b):\n    c = a <= b\n    return c.if_else(a, b)\n\ndef min_cfix(a, b):\n    c = a <= b\n    return c.if_else(a, b)\n", "response_1": "def min(a, b):\n    condition = a <= b\n    return condition.if_else(a, b)\n", "model_name": "qwen-qwq"}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x, y):\n    # Define all possible knight moves\n    moves = [\n        (x + 1, y + 2),\n        (x - 1, y + 2),\n        (x + 1, y - 2),\n        (x - 1, y - 2),\n        (x + 2, y + 1),\n        (x - 2, y + 1),\n        (x + 2, y - 1),\n        (x - 2, y - 1)\n    ]\n    \n    # Helper function to check if a position is legal\n    def legal(a, b):\n        return (a >= 0).bit_and(a <= 7).bit_and(b >= 0).bit_and(b <= 7)\n    \n    # Compute the legality of each move and sum up the results\n    legal_bits = [legal(a, b) for a, b in moves]\n    count = sum(legal_bits)\n    \n    return count\n", "response_1": "from Compiler.types import sint\n\ndef choice_of_the_knight(x, y):\n    counter = sint(0)\n\n    def legal(a, b):\n        return (a >= 0) & (a <= 7) & (b >= 0) & (b <= 7)\n\n    moves = [\n        (x + 1, y + 2),\n        (x - 1, y + 2),\n        (x + 1, y - 2),\n        (x - 1, y - 2),\n        (x + 2, y + 1),\n        (x - 2, y + 1),\n        (x + 2, y - 1),\n        (x - 2, y - 1)\n    ]\n\n    for dx, dy in moves:\n        l = legal(dx, dy)\n        counter += l.if_else(sint(1), sint(0))\n\n    return counter\n", "model_name": "qwen-qwq"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    sum = a + b\n    diff = a - b\n    cmp = sum > diff\n    return cmp.if_else(sum, diff)\n", "response_1": "def max_sum_different(a, b):\n    sum_ab = a + b\n    diff_ab = a - b\n    return sum_ab.max(diff_ab)\n", "model_name": "qwen-qwq"}
