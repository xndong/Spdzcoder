{"test_name": "next_integer", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "father_and_son", "response_0": "from Compiler.types import sint\n\n# Receive inputs\nfather_age = sint.get_input_from(0)\nson_age = sint.get_input_from(1)\n\n# Compute twice the son's age\ntwice_son_age = son_age * 2\n\n# Compute the difference\ndifference = father_age - twice_son_age\n\n# Compute the absolute value\nresult = difference.abs()\n\n# Output the result\nresult.output()\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "triangle_area", "response_0": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the area of the triangle.\n    \"\"\"\n    area = side * height / 2\n    return area\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "sin_plus_cos", "response_0": "from mpc_math import sin, cos\nfrom Compiler.types import sfix\n\ndef sin_plus_cos(a: sfix) -> sfix:\n    return sin(a) + cos(a)\n", "response_1": "def sin_plus_cos(a):\n    import mpc_math\n    sin_a = mpc_math.sin(a)\n    cos_a = mpc_math.cos(a)\n    result = sin_a + cos_a\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "sigmoid", "response_0": "", "response_1": "def sigmoid(x):\n    import mpc_math\n    return 1 / (1 + mpc_math.exp(-x))\n", "model_name": "qwen-qwq"}
{"test_name": "self_exponent", "response_0": "", "response_1": "def secure_pow(base, exponent):\n    \"\"\"\n    Securely computes base raised to the power of exponent using exponentiation by squaring.\n    \n    Parameters:\n    - base: sint, the base of the exponentiation.\n    - exponent: sint, the exponent.\n    \n    Returns:\n    - sint, the result of base^exponent.\n    \"\"\"\n    # Determine the bit length of the exponent\n    bit_length = exponent.bit_length()\n    \n    # Get the bits of the exponent\n    exponent_bits = exponent.bit_decompose(bit_length)\n    \n    # Initialize result to 1\n    result = 1\n    \n    # Current power of base\n    current = base\n    \n    for bit in exponent_bits:\n        # If the bit is set, multiply result by current\n        condition = bit == 1\n        result = condition.if_else(result * current, result)\n        \n        # Square current for the next iteration\n        current = current * current\n    \n    return result\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \n    Parameters:\n    - k: sint, the secret integer.\n    \n    Returns:\n    - sint, k raised to the power of k.\n    \"\"\"\n    return secure_pow(k, k)\n", "model_name": "qwen-qwq"}
{"test_name": "silu", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    return x / (sfix(1) + mpc_math.exp(-x))\n", "response_1": "def silu(x):\n    \"\"\"\n    SiLU function implemented in MP-SPDZ\n    \"\"\"\n    # Compute e^(-x)\n    exp_neg_x = mpc_math.exp(-x)\n    \n    # Compute the denominator: 1 + e^(-x)\n    denominator = 1 + exp_neg_x\n    \n    # Compute SiLU: x / denominator\n    result = x / denominator\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "Gaussian_bracket", "response_0": "from mpc_math import floor\n\ndef Gaussian_bracket(x):\n    x_floor = floor(x)\n    return x - x_floor\n", "response_1": "def Gaussian_bracket(x):\n    trunc_x = x.trunc()\n    is_greater = trunc_x > x\n    floor_x = trunc_x - is_greater\n    fractional_part = x - floor_x\n    return fractional_part\n", "model_name": "qwen-qwq"}
{"test_name": "asin_and_square", "response_0": "def asin_and_square(x):\n    import mpc_math\n    y = mpc_math.asin(x)\n    result = mpc_math.pow_fx(y, 2)\n    return result\n", "response_1": "def asin_and_square(x):\n    import mpc_math\n    return mpc_math.asin(x) ** 2\n", "model_name": "qwen-qwq"}
{"test_name": "cylinder_surface", "response_0": "def cylinder_surface(r, h):\n    from Compiler.types import cfix, sfix\n    pi = cfix(3.141592653589793)\n    term1 = 2 * pi * (r ** 2)\n    term2 = 2 * pi * r * h\n    surface_area = term1 + term2\n    return surface_area\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    pi = mpc_math.pi()\n    term1 = 2 * pi * mpc_math.pow_fx(r, 2)\n    term2 = 2 * pi * r * h\n    return term1 + term2\n", "model_name": "qwen-qwq"}
{"test_name": "radian_to_degree", "response_0": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    pi = sfix(math.pi)\n    return r / pi * 180\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "square_root", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef square_root(a):\n    \"\"\"\n    Return the square root of the input.\n    \"\"\"\n    return mpc_math.sqrt(a)\n", "response_1": "import mpc_math\n\ndef square_root(a):\n    \"\"\"\n    Return the square root of the input.\n\n    Parameters:\n    a (sfix): The input number for which to compute the square root.\n\n    Returns:\n    sfix: The square root of the input number.\n    \"\"\"\n    return mpc_math.sqrt(a)\n", "model_name": "qwen-qwq"}
{"test_name": "cosine_theorem", "response_0": "from Compiler import mpc_math\n\ndef cosine_theorem(a, b, rad):\n\n    return mpc_math.sqrt(a * a + b * b - 2 * a * b * mpc_math.cos(rad))\n\n", "response_1": "def cosine_theorem(a, b, rad):\n    assert isinstance(a, sfix), \"a must be sfix\"\n    assert isinstance(b, sfix), \"b must be sfix\"\n    assert isinstance(rad, sfix), \"rad must be sfix\"\n    \n    a_sq = a * a\n    b_sq = b * b\n    ab = a * b\n    cos_rad = mpc_math.cos(rad)\n    prod = 2 * ab * cos_rad\n    sum_sq = a_sq + b_sq\n    diff = sum_sq - prod\n    result = mpc_math.sqrt(diff)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "lights_states", "response_0": "", "response_1": "from Compiler.types import cint\n\ndef main():\n    num = cint.get_input_from(0)\n    result = cint(2) ** num\n    print(result)\n", "model_name": "qwen-qwq"}
{"test_name": "degree_to_radian", "response_0": "from Compiler.types import sfix, cfix\n\ndef degree_to_radian(degrees):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    # Define \u03c0 as a clear fixed-point number\n    pi = cfix(3.141592653589793)\n    \n    # Convert degrees to radians\n    radians = degrees / 180 * pi\n    return radians\n", "response_1": "def degree_to_radian(d):\n    from mpc_math import cfix, sfix\n    # Define constants with appropriate precision\n    degrees_per_radian = cfix(180.0, 10, 14)\n    pi = cfix(3.1415926535, 10, 14)\n    # Ensure d has the same precision\n    d = sfix(d, 10, 14)\n    # Perform conversion\n    radians = (d / degrees_per_radian) * pi\n    return radians\n", "model_name": "qwen-qwq"}
{"test_name": "Fah_to_Cel", "response_0": "def Fah_to_Cel(F):\n    return (F - sfix(32)) / sfix(1.8)\n", "response_1": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - 32.0) / 1.8\n", "model_name": "qwen-qwq"}
{"test_name": "elliptic_area", "response_0": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    from Compiler.types import sfix\n    import mpc_math\n\n    pi = sfix(mpc_math.pi)\n    area = pi * a * b\n    return area\n", "response_1": "def elliptic_area(a, b):\n    pi = sfix(3.1415926535)  # Approximate value of \u03c0 with sufficient precision\n    area = pi * a * b\n    return area\n", "model_name": "qwen-qwq"}
{"test_name": "floor", "response_0": "def floor(z):\n    fract = z.fract\n    return z >> fract\n", "response_1": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    return mpc_math.floor(z)\n", "model_name": "qwen-qwq"}
{"test_name": "log_and_cube", "response_0": "def log_and_cube(x):\n    log_result = mpc_math.log_fx(x, 2)\n    cube_result = mpc_math.pow_fx(log_result, 3)\n    return cube_result\n", "response_1": "from mpc_math import log_fx, pow_fx\nfrom Compiler.types import sfix\n\ndef log_and_cube(x):\n    # Ensure x is of type sfix\n    if not isinstance(x, sfix):\n        raise TypeError(\"Input must be of type sfix\")\n    \n    log_result = log_fx(x, 2)\n    cube_result = pow_fx(log_result, 3)\n    return cube_result\n", "model_name": "qwen-qwq"}
{"test_name": "floor_and_square", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef floor_and_square(z):\n    floored = mpc_math.floor(z)\n    squared = floored ** 2\n    return squared\n", "response_1": "from Compiler.math import mpc_math\n\ndef floor_and_square(z):\n    floor_z = mpc_math.floor_fx(z)\n    return floor_z * floor_z\n", "model_name": "qwen-qwq"}
{"test_name": "meters_to_feet", "response_0": "", "response_1": "from Compiler.types import cfix\n\ndef meters_to_feet(m):\n    return m * cfix(3.2808)\n", "model_name": "qwen-qwq"}
{"test_name": "sphere_area", "response_0": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    from Compiler.types import cfix, sfix\n    from Compiler.library import tree_reduce\n\n    # Define pi as a cfix constant\n    pi = cfix(3.141592653589793)\n\n    # Calculate r squared\n    r_squared = r ** 2\n\n    # Calculate 4 * pi * r_squared\n    area = 4 * pi * r_squared\n\n    return area\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "coarse_abs", "response_0": "", "response_1": "def coarse_abs(x):\n    return abs(x).convert_to_int()\n", "model_name": "qwen-qwq"}
{"test_name": "how_many_chickens", "response_0": "", "response_1": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    temp = legs - heads * 2\n    temp = temp // 2\n    result = heads - temp\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "interest_calculator", "response_0": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef interest_calculator(capital, ratio, months):\n    one = sfix(1)\n    interest_factor = mpc_math.pow_fx(one + ratio, months)\n    interest = (interest_factor - one) * capital\n    return interest\n", "response_1": "from Compiler.types import sfix, sint\nimport mpc_math\n\ndef interest_calculator(capital, ratio, months):\n    one = sfix(1.0)\n    intermediate = mpc_math.pow_fx(one + ratio, months)\n    result = (intermediate - one) * capital\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "circle_area", "response_0": "", "response_1": "def circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    # Import necessary modules\n    from Compiler import mpc_math\n    from Compiler.types import sfix\n\n    # Define \u03c0 as a secure fixed-point number\n    pi = sfix(3.1415926535)\n\n    # Compute the area: \u03c0 * r^2\n    area = pi * (r ** 2)\n\n    return area\n", "model_name": "qwen-qwq"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef cube_and_square_root(x: sfix):\n    return mpc_math.sqrt(x ** 3)\n", "response_1": "def cube_and_square_root(x):\n    x_cubed = x ** 3\n    result = mpc_math.sqrt(x_cubed)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "round", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "cryptic_adjustment", "response_0": "def cryptic_adjustment(origin):\n    import mpc_math\n    return 10 * mpc_math.sqrt(10 * mpc_math.sqrt(origin))\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sfix\n\n# Get origin from party 0\norigin = sfix.get_input_from(0)\n\n# Compute the adjustment\ninner_sqrt = mpc_math.sqrt(origin)\nmultiplied = 10 * inner_sqrt\nouter_sqrt = mpc_math.sqrt(multiplied)\nresult = 10 * outer_sqrt\n\n# Reveal the result to party 0\nresult.reveal_to(0)\n", "model_name": "qwen-qwq"}
{"test_name": "specific_pow", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "soft_plus", "response_0": "def soft_plus(x):\n    \"\"\"\n    Softplus function for sfix type.\n    \"\"\"\n    one = sfix(1)\n    exp_x = mpc_math.exp(x)\n    sum_exp = one + exp_x\n    log_sum = mpc_math.log(sum_exp)\n    return log_sum\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef soft_plus(x):\n    # Ensure x is of type sfix\n    assert isinstance(x, sfix)\n    \n    # Compute e^x\n    exp_x = mpc_math.exp(x)\n    \n    # Compute 1 + e^x\n    one = sfix(1)\n    add_one = one + exp_x\n    \n    # Compute log(1 + e^x)\n    result = mpc_math.log(add_one)\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "ball_volume", "response_0": "", "response_1": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    from Compiler.types import sfix, cfix\n    pi = cfix(3.1415926535)\n    volume = (cfix(4)/cfix(3)) * pi * (r ** 3)\n    return volume\n", "model_name": "qwen-qwq"}
{"test_name": "Heron", "response_0": "def Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its area with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    area = mpc_math.sqrt(p * (p - a) * (p - b) * (p - c))\n    return area\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef Heron(a: sfix, b: sfix, c: sfix):\n    p = (a + b + c) / 2\n    expr = p * (p - a) * (p - b) * (p - c)\n    area = mpc_math.sqrt(expr)\n    return area\n", "model_name": "qwen-qwq"}
{"test_name": "next_perfect_square", "response_0": "def next_perfect_square(x):\n    x_fix = sfix(x)\n    sqrt_x = mpc_math.sqrt(x_fix)\n    floored_sqrt_x = sqrt_x.to_sint()\n    next_root = floored_sqrt_x + 1\n    next_square = next_root * next_root\n    return next_square\n", "response_1": "def next_perfect_square(x):\n    from Compiler import mpc_math\n    from Compiler.types import sint, sfix\n\n    # Assuming x is of type sint\n    x_sfix = sfix(x, scaling=16)\n    sqrt_x = mpc_math.sqrt(x_sfix)\n    floored_sqrt_x = mpc_math.floor(sqrt_x)\n    incremented = floored_sqrt_x + 1\n    incremented_sint = sint(incremented)\n    next_square = incremented_sint * incremented_sint\n    return next_square\n", "model_name": "qwen-qwq"}
{"test_name": "pi_to_the_x", "response_0": "def pi_to_the_x(x):\n    from mpc_math import pow_fx\n    pi = cfix(3.141592653589793)\n    result = pow_fx(pi, x)\n    return result\n", "response_1": "from Compiler.types import sfix, cfix\nimport mpc_math\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    # Define pi as a clear fixed-point number\n    pi = cfix(3.141592653589793)\n    \n    # Compute pi^x using mpc_math.pow_fx\n    result = mpc_math.pow_fx(pi, x)\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "spring_rocket", "response_0": "from Compiler.types import sfix, cfix\nfrom Compiler.library import mpc_math\n\ndef spring_rocket(height: sfix(0, precision=16), m: sfix(0, precision=16), k: sfix(0, precision=16)):\n    g = cfix(9.8, precision=16)\n    two = cfix(2, precision=16)\n    inside_sqrt = two * m * g * height / k\n    result = mpc_math.sqrt(inside_sqrt)\n    return result\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "cone_volume", "response_0": "def cone_volume(r, h):\n    # Define \u03c0 as a clear fixed-point number with sf=16\n    pi_int = 205887  # Which is approximately \u03c0 * 2^16\n    pi = cfix(pi_int)\n    \n    # Calculate the volume: (\u03c0 * r^2 * h) / 3\n    volume = pi * r * r * h / 3\n    \n    return volume\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "how_many_rabbits", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
