{"test_name": "array_from_intrinsic_linspace", "response_0": "# Import necessary modules\nfrom Compiler.types import cfix, cint\n\n# Define start, end, and num\nstart = 0\nend = 99\nnum = 10\n\n# Convert start and end to cfix\nstart_cfix = cfix(start)\nend_cfix = cfix(end)\nnum_cfix = cfix(num)\n\n# Calculate step size\nstep = (end_cfix - start_cfix) / (num_cfix - 1)\n\n# Create array to hold the linearly spaced values\na = cfix.Array(num)\n\n# Populate the array\nfor i in range(num):\n    a[i] = start_cfix + i * step\n", "response_1": "from Compiler.types import cint\nfrom Compiler.library import for_range\n\nstart = 0\nend = 99\nnum = 10\n\nstep = (end - start) // (num - 1)\n\na = cint.Array(num)\n\nfor i in for_range(num):\n    a[i] = start + i * step\n", "model_name": "qwen-qwq"}
{"test_name": "more_positive", "response_0": "def more_positive(n):\n    arr = sint.get_input_from(0, size=n)\n    signs = [ (arr[i] > 0).if_else(1, 0) + (arr[i] < 0).if_else(-1, 0) for i in range(n) ]\n    count = sum(signs)\n    result = count > 0\n    result.output_to(0)\n", "response_1": "from Compiler.library import tree_reduce\n\ndef more_positive(arr):\n    positive = (arr > 0).cast(sint)\n    negative = (arr < 0).cast(sint)\n    signs = positive - negative\n    total = tree_reduce(lambda x, y: x + y, signs)\n    result = total > 0\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "select", "response_0": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays based on the condition array.\n    Arrays a and b contain float data, and ind contains boolean conditions.\n    \"\"\"\n    # Assuming ind is an array of sbit (secret bits), a and b are arrays of sfix\n    # Convert ind to sbit if it's not already\n    if not isinstance(ind[0], sbit):\n        ind = [sbit(x) for x in ind]\n    \n    # Perform the selection using secure operations\n    result = [a_i if ind_i else b_i for a_i, b_i, ind_i in zip(a, b, ind)]\n    \n    return result\n", "response_1": "def select(ind, a, b):\n    ind_fix = sfix(ind)\n    selected = a * ind_fix + b * (1 - ind_fix)\n    return selected\n", "model_name": "qwen-qwq"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function in MP-SPDZ.\n    \"\"\"\n    zero = Compiler.types.sfix(0)  # Create a secret fixed-point zero\n    mask = y >= zero  # Perform secure comparison, returns sbitint\n    return y * mask  # Element-wise multiplication\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "cost_matrix", "response_0": "def cost_matrix(profit_matrix):\n    # Get the number of rows and columns from the profit matrix\n    rows = profit_matrix.rows\n    cols = profit_matrix.columns\n    \n    # Flatten the profit matrix to a vector\n    profit_vector = profit_matrix.get_vector()\n    \n    # Find the maximum value in the profit vector\n    max_profit = profit_vector.max()\n    \n    # Create a cost matrix of the same shape as the profit matrix\n    cost_matrix = Matrix(rows, cols, sfix)\n    \n    # Assign the maximum profit value to all elements of the cost matrix\n    cost_matrix.assign_all(max_profit)\n    \n    # Subtract the profit matrix from the cost matrix\n    cost_matrix -= profit_matrix\n    \n    # Return the cost matrix\n    return cost_matrix\n", "response_1": "from Compiler.library import tree_reduce\nfrom Compiler.types import sfix, Matrix\n\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    # Assuming profit_matrix is a sfix.Matrix\n    matrix_shape = profit_matrix.shape\n\n    # Flatten the matrix to a vector\n    profit_vector = profit_matrix.get_vector()\n\n    # Find the maximum value in the profit vector\n    max_profit = tree_reduce(lambda x, y: x.max(y), profit_vector)\n\n    # Create an offset matrix where every element is the max_profit\n    offset_matrix = Matrix(matrix_shape[0], matrix_shape[1], sfix)\n    offset_matrix.assign_all(max_profit)\n\n    # Subtract the profit matrix from the offset matrix\n    cost_matrix = offset_matrix - profit_matrix\n\n    return cost_matrix\n", "model_name": "qwen-qwq"}
{"test_name": "np_zeros", "response_0": "from Compiler.types import Array, sfix\n\nn = 10\na = Array(n, sfix)\na.assign_all(0)\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler.types import Matrix, regint\n\ndef array_dimensional_indexing(matrix, row_index):\n    \"\"\"\n    MP-SPDZ function to index the i-th row from a 2-D Matrix.\n    \n    Parameters:\n    - matrix: Matrix object containing the 2-D array.\n    - row_index: Public integer (regint) specifying the row to index.\n    \n    Returns:\n    - Vector representing the i-th row of the matrix.\n    \"\"\"\n    return matrix[row_index]\n", "response_1": "def array_dimensional_indexing(matrix, row_index):\n    \"\"\"\n    MP-SPDZ function to index i-th row from 2-D Matrix.\n    \"\"\"\n    # Assuming matrix is a Matrix object and row_index is a public integer\n    array = matrix.get_row(row_index)\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    a = sint.Array(n)\n    a.assign_all(0)\n    return a\n", "response_1": "from Compiler.types import cfix, MultiArray\n\ndef zeros(shape, dtype=cfix):\n    if isinstance(shape, int):\n        shape = (shape,)\n    arr = dtype.MultiArray(shape)\n    arr.assign_all(0)\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_slicing_stride", "response_0": "def array_concate(a, b):\n    len_a = len(a)\n    len_b = len(b)\n    size_a = (len_a + 1) // 2\n    size_b = len_b // 2\n    viewA = sint.Array(size_a)\n    viewB = sint.Array(size_b)\n    for i in range(0, len_a, 2):\n        idx = i // 2\n        viewA[idx] = a[i]\n    for i in range(1, len_b, 2):\n        idx = (i - 1) // 2\n        viewB[idx] = b[i]\n    array = viewA.concat(viewB)\n    return array\n", "response_1": "from Compiler.types import Array, sint\n\ndef array_concate(ndarrayA, ndarrayB):\n    # Assuming ndarrayA and ndarrayB are Array objects of type sint\n    \n    # Get even-indexed elements from ndarrayA\n    viewA = Array(len(ndarrayA) // 2)\n    for i in range(0, len(ndarrayA), 2):\n        viewA[i // 2] = ndarrayA[i]\n    \n    # Get odd-indexed elements from ndarrayB starting from index 1\n    viewB = Array(len(ndarrayB) // 2)\n    for i in range(1, len(ndarrayB), 2):\n        viewB[(i - 1) // 2] = ndarrayB[i]\n    \n    # Concatenate viewA and viewB\n    array = viewA.concat(viewB)\n    \n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "QR_decomposition", "response_0": "from Compiler.types import sint, Matrix\nfrom Compiler.library import tree_reduce\n\ndef qr_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix.\n    \"\"\"\n    m, n = mat.rows, mat.columns\n    q = Matrix(m, n, sint)\n    r = Matrix(n, n, sint)\n\n    for j in range(n):\n        v = mat.get_column(j)\n        for i in range(j):\n            r[i, j] = q.get_column(i).dot(mat.get_column(j))\n            v = v - r[i, j] * q.get_column(i)\n        r[j, j] = v.norm()\n        q.set_column(j, v / r[j, j])\n\n    return q\n", "response_1": "def QR_decomposition(mat):\n    import mpc_math\n    from Compiler.types import sint, Matrix\n\n    num_cols = mat.columns\n    Q = Matrix(mat.rows, num_cols, sint)\n\n    for j in range(num_cols):\n        v = mat.get_column(j)\n        for i in range(j):\n            u = Q.get_column(i)\n            proj = u.dot(v)\n            v -= proj * u\n        norm = mpc_math.sqrt(v.dot(v))\n        Q.set_column(j, v / norm)\n\n    return Q\n", "model_name": "qwen-qwq"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    # Initialize minimum difference and index\n    min_diff = sfix(1 << 30)  # A large initial value\n    min_index = sint(0)\n    \n    # Iterate through the array to find the index of the nearest value\n    for i in range(len(array)):\n        diff = sfix.abs(array[i] - value)\n        condition = diff < min_diff\n        min_diff = condition.if_else(diff, min_diff)\n        min_index = condition.if_else(i, min_index)\n    \n    return min_index\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "np_concat_simple_row", "response_0": "from Compiler.types import sint, Array\n\ndef array_simple_concate_rows(A, B):\n    # Assuming A and B are Array objects of sint type\n    # Concatenate A and B along axis 0\n    result = A.concat(B)\n    return result\n", "response_1": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    array = ndarrayA.concat(ndarrayB)\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "np_copy", "response_0": "def array_copy(array):\n    # Assuming 'array' is an Array of some type, e.g., sint or sfix\n    copied_array = array.same_shape()\n    copied_array.assign(array)\n    return copied_array\n", "response_1": "from Compiler.types import MultiArray, cfix\n\ndef array_copy(ndarray):\n    sizes = ndarray.shape\n    new_array = MultiArray(sizes, cfix)\n    new_array.assign_vector(ndarray.flatten())\n    return new_array\n", "model_name": "qwen-qwq"}
{"test_name": "max_pooling", "response_0": "", "response_1": "from Compiler.types import sfix, MultiArray\nfrom Compiler.library import for_range\n\ndef max_pooling(x, stride):\n    batch_size = x.shape[0]\n    height = x.shape[1]\n    width = x.shape[2]\n    out_height = height // stride\n    out_width = width // stride\n\n    # Initialize output array\n    out = MultiArray([batch_size, out_height, out_width], sfix)\n\n    for b in range(batch_size):\n        for i in range(0, height, stride):\n            for j in range(0, width, stride):\n                max_val = x[b, i, j]\n                for k in range(stride):\n                    for l in range(stride):\n                        current_val = x[b, i + k, j + l]\n                        max_val = max_val.max(current_val)\n                out[b, i // stride, j // stride] = max_val\n    return out\n", "model_name": "qwen-qwq"}
{"test_name": "array_reshape", "response_0": "", "response_1": "from Compiler.types import Matrix, cint, Array\n\na = Matrix(3, 5, cint)\n\nvalues = [cint(i) for i in range(15)]\narr = Array.create_from(values)\n\na.assign_vector(arr)\n", "model_name": "qwen-qwq"}
{"test_name": "np_concat_simple_column", "response_0": "def array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ function to concatenate elements from two 2-D matrices along axis 1.\n    \"\"\"\n    # Concatenate ndarrayA and ndarrayB along columns\n    result = ndarrayA.concat_columns(ndarrayB)\n    return result\n", "response_1": "def array_simple_concat_column(matrixA, matrixB):\n    return matrixA.concat_columns(matrixB)\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "", "response_1": "from Compiler.types import sint, cint, Matrix\n\n# Define matrix dimensions\nm = 10  # number of rows\nn = 10  # number of columns\n\n# Define the matrix with secret integer elements\nmatrix = Matrix(m, n, sint)\n\ndef array_dimensional_indexing(column_index):\n    \"\"\"\n    Function to index the i-th column from a 2-D matrix in MP-SPDZ.\n    \n    Parameters:\n    column_index (cint): The index of the column to retrieve.\n    \n    Returns:\n    An array representing the i-th column of the matrix.\n    \"\"\"\n    # Retrieve the column using the get_column method\n    column = matrix.get_column(column_index)\n    return column\n", "model_name": "qwen-qwq"}
{"test_name": "np_diagonal", "response_0": "def diag(matrix):\n    # matrix is expected to be a Matrix object of type sint or sfix\n    return matrix.diag()\n", "response_1": "def diag(matrix):\n    return matrix.diag()\n", "model_name": "qwen-qwq"}
{"test_name": "np_concat_special", "response_0": "def array_special_concate(ndarrayA, ndarrayB):\n    # Extract even columns from ndarrayA\n    viewA = ndarrayA.get_part(0, ndarrayA.columns // 2)\n    \n    # Extract odd columns from ndarrayB\n    # Assuming ndarrayB has an odd number of columns, starting from column 1\n    viewB = ndarrayB.get_part(1, ndarrayB.columns // 2)\n    \n    # Concatenate viewA and viewB along axis 1\n    array = viewA.concat_columns(viewB)\n    \n    return array\n", "response_1": "from Compiler.types import Matrix, sint\n\ndef array_special_concat(matrixA, matrixB):\n    # Assuming matrixA and matrixB are Matrix objects of type sint\n    # and both have the same number of rows.\n    \n    N = matrixA.rows  # number of rows\n    M = matrixA.columns  # number of columns, assuming both matrices have same number of columns\n    \n    # Extract even columns from matrixA: columns 0,2,4,...\n    even_cols_A = [matrixA.get_column(i) for i in range(0, M, 2)]\n    # Concatenate them into one matrix\n    if even_cols_A:\n        even_matrix_A = even_cols_A[0].concat_columns(even_cols_A[1:])\n    else:\n        even_matrix_A = None  # Handle case when no even columns\n    \n    # Extract odd columns from matrixB: columns 1,3,5,...\n    odd_cols_B = [matrixB.get_column(i) for i in range(1, M, 2)]\n    # Concatenate them into one matrix\n    if odd_cols_B:\n        odd_matrix_B = odd_cols_B[0].concat_columns(odd_cols_B[1:])\n    else:\n        odd_matrix_B = None  # Handle case when no odd columns\n    \n    # Concatenate even_matrix_A and odd_matrix_B along columns\n    if even_matrix_A and odd_matrix_B:\n        result = even_matrix_A.concat_columns(odd_matrix_B)\n    elif even_matrix_A:\n        result = even_matrix_A\n    elif odd_matrix_B:\n        result = odd_matrix_B\n    else:\n        result = None  # Handle case when both are empty\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "np_arange", "response_0": "def arange(start, stop, step):\n    ...\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "np_eye_2", "response_0": "from Compiler.types import Matrix, cint\n\nm = 3\nn = 5\n\n# Create a matrix of size m x n initialized to zero\na = Matrix(m, n, cint)\na.assign_all(0)\n\n# Set the diagonal elements to one\nfor i in range(m):\n    a[i, i] = 1\n", "response_1": "from Compiler.types import Matrix, cfix\n\nm = 3\nn = 5\na = Matrix(m, n, cfix)\na.assign_all(cfix(0))\nfor i in range(min(m, n)):\n    a[i][i] = cfix(1)\n", "model_name": "qwen-qwq"}
{"test_name": "third_smallest", "response_0": "from Compiler.types import sint, Array\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Create an Array of sint with the same length as arr\n    secret_arr = Array(len(arr), sint)\n    \n    # Assign the input array to the secret_arr\n    for i in range(len(arr)):\n        secret_arr[i] = sint(arr[i])\n    \n    # Sort the array in place\n    secret_arr.sort()\n    \n    # Return the third element (index 2)\n    return secret_arr[2]\n", "response_1": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    n = arr.length\n    assert n >= 3, \"Array must have at least 3 elements\"\n    # Sort the array in place\n    arr.sort()\n    # Return the element at index 2\n    return arr[2]\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "from Compiler.types import Matrix, Array, sint, cint\n\ndef array_dimensional_indexing(ndarray: Matrix[sint], row_index: cint) -> Array[sint]:\n    array = ndarray[row_index]\n    return array\n", "response_1": "def array_dimensional_indexing(a, row_index):\n    return a[row_index]\n", "model_name": "qwen-qwq"}
{"test_name": "array_from_intrinsic_arange", "response_0": "", "response_1": "n = 10\na = cint.Array(n)\na.assign_vector(range(n))\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "from Compiler.types import Matrix, Array, regint\n\ndef array_dimensional_indexing(matrix, row_index):\n    \"\"\"\n    MP-SPDZ function to index the i-th row from a 2-D Matrix.\n    \"\"\"\n    row = matrix[row_index]\n    return row\n", "response_1": "def array_dimensional_indexing(a, row_index):\n    return a[row_index]\n", "model_name": "qwen-qwq"}
{"test_name": "array_from_python_structure", "response_0": "a = sint.create_from([0,10,20,30,40])\n", "response_1": "from Compiler.types import cint, Array\n\na_l = [0, 10, 20, 30, 40]\na = Array(5, cint)\na.assign(a_l)\n", "model_name": "qwen-qwq"}
{"test_name": "np_reshape", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "np_ones", "response_0": "from Compiler.types import Array, cint\n\nn = 10\na = Array(n, cint)\na.assign_all(1)\n", "response_1": "from Compiler.types import sfix, Array\n\nn = 10\na = Array(n, sfix)\na.assign_all(1)\n", "model_name": "qwen-qwq"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero_sfix(y):\n    condition = y == sfix(1)\n    mask = sfix(1) - condition.sint().sfix()\n    y.assign_vector(y * mask)\n", "response_1": "def set_one_to_zero(y):\n    # Create a mask where elements equal to 1 are set to 1, others to 0\n    mask = (y == 1)\n    # Use the mask to set elements to 0 where mask is 1\n    y = y * (1 - mask)\n    return y\n", "model_name": "qwen-qwq"}
{"test_name": "np_eye", "response_0": "from Compiler.types import Matrix, cfix\nfrom Compiler import util\n\n# Define the size of the matrix\nn = 10\n\n# Create a 10x10 matrix of cfix type initialized to 0\na = Matrix(n, n, cfix)\na.assign_all(0)\n\n# Set the diagonal elements to 1 using a secure loop\nfor i in util.for_range(n):\n    a[i][i] = cfix(1)\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "np_diag", "response_0": "# Import necessary modules\nfrom Compiler.types import sint, Array, Matrix\n\n# Define the list of integers\na_l = [1, 3, 5, 2, 4, 6]\n\n# Create an array of secret integers from the list\na_vec = sint.Array.create_from(a_l)\n\n# Create a 6x6 matrix of secret integers initialized to zero\na = sint.Matrix(6, 6)\na.assign_all(0)\n\n# Set the diagonal elements of the matrix\nfor i in range(6):\n    a[i, i] = a_vec[i]\n", "response_1": "from Compiler.types import cint, Matrix, Array\n\n# Define the list of diagonal elements\na_l = [1, 3, 5, 2, 4, 6]\n\n# Create a 6x6 matrix of type cint\na = Matrix(6, 6, cint)\n\n# Populate the matrix with the diagonal elements\nfor i in range(6):\n    # Create a list of six zeros\n    row = [0] * 6\n    # Set the diagonal element\n    row[i] = a_l[i]\n    # Create an Array from the row list\n    row_array = Array.create_from(row)\n    # Assign the row_array to the i-th row of the matrix\n    a[i, :] = row_array\n", "model_name": "qwen-qwq"}
{"test_name": "np_advanced_integer_indexing", "response_0": "def integer_array_indexing(array, indices):\n    num_indices = len(indices)\n    result = array.same_shape().Array(num_indices)\n    for i in range(num_indices):\n        result[i] = array[indices[i]]\n    return result\n", "response_1": "", "model_name": "qwen-qwq"}
