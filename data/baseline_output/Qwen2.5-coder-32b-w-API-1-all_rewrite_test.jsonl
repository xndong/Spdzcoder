{"test_name": "move_to_end", "response_0": "from Compiler.types import sint, Array\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    n = arr.size\n    new_array = sint.Array(n)\n\n    # Copy elements before the index\n    for i in range(index):\n        new_array[i] = arr[i]\n\n    # Copy elements after the index\n    for i in range(index + 1, n):\n        new_array[i - 1] = arr[i]\n\n    # Move the element at the given index to the end\n    new_array[n - 1] = arr[index]\n\n    return new_array\n", "response_1": "from Compiler.types import sint, Array\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    n = arr.length\n    new_array = sint.Array(n)\n\n    # Copy elements before the index\n    for i in range(index):\n        new_array[i] = arr[i]\n\n    # Copy elements after the index\n    for i in range(index + 1, n):\n        new_array[i - 1] = arr[i]\n\n    # Move the element at the index to the end\n    new_array[n - 1] = arr[index]\n\n    return new_array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint, sfix, cint, cfix\nfrom Compiler.library import tree_reduce\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    # Ensure the array has at least two elements\n    assert n >= 2\n\n    # Initialize the first two largest elements\n    first = arr[0]\n    second = arr[1]\n\n    # Ensure first is the largest and second is the second largest\n    cond = first < second\n    first, second = cond.if_else(second, first), cond.if_else(first, second)\n\n    for i in range(2, n):\n        # Check if arr[i] is greater than first or second\n        greater_than_first = arr[i] > first\n        greater_than_second = arr[i] > second\n\n        # If arr[i] is greater than first, update first and second\n        first, second = greater_than_first.if_else(arr[i], first), greater_than_first.if_else(second, first)\n\n        # If arr[i] is not greater than first but greater than second, update second\n        second = greater_than_second.if_else(arr[i], second) & ~greater_than_first\n\n    return second\n", "response_1": "from Compiler.types import sint, sfix, Array\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    arr_s = Array(n, sint)\n    arr_s.assign(arr)\n\n    # Initialize the first two largest elements\n    largest = arr_s[0]\n    second_largest = arr_s[1]\n\n    for i in range(2, n):\n        greater_than_largest = arr_s[i] > largest\n        greater_than_second = arr_s[i] > second_largest\n\n        # Determine the index to update\n        idx = (largest < second_largest).bit_not()\n\n        # Update the largest and second largest\n        largest = (greater_than_largest & arr_s[i]) + (greater_than_largest.bit_not() & largest)\n        second_largest = (greater_than_second & arr_s[i] & idx.bit_not()) + (greater_than_second.bit_not() & second_largest & idx.bit_not()) + (idx & arr_s[i])\n\n    return largest.if_else(second_largest, largest)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exists_true", "response_0": "from Compiler.types import sintbit, sint\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sintbit(0)\n    for elem in arr:\n        ret = ret.bit_or(elem)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    # Assuming arr is an Array of sbitint values\n    ret = sint(0)\n    for element in arr:\n        ret = ret.bit_or(element)\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_indicator", "response_0": "from Compiler.types import sint, sbitint\n\ndef array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "from Compiler.types import sint, sbitint, Array\n\ndef array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), sbitint)\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "inner_product", "response_0": "from Compiler.types import sfix, Array\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    n = len(vec1)\n    product = Array(n, sfix)\n    for i in range(n):\n        product[i] = vec1[i] * vec2[i]\n    \n    summation = sfix(0)\n    for i in range(n):\n        summation += product[i]\n    \n    return summation\n", "response_1": "from Compiler.types import sfix\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    # Assuming vec1 and vec2 are of type sfix.Array\n    lst = sfix.Array(len(vec1))\n    for i in range(len(vec1)):\n        lst[i] = vec1[i] * vec2[i]\n    \n    summation = sfix(0)\n    for i in range(len(lst)):\n        summation += lst[i]\n    \n    return summation\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_shift_2", "response_0": "from Compiler.types import sint, Array\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = sint.Array(n)\n    for i in range(n):\n        shifted_array[i] = a[(i-1) % n]\n    return shifted_array\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, sint)\n    for i in range(n):\n        shifted_array[i] = a[(i - 1) % n]\n    return shifted_array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.types import sint, Array\n\ndef array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_rises_2", "response_0": "from Compiler.types import sint, Array\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    length = len(arr) - 1\n    flag = Array(length, sint)\n    \n    for i in range(length):\n        flag[i] = arr[i] < arr[i + 1]\n    \n    count = sint(0)\n    for i in range(length):\n        count += flag[i]\n    \n    return count\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    length = len(arr) - 1\n    flag = sint.Array(length)\n    count = sint(0)\n\n    for i in range(length):\n        flag[i] = arr[i].bit_lt(arr[i + 1])\n\n    for i in range(length):\n        count += flag[i]\n\n    return count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint, Array\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(arr)\n    result = Array(n, sint)\n\n    for i in range(n):\n        is_odd = i % 2\n        increment = sint(is_odd) * 2 - 1\n        result[i] = arr[i] + increment\n\n    return result\n", "response_1": "from Compiler.types import sfix, sint\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(arr)\n    result = sint.Array(n)\n    one = sint(1)\n    for i in range(n):\n        index = sint(i)\n        is_odd = index % 2\n        increment = is_odd.if_else(one, -one)\n        result[i] = arr[i] + increment\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sint, sfix, cint, cfix\nfrom Compiler.library import if_then, if_else\n\ndef how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    # Ensure a, b, c are of type sint for secure computation\n    a = sint(a)\n    b = sint(b)\n    c = sint(c)\n\n    # Calculate the discriminant\n    discriminant = b * b - 4 * a * c\n\n    # Determine the number of roots\n    num_roots = sint(0)\n\n    # If a == 0\n    is_a_zero = a == 0\n    with if_then(is_a_zero):\n        # If b == 0\n        is_b_zero = b == 0\n        with if_then(is_b_zero):\n            num_roots = sint(0)\n        with if_else():\n            num_roots = sint(1)\n    with if_else():\n        # If a != 0\n        is_positive = discriminant > 0\n        with if_then(is_positive):\n            num_roots = sint(2)\n        with if_else():\n            is_zero = discriminant == 0\n            with if_then(is_zero):\n                num_roots = sint(1)\n            with if_else():\n                num_roots = sint(0)\n\n    return num_roots\n", "response_1": "from Compiler.types import sint\n\ndef how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    a_is_zero = a == sint(0)\n    b_is_zero = b == sint(0)\n    discriminant = b * b - sint(4) * a * c\n    discriminant_is_positive = discriminant > sint(0)\n    discriminant_is_zero = discriminant == sint(0)\n\n    # If a is zero\n    result_if_a_zero = b_is_zero.if_else(sint(0), sint(1))\n    # If a is not zero\n    result_if_a_not_zero = discriminant_is_positive.if_else(sint(2), discriminant_is_zero.if_else(sint(1), sint(0)))\n\n    return a_is_zero.if_else(result_if_a_zero, result_if_a_not_zero)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint, sbitint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    flag = sint.Array(len(arr))\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i]).bit_and(1)\n    \n    summmation = sint(0)\n    for i in range(len(arr)):\n        summmation += flag[i]\n    \n    return summmation\n", "response_1": "from Compiler.types import sint, Array\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    n = len(arr)\n    flag = Array(n, sint)\n    for i in range(n):\n        flag[i] = predicator(arr[i])\n    summation = sint(0)\n    for i in range(n):\n        summation += flag[i]\n    return summation\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sfix, sint, Array\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    # Ensure arr1 and arr2 are of type Array and have the same length\n    assert isinstance(arr1, Array) and isinstance(arr2, Array)\n    assert arr1.length == arr2.length\n\n    # Initialize the sum to zero\n    total_sum = sfix(0)\n\n    # Traverse all pairs of elements from the two arrays\n    for i in range(arr1.length):\n        # Compute the product of the two elements\n        product = arr1[i] * arr2[i]\n        # Add the product to the total sum\n        total_sum += product\n\n    return total_sum\n", "response_1": "from Compiler.types import sfix, sint, Array\nfrom Compiler.library import sum\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    # Assuming arr1 and arr2 are of the same length and contain secret fixed-point numbers\n    length = len(arr1)\n    product_array = Array(length, sfix)\n\n    for i in range(length):\n        product_array[i] = arr1[i] * arr2[i]\n\n    return sum(product_array)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_round", "response_0": "from Compiler.types import sfix, sint\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        rounded_value = arr[i].round()\n        ret[i] = rounded_value\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import round_fx\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = round_fx(arr[i])\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_greater_eq", "response_0": "from Compiler.types import sint, Array\n\ndef array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i]>=brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] >= brr[i]\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i]>=brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] >= brr[i]\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint, Array\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = arr[i] < 0\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] < 0\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_subtract_2", "response_0": "from Compiler.types import sfix, sint, Array\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the lengths of the arrays\n    len_a = len(a)\n    len_b = len(b)\n\n    # Determine the padding length\n    pad_length = abs(len_a - len_b)\n\n    # Create the padded arrays\n    if len_a < len_b:\n        a_padded = a + [sfix(0)] * pad_length\n        b_padded = b\n    else:\n        a_padded = a\n        b_padded = b + [sfix(0)] * pad_length\n\n    # Perform element-wise subtraction\n    ret = Array(max(len_a, len_b), sfix)\n    for i in range(max(len_a, len_b)):\n        ret[i] = a_padded[i] - b_padded[i]\n\n    return ret\n", "response_1": "from Compiler.types import sint, sfix, Array\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    \n    pad_length = abs(len_a - len_b)\n    pad = Array(pad_length, sint)\n    \n    if len_a < len_b:\n        for i in range(pad_length):\n            pad[i] = -b[len_b - pad_length + i]\n    else:\n        for i in range(pad_length):\n            pad[i] = a[len_a - pad_length + i]\n    \n    min_length = min(len_a, len_b)\n    ret = Array(max(len_a, len_b), sint)\n    \n    for i in range(min_length):\n        ret[i] = a[i] - b[i]\n    \n    for i in range(pad_length):\n        ret[min_length + i] = pad[i]\n    \n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_process", "response_0": "from Compiler.types import sint, sfix, Array\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    # Assuming arr is an Array of sfix or sint\n    processed_arr = Array(len(arr), arr[0].__class__)\n    for i in range(len(arr)):\n        processed_arr[i] = func(arr[i])\n    return processed_arr\n", "response_1": "from Compiler.types import sint, sfix, Array\nfrom Compiler.library import tree_reduce\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    processed_arr = Array(len(arr), arr[0].__class__)\n    for i in range(len(arr)):\n        processed_arr[i] = func(arr[i])\n    return processed_arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_shift", "response_0": "from Compiler.types import sint, Array\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    last_element = a[n-1]\n    shifted_array = Array(n, sint)\n    shifted_array[0] = last_element\n    shifted_array[1:] = a[:n-1]\n    return shifted_array\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    last_element = a[n-1]\n    shifted_array = Array(n, sint)\n    shifted_array[0] = last_element\n    for i in range(1, n):\n        shifted_array[i] = a[i-1]\n    return shifted_array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "compare_and_select", "response_0": "from Compiler.types import sint, Array\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    length = len(a)\n    ret_array = Array(length, sint)\n\n    for i in range(length):\n        x = a[i]\n        y = b[i]\n        max_value = x.if_else(x, y)\n        ret_array[i] = max_value\n\n    return ret_array\n", "response_1": "from Compiler.types import sint, Array\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    length = len(a)\n    ret_array = Array(length, sint)\n    for i in range(length):\n        ret_array[i] = a[i].max(b[i])\n    return ret_array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_subtract", "response_0": "from Compiler.types import sfix, sint, Array\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the lengths of the arrays\n    len_a = len(a)\n    len_b = len(b)\n    \n    # Calculate the padding needed\n    pad_length = abs(len_a - len_b)\n    \n    # Create padding arrays\n    pad = Array(pad_length, sfix)\n    pad.assign_all(sfix(0.0))\n    \n    # Pad the shorter array with zeros\n    if len_a < len_b:\n        a = Array(len_b, sfix).create_from(a + pad.get_vector())\n    else:\n        b = Array(len_a, sfix).create_from(b + pad.get_vector())\n    \n    # Perform elementwise subtraction\n    ret = Array(len(a), sfix)\n    for i in range(len(a)):\n        ret[i] = a[i] - b[i]\n    \n    return ret\n", "response_1": "from Compiler.types import sfix, Array\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = abs(len_a - len_b)\n    pad = Array(pad_length, sfix).assign_all(sfix(0.0))\n\n    if len_a < len_b:\n        a = Array(len_b, sfix).create_from(a)\n        a[len_a:] = pad[:]\n    else:\n        b = Array(len_a, sfix).create_from(b)\n        b[len_b:] = pad[:]\n\n    ret = Array(max(len_a, len_b), sfix)\n    for i in range(max(len_a, len_b)):\n        ret[i] = a[i] - b[i]\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "repeat_array", "response_0": "from Compiler.types import sfix, cfix, sint, cint, Array\n\ndef repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    # Assuming c is an Array of some basic type, we need to concatenate it with itself\n    # First, get the vector representation of the array\n    vector_c = c.get_vector()\n    \n    # Concatenate the vector with itself\n    repeated_vector = vector_c.concat(vector_c)\n    \n    # Create a new array of the same type and length\n    repeated_array = c.same_shape()\n    \n    # Assign the repeated vector back to the array\n    repeated_array.assign_vector(repeated_vector)\n    \n    return repeated_array\n", "response_1": "from Compiler.types import sfix, sint, cfix, cint, Array\n\ndef repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    length = len(c)\n    result = Array(length * 2, type(c[0]))\n    result[:length] = c[:]\n    result[length:] = c[:]\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "zeros", "response_0": "from Compiler.types import sint\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = sint.Array(num)\n    array.assign_all(0)\n    return array\n", "response_1": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = sint.Array(num)\n    array.assign_all(0)\n    return array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    upper_bound = sfix(upper_bound)\n    lower_bound = sfix(lower_bound)\n\n    def helper_func(x):\n        x = sfix(x)\n        upper_clipped = upper_bound.bit_and(x >= upper_bound) + upper_bound.bit_and_not(x >= upper_bound) * x\n        lower_clipped = lower_bound.bit_and(x <= lower_bound) + lower_bound.bit_and_not(x <= lower_bound) * upper_clipped\n        return lower_clipped\n\n    clipped_arr = [helper_func(x) for x in arr]\n    return clipped_arr\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import map_vector\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x):\n        # Convert bounds to sfix if they are not already\n        upper_bound_sfix = sfix(upper_bound)\n        lower_bound_sfix = sfix(lower_bound)\n\n        # Compute the clipped value\n        clipped_value = upper_bound_sfix.min(x.max(lower_bound_sfix))\n        return clipped_value\n\n    # Assuming arr is an sfix.Array\n    clipped_arr = map_vector(helper_func, arr)\n    return clipped_arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_satisfied_2", "response_0": "from Compiler.types import sint, sbitint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    flag = [predicator(x) for x in arr]\n    summmation = sint(0)\n    for f in flag:\n        summmation += f\n    return summmation\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    flag = [predicator(x) for x in arr]\n    summmation = sint(0)\n    for f in flag:\n        summmation += f\n    return summmation\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint, Array\n\ndef reverse_order_pair(arr):\n    count = sint(0)\n    cmparr = Array(len(arr), sint)\n    cmparr.assign(arr)\n\n    for i in range(len(arr)):\n        ndarray = Array(len(arr) - i, sint)\n        ndarray.assign_all(arr[i])\n        for j in range(len(arr) - i):\n            count += (ndarray[j] > cmparr[i + j]).if_else(sint(1), sint(0))\n\n    return count\n", "response_1": "from Compiler.types import sint, Array\n\ndef reverse_order_pair(arr):\n    count = sint(0)\n    cmparr = Array(len(arr), sint)\n    cmparr.assign(arr)\n\n    for i in range(len(arr)):\n        ndarray = Array(len(arr) - i, sint)\n        ndarray.assign_vector(sint(arr[i]).get_vector(0, len(arr) - i))\n        for j in range(len(arr) - i):\n            count += (ndarray[j] > cmparr[i + j]).if_else(sint(1), sint(0))\n    \n    return count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_inc", "response_0": "from Compiler.types import sint, Array\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    length = len(arr)\n    incremented_arr = sint.Array(length)\n    for i in range(length):\n        incremented_arr[i] = arr[i] + sint(1)\n    return incremented_arr\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    arr = Array(len(arr), sint)\n    arr[:] += 1\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint, Array\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)\n    n = len(arr)\n    brr = arr[1:]\n    for i in range(n - 1):\n        x = arr[i]\n        y = brr[i]\n        count += sint(y > x)\n    return count\n", "response_1": "from Compiler.types import sint, Array\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n    brr = arr[1:]\n    \n    for i in range(n-1):\n        x = arr[i]\n        y = brr[i]\n        count += sint(y > x)\n    \n    return count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_process_2", "response_0": "from Compiler.types import sint, sfix, Array\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    processed_arr = Array(len(arr), type(arr[0]))\n    for i in range(len(arr)):\n        processed_arr[i] = func(arr[i])\n    return processed_arr\n", "response_1": "from Compiler.types import sint, sfix, Array\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    processed_arr = Array(len(arr), type(arr[0]))\n    for i in range(len(arr)):\n        processed_arr[i] = func(arr[i])\n    return processed_arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    squared_vec = [item * item for item in vec]\n    sum_of_squares = sum(squared_vec)\n    return mpc_math.sqrt(sum_of_squares)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sum\nfrom Compiler.mpc_math import sqrt\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    squared_vec = [item * item for item in vec]\n    sum_of_squares = sum(squared_vec)\n    return sqrt(sum_of_squares)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "totally_dominate", "response_0": "from Compiler.types import sfix, sint, cint\nfrom Compiler.library import tree_reduce\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    amin = tree_reduce(lambda x, y: x.min(y), a)\n    bmax = tree_reduce(lambda x, y: x.max(y), b)\n    return amin >= bmax\n", "response_1": "from Compiler.types import sfix, sint, cint, Array\nfrom Compiler.library import tree_reduce\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Assuming a and b are Arrays of sfix or sint\n    amin = tree_reduce(lambda x, y: x.min(y), a.get_vector())\n    bmax = tree_reduce(lambda x, y: x.max(y), b.get_vector())\n    return amin >= bmax\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "inner_product_2", "response_0": "from Compiler.types import sfix, sint\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    summation = sfix(0)\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    # Assuming vec1 and vec2 are of type sint or sfix\n    # Element-wise multiplication\n    product = [x * y for x, y in zip(vec1, vec2)]\n    \n    # Summing the products\n    summation = tree_reduce(lambda x, y: x + y, product)\n    \n    return summation\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "get_subarr_by_indices", "response_0": "from Compiler.types import sint, Array\n\ndef get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = sint.Array(len(indices))\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint, sbitint\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = sint.Array(len(arr))\n    for i in range(len(arr)):\n        is_5 = arr[i] == 5\n        is_7 = arr[i] == 7\n        flag[i] = is_5.bit_or(is_7)\n    \n    result = sbitint(0)\n    for i in range(len(arr)):\n        result = result.bit_or(flag[i])\n    \n    return result\n", "response_1": "from Compiler.types import sint, Array\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    n = len(arr)\n    flag = Array(n, sint)\n    for i in range(n):\n        is_5 = arr[i] == sint(5)\n        is_7 = arr[i] == sint(7)\n        flag[i] = is_5.bit_or(is_7)\n    \n    result = sint(0)\n    for i in range(n):\n        result = result.bit_or(flag[i])\n    \n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "remove_by_index", "response_0": "from Compiler.types import sint, Array\n\ndef remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    length = len(arr)\n    ret = Array(length - 1, sint)\n    \n    # Copy elements before the index\n    ret[:index] = arr[:index]\n    \n    # Copy elements after the index\n    ret[index:] = arr[index+1:]\n    \n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    length = len(arr)\n    ret = Array(length - 1, sint)\n    \n    for i in range(index):\n        ret[i] = arr[i]\n    \n    for i in range(index + 1, length):\n        ret[i - 1] = arr[i]\n    \n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "average", "response_0": "from Compiler.types import sfix\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = sfix(0)\n    for element in arr:\n        summmation += element\n    \n    length = len(arr)\n    length_fix = sfix(length)\n    ret = summmation / length_fix\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = sint(0)\n    for element in arr:\n        summmation += element\n\n    length = sint(len(arr))\n    ret = summmation / length\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
