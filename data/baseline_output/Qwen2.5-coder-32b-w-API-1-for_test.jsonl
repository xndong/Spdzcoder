{"test_name": "multiply_first_five", "response_0": "from Compiler.types import sint, sfix\n\ndef multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sint(1)\n    for i in range(len(array)):\n        prod *= array[i]\n        if i >= 4:\n            break\n    return prod\n", "response_1": "from Compiler.types import sint, Array\n\ndef multiply_first_five(array):\n    prod = sint(1)\n    for i in range(5):\n        if i < len(array):\n            prod *= array[i]\n        else:\n            break\n    return prod\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array. \n    \"\"\"\n    n = len(arr)\n    largest = arr[0].if_else(arr[0], arr[1]) - arr[0].bit_and(arr[0] < arr[1])\n    second = arr[1].if_else(arr[1], arr[0]) - arr[1].bit_and(arr[1] < arr[0])\n\n    for i in range(2, n):\n        temp_largest = largest\n        temp_second = second\n\n        largest = arr[i].if_else(arr[i], largest) - arr[i].bit_and(arr[i] < largest)\n        second = arr[i].if_else(temp_largest, temp_second) - arr[i].bit_and(arr[i] >= largest).bit_and(arr[i] >= temp_second)\n\n    return second\n", "response_1": "from Compiler.types import sint, sfix\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    largest = arr[0].if_else(arr[0], arr[1], arr[0] >= arr[1])\n    second = arr[1].if_else(arr[0], arr[1], arr[0] >= arr[1])\n\n    for i in range(len(arr)):\n        if i > 1:\n            largest, second = arr[i].if_else((arr[i], largest), (largest, second), arr[i] >= largest)\n            second = arr[i].if_else(arr[i], second, arr[i] >= second)\n\n    return second\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "partial_sum", "response_0": "from Compiler.types import sint, Array\n\ndef partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array. \n    \"\"\"\n    partial = sint(0)\n    for i in range(len(arr)):\n        partial += arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "from Compiler.types import sint, Array\n\ndef partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array. \n    \"\"\"\n    partial = sint(0)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "max_adjacent_product", "response_0": "from Compiler.types import sfix, sint, cint\n\ndef max_adjacent_product(arr):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2. \n    \"\"\"\n    # Assuming arr is an Array of sfix or sint\n    cur = arr[0] * arr[1]\n    n = len(arr)\n    \n    for i in range(n - 1):\n        product = arr[i] * arr[i + 1]\n        cur = cur.max(product)\n    \n    return cur\n", "response_1": "from Compiler.types import sfix, sint, Array\n\ndef max_adjacent_product(arr):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2. \n    \"\"\"\n    # Assuming arr is an Array of sfix or sint\n    cur = arr[0] * arr[1]\n    for i in range(len(arr) - 1):\n        product = arr[i] * arr[i + 1]\n        cur = product.if_else(cur, product > cur)\n    return cur\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "argmax", "response_0": "from Compiler.types import sint, sfix, Array\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max value of an array.\n    \"\"\"\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        is_current_max = current >= a[i]\n        index = index.if_else(index, sint(i))\n        current = current.if_else(current, a[i])\n    return index\n", "response_1": "from Compiler.types import sint, cint, Array\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max value of an array. \n    \"\"\"\n    current = a[0]\n    index = cint(0)  # Use cint for index as it is a public value\n    for i in range(len(a)):\n        is_current_greater = current >= a[i]\n        index = index.if_else(index, cint(i))\n        current = current.if_else(current, a[i])\n    return index\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_distinct", "response_0": "from Compiler.types import sint, Array\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = sint(0)\n    n = len(arr)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            unique = unique.bit_and(arr[j] != arr[i])\n        counter = counter + unique\n    return counter\n", "response_1": "from Compiler.types import sint, Array\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            unique = unique.bit_and(arr[j] != arr[i])\n        counter = counter + unique\n    return counter\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exists_true", "response_0": "from Compiler.types import sintbit\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sintbit(0)\n    for item in arr:\n        ret = ret.bit_or(item)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        ret = ret.bit_or(item)\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "range", "response_0": "from Compiler.types import sfix, sint\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = max_value.max(item)\n        min_value = min_value.min(item)\n    return max_value - min_value\n", "response_1": "from Compiler.types import sfix, sint\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = max_value.max(item)\n        min_value = min_value.min(item)\n    return max_value - min_value\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_larger_than_5", "response_0": "", "response_1": "from Compiler.types import sint, sintbit\n\ndef count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5.\n    \"\"\"\n    counter = sint(0)\n    for item in arr:\n        is_larger = item > sint(5)\n        counter = counter + is_larger\n    return counter\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exists_dominator", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max_val = sfix(0)\n    sum_val = sfix(0)\n\n    for item in arr:\n        abs_item = item.abs()\n        max_val = abs_item.if_else(abs_item, max_val)\n        sum_val += abs_item\n\n    return (2 * max_val) > sum_val\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    # Convert input array to sfix if it's not already\n    arr_sfix = sfix.Array(len(arr))\n    arr_sfix.assign(arr)\n\n    # Calculate absolute values\n    abs_arr = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        abs_arr[i] = arr_sfix[i].abs()\n\n    # Find the maximum absolute value\n    max_abs = tree_reduce(lambda x, y: x.max(y), abs_arr)\n\n    # Calculate the sum of absolute values\n    sum_abs = sfix(0)\n    for i in range(len(arr)):\n        sum_abs += abs_arr[i]\n\n    # Check if there exists a dominator\n    return (2 * max_abs) > sum_abs\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "greedy_picker", "response_0": "from Compiler.types import sint, cint\n\ndef greedy_picker(items, captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    for item in items:\n        can_pick = item <= captivity\n        captivity = can_pick.if_else(captivity - item, captivity)\n        num = can_pick.if_else(num + 1, num)\n    return num\n", "response_1": "import Compiler.types\n\ndef greedy_picker(items, captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    for item in items:\n        can_pick = item <= captivity\n        captivity = captivity - item * can_pick\n        num = num + can_pick\n    return num\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "scalar_add_array", "response_0": "from Compiler.types import sint\n\ndef scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result. \n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n", "response_1": "from Compiler.types import sfix, sfixArray\n\ndef scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result. \n    \"\"\"\n    for item in l.get_vector():\n        s = s + item\n    return s\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "is_equidistant_seq", "response_0": "from Compiler.types import sint, sfix, Array\n\ndef is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence. \n    If the array has length 1 or 0, return True.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return sint(1)  # True\n\n    d = sint(0)\n    result = sint(1)  # Assume True initially\n\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if i > 0:\n            result = result.bit_and(diff == d)\n        d = diff\n\n    return result\n", "response_1": "import Compiler.types\nimport Compiler.library\n\ndef is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence. \n    If the array has length 1 or 0, return True.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return True\n\n    d = arr[1] - arr[0]\n    result = Compiler.types.sint(1)  # Assume True initially\n\n    for i in range(1, n-1):\n        diff = arr[i+1] - arr[i]\n        result = result.bit_and(diff == d)\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "inner_product", "response_0": "from Compiler.types import sfix, sint\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays. \n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        sum = sum + vec1[i] * vec2[i]\n    return sum\n", "response_1": "from Compiler.types import sfix\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays. \n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        sum = sum + vec1[i] * vec2[i]\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "more_distinct_nonnegative", "response_0": "", "response_1": "from Compiler.types import sint, sbitint\nfrom Compiler.library import tree_reduce\n\ndef more_distinct_nonnegative(arr):\n    n = len(arr)\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n\n    for i in range(n):\n        unique = sbitint(1)\n        for j in range(i):\n            unique = unique.bit_and(arr[j] != arr[i])\n        \n        if_else(unique, \n                lambda: nonnegative_counter.iadd(arr[i] >= 0), \n                lambda: None)\n        if_else(unique, \n                lambda: negative_counter.iadd(arr[i] < 0), \n                lambda: None)\n\n    return nonnegative_counter > negative_counter\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "flip_positives", "response_0": "from Compiler.types import sint, sfix, Array\n\ndef flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        is_positive = array[i] > 0\n        array[i] = is_positive.if_else(-array[i], array[i])\n    return array\n", "response_1": "from Compiler.types import sint, sfix, Array\n\ndef flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        is_positive = array[i] > 0\n        array[i] = is_positive.if_else(-array[i], array[i])\n    return array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "divide_and_plus", "response_0": "from Compiler.types import sfix\n\ndef divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n", "response_1": "from Compiler.types import sfix\n\ndef divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = x / sfix(2)\n        x = x + sfix(1)\n    return x\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_log2", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import mpc_math\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    result = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        result[i] = mpc_math.log2_fx(arr[i])\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    result = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        result[i] = mpc_math.log2_fx(arr[i])\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_to_ten", "response_0": "from Compiler.types import sint\n\ndef sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        sum += array[i]\n        condition = sum >= sint(10)\n        if condition:\n            break\n    return sum\n", "response_1": "from Compiler.types import sint, cint\n\ndef sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        sum += array[i]\n        condition = sum >= sint(10)\n        if condition:\n            break\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint, Array\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        is_odd = i % 2\n        arr[i] = arr[i] + (is_odd * 2) - 1\n    return arr\n", "response_1": "from Compiler.types import sint, Array\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    for i in range(len(arr)):\n        is_odd = i % 2\n        increment = is_odd * 2 - 1  # 1 if i is odd, -1 if i is even\n        arr[i] = arr[i] + increment\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "min_element", "response_0": "from Compiler.types import sfix, Array\n\ndef min_element(a):\n    \"\"\"\n    Return the min value of an array. \n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = current.if_else(current, item) if current <= item else item\n    \n    return current\n", "response_1": "import Compiler.types\nimport Compiler.library\n\ndef min_element(a):\n    \"\"\"\n    Return the min value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = current.min(item)\n    \n    return current\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "soft_max", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    e = sfix(2.718281828459045)  # Approximation of Euler's number\n    denominator = sfix(0)\n    for item in arr:\n        denominator += mpc_math.pow_fx(e, item)\n    \n    brr = arr.same_shape()\n    for i in range(len(arr)):\n        brr[i] = mpc_math.pow_fx(e, arr[i]) / denominator\n    \n    return brr\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array.\n    \"\"\"\n    # Assuming arr is an Array of sfix\n    n = len(arr)\n    denominator = sfix(0)\n    \n    for item in arr:\n        exp_item = mpc_math.exp(item)\n        denominator += exp_item\n    \n    brr = sfix.Array(n)\n    for i in range(n):\n        exp_item = mpc_math.exp(arr[i])\n        brr[i] = exp_item / denominator\n    \n    return brr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_reverse_pair_with_break", "response_0": "from Compiler.types import sint, cint, Array\n\ndef count_reverse_pair_with_break(arr):\n    count = sint(0)\n    n = len(arr)\n\n    for i in range(1, n):\n        is_bigger_than_10 = arr[i] > cint(10)\n        if_else = is_bigger_than_10.if_else(sint(1), sint(0))\n        if if_else == sint(1):\n            break\n\n        for j in range(i):\n            is_reverse_pair = arr[j] > arr[i]\n            count = count + is_reverse_pair.if_else(sint(1), sint(0))\n\n    return count\n", "response_1": "from Compiler.types import sint, cint, sfix, cfix\nfrom Compiler.library import for_range\n\ndef count_reverse_pair_with_break(arr):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    \"\"\"\n    count = sint(0)\n    n = len(arr)\n    \n    for_range(1, n, lambda i: [\n        arr[i] > cint(10) >> (lambda _: [\n            break\n        ]),\n        for_range(i, lambda j: [\n            arr[j] > arr[i] >> (lambda _: [\n                count += sint(1)\n            ])\n        ])\n    ])\n    \n    return count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_unique", "response_0": "from Compiler.types import sint, Array\n\ndef sum_unique(arr):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    n = len(arr)\n    sum_unique_elements = sint(0)\n    \n    for i in range(n):\n        unique = sint(1)  # Start assuming the element is unique\n        for j in range(n):\n            if j != i:\n                unique = unique.bit_and(arr[j] != arr[i])\n        sum_unique_elements = sum_unique_elements + arr[i] * unique\n    \n    return sum_unique_elements\n", "response_1": "from Compiler.types import sint, Array\n\ndef sum_unique(arr):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    n = len(arr)\n    sum_unique_elements = sint(0)\n    \n    for i in range(n):\n        unique = sint(1)\n        for j in range(n):\n            is_same = arr[j] == arr[i]\n            is_not_same_index = sint(j != i)\n            not_unique_condition = is_same & is_not_same_index\n            unique = unique & (sint(1) - not_unique_condition)\n        \n        sum_unique_elements += arr[i] * unique\n    \n    return sum_unique_elements\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "check_sum", "response_0": "from Compiler.types import sint\n\ndef check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = sint(0)\n    for num in array:\n        sum += num\n    return sum == target\n", "response_1": "from Compiler.types import sint, sfix\n\ndef check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = sint(0)\n    for num in array:\n        sum += num\n    return sum == target\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "prod", "response_0": "from Compiler.types import sfix\n\ndef prod(array):\n    \"\"\"\n    Multiply together all elements in the array. \n    \"\"\"\n    prod = sfix(1)\n    for num in array:\n        prod *= num\n    return prod\n", "response_1": "import Compiler.types\n\ndef prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    prod = sint(1)\n    for num in array:\n        prod *= num\n    return prod\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_till_negative", "response_0": "from Compiler.types import sint, sfix, cint, cfix, Array\n\ndef sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        is_negative = array[i] < sint(0)\n        sum = sum.if_else(sint(0), sum + array[i])\n        if is_negative:\n            break\n    return sum\n", "response_1": "from Compiler.types import sint, Array\n\ndef sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        is_negative = array[i] < sint(0)\n        sum = sum.if_else(sint(0), sum + array[i])\n        if is_negative:\n            break\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        sum += predicator(arr[i])\n    return sum\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        sum = sum + predicator(arr[i]).bit_and(sint(1))\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "standard_deviation", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    n = len(arr)\n    average = sfix(0)\n    variance = sfix(0)\n\n    for item in arr:\n        average += item / n\n\n    for item in arr:\n        variance += (item - average) ** 2 / n\n\n    return mpc_math.sqrt(variance)\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import mpc_math\n\ndef standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array.\n    \"\"\"\n    n = sint(len(arr))\n    average = sfix(0)\n    variance = sfix(0)\n\n    for item in arr:\n        average += item / n\n\n    for item in arr:\n        variance += (item - average) ** 2 / n\n\n    return mpc_math.sqrt(variance)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "dominate", "response_0": "from Compiler.types import sint, Array\n\ndef dominate(a, b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    ret = sint(1)  # True\n    for i in range(len(a)):\n        ret &= (a[i] >= b[i]).bit_and(ret)\n    return ret\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef dominate(a, b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    ret = sbitint(1)  # True\n    for i in range(len(a)):\n        ret &= (a[i] >= b[i])\n    return ret.reveal()\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "rescale", "response_0": "import Compiler.types\nimport Compiler.library\n\ndef rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    # Determine the type of elements in the array\n    value_type = type(brr[0])\n\n    # Initialize max_abs with the first element's absolute value\n    max_abs = abs(brr[0])\n\n    # Find the maximum absolute value in the array\n    for item in brr:\n        current_abs = abs(item)\n        max_abs = Compiler.library.tree_reduce(lambda x, y: x.max(y), [max_abs, current_abs])\n\n    # Rescale each element in the array\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n\n    return brr\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    # Convert input array to sfix\n    brr_sfix = sfix.Array(len(brr))\n    brr_sfix.assign(brr[:])\n\n    # Compute absolute values\n    abs_brr = sfix.Array(len(brr))\n    for i in range(len(brr)):\n        abs_brr[i] = brr_sfix[i].abs()\n\n    # Find the maximum absolute value\n    max_abs = tree_reduce(lambda x, y: x.max(y), abs_brr)\n\n    # Rescale the array\n    for i in range(len(brr)):\n        brr_sfix[i] = brr_sfix[i] / max_abs\n\n    # Convert back to sint if necessary\n    brr_rescaled = sint.Array(len(brr))\n    brr_rescaled.assign(brr_sfix[:])\n\n    return brr_rescaled\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_minus7", "response_0": "from Compiler.types import sint, Array\n\ndef array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] - sint(7)\n    return arr\n", "response_1": "from Compiler.types import sfix, sint\n\ndef array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    seven = sfix(7)\n    for i in range(len(arr)):\n        arr[i] = arr[i] - seven\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sfix, sint\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum += arr1[i] * arr2[j]\n    return sum\n", "response_1": "from Compiler.types import sfix, sint\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum = sum + arr1[i] * arr2[j]\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.library import tree_reduce\n\ndef longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-deceasing subsequence in the input array.\n    \"\"\"\n    n = len(a)\n    max_length = sint(0)\n    cur_length = sint(0)\n\n    for i in range(n):\n        if i == 0:\n            cur_length = sint(1)\n        else:\n            is_nondec = a[i] >= a[i-1]\n            cur_length = cur_length + sint(is_nondec)\n            max_length = max_length.if_else(cur_length, max_length) * (1 - is_nondec) + max_length * is_nondec\n\n    max_length = max_length.if_else(cur_length, max_length)\n\n    return max_length\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-deceasing subsequence in the input array.\n    \"\"\"\n    max_length = sint(0)\n    cur_length = sint(0)\n    n = len(a)\n\n    for i in range(n):\n        if i == 0:\n            cur_length = sint(1)\n            continue\n\n        is_nondec = a[i] >= a[i-1]\n        cur_length = cur_length + sint(1) * is_nondec\n        is_new_max = max_length < cur_length\n        max_length = max_length.if_else(cur_length, max_length) * is_new_max + max_length * (is_new_max.bit_not())\n\n    max_length = max_length.if_else(cur_length, max_length) * (max_length < cur_length) + max_length * ((max_length < cur_length).bit_not())\n    return max_length\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_but_skip_biggest", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.library import tree_reduce\n\ndef sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    n = len(array)\n    sum = sint(0)\n    biggest = array[0]\n\n    for i in range(n):\n        is_biggest = array[i] >= biggest\n        biggest = is_biggest.if_else(array[i], biggest)\n        sum += (~is_biggest).if_else(array[i], sint(0))\n    \n    return sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        is_bigger_or_equal = array[i] >= biggest\n        biggest = is_bigger_or_equal.if_else(array[i], biggest)\n        sum += (is_bigger_or_equal.bit_not() * array[i])\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "second_test", "response_0": "from Compiler.types import sint, sbitint\n\ndef second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    for i in range(1, len(arr)):\n        is_smaller = arr[0] < arr[i]\n        count = count + is_smaller\n    return count == sint(1)\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    first_element = arr[0]\n    for i in range(1, len(arr)):\n        is_smaller = sbitint(first_element < arr[i])\n        count += is_smaller\n    return count == sint(1)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "Manhattan_distance", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\ndef Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    ret = sfix(0)\n    for_range(len(a), lambda i: ret.iadd(abs(a[i] - b[i])))\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import sum\n\ndef Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    # Assuming a and b are arrays of sfix or sint\n    diff = a - b\n    abs_diff = diff.map(abs)\n    ret = sum(abs_diff)\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "deal_with_only_positive", "response_0": "from Compiler.types import sfix, sint\n\ndef deal_with_only_positive(array):\n    \"\"\"\n    Add and substract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sint(1)\n    sum = sfix(0)\n    for i in range(len(array)):\n        is_positive = array[i] > sfix(0)\n        sum = is_positive.if_else(sum + sign * array[i], sum)\n        sign = sign * sint(-1)\n    return sum\n", "response_1": "from Compiler.types import sint, sfix, Array\n\ndef deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sint(1)\n    sum = sint(0)\n    for i in range(len(array)):\n        is_positive = array[i] > sint(0)\n        sum = is_positive.if_else(sum + sign * array[i], sum)\n        sign = is_positive.if_else(sign * sint(-1), sign)\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import sint, cint, Array\n\ndef compare_and_return(arr, brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    ret = cint(-1)\n    found = cint(0)\n    for i in range(len(arr)):\n        is_equal = arr[i] == brr[i]\n        new_ret = i * is_equal + ret * (1 - is_equal)\n        ret = new_ret\n        found = found.bit_or(is_equal)\n        if found:\n            break\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef compare_and_return(arr, brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    ret = sint(-1)\n    for i in range(len(arr)):\n        condition = arr[i] == brr[i]\n        ret = condition.if_else(sint(i), ret)\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_odd_positive", "response_0": "from Compiler.types import sint, sfix, cint, cfix, Array\n\ndef sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        is_odd = item % sint(2)\n        is_positive = item > sint(0)\n        is_odd_positive = is_odd.bit_and(is_positive)\n        sum = sum + item.if_else(item, sint(0))\n    return sum\n", "response_1": "from Compiler.types import sint, sfix\n\ndef sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        is_odd = item % sint(2)\n        is_positive = item > sint(0)\n        is_odd_and_positive = is_odd.bit_and(is_positive)\n        sum = sum + item.if_else(item, sint(0))\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "two_sum", "response_0": "from Compiler.types import sint, sbitint\n\ndef two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value. \n    \"\"\"\n    n = len(arr)\n    found = sbitint(0)\n    for i in range(n):\n        for j in range(n):\n            sum_ij = arr[i] + arr[j]\n            is_equal = sum_ij == target\n            found = found.bit_or(is_equal)\n    reveal(found)\n    return found\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value. \n    \"\"\"\n    n = len(arr)\n    found = sbitint(0)\n    for i in range(n):\n        for j in range(n):\n            sum_ij = arr[i] + arr[j]\n            is_equal = sum_ij == target\n            found = found.bit_or(is_equal)\n    reveal(found)\n    return found\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "seq_search", "response_0": "from Compiler.types import sint, sbitint, Array\n\ndef seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    n = len(arr)\n    result = sint(-1)\n    found = sbitint(0)\n\n    for i in range(n):\n        is_equal = arr[i] == target\n        found = found.bit_or(is_equal)\n        result = found.if_else(i, result)\n\n    return result\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "choppy_array", "response_0": "from Compiler.types import sint, Array\n\ndef choppy_array(arr):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    n = len(arr)\n    arr_sint = Array(n, sint)\n    arr_sint.assign(arr)\n\n    for i in range(n):\n        for j in range(n - i):\n            if i % 2:\n                if arr_sint[i + j] > arr_sint[i]:\n                    return sint(0)\n            else:\n                if arr_sint[i + j] < arr_sint[i]:\n                    return sint(0)\n    return sint(1)\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef choppy_array(arr):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i):\n            if i % 2:\n                # arr[i+j] > arr[i]\n                condition = arr[i+j] > arr[i]\n            else:\n                # arr[i+j] < arr[i]\n                condition = arr[i+j] < arr[i]\n            \n            # If condition is true, return False\n            if condition:\n                return sbitint(0)\n    return sbitint(1)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_process", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.library import for_range\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.library import for_range\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for_range(len(arr), lambda i: arr[i].assign(func(arr[i])))\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "normalize", "response_0": "import mpc_math\nfrom Compiler.types import sfix, Array\n\ndef normalize(vec):\n    \"\"\"\n    Normalize the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum += item * item\n    \n    base = mpc_math.sqrt(sum)\n    \n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    \n    return vec\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import mpc_math\n\ndef normalize(vec):\n    \"\"\"\n    Normalize the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + (item * item)\n    base = mpc_math.sqrt(sum)\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "impatient_merchant", "response_0": "from Compiler.types import sint, Array\n\ndef impatient_merchant(days):\n    \"\"\"\n    You are given the prices of some goods in consecutive days. \n    Here's an impatient merchant who will buy the good at the first days, \n    and sell it until its price becomes higher than its original cost. \n    Then he will buy the good in the next day and repeat the above process. \n    The good left in the hand of the merchant in the last day will worth nothing.\n    You should calculate the net value the impatient merchant can earn.\n    \"\"\"\n    can_buy = sint(1)  # True initially\n    net = sint(0)\n    orig_price = sint(0)\n    days_array = Array(len(days), sint)\n    days_array.assign(days)\n\n    for i in range(len(days)):\n        if can_buy:\n            net = net - days_array[i]\n            orig_price = days_array[i]\n            can_buy = sint(0)  # False after buying\n        else:\n            price_gt_orig = days_array[i] > orig_price\n            net = net + price_gt_orig * days_array[i]\n            can_buy = price_gt_orig  # Can buy if sold\n\n    return net\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef impatient_merchant(days):\n    \"\"\"\n    You are given the prices of some goods in consecutive days. \n    Here's an impatient merchant who will buy the good at the first days, \n    and sell it until its price becomes higher than its original cost. \n    Then he will buy the good in the next day and repeat the above process. \n    The good left in the hand of the merchant in the last day will worth nothing.\n    You should calculate the net value the impatient merchant can earn.\n    \"\"\"\n    can_buy = sbitint(1)\n    net = sint(0)\n    orig_price = sint(0)\n    \n    for i in range(len(days)):\n        if_else = can_buy.if_else(sint(0), days[i])\n        net -= if_else\n        orig_price = can_buy.if_else(orig_price, days[i])\n        \n        can_buy = (days[i] > orig_price).bit_or(can_buy.bit_not())\n    \n    return net\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_shift", "response_0": "from Compiler.types import sint, Array\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1):\n        a[n-i-1] = a[n-i-2]\n    a[0] = temp\n    return a\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1):\n        a[n-i-1] = a[n-i-2]\n    a[0] = temp\n    return a\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_double", "response_0": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n\n# MP-SPDZ equivalent\ndef array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n\n# Assuming arr is of type sint.Array or cint.Array\ndef array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "from Compiler.types import sint, sfix\n\ndef array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n\n# If the array contains secret fixed-point numbers\ndef array_double_sfix(arr):\n    \"\"\"\n    Double all elements in the input array of secret fixed-point numbers.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.types import sint, Array\n\ndef stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    length = len(array)\n    for i in range(length):\n        is_zero = array[i] == sint(0)\n        array[i] = array[i] + sint(1) - is_zero\n        if is_zero:\n            break\n    return array\n", "response_1": "from Compiler.types import sint, Array\n\ndef stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    length = len(array)\n    for i in range(length):\n        is_zero = array[i] == 0\n        array[i] = array[i] + 1 - is_zero\n        if is_zero:\n            break\n    return array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_not", "response_0": "from Compiler.types import sint\n\ndef array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i].bit_not()\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i].bit_not()\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_process_then_clip", "response_0": "from Compiler.types import sfix, sint\n\ndef array_process_then_clip(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome in to range [-10,10]\n    \"\"\"\n    ten = sfix(10)\n    neg_ten = sfix(-10)\n\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = arr[i].min(ten)\n        arr[i] = arr[i].max(neg_ten)\n\n    return arr\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef array_process_then_clip(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome in to range [-10,10]\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = arr[i].min(10)\n        arr[i] = arr[i].max(-10)\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "add_and_count_positive", "response_0": "from Compiler.types import sint, sintbit\n\ndef add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        is_positive = array[i] > sint(0)\n        count = count + is_positive\n    return array, count\n", "response_1": "from Compiler.types import sint, cint, sfix, cfix, Array\n\ndef add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    n = len(array)\n    output_array = sint.Array(n)\n    count = sint(0)\n\n    for i in range(n):\n        output_array[i] = array[i] + k\n        is_positive = sint(output_array[i] > 0)\n        count = count + is_positive\n\n    return output_array, count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_subtract", "response_0": "from Compiler.types import sfix, Array\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    \n    if len_a > len_b:\n        ret = Array(len_a, sfix)\n        ret.assign_all(sfix(0))\n        for i in range(len_b):\n            ret[i] = a[i] - b[i]\n        for i in range(len_a - len_b):\n            ret[len_b + i] = a[len_b + i]\n    else:\n        ret = Array(len_b, sfix)\n        ret.assign_all(sfix(0))\n        for i in range(len_a):\n            ret[i] = a[i] - b[i]\n        for i in range(len_b - len_a):\n            ret[len_a + i] = -b[len_a + i]\n    \n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    \n    if len_a > len_b:\n        ret = Array(len_a, sint)\n        for i in range(len_b):\n            ret[i] = a[i] - b[i]\n        for i in range(len_a - len_b):\n            ret[len_b + i] = a[len_b + i]\n    else:\n        ret = Array(len_b, sint)\n        for i in range(len_a):\n            ret[i] = a[i] - b[i]\n        for i in range(len_b - len_a):\n            ret[len_a + i] = -b[len_a + i]\n    \n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "lower_bound", "response_0": "", "response_1": "from Compiler.types import sint, sbitint, Array\n\ndef lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = sint(-1)\n    distance = sint(0)\n    found = sbitint(0)\n\n    for i in range(len(arr)):\n        is_less_or_equal = arr[i] <= x\n        is_closer = x - arr[i] < distance\n        should_update = is_less_or_equal & (found.bit_not() | is_closer)\n\n        ret = ret.if_else(i, ret)\n        distance = distance.if_else(x - arr[i], distance)\n        found = found.bit_or(is_less_or_equal)\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "argmin", "response_0": "import Compiler.types\n\ndef argmin(a):\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        new_index = index.bit_and((current <= a[i]).bit_not()) + i.bit_and((current > a[i]))\n        index = new_index\n        current = current.if_else(current, a[i], current > a[i])\n    return index\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef argmin(a):\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        is_current_min = current <= a[i]\n        index = index.if_else(index, sint(i))\n        current = current.if_else(current, a[i])\n    return index\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "independent_robbery", "response_0": "from Compiler.types import sint, Array\n\ndef independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem:\n    The robber wants to rob some houses align a street, each of which has some amount of money in it (guaranteed to be nonnegative). \n    The robber cannot rob two consecutive houses, we want to know the max amount of money he can get. \n    The number of houses is guaranteed to be no smaller than 3.\n    \"\"\"\n    n = len(houses)\n    dp = sint.Array(n)\n    \n    dp[0] = houses[0]\n    dp[1] = dp[1].if_else(dp[1], dp[0])  # dp[1] if dp[1] >= dp[0] else dp[0]\n    \n    for i in range(2, n):\n        temp1 = dp[i-2] + houses[i]\n        dp[i] = temp1.if_else(temp1, dp[i-1])  # dp[i-2] + houses[i] if dp[i-2] + houses[i] >= dp[i-1] else dp[i-1]\n    \n    return dp[n-1]\n", "response_1": "from Compiler.types import sint, Array\n\ndef independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem:\n    The robber wants to rob some houses align a street, each of which has some amount of money in it (guaranteed to be nonnegative). \n    The robber cannot rob two consecutive houses, we want to know the max amount of money he can get. \n    The number of houses is guaranteed to be no smaller than 3.\n    \"\"\"\n    n = len(houses)\n    dp = sint.Array(n)\n\n    dp[0] = houses[0]\n    dp[1] = dp[0].max(houses[1])\n\n    for i in range(2, n):\n        dp_i_minus_2_plus_houses_i = dp[i-2] + houses[i]\n        dp[i] = dp_i_minus_2_plus_houses_i.max(dp[i-1])\n\n    return dp[n-1]\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_odd_and_odd", "response_0": "from Compiler.types import sint, cint\n\ndef sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        is_i_odd = i % 2\n        if is_i_odd == 0:\n            continue\n        for j in range(i):\n            is_j_odd = j % 2\n            if is_j_odd == 0:\n                continue\n            sum += arr[j]\n    return sum\n", "response_1": "from Compiler.types import sint, cint\n\ndef sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    arr_length = cint(len(arr))\n    sum = sint(0)\n    \n    for i in range(arr_length):\n        is_i_odd = i % 2\n        if is_i_odd == 0:\n            continue\n        for j in range(i):\n            is_j_odd = j % 2\n            if is_j_odd == 0:\n                continue\n            sum += arr[j]\n    \n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "is_monotonous", "response_0": "from Compiler.types import sint, Array\n\ndef is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    d = sint(0)\n    result = sint(1)  # True initially\n\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        condition = (i > 0) & ((diff * d) <= 0)\n        result = result & ~condition\n        d = diff\n\n    return result\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    d = sint(0)\n    is_monotonic = sbitint(1)\n\n    for i in range(n-1):\n        diff = arr[i+1] - arr[i]\n        if i > 0:\n            product = diff * d\n            is_non_positive = product <= sint(0)\n            is_monotonic = is_monotonic.bit_and(is_non_positive.bit_not())\n        d = diff\n\n    return is_monotonic\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler.types import sint, cint\n\ndef positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint(0)\n    sum = sint(0)\n    for item in arr:\n        is_positive = sint(item > 0)\n        count += is_positive\n        is_negative = sint(item < 0)\n        sum += item * is_negative\n    return count, sum\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_even", "response_0": "from Compiler.types import sint, sintbit\n\ndef sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        is_even = item.bit_and(sint(1)).bit_not()\n        sum = sum + item * is_even\n    return sum\n", "response_1": "from Compiler.types import sint, sintbit\n\ndef sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        is_even = item % 2 == sint(0)\n        sum = sum + item.if_else(item, sint(0))\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "one_norm", "response_0": "from Compiler.types import sfix, sint\n\ndef one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item.abs()\n    return sum\n", "response_1": "from Compiler.types import sfix\n\ndef one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item.abs()\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_floor", "response_0": "from Compiler.types import sfix, sint, cfix, cint\nfrom Compiler.library import tree_reduce\n\ndef array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        # Convert to sfix for floor operation\n        arr_sfix = sfix(arr[i])\n        # Apply floor operation\n        floored_value = arr_sfix.floor()\n        # Convert back to sint\n        ret[i] = sint(floored_value)\n    return ret\n", "response_1": "from Compiler.types import sfix, sint, cfix, cint\nfrom Compiler.library import for_range\n\ndef array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for_range(len(arr), lambda i: ret[i].assign(arr[i] >> sfix(1) << sfix(1)))\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "three_five", "response_0": "from Compiler.types import sint, sbitint\n\ndef three_five(arr):\n    has3 = sbitint(0)\n    has5 = sbitint(0)\n    for item in arr:\n        has3 = has3.bit_or(item == sint(3))\n        has5 = has5.bit_or(item == sint(5))\n    return has3.bit_and(has5).bit_or(has3.bit_not().bit_and(has5.bit_not()))\n", "response_1": "from Compiler.types import sint\n\ndef three_five(arr):\n    has3 = sint(0)\n    has5 = sint(0)\n    for item in arr:\n        has3 = has3.bit_or(item == 3)\n        has5 = has5.bit_or(item == 5)\n    return (has3.bit_and(has5)).bit_or((has3.bit_not().bit_and(has5.bit_not())))\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "num_above_average", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import cint\n\ndef num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value.\n    \"\"\"\n    n = len(arr)\n    sum = sfix(0)\n    count = sint(0)\n\n    for i in range(n):\n        sum += arr[i]\n\n    avg = sum / cint(n)\n\n    for item in arr:\n        count += (item >= avg).if_else(sint(1), sint(0))\n\n    return count\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    n = sint(len(arr))\n    sum = sfix(0)\n    for i in range(len(arr)):\n        sum += arr[i]\n    avg = sum / n\n\n    count = sint(0)\n    for item in arr:\n        count += sint(item >= avg)\n    return count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix, sint\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    upper_bound = sfix(upper_bound)\n    lower_bound = sfix(lower_bound)\n    \n    for i in range(len(arr)):\n        arr[i] = arr[i].max(lower_bound)\n        arr[i] = arr[i].min(upper_bound)\n    \n    return arr\n", "response_1": "from Compiler.types import sfix, sint, Array\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    length = len(arr)\n    clipped_arr = Array(length, sfix)\n\n    for i in range(length):\n        # Convert bounds to sfix if they are not already\n        upper_bound_sfix = sfix(upper_bound)\n        lower_bound_sfix = sfix(lower_bound)\n\n        # Clip lower bound\n        lower_clipped = arr[i].max(lower_bound_sfix)\n        # Clip upper bound\n        clipped_value = lower_clipped.min(upper_bound_sfix)\n\n        clipped_arr[i] = clipped_value\n\n    return clipped_arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "from Compiler.types import sfix, sint\n\ndef sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(array)):\n        current_sum = sum + array[i]\n        lower_bound_check = current_sum >= sfix(5)\n        upper_bound_check = current_sum <= sfix(10)\n        skip_element = lower_bound_check.bit_and(upper_bound_check)\n        sum = sum.if_else(current_sum, sum)\n    return sum\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.library import tree_reduce\n\ndef sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    n = len(array)\n    sum = sint(0)\n    for i in range(n):\n        current_sum = sum + array[i]\n        skip = (current_sum >= sint(5)) & (current_sum <= sint(10))\n        sum = sum + (array[i] * skip.bit_not())\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.types import sint, cint\n\ndef sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        is_odd = item % sint(2)\n        odd_sum = odd_sum + item * is_odd\n        even_sum = even_sum + item * (is_odd.bit_not())\n    return odd_sum, even_sum\n", "response_1": "from Compiler.types import sint, cint, sfix, cfix, Array\n\ndef sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        is_odd = item % sint(2)\n        odd_sum = odd_sum + item * is_odd\n        even_sum = even_sum + item * (sint(1) - is_odd)\n    return odd_sum, even_sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "distance", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import mpc_math\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        sum = sum + (diff * diff)\n    return mpc_math.sqrt(sum)\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import mpc_math\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        sum = sum + diff * diff\n    return mpc_math.sqrt(sum)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "num_occurrence", "response_0": "from Compiler.types import sint, cint, sfix, cfix, Array\n\ndef num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sint(0)\n    for item in arr:\n        count += sint(item == target)\n    return count\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef num_occurrence(arr, target):\n    count = sint(0)\n    for item in arr:\n        is_equal = item == target\n        count = count + sbitint(is_equal).if_else(sint(1), sint(0))\n    return count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "palindrome", "response_0": "from Compiler.types import sint, Array\n\ndef palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    flag = sint(1)\n    n = len(arr)\n    for i in range(n):\n        flag = flag.bit_and(arr[i] == arr[n - 1 - i])\n    return flag\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    flag = sbitint(1)  # Initialize flag as True\n    for i in range(len(arr)):\n        flag = flag.bit_and(arr[i] == arr[len(arr) - 1 - i])\n    return flag\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint, Array\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array. \n    \"\"\"\n    num = sint(0)\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            is_reverse = arr[i] > arr[j]\n            num += is_reverse\n    return num\n", "response_1": "from Compiler.types import sint, Array\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    num = sint(0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            is_reverse = arr[i] > arr[j]\n            num += is_reverse\n    return num\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_of_cubes", "response_0": "from Compiler.types import sfix, sint\n\ndef sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sfix(0)\n    for item in arr:\n        ret = ret + (item ** 3)\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\n\ndef sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sfix(0)\n    for item in arr:\n        ret = ret + item**3\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "max_element", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    return tree_reduce(lambda x, y: x.max(y), a)\n", "response_1": "from Compiler.types import sfix, sint\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a[1:]:  # Start from the second element\n        current = current.max(item)\n    \n    return current\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_if_else", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.library import tree_reduce\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    result = sint.Array(len(arr))\n    for i in range(len(arr)):\n        pred = predicator(arr[i])\n        result[i] = pred.if_else(if_func(arr[i]), else_func(arr[i]))\n    return result\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.library import tree_reduce\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    result = sint.Array(len(arr))\n    for i in range(len(arr)):\n        pred = predicator(arr[i])\n        result[i] = pred.if_else(if_func(arr[i]), else_func(arr[i]))\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "inf_norm", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import tree_reduce\n\ndef inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    # Assuming vec is an Array of sfix\n    abs_values = [mpc_math.abs(item) for item in vec]\n    return tree_reduce(lambda x, y: x.max(y), abs_values)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import tree_reduce\n\ndef inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    return tree_reduce(lambda x, y: x.max(y), [abs(item) for item in vec])\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_inc", "response_0": "from Compiler.types import sint, Array\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + sint(1)\n    return arr\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint, cint\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        is_rise = arr[i] < arr[i + 1]\n        count = count + is_rise\n    return count\n", "response_1": "from Compiler.types import sint, Array\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        is_rise = arr[i] < arr[i + 1]\n        count = count + is_rise\n    return count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "skip_at_zero", "response_0": "from Compiler.types import sint, Array\n\ndef skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    result = Array(len(array), sint)\n    for i in range(len(array)):\n        is_zero = array[i] == 0\n        result[i] = array[i] + (1 - is_zero)\n    return result\n", "response_1": "from Compiler.types import sint, Array\n\ndef skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    result = Array(len(array), sint)\n    for i in range(len(array)):\n        is_zero = array[i] == sint(0)\n        result[i] = array[i] + sint(1).if_else(is_zero, sint(0))\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_intersect", "response_0": "from Compiler.types import sint, Array\n\ndef array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    len_p = len(p)\n    len_q = len(q)\n    \n    for i in range(len_p):\n        for j in range(len_q):\n            if p[i] == q[j]:\n                return sint(1)\n    return sint(0)\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    n = len(p)\n    m = len(q)\n    result = sint(0)\n    for i in range(n):\n        for j in range(m):\n            result = result.bit_or(p[i] == q[j])\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item**2\n    return mpc_math.sqrt(sum)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item ** 2\n    return mpc_math.sqrt(sum)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_between", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.library import tree_reduce\n\ndef sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        # Check if item is within the range [l, u]\n        is_within_range = (l <= item) & (item <= u)\n        # Use if_else to add item to sum if it is within the range\n        sum = sum + item.if_else(item, sint(0))\n    return sum\n", "response_1": "from Compiler.types import sint, sfix\n\ndef sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        # Check if item is within the range [l, u]\n        is_within_range = (item >= l) & (item <= u)\n        # Conditionally add item to sum if it is within the range\n        sum = sum + is_within_range.if_else(item, sint(0))\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "largest_gap", "response_0": "from Compiler.types import sfix, sint, Array\n\ndef largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    # Convert input list to an Array of sfix\n    arr_sfix = Array(len(arr), sfix)\n    arr_sfix.assign_vector([sfix(x) for x in arr])\n\n    cur = sfix(0)\n    for i in range(len(arr) - 1):\n        diff = arr_sfix[i + 1] - arr_sfix[i]\n        abs_diff = diff.abs()\n        cur = abs_diff.if_else(abs_diff, cur)\n\n    return cur\n", "response_1": "from Compiler.types import sfix, sint, Array\nfrom Compiler.library import tree_reduce\n\ndef largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    n = len(arr)\n    gaps = Array(n-1, sfix)\n    \n    for i in range(n-1):\n        diff = abs(arr[i+1] - arr[i])\n        gaps[i] = diff\n    \n    cur = tree_reduce(lambda x, y: x.max(y), gaps)\n    return cur\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "totally_dominate", "response_0": "from Compiler.types import sint, sfix\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    \n    for i in range(len(a)):\n        amin = amin.min(a[i])\n    \n    for i in range(len(b)):\n        bmax = bmax.max(b[i])\n    \n    return amin >= bmax\n", "response_1": "from Compiler.types import sint, sfix, Array\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    \n    for i in range(len(a)):\n        amin = amin.min(a[i])\n    \n    for i in range(len(b)):\n        bmax = bmax.max(b[i])\n    \n    return amin >= bmax\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "element_count", "response_0": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    ret = sint(0)\n    for item in arr:\n        ret += item.if_else(sint(1), sint(0)).bit_and(item == target)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        ret += (item == target).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "is_subarray", "response_0": "from Compiler.types import sint, Array\n\ndef is_subarray(c, d):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    len_c = sint(len(c))\n    len_d = sint(len(d))\n    \n    for i in range(len_d):\n        if len_c <= len_d - i:\n            flag = sint(1)\n            for j in range(len_c):\n                flag = flag.bit_and(d[i + j] == c[j])\n            if flag:\n                return sint(1)\n    return sint(0)\n", "response_1": "from Compiler.types import sint, Array\n\ndef is_subarray(c, d):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    len_c = len(c)\n    len_d = len(d)\n    \n    c_array = Array(len_c, sint)\n    d_array = Array(len_d, sint)\n    \n    c_array.assign(c)\n    d_array.assign(d)\n    \n    result = sint(0)\n    \n    for i in range(len_d):\n        if len_c <= len_d - i:\n            flag = sint(1)\n            for j in range(len_c):\n                flag = flag.bit_and(d_array[i + j] == c_array[j])\n            result = result.bit_or(flag)\n    \n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint, sintbit\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    found = sintbit(0)\n    for item in arr:\n        is_five = (item == 5)\n        is_seven = (item == 7)\n        found = found.bit_or(is_five.bit_or(is_seven))\n    return found\n", "response_1": "from Compiler.types import sint, sintbit\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    result = sintbit(0)\n    for item in arr:\n        is_5 = item == sint(5)\n        is_7 = item == sint(7)\n        result = result.bit_or(is_5).bit_or(is_7)\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "variance", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import mpc_math\n\ndef variance(arr):\n    \"\"\"\n    Return the variance of the array.\n    \"\"\"\n    n = len(arr)\n    n_inv = sfix(1) / sfix(n)\n    \n    average = sfix(0)\n    for item in arr:\n        average += item * n_inv\n    \n    variance = sfix(0)\n    for item in arr:\n        diff = item - average\n        variance += diff * diff * n_inv\n    \n    return variance\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import cint\n\ndef variance(arr):\n    \"\"\"\n    Return the variance of the array. \n    \"\"\"\n    n = cint(len(arr))\n    average = sfix(0)\n    variance = sfix(0)\n    \n    for item in arr:\n        average = average + item / n\n    \n    for item in arr:\n        variance = variance + ((item - average) ** 2) / n\n    \n    return variance\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "is_ascending", "response_0": "from Compiler.types import sint, sbitint\n\ndef is_ascending(arr):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    n = len(arr)\n    if n == 1:\n        return True\n\n    ascending = sbitint(1)  # Start assuming the array is ascending\n\n    for i in range(n - 1):\n        ascending = ascending.bit_and(arr[i] < arr[i + 1])\n\n    return ascending\n", "response_1": "from Compiler.types import sint, Array\n\ndef is_ascending(arr):\n    n = len(arr)\n    if n == 1:\n        return sint(1)  # True\n\n    ascending = sint(1)  # Assume the array is ascending\n\n    for i in range(n - 1):\n        ascending &= (arr[i] < arr[i + 1])\n\n    return ascending\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "xor_all", "response_0": "from Compiler.types import sint\n\ndef xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret.bit_xor(arr[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret.bit_xor(arr[i])\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "upper_bound", "response_0": "from Compiler.types import sint, cint\n\ndef upper_bound(arr, x):\n    ret = cint(-1)\n    distance = sint(2**32)  # Assuming a large initial distance\n    found = sint(0)  # False initially\n\n    for i in range(len(arr)):\n        is_greater = arr[i] > x\n        is_closer = (arr[i] - x) < distance\n        should_update = is_greater & (found.bit_not() | is_closer)\n\n        ret = ret.if_else(i, ret)\n        distance = distance.if_else(arr[i] - x, distance)\n        found = found.if_else(sint(1), found)\n\n    return ret\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef upper_bound(arr, x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = sint(-1)\n    distance = sint(0)\n    found = sbitint(0)\n\n    for i in range(len(arr)):\n        is_greater = arr[i] > x\n        is_closer = arr[i] - x < distance\n        should_update = is_greater & (found.bit_not() | is_closer)\n        ret = ret.if_else(i, ret)\n        distance = distance.if_else(arr[i] - x, distance)\n        found = found.bit_or(should_update)\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler.types import sfix, sint\n\ndef array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        sum += arr[i]\n    return sum\n", "response_1": "from Compiler.types import sint, sfix\n\ndef array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        sum += arr[i]\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "average", "response_0": "from Compiler.types import sfix, sint\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sfix(0)\n    length = len(arr)\n    for i in range(length):\n        sum = sum + arr[i]\n    ret = sum / sfix(length)\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sfix(0)\n    length = len(arr)\n    for i in range(length):\n        sum = sum + arr[i]\n    ret = sum / sfix(length)\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_filter", "response_0": "from Compiler.types import sint, sbitint\n\ndef array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    for i in range(len(arr)):\n        condition = predicator(arr[i])\n        arr[i] = arr[i].if_else(arr[i], sint(0))\n    return arr\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    filtered_arr = sint.Array(len(arr))\n    for i in range(len(arr)):\n        condition = predicator(arr[i])\n        filtered_arr[i] = arr[i] * condition + (1 - condition) * 0\n    return filtered_arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_up", "response_0": "import Compiler.types\n\ndef sum_up(array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    sum = Compiler.types.sint(0)\n    for num in array:\n        sum = sum + num\n    return sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_up(array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    sum = sint(0)\n    for num in array:\n        sum += num\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "negative_to_zero", "response_0": "from Compiler.types import sint, sfix, Array\n\ndef negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(len(array)):\n        is_negative = array[i] < 0\n        array[i] = array[i].if_else(0, array[i])\n    return array\n", "response_1": "from Compiler.types import sint, sfix, Array\n\ndef negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(len(array)):\n        is_negative = array[i] < sint(0)\n        array[i] = is_negative.if_else(sint(0), array[i])\n    return array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_only_positive_to_ten", "response_0": "from Compiler.types import sint\n\ndef sum_only_positive_to_ten(array):\n    sum = sint(0)\n    for i in range(len(array)):\n        is_positive = array[i] > sint(0)\n        is_sum_less_than_10 = sum < sint(10)\n        should_add = is_positive.bit_and(is_sum_less_than_10)\n        sum = sum + (array[i] * should_add)\n        is_sum_at_least_10 = sum >= sint(10)\n        if is_sum_at_least_10:\n            break\n    return sum\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.library import for_range\n\ndef sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    ten = sint(10)\n    array_len = len(array)\n\n    @for_range(array_len)\n    def loop(i):\n        nonlocal sum\n        positive_check = array[i] > sint(0)\n        sum_greater_equal_ten = sum >= ten\n\n        # If sum is already >= 10, do nothing\n        sum = sum_greater_equal_ten.if_else(sum, sum + positive_check.if_else(array[i], sint(0)))\n\n    return sum\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "bubble_sort", "response_0": "from Compiler.types import sint, Array\n\ndef bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array. \n    \"\"\"\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-1-i):\n            cond = arr[j] >= arr[j+1]\n            arr[j], arr[j+1] = cond.if_else(arr[j+1], arr[j]), cond.if_else(arr[j], arr[j+1])\n    return arr\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import cint\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            # Compare arr[j] and arr[j+1]\n            is_greater_or_equal = arr[j] >= arr[j+1]\n            # Conditional swap\n            arr[j], arr[j+1] = is_greater_or_equal.if_else(arr[j+1], arr[j]), is_greater_or_equal.if_else(arr[j], arr[j+1])\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
