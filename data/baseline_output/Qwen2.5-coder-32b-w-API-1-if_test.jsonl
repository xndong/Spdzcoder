{"test_name": "sin_or_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Ensure x is of type sfix for secure computation\n    x = sfix(x)\n\n    # Compute the sign of x\n    is_nonnegative = x >= 0\n\n    # Compute sin(x) and cos(x)\n    sin_x = mpc_math.sin(x)\n    cos_x = mpc_math.cos(x)\n\n    # Use if_else to select between sin(x) and cos(x) based on the sign of x\n    result = is_nonnegative.if_else(sin_x, cos_x)\n\n    return result\n", "response_1": "import mpc_math\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    zero = sint(0)\n    condition = x >= zero\n    sin_x = mpc_math.sin(x)\n    cos_x = mpc_math.cos(x)\n    return condition.if_else(sin_x, cos_x)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "negative_relu", "response_0": "from Compiler.types import sint\n\ndef negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    zero = sint(0)\n    condition = input < zero\n    result = condition.if_else(input, zero)\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    zero = sint(0)\n    condition = input < zero\n    result = condition.if_else(input, zero)\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "is_close", "response_0": "from Compiler.types import sfix\n\ndef is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close: \n    their absolute difference is no larger than 1. \n    \"\"\"\n    return (a - b).abs() <= sfix(1)\n", "response_1": "from Compiler.types import sfix\n\ndef is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close: \n    their absolute difference is no larger than 1. \n    \"\"\"\n    diff = a - b\n    abs_diff = diff.abs()\n    return abs_diff <= sfix(1)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "hardswish", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import tree_reduce\n\ndef hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    # Define constants\n    three = sfix(3)\n    neg_three = sfix(-3)\n    six = sfix(6)\n\n    # Compute conditions\n    condition1 = x < neg_three\n    condition2 = x > three\n\n    # Compute the result for the range -3 <= x <= 3\n    result_middle = x * (x + three) / six\n\n    # Use if_else to select the correct result\n    result = condition1.if_else(sfix(0), condition2.if_else(x, result_middle))\n\n    return result\n", "response_1": "import Compiler.types\nimport Compiler.library\n\ndef hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    zero = Compiler.types.sfix(0)\n    three = Compiler.types.sfix(3)\n    six = Compiler.types.sfix(6)\n\n    # Calculate x + 3\n    x_plus_three = x + three\n\n    # Calculate x * (x + 3)\n    x_times_x_plus_three = x * x_plus_three\n\n    # Calculate x * (x + 3) / 6\n    result = x_times_x_plus_three / six\n\n    # Create conditions\n    cond1 = x <= -three\n    cond2 = x > three\n\n    # Use if_else to select the appropriate result\n    result = cond1.if_else(zero, result)\n    result = cond2.if_else(x, result)\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "clip_at_6", "response_0": "from Compiler.types import sint\n\ndef clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    six = sint(6)\n    neg_six = sint(-6)\n\n    # Compute x > 6\n    gt_six = x > six\n    # Compute x < -6\n    lt_neg_six = x < neg_six\n\n    # Clip x to 6 if x > 6\n    clipped = x.if_else(six, x)\n    # Clip clipped value to -6 if x < -6\n    clipped = lt_neg_six.if_else(neg_six, clipped)\n\n    return clipped\n", "response_1": "from Compiler.types import sint\n\ndef clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    six = sint(6)\n    neg_six = sint(-6)\n    \n    # Compute the maximum between x and -6\n    clipped_min = mpc_math.max(x, neg_six)\n    \n    # Compute the minimum between the clipped_min and 6\n    clipped_value = mpc_math.min(clipped_min, six)\n    \n    return clipped_value\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "piecewise_function", "response_0": "from Compiler.types import sint\n\ndef piecewise_function(x):\n    \"\"\"\n    A piecewise function.\n    \"\"\"\n    ret = sint(0)\n    \n    # x > 1\n    condition1 = x > sint(1)\n    ret = condition1.if_else(x, ret)\n    \n    # x < -1\n    condition2 = x < sint(-1)\n    ret = condition2.if_else(x, ret)\n    \n    # x > 0\n    condition3 = (x > sint(0)) & (x <= sint(1))\n    ret = condition3.if_else(sint(1), ret)\n    \n    # x < 0\n    condition4 = (x < sint(0)) & (x >= sint(-1))\n    ret = condition4.if_else(sint(-1), ret)\n    \n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    \"\"\"\n    A piecewise function.\n    \"\"\"\n    ret = sfix(0)\n\n    # x > 1\n    condition1 = x > sfix(1)\n    ret = condition1.if_else(x, ret)\n\n    # x < -1\n    condition2 = x < sfix(-1)\n    ret = condition2.if_else(x, ret)\n\n    # x > 0\n    condition3 = (x > sfix(0)) & (x <= sfix(1))\n    ret = condition3.if_else(sfix(1), ret)\n\n    # x < 0\n    condition4 = (x < sfix(0)) & (x >= sfix(-1))\n    ret = condition4.if_else(sfix(-1), ret)\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "middle", "response_0": "from Compiler.types import sint\n\ndef middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # First comparison: if a >= b, swap a and b\n    cond = a >= b\n    temp = cond.if_else(a, b)\n    a = cond.if_else(b, a)\n    b = temp\n\n    # Second comparison: if b >= c, swap b and c\n    cond = b >= c\n    temp = cond.if_else(b, c)\n    b = cond.if_else(c, b)\n    c = temp\n\n    # Third comparison: if a >= b, swap a and b\n    cond = a >= b\n    temp = cond.if_else(a, b)\n    a = cond.if_else(b, a)\n    b = temp\n\n    return b\n", "response_1": "import Compiler.types\n\ndef middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # Use sbitint for comparison results\n    temp = sint(0)\n\n    # First comparison: if a >= b, swap a and b\n    cmp_ab = a >= b\n    a, b = cmp_ab.if_else(b, a), cmp_ab.if_else(a, b)\n\n    # Second comparison: if b >= c, swap b and c\n    cmp_bc = b >= c\n    b, c = cmp_bc.if_else(c, b), cmp_bc.if_else(b, c)\n\n    # Third comparison: if a >= b, swap a and b\n    cmp_ab = a >= b\n    a, b = cmp_ab.if_else(b, a), cmp_ab.if_else(a, b)\n\n    return b\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.library import mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Assuming x is a secret fixed-point number\n    x_sfix = sfix(x)\n\n    # Convert boolean indicator to secret integer\n    ind_sint = sint(ind)\n\n    # Compute sine and cosine\n    sin_x = mpc_math.sin(x_sfix)\n    cos_x = mpc_math.cos(x_sfix)\n\n    # Use if_else to select between sin and cos based on ind\n    result = ind_sint.if_else(sin_x, cos_x)\n\n    return result\n", "response_1": "from Compiler.types import sfix, sintbit\nfrom Compiler.library import mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Convert the indicator to a secret bit\n    ind_bit = sintbit(ind)\n    \n    # Calculate sine and cosine\n    sin_x = mpc_math.sin(x)\n    cos_x = mpc_math.cos(x)\n    \n    # Use if_else to select between sine and cosine based on the indicator\n    result = ind_bit.if_else(sin_x, cos_x)\n    \n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "minus2_if_else", "response_0": "from Compiler.types import sint\n\ndef minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    condition = (x - 2) >= 0\n    result = condition.if_else(x - 2, x)\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    x_minus_2 = x - 2\n    condition = x_minus_2 >= 0\n    result = condition.if_else(x_minus_2, x)\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "relu6", "response_0": "from Compiler.types import sfix\n\ndef relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    zero = sfix(0)\n    six = sfix(6)\n\n    # Calculate the maximum between x and 0\n    max_x_zero = x.max(zero)\n\n    # Calculate the minimum between the result and 6\n    result = max_x_zero.min(six)\n\n    return result\n", "response_1": "from Compiler.types import sfix\n\ndef relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    zero = sfix(0)\n    six = sfix(6)\n    \n    # Compute x < 0\n    less_than_zero = x < zero\n    \n    # Compute x > 6\n    greater_than_six = x > six\n    \n    # Compute the result using conditional logic\n    result = less_than_zero.if_else(zero, x)\n    result = greater_than_six.if_else(six, result)\n    \n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exp_slide", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    # Convert x to sfix if it's not already\n    if not isinstance(x, sfix):\n        x = sfix(x)\n\n    # Check if x is nonnegative\n    is_nonnegative = x >= sfix(0)\n\n    # Calculate e^x using mpc_math.exp\n    exp_x = mpc_math.exp(x)\n\n    # Calculate x + 1\n    x_plus_1 = x + sfix(1)\n\n    # Use if_else to select between exp_x and x_plus_1 based on is_nonnegative\n    result = is_nonnegative.if_else(exp_x, x_plus_1)\n\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_then_else\nfrom Compiler.mpc_math import pow_fx\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    e = sfix(math.e)\n    exp_x = pow_fx(e, x)\n    result = if_then_else(x >= 0, exp_x, x + 1)\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "pass_or_not", "response_0": "from Compiler.types import sint, sbitint\n\ndef pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    threshold = sint(60)\n    passed = score >= threshold\n    score = score.if_else(score, sint(59))\n    passed = passed.if_else(sbitint(1), sbitint(0))\n    return score, passed\n", "response_1": "from Compiler.types import sint, sintbit\n\ndef pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Convert score to secret integer if not already\n    score = sint(score)\n    \n    # Check if score is greater than or equal to 60\n    passed = score >= sint(60)\n    \n    # Use if_else to determine the final score\n    final_score = passed.if_else(score, sint(59))\n    \n    return final_score, passed\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef how_many_roots(a, b, c):\n    # Convert inputs to sfix for fixed-point arithmetic\n    a = sfix(a)\n    b = sfix(b)\n    c = sfix(c)\n\n    # Calculate the discriminant\n    discriminant = b * b - 4 * a * c\n\n    # Determine the number of roots based on the discriminant\n    two_roots = (discriminant > 0).bit_and(a != 0)\n    one_root = (discriminant == 0).bit_and(a != 0).bit_or((b != 0).bit_and(a == 0))\n    no_roots = (discriminant < 0).bit_and(a != 0).bit_or((b == 0).bit_and(a == 0))\n\n    # Convert boolean results to sint for counting\n    two_roots_count = two_roots.if_else(sint(2), sint(0))\n    one_root_count = one_root.if_else(sint(1), sint(0))\n    no_roots_count = no_roots.if_else(sint(0), sint(0))\n\n    # Sum up the counts\n    result = two_roots_count + one_root_count + no_roots_count\n\n    return result\n", "response_1": "from Compiler.types import sfix\n\ndef how_many_roots(a, b, c):\n    # Convert inputs to sfix if they are not already\n    a = sfix(a)\n    b = sfix(b)\n    c = sfix(c)\n\n    # Calculate the discriminant\n    discriminant = b * b - 4 * a * c\n\n    # Initialize result as sfix\n    result = sfix(0)\n\n    # Check if a is zero\n    is_a_zero = a == sfix(0)\n    is_b_zero = b == sfix(0)\n\n    # If a is zero, check b\n    result = is_a_zero.if_else(\n        is_b_zero.if_else(sfix(0), sfix(1)), \n        result\n    )\n\n    # Check discriminant\n    is_discriminant_positive = discriminant > sfix(0)\n    is_discriminant_zero = discriminant == sfix(0)\n\n    # Update result based on discriminant\n    result = is_discriminant_positive.if_else(sfix(2), result)\n    result = is_discriminant_zero.if_else(sfix(1), result)\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "elu", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    e = sfix(math.e)  # Define the constant e as a secret fixed-point number\n    one = sfix(1)      # Define 1 as a secret fixed-point number\n\n    # Conditionally return x if x > 0, otherwise return e^x - 1\n    return mpc_math.pow_fx(e, x) - one & (x <= 0) | x & (x > 0)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    e = sfix(2.718281828459045)  # Approximation of e\n    one = sfix(1)\n    \n    # Check if x > 0\n    is_positive = x > 0\n    \n    # Calculate e^x - 1 for x <= 0\n    exp_x_minus_one = mpc_math.pow_fx(e, x) - one\n    \n    # Return x if x > 0, otherwise return e^x - 1\n    return is_positive.if_else(x, exp_x_minus_one)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "relu", "response_0": "from Compiler.types import sint\n\ndef relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    zero = sint(0)\n    return x.if_else(x, zero)\n", "response_1": "from Compiler.types import sint, sfix\n\ndef relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    zero = sint(0)\n    return x.max(zero)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "leaky_relu", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    return if_else(x > 0, x, x * alpha)\n", "response_1": "from Compiler.types import sfix\n\ndef leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    # Convert inputs to sfix if they are not already\n    x = sfix(x) if isinstance(x, (int, float)) else x\n    alpha = sfix(alpha) if isinstance(alpha, (int, float)) else alpha\n\n    # Compute the condition x > 0\n    condition = x > 0\n\n    # Use if_else to select between x and x*alpha based on the condition\n    result = condition.if_else(x, x * alpha)\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "response_1": "from Compiler.types import sfix\n\ndef max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "bowl_shape", "response_0": "from Compiler.types import sint, sbitint\n\ndef bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    one = sint(1)\n    neg_one = sint(-1)\n    \n    # Compute x > 1\n    greater_than_one = x > one\n    \n    # Compute x < -1\n    less_than_neg_one = x < neg_one\n    \n    # Compute x - 1\n    x_minus_one = x - one\n    \n    # Compute -x - 1\n    neg_x_minus_one = -x - one\n    \n    # Use if_else to select the appropriate result\n    result = greater_than_one.if_else(x_minus_one, less_than_neg_one.if_else(neg_x_minus_one, sint(0)))\n    \n    return result\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_then_else\n\ndef bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    one = sfix(1)\n    negative_one = sfix(-1)\n    \n    condition1 = x > one\n    condition2 = x < negative_one\n    \n    result1 = x - one\n    result2 = -x - one\n    result3 = sfix(0)\n    \n    result = if_then_else(condition1, result1, if_then_else(condition2, result2, result3))\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "rounded_kinetic_energy", "response_0": "import Compiler.types\nimport Compiler.library\n\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    # Assuming m and v are of type sfix for secret fixed-point numbers\n    k = m * (v * v) / 2\n    k_int = mpc_math.floor(k)\n    # Compute the fractional part\n    fractional_part = k - k_int\n    # Compare fractional part with 0.5\n    is_greater_or_equal = fractional_part >= 0.5\n    # Use if_else to round correctly\n    result = k_int.if_else(k_int + 1, k_int)\n    return result\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    # Assuming m and v are of type sfix for secret fixed-point numbers\n    k = (m * (v ** 2)) / 2\n    k_int = k.floor()\n    half = sfix(0.5)\n    k_minus_k_int = k - k_int\n    condition = k_minus_k_int < half\n    result = k_int + condition.if_else(sint(1), sint(0))\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "danger_test", "response_0": "from Compiler.types import sint\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    dangerous = health_left <= sint(10)\n    return dangerous\n", "response_1": "from Compiler.types import sfix\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    return health_left <= 10\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "indicated_sum_or_multiply", "response_0": "from Compiler.types import sint, cint, sfix, cfix\n\ndef indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    # Convert indicator to secret integer if it's not already\n    if isinstance(ind, cint):\n        ind = sint(ind)\n    elif isinstance(ind, int):\n        ind = sint(cint(ind))\n    \n    # Compute the sum and product\n    sum_xy = x + y\n    prod_xy = x * y\n    \n    # Use if_else to select between sum and product based on the indicator\n    result = ind.if_else(sum_xy, prod_xy)\n    \n    return result\n", "response_1": "from Compiler.types import sint\n\ndef indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    ind_sint = ind.cast(sint)  # Convert boolean indicator to sint\n    sum_xy = x + y\n    prod_xy = x * y\n    result = ind_sint.if_else(sum_xy, prod_xy)\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "median", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        raise ValueError(\"The length of the array is 0!\")\n\n    arr.sort()\n\n    ret = sint(0)\n    if n % 2:\n        ret = arr[n // 2]\n    else:\n        mid1 = arr[n // 2]\n        mid2 = arr[n // 2 - 1]\n        ret = (mid1 + mid2) / sint(2)\n    \n    return ret\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.sorting import radix_sort\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Convert Python list to MP-SPDZ Array\n    arr = Array.create_from(arr)\n    \n    # Sort the array\n    radix_sort(arr, arr)\n    \n    ret = sint(0)\n    if n % 2:\n        ret = arr[n // 2]\n    else:\n        ret = (arr[n // 2] + arr[n // 2 - 1]) / sint(2)\n    \n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "add_upto_10", "response_0": "from Compiler.types import sint\n\ndef add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    ten = sint(10)\n    clipped_sum = sum_ab.min(ten)\n    return clipped_sum\n", "response_1": "from Compiler.types import sint\n\ndef add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    clip_value = sint(10)\n    is_greater = sum_ab > clip_value\n    result = sum_ab - (sum_ab - clip_value) * is_greater\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "taxi_fare", "response_0": "from Compiler.types import sfix\n\ndef taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 miles.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    base_fare = sfix(5)\n    rate_1 = sfix(1.2)\n    rate_2 = sfix(1.5)\n    five = sfix(5)\n    ten = sfix(10)\n\n    # Calculate fare for m <= 5\n    fare_1 = base_fare\n\n    # Calculate fare for 5 < m <= 10\n    fare_2 = base_fare + rate_1 * (m - five)\n    fare_2 = fare_2 * (m > five).bit_and(m <= ten)\n\n    # Calculate fare for m > 10\n    fare_3 = base_fare + rate_1 * (ten - five) + rate_2 * (m - ten)\n    fare_3 = fare_3 * (m > ten)\n\n    # Combine all fares\n    total_fare = fare_1 + fare_2 + fare_3\n\n    return total_fare\n", "response_1": "from Compiler.types import sfix\n\ndef taxi_fare(m):\n    # Define constants as fixed-point numbers\n    base_fare = sfix(5)\n    rate_1 = sfix(1.2)\n    rate_2 = sfix(1.5)\n    threshold_1 = sfix(5)\n    threshold_2 = sfix(10)\n\n    # Calculate fare for m <= 5\n    fare_1 = base_fare\n\n    # Calculate fare for 5 < m <= 10\n    fare_2 = base_fare + rate_1 * (m - threshold_1)\n\n    # Calculate fare for m > 10\n    fare_3 = base_fare + rate_1 * (threshold_2 - threshold_1) + rate_2 * (m - threshold_2)\n\n    # Use comparisons to determine which fare to return\n    cond1 = m <= threshold_1\n    cond2 = m <= threshold_2\n\n    # Use if_else to select the correct fare\n    fare = cond1.if_else(fare_1, cond2.if_else(fare_2, fare_3))\n\n    return fare\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "round", "response_0": "from Compiler.types import sfix\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x.floor()\n    half = sfix(0.5)\n    condition = (x - x_int) < half\n    return x_int.if_else(x_int, x_int + sfix(1))\n", "response_1": "import Compiler.types\nimport Compiler.library\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = x.floor()\n    half = Compiler.types.sfix(0.5)\n    condition = (x - x_int) < half\n    return x_int.if_else(x_int, x_int + 1)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "gpa_calculator", "response_0": "from Compiler.types import sfix\n\ndef gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    gpa_4_0 = sfix(4.0)\n    gpa_3_6 = sfix(3.6)\n    gpa_3_3 = sfix(3.3)\n    gpa_3_0 = sfix(3.0)\n    gpa_2_6 = sfix(2.6)\n    gpa_2_3 = sfix(2.3)\n\n    ninety = sfix(90)\n    eighty_five = sfix(85)\n    eighty = sfix(80)\n    seventy_five = sfix(75)\n    seventy = sfix(70)\n\n    gpa = gpa_2_3\n\n    gpa = gpa.if_else(gpa_4_0, gpa, score >= ninety)\n    gpa = gpa.if_else(gpa_3_6, gpa, score >= eighty_five)\n    gpa = gpa.if_else(gpa_3_3, gpa, score >= eighty)\n    gpa = gpa.if_else(gpa_3_0, gpa, score >= seventy_five)\n    gpa = gpa.if_else(gpa_2_6, gpa, score >= seventy)\n\n    return gpa\n", "response_1": "from Compiler.types import sfix\n\ndef gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    gpa_4_0 = sfix(4.0)\n    gpa_3_6 = sfix(3.6)\n    gpa_3_3 = sfix(3.3)\n    gpa_3_0 = sfix(3.0)\n    gpa_2_6 = sfix(2.6)\n    gpa_2_3 = sfix(2.3)\n\n    gpa = gpa_2_3\n\n    cond_90 = score >= sfix(90)\n    cond_85 = score >= sfix(85)\n    cond_80 = score >= sfix(80)\n    cond_75 = score >= sfix(75)\n    cond_70 = score >= sfix(70)\n\n    gpa = cond_90.if_else(gpa_4_0, gpa)\n    gpa = cond_85.if_else(gpa_3_6, gpa)\n    gpa = cond_80.if_else(gpa_3_3, gpa)\n    gpa = cond_75.if_else(gpa_3_0, gpa)\n    gpa = cond_70.if_else(gpa_2_6, gpa)\n\n    return gpa\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sign", "response_0": "from Compiler.types import sint\n\ndef sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    neg_one = sint(-1)\n\n    is_zero = x == zero\n    is_positive = x > zero\n\n    result = is_positive.if_else(one, neg_one)\n    result = is_zero.if_else(zero, result)\n\n    return result\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_or_difference", "response_0": "from Compiler.types import sint\n\ndef sum_or_difference(a, b):\n    # Convert inputs to secret integers if they are not already\n    a = sint(a)\n    b = sint(b)\n    \n    # Compute the condition a <= b\n    condition = a <= b\n    \n    # Compute the sum and difference\n    sum_ab = a + b\n    diff_ab = a - b\n    \n    # Use if_else to select between sum and difference based on the condition\n    result = condition.if_else(sum_ab, diff_ab)\n    \n    return result\n", "response_1": "import Compiler.library\n\ndef sum_or_difference(a, b):\n    # Compare a and b\n    condition = a <= b\n\n    # Convert condition to sint for use in arithmetic operations\n    condition_sint = condition.if_else(sint(1), sint(0))\n\n    # Calculate sum and difference\n    sum_ab = a + b\n    diff_ab = a - b\n\n    # Return sum if condition is true, otherwise return difference\n    result = condition_sint * sum_ab + (sint(1) - condition_sint) * diff_ab\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "CNOT", "response_0": "from Compiler.types import sintbit\n\ndef CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit. \n    \"\"\"\n    # Convert inputs to sintbit if they are not already\n    control_bit = sintbit(control_bit)\n    flip_bit = sintbit(flip_bit)\n    \n    # CNOT operation: flip_bit if control_bit is 1, else not flip_bit\n    return control_bit.if_else(flip_bit, flip_bit.bit_not())\n", "response_1": "from Compiler.types import sint\n\ndef CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    # Convert Python bools to sint if necessary\n    control_bit = sint(control_bit)\n    flip_bit = sint(flip_bit)\n    \n    # CNOT logic: flip_bit if control_bit is 1, else not flip_bit\n    result = control_bit.bit_xor(flip_bit)\n    not_flip_bit = flip_bit.bit_not()\n    cnot_result = control_bit.bit_and(result) + control_bit.bit_not().bit_and(not_flip_bit)\n    \n    return cnot_result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "negative_plus1", "response_0": "from Compiler.types import sint\n\ndef negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    is_negative = y < 0\n    return y + 1 * is_negative + y * (1 - is_negative)\n", "response_1": "from Compiler.types import sint\n\ndef negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    is_negative = y < 0\n    one = sint(1)\n    return y + is_negative.if_else(one, sint(0))\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler.types import sint, sbitint\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return (x[0] == y[0]).bit_and(x[1] == y[1])\n\n    # Check if any two points are the same\n    same_ab = same(a, b)\n    same_ac = same(a, c)\n    same_ad = same(a, d)\n    same_bc = same(b, c)\n    same_bd = same(b, d)\n    same_cd = same(c, d)\n\n    any_same = same_ab.bit_or(same_ac).bit_or(same_ad).bit_or(same_bc).bit_or(same_bd).bit_or(same_cd)\n\n    # Check parallelogram conditions\n    cond1 = ((a[0] + b[0] == c[0] + d[0]).bit_and(a[1] + b[1] == c[1] + d[1]))\n    cond2 = ((a[0] + c[0] == b[0] + d[0]).bit_and(a[1] + c[1] == b[1] + d[1]))\n    cond3 = ((a[0] + d[0] == b[0] + c[0]).bit_and(a[1] + d[1] == b[1] + c[1]))\n\n    is_parallelogram = any_same.bit_not().bit_and(cond1.bit_or(cond2).bit_or(cond3))\n\n    return is_parallelogram\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return (x[0] == y[0]).bit_and(x[1] == y[1])\n\n    # Check if any two points are the same\n    if same(a, b).bit_or(same(a, c)).bit_or(same(a, d)).bit_or(same(b, c)).bit_or(same(b, d)).bit_or(same(c, d)):\n        return sbitint(0)\n\n    # Check parallelogram conditions\n    cond1 = (a[0] + b[0] == c[0] + d[0]).bit_and(a[1] + b[1] == c[1] + d[1])\n    cond2 = (a[0] + c[0] == b[0] + d[0]).bit_and(a[1] + c[1] == b[1] + d[1])\n    cond3 = (a[0] + d[0] == b[0] + c[0]).bit_and(a[1] + d[1] == b[1] + c[1])\n\n    return cond1.bit_or(cond2).bit_or(cond3)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "min", "response_0": "from Compiler.types import sint\n\ndef min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "response_1": "import Compiler.types\n\ndef min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "choice_of_the_knight", "response_0": "import Compiler.types\n\ndef choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = Compiler.types.sint(0)\n\n    def legal(a, b):\n        lower_bound = Compiler.types.sint(0)\n        upper_bound = Compiler.types.sint(7)\n        return a.bit_and(a >= lower_bound).bit_and(a <= upper_bound).bit_and(b >= lower_bound).bit_and(b <= upper_bound)\n\n    counter = counter + legal(x + Compiler.types.sint(1), y + Compiler.types.sint(2))\n    counter = counter + legal(x - Compiler.types.sint(1), y + Compiler.types.sint(2))\n    counter = counter + legal(x + Compiler.types.sint(1), y - Compiler.types.sint(2))\n    counter = counter + legal(x - Compiler.types.sint(1), y - Compiler.types.sint(2))\n    counter = counter + legal(x + Compiler.types.sint(2), y + Compiler.types.sint(1))\n    counter = counter + legal(x - Compiler.types.sint(2), y + Compiler.types.sint(1))\n    counter = counter + legal(x + Compiler.types.sint(2), y - Compiler.types.sint(1))\n    counter = counter + legal(x - Compiler.types.sint(2), y - Compiler.types.sint(1))\n\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sint(0)\n\n    def legal(a, b):\n        return (a >= sint(0)) & (a <= sint(7)) & (b >= sint(0)) & (b <= sint(7))\n\n    counter += sint(1) if legal(x + sint(1), y + sint(2)) else sint(0)\n    counter += sint(1) if legal(x - sint(1), y + sint(2)) else sint(0)\n    counter += sint(1) if legal(x + sint(1), y - sint(2)) else sint(0)\n    counter += sint(1) if legal(x - sint(1), y - sint(2)) else sint(0)\n    counter += sint(1) if legal(x + sint(2), y + sint(1)) else sint(0)\n    counter += sint(1) if legal(x - sint(2), y + sint(1)) else sint(0)\n    counter += sint(1) if legal(x + sint(2), y - sint(1)) else sint(0)\n    counter += sint(1) if legal(x - sint(2), y - sint(1)) else sint(0)\n\n    return counter\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "max_sum_difference", "response_0": "from Compiler.types import sfix\n\ndef max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    max_value = sum_ab.max(diff_ab)\n    return max_value\n", "response_1": "from Compiler.types import sfix\n\ndef max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    max_value = sum_ab.if_else(sum_ab, diff_ab)\n    return max_value\n", "model_name": "qwen2.5-coder-32b"}
