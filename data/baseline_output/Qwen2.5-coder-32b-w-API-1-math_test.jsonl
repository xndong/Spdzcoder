{"test_name": "next_integer", "response_0": "from Compiler.types import sfix\n\ndef next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return mpc_math.floor(t) + sfix(1)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    # Assuming t is a secret fixed-point number\n    t_floor = mpc_math.floor(t)\n    next_int = t_floor + cfix(1)\n    return next_int\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "father_and_son", "response_0": "from Compiler.types import sfix\n\ndef father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    # Calculate the difference: father_age - 2 * son_age\n    difference = father_age - (son_age * 2)\n    # Return the absolute value of the difference\n    return difference.abs()\n", "response_1": "from Compiler.types import sfix\n\ndef father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    # Calculate the difference between father_age and twice the son_age\n    difference = father_age - (son_age * 2)\n    # Return the absolute value of the difference\n    return mpc_math.abs(difference)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "triangle_area", "response_0": "", "response_1": "from Compiler.types import sfix\n\ndef triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the size of the triangle.\n    \"\"\"\n    area = (side * height) / sfix(2)\n    return area\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sin_plus_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.mpc_math import sin, cos\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    # Assuming 'a' is a secret fixed-point number\n    a_sfix = sfix(a)\n    return sin(a_sfix) + cos(a_sfix)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a)+cos(a)\n    \"\"\"\n    sin_a = mpc_math.sin(a)\n    cos_a = mpc_math.cos(a)\n    return sin_a + cos_a\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sigmoid", "response_0": "import mpc_math\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    e = mpc_math.e()\n    exp_neg_x = mpc_math.pow_fx(e, -x)\n    return 1 / (1 + exp_neg_x)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    e = sfix(math.e)\n    neg_x = -x\n    exp_neg_x = mpc_math.exp(neg_x)\n    one = sfix(1)\n    return one / (one + exp_neg_x)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "self_exponent", "response_0": "import mpc_math\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return mpc_math.pow_fx(k, k)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    k_fixed = sfix(k)\n    return mpc_math.pow_fx(k_fixed, k_fixed)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "silu", "response_0": "import mpc_math\n\ndef silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    e = mpc_math.e\n    exp_neg_x = mpc_math.pow_fx(e, -x)\n    denominator = 1 + exp_neg_x\n    return x / denominator\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    exp_neg_x = mpc_math.exp(-x)\n    denominator = 1 + exp_neg_x\n    return x / denominator\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "Gaussian_bracket", "response_0": "from Compiler.types import sfix\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = x.floor()\n    return x - x_int\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = mpc_math.floor(x)\n    return x - x_int\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "asin_and_square", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef asin_and_square(x):\n    # Convert input to secret fixed-point number if not already\n    if not isinstance(x, sfix):\n        x = sfix(x)\n    \n    # Compute arcsin\n    asin_x = mpc_math.asin(x)\n    \n    # Compute square of arcsin\n    result = mpc_math.pow_fx(asin_x, 2)\n    \n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome. \n    \"\"\"\n    # Convert input to secret fixed-point number if it's not already\n    if not isinstance(x, sfix):\n        x = sfix(x)\n    \n    # Compute arcsin\n    asin_x = mpc_math.asin(x)\n    \n    # Compute square of arcsin\n    result = asin_x * asin_x\n    \n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "cylinder_surface", "response_0": "import mpc_math\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area. \n    \"\"\"\n    pi = mpc_math.pi\n    return 2 * pi * (r ** 2) + 2 * pi * r * h\n", "response_1": "from Compiler.types import sfix, cfix\nfrom Compiler.library import mpc_math\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area. \n    \"\"\"\n    pi = cfix(3.141592653589793)  # Using a fixed-point representation of pi\n    two = cfix(2)\n    \n    r_squared = r * r\n    two_pi = two * pi\n    two_pi_r_squared = two_pi * r_squared\n    two_pi_r_h = two_pi * r * h\n    \n    surface_area = two_pi_r_squared + two_pi_r_h\n    return surface_area\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "radian_to_degree", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    pi = sfix(math.pi)\n    factor = sfix(180) / pi\n    return r * factor\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    pi = sfix(mpc_math.pi)\n    return r / pi * 180\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "square_root", "response_0": "from Compiler.types import sfix\nfrom Compiler.mpc_math import sqrt\n\ndef square_root(a):\n    \"\"\"\n    Return the square root of the input.\n    \"\"\"\n    # Assuming 'a' is a secret fixed-point number\n    a_fixed = sfix(a)\n    return sqrt(a_fixed)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef square_root(a):\n    \"\"\"\n    return the square root of the input. \n    \"\"\"\n    # Assuming 'a' is a secret fixed-point number\n    a_sfix = sfix(a)\n    return mpc_math.sqrt(a_sfix)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "cosine_theorem", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    a_squared = a * a\n    b_squared = b * b\n    two_ab = 2 * a * b\n    cos_rad = mpc_math.cos(rad)\n    term = a_squared + b_squared - two_ab * cos_rad\n    return mpc_math.sqrt(term)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    a_squared = a * a\n    b_squared = b * b\n    two_ab = 2 * a * b\n    cos_rad = mpc_math.cos(rad)\n    term = a_squared + b_squared - two_ab * cos_rad\n    return mpc_math.sqrt(term)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "lights_states", "response_0": "from Compiler.types import sint, cint, sfix, cfix\nfrom Compiler.library import mpc_math\n\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    # Convert the input to a secret fixed-point number\n    num_sfix = sfix(num)\n    # Compute 2^num using the mpc_math.pow_fx function\n    total_states = mpc_math.pow_fx(sfix(2), num_sfix)\n    return total_states\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    # Convert num to sfix type\n    num_sfix = sfix(num)\n    # Use mpc_math.pow_fx to compute 2^num\n    return mpc_math.pow_fx(sfix(2), num_sfix)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "degree_to_radian", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return d / 180 * pi\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import pi\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    # Convert degree to radian using the formula: radian = degree * (pi / 180)\n    radian = d * (pi / sfix(180))\n    return radian\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "Fah_to_Cel", "response_0": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    # Convert F to sfix if it's not already\n    if not isinstance(F, sfix):\n        F = sfix(F)\n    \n    # Define the constants as sfix\n    thirty_two = sfix(32)\n    one_point_eight = sfix(1.8)\n    \n    # Perform the conversion\n    C = (F - thirty_two) / one_point_eight\n    \n    return C\n", "response_1": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    # Convert input to sfix for fixed-point arithmetic\n    F_sfix = sfix(F)\n    # Perform the conversion using fixed-point arithmetic\n    C_sfix = (F_sfix - sfix(32)) / sfix(1.8)\n    return C_sfix\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "elliptic_area", "response_0": "import Compiler.types\nimport Compiler.library\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area. \n    \"\"\"\n    pi = Compiler.types.sfix(3.141592653589793)\n    area = pi * a * b\n    return area\n", "response_1": "from Compiler.types import sfix, cfix\nimport Compiler.mpc_math\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the ellipse, return its area.\n    \"\"\"\n    # Define the value of pi as a clear fixed-point number\n    pi = cfix(3.141592653589793)\n    \n    # Calculate the area of the ellipse\n    area = pi * a * b\n    \n    return area\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "floor", "response_0": "from Compiler.types import sfix, cfix\n\ndef floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Assuming z is a secret fixed-point number (sfix)\n    # Convert to integer by truncating the fractional part\n    return z >> sfix.f\n", "response_1": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # In MP-SPDZ, we need to use a different approach since there is no direct floor function.\n    # We can use the fact that floor(z) = z - (z % 1) for positive numbers.\n    # For secret fixed-point numbers, we need to handle the fractional part.\n    # Assuming z is a secret fixed-point number (sfix).\n    one = sfix(1)\n    fractional_part = z % one\n    result = z - fractional_part\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "log_and_cube", "response_0": "import mpc_math\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    log_base_2_x = mpc_math.log_fx(x, 2)\n    result = mpc_math.pow_fx(log_base_2_x, 3)\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    log_x_base_2 = mpc_math.log_fx(x, sfix(2))\n    result = mpc_math.pow_fx(log_x_base_2, sfix(3))\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "floor_and_square", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import tree_reduce\n\ndef floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    # Assuming z is a secret fixed-point number\n    # Convert z to an integer by flooring\n    z_floor = z.cast(sint)\n    \n    # Square the floored integer\n    result = z_floor * z_floor\n    \n    return result\n", "response_1": "from Compiler.types import sfix\n\ndef floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    # Assuming z is a secret fixed-point number\n    floor_z = z.floor()\n    result = floor_z * floor_z\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "meters_to_feet", "response_0": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    conversion_factor = sfix(3.2808)\n    return m * conversion_factor\n", "response_1": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    conversion_factor = sfix(3.2808)\n    return m * conversion_factor\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sphere_area", "response_0": "from Compiler.types import sfix, cfix\nfrom Compiler.library import mpc_math\n\ndef sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    pi = cfix(3.141592653589793)  # Using a fixed-point representation for pi\n    four = cfix(4)\n    area = four * pi * mpc_math.pow_fx(r, 2)\n    return area\n", "response_1": "from Compiler.types import sfix, cfix\nfrom Compiler.library import mpc_math\n\ndef sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    pi = cfix(3.141592653589793)  # Define pi as a clear fixed-point number\n    four = cfix(4)  # Define 4 as a clear fixed-point number\n    r_squared = r * r  # Square the radius\n    area = four * pi * r_squared  # Calculate the area\n    return area\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "coarse_abs", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = mpc_math.abs(x)\n    floor_abs_x = mpc_math.floor(abs_x)\n    return floor_abs_x\n", "response_1": "from Compiler.types import sfix, sint\n\ndef coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = x.abs()\n    floor_abs_x = abs_x.floor()\n    return floor_abs_x\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "how_many_chickens", "response_0": "from Compiler.types import sint\n\ndef how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    two = sint(2)\n    heads_times_two = heads * two\n    legs_minus_heads_times_two = legs - heads_times_two\n    result = heads - (legs_minus_heads_times_two // two)\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    two = sint(2)\n    return heads - (legs - heads * two) // two\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "interest_calculator", "response_0": "from Compiler.types import sfix\n\ndef interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get. \n    \"\"\"\n    one = sfix(1)\n    ratio_plus_one = one + ratio\n    power_result = mpc_math.pow_fx(ratio_plus_one, months)\n    interest = (power_result - one) * capital\n    return interest\n", "response_1": "from Compiler.types import sfix\n\ndef interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get. \n    \"\"\"\n    one = sfix(1)\n    base = one + ratio\n    power_result = mpc_math.pow_fx(base, months)\n    interest = power_result - one\n    return interest * capital\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "circle_area", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = sfix(3.141592653589793)  # Approximation of pi\n    area = pi * (r ** 2)\n    return area\n", "response_1": "from Compiler.types import sfix\nimport Compiler.mpc_math\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = sfix(3.141592653589793)  # Approximation of pi\n    area = pi * r * r\n    return area\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler.types import sfix\nfrom Compiler.mpc_math import pow_fx, sqrt\n\ndef cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    x_sfix = sfix(x)\n    cubed = pow_fx(x_sfix, 3)\n    result = sqrt(cubed)\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    x_cubed = mpc_math.pow_fx(x, 3)\n    result = mpc_math.sqrt(x_cubed)\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "round", "response_0": "import mpc_math\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = mpc_math.floor(x)\n    half = sfix(0.5)\n    condition = (x - x_int) < half\n    return x_int.if_else(x_int, x_int + sfix(1))\n", "response_1": "from Compiler.types import sfix\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = x.floor()\n    half = sfix(0.5)\n    condition = x - x_int < half\n    return x_int.if_else(x_int, x_int + sfix(1))\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "cryptic_adjustment", "response_0": "import mpc_math\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor want to adjust the pessimistic score of his students mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    inner_sqrt = mpc_math.sqrt(origin * 10)\n    return 10 * mpc_math.sqrt(inner_sqrt * 10)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor want to adjust the pessimistic score of his students mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    # Convert the input to a secret fixed-point number\n    origin_sfix = sfix(origin)\n    \n    # Calculate the inner square root\n    inner_sqrt = mpc_math.sqrt(origin_sfix * 10)\n    \n    # Calculate the outer square root and multiply by 10\n    result = 10 * mpc_math.sqrt(inner_sqrt * 10)\n    \n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "specific_pow", "response_0": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5).\n    \"\"\"\n    # Convert x to sfix if it's not already\n    x_fixed = sfix(x) if isinstance(x, sfix) else sfix(int(x * (2 ** sfix.f)) / (2 ** sfix.f))\n    # Calculate x^(2.5) using mpc_math.pow_fx\n    result = mpc_math.pow_fx(x_fixed, sfix(2.5))\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5).\n    \"\"\"\n    # Convert x to sfix if it is not already\n    x_fixed = sfix(x) if isinstance(x, sfix) else sfix.load_int(x)\n    \n    # Use mpc_math.pow_fx for power operation\n    result = mpc_math.pow_fx(x_fixed, sfix(2.5))\n    \n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "soft_plus", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    e = sfix(2.718281828459045)  # Approximation of e\n    exp_x = mpc_math.pow_fx(e, x)\n    return mpc_math.log_fx(exp_x + 1, e)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    one = sfix(1)\n    exp_x = mpc_math.pow_fx(sfix(math.e), x)\n    return mpc_math.log_fx(one + exp_x, sfix(math.e))\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "ball_volume", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    four_thirds = sfix(4) / sfix(3)\n    volume = pi * (mpc_math.pow_fx(r, sfix(3))) * four_thirds\n    return volume\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    four_thirds = sfix(4.0 / 3.0)\n    volume = pi * mpc_math.pow_fx(r, 3) * four_thirds\n    return volume\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "Heron", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    area_squared = p * (p - a) * (p - b) * (p - c)\n    return mpc_math.sqrt(area_squared)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    return mpc_math.sqrt(p * (p - a) * (p - b) * (p - c))\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "next_perfect_square", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import mpc_math\n\ndef next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    # Convert x to a secret fixed-point number\n    x_sfix = sfix(x)\n    \n    # Compute the square root of x\n    sqrt_x = mpc_math.sqrt(x_sfix)\n    \n    # Floor the square root and add 1\n    next_int = sint(sqrt_x) + 1\n    \n    # Compute the next perfect square\n    next_square = next_int * next_int\n    \n    return next_square\n", "response_1": "import mpc_math\n\ndef next_perfect_square(x):\n    sqrt_x = mpc_math.sqrt(x)\n    floor_sqrt_x = sqrt_x.floor()\n    next_int = floor_sqrt_x + 1\n    return next_int * next_int\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "pi_to_the_x", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return mpc_math.pow_fx(pi, x)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    pi = sfix(math.pi)\n    return mpc_math.pow_fx(pi, x)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "spring_rocket", "response_0": "from Compiler.types import sfix\nfrom Compiler.mpc_math import sqrt\n\ndef spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = sfix(9.8)\n    return sqrt(2 * m * g * height / k)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef spring_rocket(height, m, k):\n    g = sfix(9.8)\n    return mpc_math.sqrt(2 * m * g * height / k)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "cone_volume", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = sfix(3.141592653589793)  # Approximation of pi\n    volume = pi * r * r * h / sfix(3)\n    return volume\n", "response_1": "from Compiler.types import sfix\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return pi * r * r * h / 3\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "how_many_rabbits", "response_0": "import Compiler.types\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    two = sint(2)\n    heads_times_two = heads * two\n    legs_minus_heads_times_two = legs - heads_times_two\n    rabbits = legs_minus_heads_times_two // two\n    return rabbits\n", "response_1": "from Compiler.types import sint\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    heads_times_two = heads * sint(2)\n    legs_minus_heads_times_two = legs - heads_times_two\n    rabbits = legs_minus_heads_times_two // sint(2)\n    return rabbits\n", "model_name": "qwen2.5-coder-32b"}
