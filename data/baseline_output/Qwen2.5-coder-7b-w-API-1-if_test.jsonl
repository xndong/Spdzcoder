{"test_name": "sin_or_cos", "response_0": "from Compiler import mpc_math\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    if x >= 0:\n        return mpc_math.sin(x)\n    return mpc_math.cos(x)\n", "response_1": "import Compiler.types as T\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    if x >= 0:\n        return T.mpc_math.sin(x)\n    return T.mpc_math.cos(x)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "negative_relu", "response_0": "from Compiler import mpc_math\n\ndef negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise retrun 0.\n    \"\"\"\n    return input.bit_and(input < 0)\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise retrun 0.\n    \"\"\"\n    return input.bit_and(input.bit_xor(0))  # This is equivalent to input if input < 0, otherwise 0\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close: \n    their absolute difference is no larger than 1.\n    \"\"\"\n    return a.bit_and(b.bit_and((a - b).abs() <= 1))\n", "response_1": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close: \n    their absolute difference is no larger than 1. \n    \"\"\"\n    return a.bit_and(b).if_else(1, 0) == 1\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "hardswish", "response_0": "import Compiler.types as T\n\ndef hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    # Convert input to sfix for fixed-point arithmetic\n    x = T.sfix(x)\n    \n    # Define constants for the hardswish function\n    zero = T.sfix(0)\n    three = T.sfix(3)\n    \n    # Conditional logic for hardswish function\n    x_neg3 = x.bit_and(x < -three)\n    x_3 = x.bit_and(x > three)\n    \n    # Apply the hardswish function\n    result = x_neg3.if_else(zero, x_3.if_else(x, x * (x + three) / 6))\n    \n    return result\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    x = x.max(0)  # Equivalent to max(x, 0)\n    x = x.min(3)  # Equivalent to min(x, 3)\n    return x * (x + 3) // 6\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    x = x.max(-6)\n    x = x.min(6)\n    return x\n", "response_1": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    lower_bound = -6\n    upper_bound = 6\n    return x.max(lower_bound).min(upper_bound)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "piecewise_function", "response_0": "from Compiler import mpc_math\n\ndef piecewise_function(x):\n    ret = x.if_else(x.bit_and(x > 1), x)\n    ret = ret.if_else(x.bit_and(x < -1), x, ret)\n    ret = ret.if_else(x.bit_and(x > 0), 1, ret)\n    ret = ret.if_else(x.bit_and(x < 0), -1, ret)\n    ret = ret.if_else(x.bit_and(x == 0), 0, ret)\n    return ret\n", "response_1": "import Compiler.types as T\n\ndef piecewise_function(x):\n    ret = T.sint(0)\n    if x > 1:\n        ret = x\n    elif x < -1:\n        ret = x\n    elif x > 0:\n        ret = T.sint(1)\n    elif x < 0:\n        ret = T.sint(-1)\n    else:\n        ret = T.sint(0)\n    return ret\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    a = a.max(b)\n    c = c.min(b)\n    a = a.min(c)\n    return b\n", "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    if a >= b:\n        a, b = b, a\n    if b >= c:\n        b, c = c, b\n    if a >= b:\n        a, b = b, a\n    return b\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler import mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    if ind:\n        return mpc_math.sin(x)\n    return mpc_math.cos(x)\n", "response_1": "def indicated_sin_or_cos(x, ind):\n    if ind:\n        return mpc_math.sin(x)\n    else:\n        return mpc_math.cos(x)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "minus2_if_else", "response_0": "from Compiler.types import sint\n\ndef minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    return x.bit_and(x-2) + x.bit_and((x-2).bit_not())\n", "response_1": "def minus2_if_else(x):\n    return x - 2 if x - 2 >= 0 else x\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    return x.bit_and(6)\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    return x.max(0).min(6)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "exp_slide", "response_0": "import Compiler.types as T\n\ndef exp_slide(x):\n    if x >= 0:\n        return T.mpc_math.pow(T.sint.get_random(0, 2), x)\n    return x + 1\n", "response_1": "from Compiler import mpc_math\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    if x >= 0:\n        return mpc_math.pow_fx(x, 1)\n    return x + 1\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "pass_or_not", "response_0": "def pass_or_not(score):\n    score = mpc_math.if_else(score >= 60, score, 59)\n    passed = mpc_math.if_else(score >= 60, True, False)\n    return score, passed\n", "response_1": "from Compiler import *\n\ndef pass_or_not(score):\n    score = score if score >= 60 else 59.sint()\n    passed = (score >= 60).if_else(True, False)\n    return score, passed\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "how_many_roots", "response_0": "import Compiler.types as types\n\ndef how_many_roots(a, b, c):\n    discriminant = b.sq() - 4 * a * c\n    if a == 0:\n        if b == 0:\n            return types.sint(0)\n        else:\n            return types.sint(1)\n    if discriminant > 0:\n        return types.sint(2)\n    elif discriminant == 0:\n        return types.sint(1)\n    else:\n        return types.sint(0)\n", "response_1": "from Compiler import mpc_math, sint\n\ndef how_many_roots(a, b, c):\n    discriminant = mpc_math.pow_fx(b, 2) - mpc_math.mul_fx(mpc_math.mul_fx(4, a), c)\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    elif discriminant > 0:\n        return 2\n    elif discriminant == 0:\n        return 1\n    else:\n        return 0\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "elu", "response_0": "def elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    if x > 0:\n        return x\n    else:\n        return mpc_math.pow_fx(math.e, x) - 1\n", "response_1": "import mpc_math\n\ndef elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    if x > 0:\n        return x\n    else:\n        return mpc_math.exp(x) - 1\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return x.max(0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return x.max(0)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "leaky_relu", "response_0": "from Compiler import mpc_math\n\ndef leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    return x.if_else(x, x * alpha)\n", "response_1": "import Compiler.types as T\n\ndef leaky_relu(x: T.sfix, alpha: T.sfix) -> T.sfix:\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    return x.max(x * alpha)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "bowl_shape", "response_0": "from Compiler import Compiler\n\ndef bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    return x.bit_and((x - 1) * Compiler.sint(1).bit_and(x > 1)) + \\\n           (-x).bit_and((-x - 1) * Compiler.sint(1).bit_and(x < -1)) + \\\n           (1 - x.bit_and(x > 1)).bit_and(x.bit_and(x < -1))\n", "response_1": "def bowl_shape(x):\n    return x.bit_and(x.bit_not()).if_else(x.bit_and(x-1), x.bit_and(-x-1), 0)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "rounded_kinetic_energy", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import sint\n\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    k = m * v * v / 2\n    k_int = mpc_math.floor(k)\n    return k_int.bit_and(k_int + mpc_math.bit_and(k - k_int, 1))\n", "response_1": "import Compiler.types as ct\n\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    k = m * ct.mpc_math.pow_fx(v, 2) / 2\n    k_int = ct.sint.get_random_bit()  # Placeholder for integer conversion and rounding logic\n    return k_int if (k - k_int) < 0.5 else k_int + 1\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "danger_test", "response_0": "from Compiler import mpc_math\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return origin - damage <= 10\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sint\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return origin - damage <= 10\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "indicated_sum_or_multiply", "response_0": "from Compiler.types import sint\n\ndef indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    return x + y if ind else x * y\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    return ind.if_else(x + y, x * y)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "median", "response_0": "from Compiler import mpc_math, Compiler\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if arr.length == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    arr.sort()\n    \n    if arr.length % 2:\n        ret = arr[arr.length // 2]\n    else:\n        ret = (arr[arr.length // 2] + arr[arr.length // 2 - 1]) / 2\n    \n    return ret\n", "response_1": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if arr.len() == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    arr.sort()\n    \n    ret = arr[0]\n    if arr.len() % 2 == 1: \n        ret = arr[arr.len() // 2]\n    else:\n        ret = (arr[arr.len() // 2] + arr[arr.len() // 2 - 1]) / 2\n    \n    return ret\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "add_upto_10", "response_0": "from Compiler import mpc_math, sint\n\ndef add_upto_10(a, b):\n    sum = a + b\n    return mpc_math.min(sum, 10)\n", "response_1": "def add_upto_10(a, b):\n    result = a + b\n    return result.if_else(result, 10).bit_and(result > 10)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "taxi_fare", "response_0": "from Compiler import mpc_math, sint\n\ndef taxi_fare(m):\n    base_fare = sint(5)\n    fare_5_to_10 = sint(1.2) * (sint(10) - sint(5))\n    fare_above_10 = sint(1.5) * (m - sint(10))\n\n    fare_5_to_10_condition = m.bit_and(m >= sint(5)) & (m <= sint(10))\n    fare_above_10_condition = m.bit_and(m > sint(10))\n\n    fare = base_fare + fare_5_to_10 * fare_5_to_10_condition + fare_above_10 * fare_above_10_condition\n    return fare\n", "response_1": "from Compiler import mpc_math\n\ndef taxi_fare(m):\n    base_fare = 5\n    fare_per_mile_5_to_10 = 1.2\n    fare_per_mile_above_10 = 1.5\n\n    if m <= 5:\n        return base_fare\n    elif 5 <= m <= 10:\n        return base_fare + fare_per_mile_5_to_10 * (m - 5)\n    else:\n        return base_fare + fare_per_mile_5_to_10 * 5 + fare_per_mile_above_10 * (m - 10)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = mpc_math.floor(x)\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x.floor()\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "gpa_calculator", "response_0": "from Compiler import mpc_math, sint\n\ndef gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    if score >= 90:\n        return 4.0\n    elif score >= 85:\n        return 3.6\n    elif score >= 80:\n        return 3.3\n    elif score >= 75:\n        return 3.0\n    elif score >= 70:\n        return 2.6\n    else:\n        return 2.3\n", "response_1": "from Compiler.types import sint\n\ndef gpa_calculator(score):\n    if score >= 90:\n        return sint(4.0)\n    elif score >= 85:\n        return sint(3.6)\n    elif score >= 80:\n        return sint(3.3)\n    elif score >= 75:\n        return sint(3.0)\n    elif score >= 70:\n        return sint(2.6)\n    else:\n        return sint(2.3)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "sign", "response_0": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    return x.bit_and(x.bit_not()).if_else(0, x.bit_and(1).if_else(1, -1))\n", "response_1": "from Compiler import types as T\n\ndef sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    return T.sint.get_random_bit() - T.sint.get_random_bit() if x == 0 else T.sint.get_random_bit() * 2 - 1\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    return a + b if a.bit_and(b - a) == 0 else a - b\n", "response_1": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    return a + b if a <= b else a - b\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    return control_bit.bit_and(flip_bit.bit_not())\n", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit. \n    \"\"\"\n    return control_bit.bit_and(flip_bit.bit_not()) | flip_bit.bit_and(control_bit.bit_not())\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    return y + (y < 0).if_else(1, 0)\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    return y.if_else(y + 1, y)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler.types import sint\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n    \n    return (a[0] + b[0] == c[0] + d[0] and a[1] + b[1] == c[1] + d[1]) or \\\n           (a[0] + c[0] == b[0] + d[0] and a[1] + c[1] == b[1] + d[1]) or \\\n           (a[0] + d[0] == b[0] + c[0] and a[1] + d[1] == b[1] + c[1])\n", "response_1": "from Compiler import mpc_math\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n\n    return (a[0] + b[0] == c[0] + d[0] and a[1] + b[1] == c[1] + d[1]) or \\\n           (a[0] + c[0] == b[0] + d[0] and a[1] + c[1] == b[1] + d[1]) or \\\n           (a[0] + d[0] == b[0] + c[0] and a[1] + d[1] == b[1] + c[1])\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "choice_of_the_knight", "response_0": "from Compiler.types import sint\n\ndef choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sint(0)\n    def legal(a, b):\n        return 0 <= a <= 7 and 0 <= b <= 7\n    counter = counter + sint(1).if_else(legal(x + 1, y + 2), counter)\n    counter = counter + sint(1).if_else(legal(x - 1, y + 2), counter)\n    counter = counter + sint(1).if_else(legal(x + 1, y - 2), counter)\n    counter = counter + sint(1).if_else(legal(x - 1, y - 2), counter)\n    counter = counter + sint(1).if_else(legal(x + 2, y + 1), counter)\n    counter = counter + sint(1).if_else(legal(x - 2, y + 1), counter)\n    counter = counter + sint(1).if_else(legal(x + 2, y - 1), counter)\n    counter = counter + sint(1).if_else(legal(x - 2, y - 1), counter)\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sint(0)\n    \n    def legal(a, b):\n        return 0 <= a <= 7 and 0 <= b <= 7\n    \n    counter = counter + (sint(1) if legal(x + 1, y + 2) else sint(0))\n    counter = counter + (sint(1) if legal(x - 1, y + 2) else sint(0))\n    counter = counter + (sint(1) if legal(x + 1, y - 2) else sint(0))\n    counter = counter + (sint(1) if legal(x - 1, y - 2) else sint(0))\n    counter = counter + (sint(1) if legal(x + 2, y + 1) else sint(0))\n    counter = counter + (sint(1) if legal(x - 2, y + 1) else sint(0))\n    counter = counter + (sint(1) if legal(x + 2, y - 1) else sint(0))\n    counter = counter + (sint(1) if legal(x - 2, y - 1) else sint(0))\n    \n    return counter\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    # Calculate a + b and a - b\n    sum_ab = a + b\n    diff_ab = a - b\n    \n    # Use the if_else function to select the maximum value\n    return sum_ab.if_else(sum_ab > diff_ab, sum_ab, diff_ab)\n", "response_1": "def max_sum_different(a, b):\n    return a + b if a + b > a - b else a - b\n", "model_name": "qwen2.5-coder-7b"}
