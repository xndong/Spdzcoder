{"test_name": "next_integer", "response_0": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return t.floor() + 1\n", "response_1": "def next_integer(t):\n    return mpc_math.floor(t) + 1\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "father_and_son", "response_0": "from Compiler import mpc_math\n\ndef father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    return mpc_math.abs(father_age - son_age * 2)\n", "response_1": "def father_and_son(father_age, son_age):\n    father_age = father_age.sint()\n    son_age = son_age.sint()\n    diff = father_age - son_age * 2\n    return diff.abs()\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "triangle_area", "response_0": "def triangle_area(side, height):\n    return (side * height) / 2\n", "response_1": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the size of the triangle. \n    \"\"\"\n    return side * height // 2\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "sin_plus_cos", "response_0": "import mpc_math\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    return mpc_math.sin(a) + mpc_math.cos(a)\n", "response_1": "import Compiler.types as T\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    return T.mpc_math.sin(a) + T.mpc_math.cos(a)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "sigmoid", "response_0": "from Compiler import mpc_math\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    return 1 / (1 + mpc_math.pow_fx(mpc_math.exp(x), -1))\n", "response_1": "from Compiler.types import sfix\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    return 1 / (1 + sfix.exp(-x))\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "self_exponent", "response_0": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return mpc_math.pow_fx(k, k)\n", "response_1": "from Compiler.types import sint\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return sint(k).pow(k)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "silu", "response_0": "def silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    e_pow_neg_x = mpc_math.pow_fx(math.e, -x)\n    one_plus_e_pow_neg_x = 1 + e_pow_neg_x\n    return x / one_plus_e_pow_neg_x\n", "response_1": "from Compiler import mpc_math\n\ndef silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    return x / (1 + mpc_math.pow_fx(mpc_math.exp(x), -1))\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "Gaussian_bracket", "response_0": "from Compiler import mpc_math\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = mpc_math.floor(x)\n    return x - x_int\n", "response_1": "from Compiler import mpc_math\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = mpc_math.floor(x)\n    return x - x_int\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "asin_and_square", "response_0": "import Compiler.types as ct\nimport mpc_math\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome. \n    \"\"\"\n    return mpc_math.pow_fx(mpc_math.asin(x), 2)\n", "response_1": "import mpc_math\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome. \n    \"\"\"\n    return mpc_math.pow_fx(mpc_math.asin(x), 2)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "cylinder_surface", "response_0": "import Compiler.types as T\nimport Compiler.library as lib\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area. \n    \"\"\"\n    pi = T.sint.get_random_bit(1).if_else(3, 2)\n    return 2 * pi * r * r + 2 * pi * r * h\n", "response_1": "from Compiler import mpc_math\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area. \n    \"\"\"\n    pi = 3.141592653589793\n    return 2 * pi * r**2 + 2 * pi * r * h\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "radian_to_degree", "response_0": "from Compiler.types import sint\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    return r / sint.pi * 180\n", "response_1": "import Compiler.types as types\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    return r / types.sfix.get_random(lower=math.pi, upper=math.pi) * 180\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "square_root", "response_0": "from Compiler.types import sint\nfrom Compiler.mpc_math import sqrt\n\ndef square_root(a):\n    \"\"\"\n    return the square root of the input. \n    \"\"\"\n    return sqrt(a)\n", "response_1": "def square_root(a):\n    \"\"\"\n    return the square root of the input. \n    \"\"\"\n    return mpc_math.sqrt(a)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "cosine_theorem", "response_0": "from Compiler.types import sfix\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    return sfix.sqrt(a**2 + b**2 - 2 * a * b * sfix.cos(rad))\n", "response_1": "def cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    # Import the necessary MP-SPDZ module\n    from Compiler import mpc_math\n\n    # Compute the cosine of the angle\n    cos_rad = mpc_math.cos(rad)\n\n    # Compute the third edge using the cosine theorem\n    c_squared = a**2 + b**2 - 2 * a * b * cos_rad\n    c = mpc_math.sqrt(c_squared)\n\n    return c\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "lights_states", "response_0": "import mpc_math\n\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return mpc_math.pow(2, num)\n", "response_1": "from Compiler.types import sint\n\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return sint.exp2(num)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "degree_to_radian", "response_0": "import mpc_math\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    return d / 180 * mpc_math.pi\n", "response_1": "def degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    return d / 180 * mpc_math.pi\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "Fah_to_Cel", "response_0": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - 32) / 1.8\n", "response_1": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - 32) / 1.8\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "elliptic_area", "response_0": "from Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area. \n    \"\"\"\n    pi = sfix.get_random(3.141592653589793, 3.141592653589793)\n    return pi * a * b\n", "response_1": "from Compiler import mpc_math\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area. \n    \"\"\"\n    pi = mpc_math.pi\n    return pi * a * b\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "floor", "response_0": "import Compiler.types as ct\n\ndef floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    return ct.sint.floor(z)\n", "response_1": "from Compiler import mpc_math\n\ndef floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    return mpc_math.floor(z)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "log_and_cube", "response_0": "def log_and_cube(x):\n    # Convert input to sfix to support non-linear operations\n    x_sfix = sfix(x)\n    # Compute log base 2 using the MP-SPDZ function\n    log_result = mpc_math.log_fx(x_sfix, 2)\n    # Compute cube using element-wise multiplication\n    cube_result = log_result * log_result * log_result\n    return cube_result\n", "response_1": "from Compiler import mpc_math\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    return mpc_math.pow_fx(mpc_math.log_fx(x, 2), 3)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "floor_and_square", "response_0": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    return mpc_math.floor(z)**2\n", "response_1": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    return mpc_math.floor(z) * mpc_math.floor(z)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "meters_to_feet", "response_0": "import Compiler.types as T\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * 3.2808\n", "response_1": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * 3.2808\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "sphere_area", "response_0": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    import mpc_math\n    return 4 * mpc_math.pi * r ** 2\n", "response_1": "from Compiler import mpc_math\n\ndef sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    return 4 * mpc_math.pi * r * r\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "coarse_abs", "response_0": "from Compiler import mpc_math\n\ndef coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    return mpc_math.floor(mpc_math.abs(x))\n", "response_1": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = x.abs()\n    return abs_x.floor()\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "how_many_chickens", "response_0": "from Compiler import mpc_math, sint\n\ndef how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - (legs - heads * 2) // 2\n", "response_1": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - (legs - heads * 2) // 2\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "interest_calculator", "response_0": "from Compiler import mpc_math\n\ndef interest_calculator(capital, ratio, months):\n    interest = (mpc_math.pow_fx(1 + ratio, months) - 1) * capital\n    return interest\n", "response_1": "from Compiler import mpc_math\n\ndef interest_calculator(capital, ratio, months):\n    return (mpc_math.pow_fx(1 + ratio, months) - 1) * capital\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "circle_area", "response_0": "import Compiler.types as t\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    return t.mpc_math.pi * r * r\n", "response_1": "from Compiler.types import sfix\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = sfix.get_random(lower=3.14, upper=3.15)  # Approximate value of pi\n    return pi * r * r\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "cube_and_square_root", "response_0": "import Compiler.types as T\n\ndef cube_and_square_root(x):\n    # Compute the cube of the input\n    cube = x * x * x\n    # Compute the square root of the cube\n    sqrt_cube = T.mpc_math.sqrt(cube)\n    return sqrt_cube\n", "response_1": "import Compiler.types as T\n\ndef cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    return T.mpc_math.sqrt(T.mpc_math.pow_fx(x, 3))\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = mpc_math.floor(x)\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x.floor()\n    return x_int + (x - x_int).bit_and(1)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "cryptic_adjustment", "response_0": "from Compiler import mpc_math\n\ndef cryptic_adjustment(origin):\n    # Calculate the innermost square root\n    inner_sqrt = mpc_math.sqrt(origin)\n    # Calculate the next square root\n    next_sqrt = mpc_math.sqrt(10 * inner_sqrt)\n    # Calculate the final result\n    result = 10 * mpc_math.sqrt(10 * next_sqrt)\n    return result\n", "response_1": "from Compiler import mpc_math, sint\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor want to adjust the pessimistic score of his students mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    return 10 * mpc_math.sqrt(10 * mpc_math.sqrt(origin))\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "specific_pow", "response_0": "def specific_pow(x):\n    return mpc_math.pow_fx(x, 2.5)\n", "response_1": "import mpc_math\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5).\n    \"\"\"\n    return mpc_math.pow_fx(x, 2.5)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "soft_plus", "response_0": "def soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    e_x = mpc_math.exp(x)\n    return mpc_math.log(1 + e_x, mpc_math.e)\n", "response_1": "import mpc_math\n\ndef soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    return mpc_math.log_fx(1 + mpc_math.pow_fx(mpc_math.exp(1), x), mpc_math.exp(1))\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "ball_volume", "response_0": "import mpc_math\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    return mpc_math.pi*r**3*4//3\n", "response_1": "import mpc_math\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    pi = mpc_math.pi\n    return pi * r ** 3 * 4 / 3\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "Heron", "response_0": "def Heron(a, b, c):\n    p = (a + b + c) / 2\n    return mpc_math.sqrt(p * (p - a) * (p - b) * (p - c))\n", "response_1": "from Compiler import mpc_math\n\ndef Heron(a, b, c):\n    p = (a + b + c) / 2\n    return mpc_math.sqrt(p * (p - a) * (p - b) * (p - c))\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "next_perfect_square", "response_0": "from Compiler.types import sint\n\ndef next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    sqrt_x = mpc_math.sqrt(x)\n    floor_sqrt_x = sqrt_x.floor()\n    next_sqrt_x = floor_sqrt_x + 1\n    return next_sqrt_x * next_sqrt_x\n", "response_1": "import Compiler.types as T\n\ndef next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    sqrt_x = T.mpc_math.sqrt(x)\n    floor_sqrt_x = T.mpc_math.floor(sqrt_x)\n    next_square = (floor_sqrt_x + 1) * (floor_sqrt_x + 1)\n    return next_square\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "pi_to_the_x", "response_0": "import mpc_math\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    return mpc_math.pow_fx(math.pi, x)\n", "response_1": "import mpc_math\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    return mpc_math.pow_fx(mpc_math.pi, x)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "spring_rocket", "response_0": "from Compiler import mpc_math\n\ndef spring_rocket(height, m, k):\n    g = 9.8\n    return mpc_math.sqrt(2 * m * g * height / k)\n", "response_1": "from Compiler import mpc_math\n\ndef spring_rocket(height, m, k):\n    g = 9.8\n    return mpc_math.sqrt(2 * m * g * height / k)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "cone_volume", "response_0": "import Compiler.types as types\n\ndef cone_volume(r, h):\n    pi = types.sfix.get_random(3.141592653589793, 3.141592653589793)\n    return pi * r * r * h / 3\n", "response_1": "from Compiler import types\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = types.sfix.get_random(3.141592653589793, 3.141592653589793, 1)\n    return pi * r * r * h / 3\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "response_1": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "model_name": "qwen2.5-coder-7b"}
