{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler import types\n\n# Create an array of 10 secret integers from 0 to 99\na = types.sint.Array(10)\na.assign(np.linspace(0, 99, 10))\n", "response_1": "from Compiler.types import sint\n\n# Initialize the array with 10 elements\na = sint.Array(10)\n\n# Assign values to the array using linspace logic\nfor i in range(10):\n    a[i] = (i * (end - start) // (num - 1)) + start\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "more_positive", "response_0": "from Compiler import types\nfrom Compiler.library import tree_reduce\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    signs = arr.sign()\n    count = tree_reduce(lambda x, y: x + y, signs)\n    return count > 0\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sint\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    signs = arr.sign()\n    count = signs.sum()\n    return count > 0\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "select", "response_0": "from Compiler import mpc_math\n\ndef select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    return mpc_math.if_else(ind, a, b)\n", "response_1": "from Compiler.types import *\n\ndef select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    return ind.if_else(a, b)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return y.max(0)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return y.max(0)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "cost_matrix", "response_0": "from Compiler import types\n\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    matrix_shape = profit_matrix.shape\n    offset_matrix = types.sfix.Array(matrix_shape).assign_all(profit_matrix.max())\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n", "response_1": "from Compiler.types import sint, Array\n\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    matrix_shape = profit_matrix.shape\n    offset_matrix = Array(matrix_shape, 1) * profit_matrix.max()\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_zeros", "response_0": "n = 10\na = sint.Array(n).assign_all(0)\n", "response_1": "n = 10\na = Compiler.types.sint.Array(n).assign_all(0)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler.types import Array, sint\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index]\n    return array\n", "response_1": "from Compiler.types import Array\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_vector(base=row_index, size=ndarray.shape[1])\n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    return sint.Array(n, 0)\n", "response_1": "from Compiler.types import sint\n\ndef zeros(n):\n    return sint.Array(n).assign_all(0)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_basic_slicing_stride", "response_0": "from Compiler.types import Array, sint\n\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    viewA = ndarrayA[::2]\n    viewB = ndarrayB[1:][::2]\n    array = Array.concatenate([viewA, viewB])\n    return array\n", "response_1": "from Compiler.types import Array, sint\n\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    # Create views of the arrays\n    viewA = ndarrayA.get_vector(base=0, size=None)[::2]\n    viewB = ndarrayB.get_vector(base=1, size=None)[::2]\n\n    # Concatenate the views\n    array = Array.create_from([viewA, viewB])\n\n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "QR_decomposition", "response_0": "from Compiler.types import Matrix, sint\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    # Initialize the Q matrix with the same size as the input matrix\n    Q = Matrix(mat.rows, mat.columns, sint)\n    Q.assign(mat)\n\n    # Perform QR decomposition\n    for k in range(mat.columns):\n        # Compute the Householder vector\n        v = Q.get_column(k)\n        v[k] += v[k].abs()\n        v = v / v[k]\n\n        # Apply the Householder transformation to Q\n        for i in range(k, mat.rows):\n            alpha = v[i] * v[i]\n            Q[i] -= 2 * alpha * v\n\n    return Q\n", "response_1": "from Compiler import mpc_math\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    # Perform QR decomposition using MP-SPDZ's built-in functions\n    q, _ = mpc_math.qr(mat)\n    return q\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "find_nearest_index", "response_0": "from Compiler import mpc_math\n\ndef find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    # Convert numpy array to MP-SPDZ Array\n    array = Compiler.types.Array.create_from(array)\n    value = Compiler.types.sint(value)\n\n    # Compute the absolute difference\n    diff = mpc_math.abs(array - value)\n\n    # Find the index of the minimum difference\n    idx = diff.argmin()\n\n    return idx\n", "response_1": "from Compiler.types import Array, sint\n\ndef find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    # Convert array and value to MP-SPDZ types\n    array = Array(len(array), sint)\n    array.assign(array)\n    value = sint(value)\n\n    # Compute the absolute difference\n    diff = array - value\n    abs_diff = diff.abs()\n\n    # Find the minimum difference\n    min_diff = sint.get_random_bit()\n    min_idx = 0\n    for i in range(len(array)):\n        if abs_diff[i] < min_diff:\n            min_diff = abs_diff[i]\n            min_idx = i\n\n    return min_idx\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_concat_simple_row", "response_0": "from Compiler.types import Array\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    array = Array.create_from(ndarrayA) + Array.create_from(ndarrayB)\n    return array\n", "response_1": "from Compiler import types\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    arrayA = types.Array(ndarrayA.shape[0], types.sint)\n    arrayA.assign(ndarrayA)\n    arrayB = types.Array(ndarrayB.shape[0], types.sint)\n    arrayB.assign(ndarrayB)\n    array = arrayA.concat(arrayB)\n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_copy", "response_0": "import Compiler.types as ct\n\ndef array_copy(ndarray):\n    array = ndarray.copy()\n    return array\n", "response_1": "from Compiler.types import Array\n\ndef array_copy(ndarray):\n    array = Array(ndarray.size, ndarray.dtype)\n    array.assign(ndarray)\n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "max_pooling", "response_0": "from Compiler.types import Array, sint\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-max_pooling.\n    \"\"\"\n    out = Array([x.shape[0], x.shape[1] // stride, x.shape[2] // stride], sint)\n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                out[b, i // stride, j // stride] = x[b, i:i+stride, j:j+stride].max()\n    return out\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import Array, Matrix\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-max_pooling.\n    \"\"\"\n    out_shape = (x.shape[0], x.shape[1] // stride, x.shape[2] // stride)\n    out = Array(out_shape, value_type=sint)\n\n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                out[b, i // stride, j // stride] = mpc_math.max(x[b, i:i+stride, j:j+stride])\n\n    return out\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "array_reshape", "response_0": "from Compiler.types import Matrix\n\na = Matrix(3, 5, sint)\na.assign(np.arange(15).reshape(3, 5))\n", "response_1": "from Compiler.types import Matrix\n\n# Create a 3x5 matrix with values from 0 to 14\na = Matrix(3, 5, sint).create_from(range(15))\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_concat_simple_column", "response_0": "from Compiler.types import Matrix\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    matrixA = Matrix(ndarrayA.shape[0], ndarrayA.shape[1], value_type=sint)\n    matrixA.assign(ndarrayA)\n\n    matrixB = Matrix(ndarrayB.shape[0], ndarrayB.shape[1], value_type=sint)\n    matrixB.assign(ndarrayB)\n\n    result = Matrix(ndarrayA.shape[0], ndarrayA.shape[1] + ndarrayB.shape[1], value_type=sint)\n    result.concat_columns(matrixB)\n\n    return result\n", "response_1": "from Compiler.types import Matrix\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Convert numpy arrays to MP-SPDZ matrices\n    matrixA = Matrix.from_values(ndarrayA.tolist())\n    matrixB = Matrix.from_values(ndarrayB.tolist())\n    \n    # Concatenate the matrices along axis 1\n    result_matrix = matrixA.concat_columns(matrixB)\n    \n    # Convert the result back to a list of lists\n    result = result_matrix.get_values()\n    \n    return result\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "import Compiler.types as T\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    array = ndarray[:, column_index]\n    return array\n", "response_1": "from Compiler import types\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_vector(base=column_index, size=ndarray.shape[1])\n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_diagonal", "response_0": "from Compiler.types import Array, sint\n\ndef diag(array):\n    n = array.shape[0]\n    diag_array = Array(n, sint)\n    for i in range(n):\n        diag_array[i] = array[i][i]\n    return diag_array\n", "response_1": "def diag(array):\n    return array.diag()\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_concat_special", "response_0": "from Compiler import types\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1. Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Extract even columns from ndarrayA\n    viewA = ndarrayA[:, ::2]\n    \n    # Extract odd columns from ndarrayB\n    viewB = ndarrayB[:, 1::2]\n    \n    # Concatenate the views along axis 1\n    array = types.Array(ndarrayA.shape[0], ndarrayA.shape[1]).assign(viewA)\n    array[:, ::2] = viewA\n    array[:, 1::2] = viewB\n    \n    return array\n", "response_1": "from Compiler import types\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1. Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Extract even columns from ndarrayA\n    viewA = ndarrayA.get_vector(base=0, size=None)[::2]\n    \n    # Extract odd columns from ndarrayB\n    viewB = ndarrayB.get_vector(base=1, size=None)[::2]\n    \n    # Concatenate the extracted columns along axis 1\n    array = types.Array(ndarrayA.shape[0], ndarrayA.value_type).create_from([viewA, viewB])\n    \n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_arange", "response_0": "# MP-SPDZ code for arange function\ndef arange(start, stop=None, step=1):\n    \"\"\"\n    create a 1-d array by calling intrinsic MP-SPDZ function\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    array = Compiler.types.sint.Array(stop - start, 0)\n    array.assign(range(start, stop, step))\n    return array\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    create a 1-d array by calling intrinsic function\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Create an array of sint type with the given range and step\n    array = Compiler.types.sint.Array(stop - start, value_type=Compiler.types.sint)\n    array.assign_all(start)\n    for i in range(1, stop - start):\n        array[i] = array[i - 1] + step\n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_eye_2", "response_0": "from Compiler.types import Matrix\n\nm = 3\nn = 5\na = Matrix(m, n, sint)\na.assign_all(0)\nfor i in range(min(m, n)):\n    a[i][i] = 1\n", "response_1": "m = 3\nn = 5\na = Compiler.types.sint.Matrix(m, n).assign_all(0)\nfor i in range(min(m, n)):\n    a[i, i] = 1\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "third_smallest", "response_0": "from Compiler import Compiler\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Convert the input array to an MP-SPDZ Array\n    arr = Compiler.types.sint.Array(len(arr)).assign_all(arr)\n\n    # Sort the array using radix sort\n    Compiler.sorting.radix_sort(arr, arr)\n\n    # Return the third smallest element\n    return arr[2]\n", "response_1": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Convert the input array to an MP-SPDZ Array\n    arr = Compiler.types.sint.Array(len(arr))\n    arr[:] = arr\n\n    # Sort the array using radix sort\n    Compiler.sorting.radix_sort(arr, arr)\n\n    # Return the third smallest element\n    return arr[2]\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "from Compiler.types import Array\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_vector(base=row_index, size=None)\n    return array\n", "response_1": "from Compiler.types import Array\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_part(row_index, 1)\n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = Compiler.types.sint.Array(n)\na.assign_all(range(n))\n", "response_1": "from Compiler.types import sint\n\nn = 10\na = sint.Array(n).assign_all(0)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "from Compiler import types\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_vector(row_index, 1)\n    return array\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_vector(row_index, 1)\n    return array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler.types import sint\n\n# Create a 1-dimensional array with length 5 by converting from Python built-in structures\na_l = [0, 10, 20, 30, 40]\na = sint.Array(5).create_from(a_l)\n", "response_1": "from Compiler import types\n\na_l = [0, 10, 20, 30, 40]\na = types.sint.Array(5).create_from(a_l)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_reshape", "response_0": "from Compiler.types import Array\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a numpy array.\n    \"\"\"\n    array = Array.create_from(ndarray).get_vector(0, m*n).reshape(m, n)\n    return array\n", "response_1": "from Compiler.types import Array\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape an array.\n    \"\"\"\n    array = Array.create_from(ndarray)\n    reshaped_array = Array(m * n, array[0].__class__)\n    reshaped_array.assign(array.reshape(m, n).flatten())\n    return reshaped_array\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_ones", "response_0": "n = 10\na = sint.Array(10)\na.assign_all(1)\n", "response_1": "n = 10\na = Compiler.types.sint.Array(n).assign_all(1)\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "set_one_to_zero", "response_0": "from Compiler import mpc_math\n\ndef set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    y.assign(y.bit_and(y - 1))\n    return y\n", "response_1": "from Compiler.types import sint, Array\n\ndef set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    y.assign(y.if_else(0, y))\n    return y\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_eye", "response_0": "import Compiler.types as T\n\nn = 10\na = T.sint.Matrix(n, n).assign_all(0)\nfor i in range(n):\n    a[i][i] = 1\n", "response_1": "n = 10\na = Compiler.types.sint.Matrix(n, n, Compiler.types.sint(1))\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_diag", "response_0": "from Compiler.types import sfix\n\n# Define the list\na_l = [1, 3, 5, 2, 4, 6]\n\n# Convert the list to a MultiArray\na = sfix.Tensor([6, 6]).assign_all(0)\nfor i in range(6):\n    a[i][i] = a_l[i]\n", "response_1": "import Compiler.types as types\n\n# Create a secret integer array from the list\na_l = types.sint.Array(6)\na_l.assign_all([1, 3, 5, 2, 4, 6])\n\n# Create a diagonal matrix from the array\na = types.sint.Matrix(6, 6)\na.assign_all(0)\nfor i in range(6):\n    a[i, i] = a_l[i]\n", "model_name": "qwen2.5-coder-7b"}
{"test_name": "np_advanced_integer_indexing", "response_0": "from Compiler.types import Array, sint\n\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an MP-SPDZ array from an integer array.\n    \"\"\"\n    # Convert indices to MP-SPDZ sint type\n    indices = Array(len(indices), sint).assign(indices)\n    \n    # Perform indexing\n    ret_array = array[indices]\n    \n    return ret_array\n", "response_1": "from Compiler.types import Array, sint\n\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    indexing a numpy array from an integer array.\n    \"\"\"\n    indices = Array(len(indices), sint)\n    ret_array = array[indices]\n    return ret_array\n", "model_name": "qwen2.5-coder-7b"}
