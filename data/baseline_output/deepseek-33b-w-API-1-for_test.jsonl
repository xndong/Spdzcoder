{"test_name": "multiply_first_five", "response_0": "from Compiler.types import sint\n\ndef multiply_first_five(array: sint.Array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sint(1)\n    for i in range(len(array)):\n        prod *= array[i]\n        if i>=5:\n            break\n    return prod\n", "response_1": "def multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    from Compiler.types import sint\n    prod = sint(1)\n    for i in range(len(array)):\n        prod *= array[i]\n        if i>=5:\n            break\n    return prod\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array. \n    \"\"\"\n    largest = arr[0] if arr[0]>=arr[1] else arr[1]\n    second = arr[1] if arr[0]>=arr[1] else arr[0]\n    for i in range(len(arr)):\n        if i>1:\n            if arr[i] >= largest:\n                second = largest\n                largest = arr[i]\n            else:\n                if arr[i]>=second:\n                    second = arr[i]\n    \n    return second\n", "response_1": "from Compiler.types import sint\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "partial_sum", "response_0": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array. \n    \"\"\"\n    partial = sint(0)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef partial_sum(arr: sint.Array):\n    \"\"\"\n    Compute the partial sum of the array. \n    \"\"\"\n    partial = 0\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "max_adjacent_product", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef max_adjacent_product(arr):\n    cur = arr[0] * arr[1]\n    for i in range(len(arr) - 1):\n        if arr[i] * arr[i + 1] > cur:\n            cur = arr[i] * arr[i + 1]\n    return cur\n", "response_1": "import Compiler.types as types\n\ndef max_adjacent_product(arr):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2. \n    \"\"\"\n    cur = arr[0]*arr[1]\n    for i in range(len(arr)-1):\n        if arr[i]*arr[i+1] > cur:\n            cur = arr[i]*arr[i+1]\n    return cur\n\n# In MP-SPDZ, you should specify the size of the array and the data type.\n# Since this is a secret computation, we can use 'sint' which is the secret integer in the protocol-specific domain.\narr = types.sint.Array(10) # Replace 10 with the actual length of the array\ncur = arr[0]*arr[1]\nfor i in range(len(arr)-1):\n    if arr[i]*arr[i+1] > cur:\n        cur = arr[i]*arr[i+1]\nmax_product = cur\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "argmax", "response_0": "from Compiler.types import Array, sfix\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max velue of an array. \n    \"\"\"\n    current = a[0]\n    index = 0\n    for i in range(len(a)):\n        index = index.if_else(current>=a[i], index, i)\n        current = current.if_else(current>=a[i], current, a[i])\n    return index\n", "response_1": "from Compiler.types import Array, sint\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max value of an array. \n    \"\"\"\n    current = a[0]\n    index = sint(0)\n    for i in range(1, len(a)):\n        index = index.if_else(current>=a[i], index, sint(i))\n        current = current.if_else(current>=a[i], current, a[i])\n    return index\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "count_distinct", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = sint(0)\n    for i in range(len(arr)):\n        unique = True\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = False\n        if unique:\n            counter = counter + 1\n    return tree_reduce(lambda x, y: x + y, counter)\n", "response_1": "import Compiler\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = sint(0)\n    for i in range(len(arr)):\n        unique = sint(1)\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = sint(0)\n        counter = counter + unique\n    return counter\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "exists_true", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.oram import OptimalORAM\nfrom Compiler.library import tree_reduce\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    ret[:] = arr[:]\n    ret = tree_reduce(lambda x, y: x.bit_or(y), ret)\n    return ret\n\n\n# Usage:\n# arr = Array(10, sint)  # Create a 10-element array\n# result = exists_true(arr)\n# print(result)  # Print the result\n", "response_1": "from Compiler.types import Array, sint\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        ret = ret.bit_or(item)\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "range", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = tree_reduce(lambda x, y: x.max(y), arr)\n        min_value = tree_reduce(lambda x, y: x.min(y), arr)\n    return max_value - min_value\n", "response_1": "from Compiler.types import *\nimport Compiler.library as lib\nimport Compiler.oram\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = lib.if_(max_value>=item, max_value, item)\n        min_value = lib.if_(min_value<=item, min_value, item)\n    return max_value-min_value\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "count_larger_than_5", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5. \n    \"\"\"\n    greater_than_5 = arr > 5\n    counter = tree_reduce(lambda x, y: x.bit_and(y), greater_than_5)\n    return counter\n\narr = sint.Array(10)\ncounter = count_larger_than_5(arr)\n", "response_1": "from Compiler.types import sint, cint, Array\n\ndef count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5. \n    \"\"\"\n    counter = cint(0)\n    for item in arr:\n        counter = counter + (item > 5)\n    return counter\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "exists_dominator", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = arr[0].abs()\n    sum = arr[0].abs()\n    for item in arr[1:]:\n        max = (item.abs() > max) .if_else(item.abs(), max)\n        sum = sum + item.abs()\n    return (2*max > sum)\n", "response_1": "from Compiler.types import sfix, sint, Array, same_shape\nfrom Compiler.library import for_range\nfrom Compiler.math import mpc_math\n\ndef exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = sfix(0,10,10)\n    sum = sfix(0,10,10)\n    for i in for_range(0, len(arr)):\n        max = mpc_math.max(max, arr[i].abs())\n        sum = sum + arr[i].abs()\n    return 2*max > sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "greedy_picker", "response_0": "from Compiler.types import sfix, sint, cint, Array\nfrom Compiler.library import for_range\n\ndef greedy_picker(items, captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    for i in range(len(items)):\n        if items[i] <= captivity:\n            captivity = captivity - items[i]\n            num = num + 1\n    return num\n", "response_1": "from Compiler.types import sint, cint\nfrom Compiler.sorting import radix_sort\n\ndef greedy_picker(items, captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = cint(0)\n    radix_sort(sint(captivity), items)\n    for item in items:\n        if item <= captivity:\n            captivity = captivity - item\n            num = num + cint(1)\n    return num\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    from Compiler.types import sint\n    from Compiler.library import for_range\n\n    n = len(l)\n    total = sint(0)\n    for i in range(n):\n        total = total + l[i]\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result. \n    \"\"\"\n    for item in l:\n        s += item\n    return s\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "is_equidistant_seq", "response_0": "def is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence. \n    If the array has length 1 or 0, return True.\n    \"\"\"\n    import Compiler.types as t\n    import Compiler.library as lib\n    import Compiler.GC.types as gt\n    import Compiler.oram as oram\n    import Compiler.sqrt_oram as sqrt_oram\n    import Compiler.sorting as sorting\n    import Compiler.types.mpc_math as mpc_math\n\n    arr = [x[0] for x in arr] # Assume that the arr is a matrix. This line of code is assuming the input data is a multi-dimensional array and converting it into a simple array for calculation.\n\n    d = 0\n    for i in range(len(arr)-1):\n        if i>0 and arr[i+1]-arr[i] != d:\n            return False\n        d = arr[i+1]-arr[i]\n    return True\n\n", "response_1": "import Compiler.types\n\ndef is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence. \n    If the array has length 1 or 0, return True.\n    \"\"\"\n    d = sint(0)\n    for i in range(Compiler.types.length(arr)-1):\n        if i>0 and arr[i+1]-arr[i] != d:\n            return False\n        d = arr[i+1]-arr[i]\n    return True\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "inner_product", "response_0": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(vec1)):\n        sum += vec1[i] * vec2[i]\n    return sum\n", "response_1": "from Compiler.types import sfix, sint\n\ndef inner_product(vec1: sfix, vec2: sfix) -> sfix:\n    \"\"\"\n    Compute the inner product of the two sfix arrays. \n    \"\"\"\n    sum = sfix(0.0)\n    for i in range(len(vec1)):\n        sum += vec1[i] * vec2[i]\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "more_distinct_nonnegative", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef more_distinct_nonnegative(arr):\n    nonnegative_counter = 0\n    negative_counter = 0\n    for i in range(len(arr)):\n        unique = True\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = False\n        if unique:\n            if arr[i] >= 0:\n                nonnegative_counter = nonnegative_counter + 1\n            else:\n                negative_counter = negative_counter + 1\n    return nonnegative_counter > negative_counter\n", "response_1": "from Compiler.types import sint, MemValue, Array\n\ndef more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    for i in range(len(arr)):\n        unique = MemValue(True)\n        for j in range(i):\n            unique.iadd(arr[j].bit_and(arr[i]))\n        unique_not = MemValue(1).bit_not().bit_and(unique)\n        unique_is_nonnegative = arr[i].bit_not().bit_and(sint(0))\n        unique_is_negative = arr[i].bit_and(sint(-1))\n        nonnegative_counter.iadd(unique_not.bit_and(unique_is_nonnegative))\n        negative_counter.iadd(unique_not.bit_and(unique_is_negative))\n    return nonnegative_counter.bit_and(nonnegative_counter) > negative_counter.bit_and(negative_counter)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "flip_positives", "response_0": "from Compiler.types import sint\n\ndef flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        array[i] = (array[i] > sint(0)).if_else(array[i] * sint(-1), array[i])\n    return array\n", "response_1": "def flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        array[i] = array[i].if_else(array[i]*-1, array[i])\n    return array\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "divide_and_plus", "response_0": "from Compiler.types import sint\n\ndef divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = x >> 1  \n        x = x + sint(1) \n    return x\n", "response_1": "from Compiler.types import *\nimport Compiler.library\nimport Compiler.math_int_math_mult\n\n@spec()\ndef divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = Compiler.math_int_math_mult.div_fx(x,2)\n        x = x + 1\n    return x\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_log2", "response_0": "from Compiler.types import *\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = mpc_math.log2(arr[i])\n    return arr\n", "response_1": "def array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    from Compiler.types import sint, sfix, Array\n    from Compiler.library import log2_fx\n    for i in range(len(arr)):\n        arr[i] = log2_fx(arr[i])\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_to_ten", "response_0": "import Compiler.types as T\n\ndef sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = T.sint(0)\n    for i in range(len(array)):\n        sum += array[i]\n        if sum.reveal()>=10:\n            break\n    return sum\n", "response_1": "from Compiler.types import Array\n\ndef sum_to_ten(array):\n    sum = 0\n    for i in range(len(array)):\n        sum += array[i]\n        if sum.reveal() >= 10:  # This will reveal the secret integer and stop the loop if the condition is satisfied.\n            break\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr: sint.Array):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    for i in range(len(arr)):\n        if i%2:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "from Compiler.types import Array\nfrom Compiler.types import sint\n\ndef choppy_plus_minus(arr: Array(sint)):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    for i in range(len(arr)):\n        if i%2:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "min_element", "response_0": "from Compiler.types import Array\nfrom Compiler.library import tree_reduce\n\ndef min_element(a):\n    \"\"\"\n    Return the min value of an array. \n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = current if current <= item else item\n    \n    return current\n\n# Use MP-SPDZ's tree_reduce method\ndef min_element_mpspdz(a):\n    \"\"\"\n    Return the min value of an array. \n    \"\"\"\n    return tree_reduce(lambda x, y: x if x <= y else y, a)\n\n# Define the input array\ninput_array = Array(10, sint)\ninput_array.assign_all(5)\n\n# Call the function\nmin_val = min_element_mpspdz(input_array)\nprint(min_val)\n", "response_1": "from Compiler.types import *\n\ndef min_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = current.min(item)\n    \n    return current\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "soft_max", "response_0": "def soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    import Compiler.types as sint\n\n    denominator = 0\n    for item in arr:\n        denominator = denominator + sint.mpc_math.pow_fx(sint.mpc_math.e, item)\n\n    brr = arr\n    for i in range(len(arr)):\n        brr[i] = sint.mpc_math.pow_fx(sint.mpc_math.e, arr[i]) / denominator\n\n    return brr\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\nimport math\n\ndef soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    denominator = tree_reduce(lambda x, y: x + math.pow(sfix.E_fx, y), arr)\n    brr = sint.Array(len(arr))\n    for i in range(len(arr)):\n        brr[i] = math.pow(sfix.E_fx, arr[i])/denominator\n    return brr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "count_reverse_pair_with_break", "response_0": "from Compiler.types import sint, Array\n\ndef count_reverse_pair_with_break(arr: Array):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    \"\"\"\n    count = sint(0)\n    for i in range(1, len(arr)):\n        if arr[i] > 10:\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count += 1\n    return count\n", "response_1": "", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_unique", "response_0": "from Compiler.types import *\n", "response_1": "from Compiler.types import sint\n\ndef sum_unique(arr):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        unique = True\n        for j in range(len(arr)):\n            if arr[j]==arr[i] and j != i:\n                unique = False\n                break\n        if unique:\n            sum = sum + arr[i]\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "check_sum", "response_0": "def check_sum_mpc(array,target, k):\n    \"\"\"\n    Check whether the sum of the array equals the target value in a MPC context.\n    \"\"\"\n    sum = 0\n    for num in array:\n        sum = sum + num\n    return sfix.greater_or_equal_zero(sfix.bit_xor(sum - target, k))\n", "response_1": "from Compiler.types import sint\n\ndef check_sum(array: sint.Array, target: sint):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum_of_array = sint(0)\n    for num in array:\n        sum_of_array += num\n    return sum_of_array == target\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "prod", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef prod(array):\n    \"\"\"\n    Multiply together all elements in the array using MP-SPDZ. \n    \"\"\"\n    prod = sint(1)\n    for num in array:\n        prod = prod * sint(num)\n    return prod\n\ndef optimized_prod(array):\n    \"\"\"\n    Multiply together all elements in the array using MP-SPDZ optimized version. \n    \"\"\"\n    prod = sint(1)\n    for num in array:\n        prod = prod * sint(num)\n    return tree_reduce(lambda x, y: x * y, array)\n", "response_1": "from Compiler.types import sint\n\ndef prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    prod = sint(1)\n    for num in array:\n        prod = prod * num\n    return prod\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_till_negative", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        if array[i]<0:\n            break\n        sum += array[i]\n    return sum\n\narray = Array(10, sint)\nsum = sum_till_negative(array)\n", "response_1": "from Compiler.types import sint\n\ndef sum_till_negative_MP_SPDZ(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum_ = sint(0)\n    for i in range(len(array)):\n        if array[i]<0:\n            break\n        sum_ += array[i]\n    return sum_\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator. \n    \"\"\"\n    arr = sint.Array(len(arr)).assign(arr)\n    pred = sint.Array(len(arr)).assign([int(predicator(arr[i])) for i in range(len(arr))])\n    return tree_reduce(lambda x, y: x + y, pred)\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator. \n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        sum += predicator(arr[i])\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "standard_deviation", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\nimport mpc_math\n\ndef standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array.\n    \"\"\"\n    average = 0\n    variance = 0\n    for item in arr:\n        average = average + item / len(arr)\n    for item in arr:\n        variance = variance + (item - average)**2 / len(arr)\n    return mpc_math.InvertSqrt(variance)\n\narr = sint.Array(10)\nres = standard_deviation(arr)\n", "response_1": "import math\nfrom Compiler.types import sfix, sint, Matrix, MultiArray\nfrom Compiler.library import tree_reduce\nfrom Compiler.sqrt_oram import SqrtOram\nfrom Compiler.sorting import radix_sort\n\ndef standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    # The type of the array elements is taken as sfix\n    average = 0\n    variance = 0\n    for item in arr:\n        average = average+item/len(arr)\n    for item in arr:\n        variance = variance + (item-average)**2/len(arr)\n    return math.sqrt(variance)\n\narr = SqrtOram(1000, sfix)\n# Fill the ORAM with some values\nfor i in range(len(arr)):\n    arr[i] = sfix.get_input_from(i)\n# Calculate the average\naverage = tree_reduce(lambda x, y: x+y/len(arr), arr)\n# Calculate the variance\nvariance = tree_reduce(lambda x, y: x + (y-average)**2/len(arr), arr)\n# Return the standard deviation\nreturn math.sqrt(variance)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "dominate", "response_0": "from Compiler.types import *\n\ndef dominate(a, b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    ret = sint(1)\n    for i in range(len(a)):\n        if a[i] < b[i]:\n            ret = sint(0)\n    return ret\n", "response_1": "def dominate(a, b):\n    ret = True\n    n = len(a)\n    for_range(0, n, lambda i: a[i] < b[i])\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = sint.get_input_from(0)\n    for_range(len(brr)):\n        if abs(brr[i])>max_abs:\n            max_abs = abs(brr[i])\n    for_range(len(brr)):\n        brr[i] = brr[i]/max_abs\n    return brr\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import any_ge\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_minus7", "response_0": "from Compiler.types import sint\n\ndef array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] -= 7\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_minus7(arr:sint):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\nfrom Compiler.sqrt_oram import SqrtOram\n\ndef traverse_and_sum(arr1: Array(len(arr1), sint), arr2: Array(len(arr2), sint)) -> sint:\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    result = SqrtOram(len(arr1), sint)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            result[i] += arr1[i]*arr2[j]\n    return tree_reduce(lambda x, y: x + y, result)\n", "response_1": "from Compiler.types import *\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum = sum + arr1[i].bit_and(arr2[j])\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "longest_nondec_subseq", "response_0": "import Compiler.types as T\nimport Compiler.GC.types as GC_T\nimport Compiler.library as Lib\n\ndef longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    max_length = T.sint(0)\n    cur_length = T.sint(0)\n    for i in range(len(a)):\n        if i==0:\n            cur_length = T.sint(1)\n            continue\n        if a[i] >= a[i-1]:\n            cur_length += T.sint(1)\n        else:\n            max_length = Lib.tree_reduce(lambda x, y: x if x>=y else y, [max_length, cur_length])\n            cur_length = T.sint(1)\n    max_length = Lib.tree_reduce(lambda x, y: x if x>=y else y, [max_length, cur_length])\n    return max_length\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.sorting import radix_sort\nfrom Compiler.library import tree_reduce\n\ndef longest_nondec_subseq(a: Array):\n    \"\"\"\n    Return the length of the longest non-deceasing subsequence in the input array.\n    \"\"\"\n    max_length = sint(0)\n    cur_length = sint(0)\n    for i in range(len(a)):\n        if i==0:\n            cur_length = sint(1)\n            continue\n        if a[i] >= a[i-1]:\n            cur_length = cur_length + sint(1)\n        else:\n            max_length = max_length if max_length>=cur_length else cur_length\n            cur_length = sint(1)\n    max_length = max_length if max_length>=cur_length else cur_length\n    return max_length\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_but_skip_biggest", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef sum_but_skip_biggest(array):\n    sum = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        if array[i]>=biggest:\n            biggest = array[i]\n            continue\n        sum += array[i]\n    return sum\n\nbiggest_array = tree_reduce(lambda x, y: x.max(y), array)\n\nskip_biggest = sint.Array(len(array))\nfor i in range(len(array)):\n    skip_biggest[i] = sint.if_else(array[i] != biggest_array, array[i], sint(0))\n\nsum = tree_reduce(lambda x, y: x + y, skip_biggest)\n", "response_1": "from Compiler.types import sint\nfrom Compiler.sorting import radix_sort\n\ndef sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = sint(0)\n    biggest = array[0]\n    key = sint.Array(len(array))\n    for i in range(len(array)):\n        key[i] = array[i]\n        if array[i]>=biggest:\n            biggest = array[i]\n            continue\n        sum += array[i]\n    radix_sort(key, array)\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "second_test", "response_0": "def second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    for i in range(1,len(arr)):\n        if arr[0]<arr[i]:\n            count = count + sint(1)\n    if count == sint(1):\n        return sint(1)\n    else:\n        return sint(0)\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    for i in for_range(1, len(arr)):\n        if arr[0] < arr[i]:\n            count += sint(1)\n    if count == sint(1):\n        return True\n    else:\n        return False\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "Manhattan_distance", "response_0": "import Compiler.types as types\n\ndef Manhattan_distance(a,b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    ret = types.sint.Array(1).assign_all(0)\n    for i in range(len(a)):\n        ret += types.mpc_math.abs(a[i] - b[i])\n    return ret\n", "response_1": "def Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    ret = Compiler.types.sfix(val=0)\n    for i in range(len(a)):\n        ret += abs(a[i] - b[i])\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "deal_with_only_positive", "response_0": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and substract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    from Compiler.types import sfix, sint\n\n    sign = sint(1)\n    sum = sfix(0.0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        sum = sum + sign * array[i]\n        sign = (-1) * sign\n    return sum\n", "response_1": "def main():\n    array = sint.Array(10)\n    array.randomize()\n    sum = deal_with_only_positive(array)\n    sum.reveal()\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\nfrom Compiler import sqrt_oram\n\ndef compare_and_return(arr,brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    ret = sint(0)\n    for i in range(len(arr)):\n        if arr[i]==brr[i]:\n            ret = i\n            break\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\n\ndef compare_and_return(arr: [sfix], brr: [sfix]) -> sint:\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    ret = sint(-1)\n    for i in range(len(arr)):\n        if arr[i] == brr[i]:\n            ret = sint(i)\n            break\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_odd_positive", "response_0": "from Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        if item.bit_and(1) and item>0:\n            sum += item\n    return sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        if (item & 1) and (item > 0):\n            sum = sum + item\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "two_sum", "response_0": "", "response_1": "from Compiler.types import sint, Array\n\ndef two_sum_mpc(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value. \n    \"\"\"\n    found = sint(0)\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if arr[i] + arr[j] == target:\n                found = sint(1)\n    return found\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "seq_search", "response_0": "import Compiler\n\ndef seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i]==target:\n            return i\n    return -1\n\ndef seq_search_mp_spdz(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    length = len(arr)\n    for i in range(length):\n        if arr[i]==target:\n            return i\n    return -1\n", "response_1": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    index = -1\n    for i in range(len(arr)):\n        index = index.bit_and(i-1).bit_or((arr[i]==target).bit_and(i))\n    return index\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "choppy_array", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef choppy_array(arr):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n-i):\n            if i % 2 == 0 and arr[i] < arr[i+j]:\n                return sint(0)\n            if i % 2 == 1 and arr[i] > arr[i+j]:\n                return sint(0)\n    return sint(1)\n\n\nfor_range(0, len(arr), name='i')\nfor_range(i, len(arr)-i, name='j')\nif i % 2 == 0:\n    arr[i] < arr[i+j]\nelif i % 2 == 1:\n    arr[i] > arr[i+j]\n", "response_1": "def choppy_array(arr):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(len(arr)-i):\n            if i%2 and arr[i+j]>arr[i]:\n                return False\n            if (not i%2) and arr[i+j]<arr[i]:\n                return False\n    return True\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_process", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    arr = sint.create_from(arr)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr.get_vector(0, len(arr))\n", "response_1": "from Compiler.types import Array\n\ndef array_process(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "normalize", "response_0": "def normalize(vec):\n    \"\"\"\n    Normalize the vector.\n    \"\"\"\n    import mpc_math\n    sum = 0\n    for item in vec:\n        sum = sum + mpc_math.pow_fx(item, 2)\n    base = mpc_math.sqrt(sum)\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.mpc_math import sqrt\n\ndef normalize(vec):\n    \"\"\"\n    Normalize the vector.\n    \"\"\"\n    sum = 0\n    for item in vec:\n        sum = sum + item**2\n    base = sqrt(sum)\n    for i in range(len(vec)):\n        vec[i] = vec[i]/base\n    return vec\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "impatient_merchant", "response_0": "from Compiler.types import sint\n\ndef impatient_merchant(days: list[int]):\n    \"\"\"\n    You are given the prices of some goods in consecutive days.\n    Here's an impatient merchant who will buy the good at the first days,\n    and sell it until its price becomes higher than its original cost.\n    Then he will buy the good in the next day and repeat the above process.\n    The good left in the hand of the merchant in the last day will worth nothing.\n    You should calculate the net value the impatient merchant can earn.\n    \"\"\"\n    can_buy = sint(1)\n    net = sint(0)\n    orig_price = sint(0)\n    for i in range(len(days)):\n        if can_buy:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = sint(0)\n        else:\n            if days[i]>orig_price:\n                net = net + days[i]\n                can_buy = sint(1)\n    return net\n", "response_1": "from Compiler.types import *\n\ndef impatient_merchant(days):\n    \"\"\"\n    You are given the prices of some goods in consecutive days. \n    Here's an impatient merchant who will buy the good at the first days, \n    and sell it until its price becomes higher than its original cost. \n    Then he will buy the good in the next day and repeat the above process. \n    The good left in the hand of the merchant in the last day will worth nothing.\n    You should calculate the net value the impatient merchant can earn.\n    \"\"\"\n    can_buy = True\n    net = sint(0)\n    orig_price = sint(0)\n    for i in range(len(days)):\n        if can_buy:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = False\n        else:\n            if days[i]>orig_price:\n                net = net + days[i]\n                can_buy = True\n    return net\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_shift", "response_0": "from Compiler.types import sint, MemValue, Array\n\ndef array_shift(a: Array(10, sint)) -> Array(10, sint):\n    temp = MemValue(a[len(a)-1])\n    for i in range(len(a)-1):\n        a[len(a)-i-1] = a[len(a)-i-2]\n    a[0] = temp\n    return a\n", "response_1": "from Compiler.types import Array\n\ndef array_shift_mpspdz(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    temp = a[len(a)-1]\n    for i in range(len(a)-1):\n        a[len(a)-i-1] = a[len(a)-i-2]\n    a[0] = temp\n    return a\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_double", "response_0": "from Compiler.types import sint, Array\n\ndef array_double(arr: Array(sint, len(arr))):\n    for i in range(len(arr)):\n        arr[i] *= 2\n    return arr\n", "response_1": "import Compiler.types as sint\n\ndef array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + arr[i]\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.types import sint\n\ndef stop_at_zero(array: sint.Array) -> sint.Array:\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    for i in range(array.length()):\n        if array[i] == zero:\n            break\n        array[i] += one\n    return array\n", "response_1": "import Compiler.types.sint as sint\n\ndef stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    zero = sint.Array(1, sint)\n    zero[0] = 0\n    one = sint.Array(1, sint)\n    one[0] = 1\n    for i in range(len(array)):\n        if array[i]==zero[0]:\n            break\n        array[i] += one[0]\n    return array\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i].bit_xor(1)\n    return arr\n", "response_1": "from Compiler.types import sfix, sint, Array\n\ndef array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i].bit_not()\n    return arr\n\narray = Array(10, sfix)\narray = array_not(array)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_process_then_clip", "response_0": "from Compiler.types import Array\nfrom Compiler import mpc_math\n\ndef array_process_then_clip(arr: Array, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome in to range [-10,10]\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = mpc_math.min(mpc_math.max(arr[i], -10), 10)\n    return arr\n", "response_1": "from Compiler import types\n\ndef array_process_then_clip(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome in to range [-10,10]\n    \"\"\"\n    length = len(arr)\n    for i in range(length):\n        arr[i] = func(arr[i])\n        arr[i] = arr[i].if_else(arr[i].max(-10), arr[i].min(10))\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "add_and_count_positive", "response_0": "def add_and_count_positive(array,k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        temp = array[i] > 0\n        temp = temp.bit_and(temp)\n        count = count + temp\n    return array, count\n", "response_1": "from Compiler.types import sint\n\ndef add_and_count_positive(array,k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        count = count + (array[i] > 0)\n    return array, count\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_subtract", "response_0": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    \n    if len_a > len_b:\n        ret = sint.Array(len_a)\n        ret[:] += a[:]\n        ret[len_b:] -= a[len_b:]\n        ret[:len_b] -= b[:]\n    else:\n        ret = sint.Array(len_b)\n        ret[:] -= b[:]\n        ret[len_a:] += a[:]\n        ret[:len_a] += a[:]\n        \n    return ret\n", "response_1": "def array_subtract(a,b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    import Compiler.types\n\n    if len(a)>len(b):\n        ret = Compiler.types.sint.Array(len(a))\n        for i in range(len(b)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(a)-len(b)):\n            ret[len(b)+i] = a[len(b)+i]\n        return ret\n    else:\n        ret = Compiler.types.sint.Array(len(b))\n        for i in range(len(a)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(b)-len(a)):\n            ret[len(a)+i] = -b[len(a)+i]\n        return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "lower_bound", "response_0": "from Compiler.types import sfix, sint\n\ndef lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = sint(-1)\n    distance = sfix(0)\n    found = False\n    for i in range(len(arr)):\n        if arr[i] <= x:\n            if not found or x - arr[i] < distance:\n                ret = i\n                distance = x - arr[i]\n                found = True\n    return ret\n", "response_1": "from Compiler.types import Array, sint\n\ndef lower_bound(arr: Array, arr_length: int, x: sint):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = -1\n    distance = 0\n    found = False\n    for i in range(arr_length):\n        if arr[i]<=x:\n            if not found or x-arr[i]<distance:\n                ret = i\n                distance = x-arr[i]\n                found = True\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "argmin", "response_0": "def argmin(a):\n    \"\"\"\n    Return the index of the min value of an array. \n    \"\"\"\n    from Compiler.types import sint, Array\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        index = index if current<=a[i] else sint(i)\n        current = current if current<=a[i] else a[i]\n    return index\n", "response_1": "def argmin(a):\n    \"\"\"\n    Return the index of the min velue of an array. \n    \"\"\"\n    from Compiler.types import sint\n\n    current = a[0]\n    index = sint(0)\n    size = len(a)\n\n    for i in range(size):\n        temp_index = index.cond_swap(sint(i), i < size)\n        temp_current = current.cond_swap(a[i], i < size)\n        index.update(temp_index)\n        current.update(temp_current)\n\n    return index\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "independent_robbery", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem:\n    The robber wants to rob some houses align a street, each of which has some amount of money in it (guaranteed to be nonnegative). \n    The robber cannot rob two consecutive houses, we want to know the max amount of money he can get. \n    The number of houses is guaranteed to be no smaller than 3.\n    \"\"\"\n    dp = sint.Array(len(houses))\n    dp[0] = houses[0]\n    dp[1] = dp[1].max(dp[0])\n    for i in range(2, len(houses)):\n        dp[i] = (dp[i-2] + houses[i]).max(dp[i-1])\n    return tree_reduce(lambda x, y: x.max(y), dp)\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem:\n    The robber wants to rob some houses align a street, each of which has some amount of money in it (guaranteed to be nonnegative). \n    The robber cannot rob two consecutive houses, we want to know the max amount of money he can get. \n    The number of houses is guaranteed to be no smaller than 3.\n    \"\"\"\n    dp = [0 for i in range(len(houses))]\n    dp[0] = houses[0]\n    dp[1] = max(dp[1], dp[0])\n    for i in range(2,len(houses)):\n        if dp[i-2]+houses[i] >= dp[i-1]:\n            dp[i] = dp[i-2]+houses[i]\n        else:\n            dp[i] = dp[i-1]\n    return dp[len(houses)-1]\n\ndef main(inputs):\n    houses = sfix.Array(len(inputs))\n    houses[:] = inputs[:]\n    return independent_robbery(houses)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_odd_and_odd", "response_0": "def sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    sum_sint = sint(0)\n    for i in range(len(arr)):\n        if i%2 != 0:\n            for j in range(i):\n                if j%2 != 0:\n                    sum_sint += arr[j]\n    return sum_sint\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.oram import OptimalORAM\nfrom Compiler.library import tree_reduce\n\ndef sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    sum = sfix(0, 24, 4)  # Initialize with compile-time precision\n    arr_size = len(arr)\n    oram = OptimalORAM(arr_size)\n\n    for i in range(arr_size):\n        if i%2==0:\n            continue\n        for j in range(i):\n            if j%2==0:\n                continue\n            oram[i] = sint.get_random_bit()  # Random bit generation\n\n    for i in range(arr_size):\n        if i%2==0:\n            continue\n        for j in range(i):\n            if j%2==0:\n                continue\n            sum += oram[j]\n\n    return tree_reduce(lambda x, y: x + y, sum)  # Tree reduction\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "is_monotonous", "response_0": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    d = sint(0)\n    for i in range(len(arr)-1):\n        if i>0 and (arr[i+1]-arr[i])*d<=0:\n            return False\n        d = arr[i+1]-arr[i]\n    return True\n", "response_1": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    d = sint(0)\n    for i in range(len(arr)-1):\n        temp_d = arr[i+1] - arr[i]\n        if i>0 and (temp_d*d) <= 0:\n            return False\n        d = temp_d\n    return True\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler.types import sint, cint\n\ndef positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint(0)\n    sum = sint(0)\n    for item in arr:\n        if item.bit_and(item) > sint(0):\n            count += sint(1)\n        if item.bit_and(item) < sint(0):\n            sum += item\n    return count, sum\n", "response_1": "import Compiler.types as sint\n\ndef positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint.sint(0)\n    sum = sint.sint(0)\n    for item in arr:\n        if item > 0:\n            count += 1\n        if item < 0:\n            sum += item\n    return count, sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_even", "response_0": "import Compiler\nfrom Compiler.types import sint\n\ndef sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        if not sint(item).bit_and(1):\n            sum += sint(item)\n    return sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef sum_even(arr: sint.Array) -> sint:\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    # map the array to a new array where even numbers are kept and others are set to 0\n    arr_even = arr.map(lambda x: x * (x % 2))\n\n    # sum the new array\n    sum = tree_reduce(lambda x, y: x + y, arr_even)\n\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sint(0)  # initialize sum with a secret integer\n    for item in vec:\n        sum = sum + abs(item)  # use the built-in abs function to get absolute value\n    return sum\n", "response_1": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sint.get_input_from(0)  # Initialize sum as secret input from party 0\n    for item in vec:\n        item = sint.get_input_from(1)  # Assume the input from party 1\n        sum = sum + abs(item)\n    sum.output_as_parties(0)  # Output the result as party 0\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_floor", "response_0": "import Compiler\nfrom Compiler.types import sint\n\ndef array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = sint.floor(arr[i])\n    return ret\n", "response_1": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    import mpc_math\n    ret = []\n    for i in range(len(arr)):\n        ret.append(mpc_math.floor(arr[i]))\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "three_five", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef three_five(arr):\n    \"\"\"\n    If the input array contain both/neither 3 and/or 5, return True, \n    otherwise return False. \n    \"\"\"\n    has3 = Array(1,sint).assign_all(0)\n    has5 = Array(1,sint).assign_all(0)\n    for item in arr:\n        has3[0] = has3[0].bit_or(item == 3)\n        has5[0] = has5[0].bit_or(item == 5)\n    return (has3[0] and has5[0]) or ((not has3[0]) and (not has5[0]))\n\narr = Array(5, sint).assign_all(0)  # initialize an array of size 5 with all zeros\ntree_reduce(lambda x, y: x.bit_or(y == 3), arr)  # set has3 to 1 if there is a 3 in the array\ntree_reduce(lambda x, y: x.bit_or(y == 5), arr)  # set has5 to 1 if there is a 5 in the array\n\nhas3 = tree_reduce(lambda x, y: x.bit_or(y == 3), arr)  # has3 is 1 if there is a 3 in the array, 0 otherwise\nhas5 = tree_reduce(lambda x, y: x.bit_or(y == 5), arr)  # has5 is 1 if there is a 5 in the array, 0 otherwise\n\nresult = (has3 and has5) or ((not has3) and (not has5))  # True if there is both 3 and 5, or neither, False otherwise\n", "response_1": "from Compiler.types import sint\n\ndef three_five(arr):\n    \"\"\"\n    If the input array contain both/neither 3 and/or 5, return True,\n    otherwise return False.\n    \"\"\"\n    has3 = sint(0)\n    has5 = sint(0)\n    for item in arr:\n        has3 = has3 | (item==3)\n        has5 = has5 | (item==5)\n    return ((has3 & has5) | ((~has3) & (~has5)))\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "num_above_average", "response_0": "from Compiler.types import *\n\ndef num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    sum = sint(0)\n    count = sint(0)\n    for i in range(len(arr)):\n        sum = sum + arr[i]\n    avg = sum/sint(len(arr))\n    for item in arr:\n        sum = sum + item.bit_and(item >= avg)\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    sum = sint(0)\n    count = sint(0)\n    for i in range(len(arr)):\n        sum = sum + arr[i]\n    avg = sum/len(arr)\n    for item in arr:\n        if item>=avg:\n            count = count + 1\n    return count\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "clip", "response_0": "import Compiler.types as types\nimport Compiler.library as library\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    # Convert the array into a MP-SPDZ array\n    arr = types.sfix.Array(len(arr), arr)\n\n    # Perform clipping in MP-SPDZ\n    for i in range(len(arr)):\n        if arr[i] < lower_bound:\n            arr[i] = lower_bound\n        if arr[i] > upper_bound:\n            arr[i] = upper_bound\n    return arr\n\n", "response_1": "from Compiler.types import sint\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    upper_bound_arr = sint.Array(len(arr), upper_bound)\n    lower_bound_arr = sint.Array(len(arr), lower_bound)\n    \n    for i in range(len(arr)):\n        arr.get_part(i, 1).assign_vector(arr.get_part(i, 1).max(lower_bound_arr.get_part(i, 1)))\n        arr.get_part(i, 1).assign_vector(arr.get_part(i, 1).min(upper_bound_arr.get_part(i, 1)))\n\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        if 5<=(sum+array[i]).reveal()<=10:\n            continue\n        sum += array[i]\n    return sum.reveal()\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_of_odd_and_even", "response_0": "# First, you need to import the necessary modules from MP-SPDZ. \nfrom Compiler.types import *\n\n# Now, you can define your function. \ndef sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers. \n    \"\"\"\n    # Initialize the sum variables as secret integers.\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    \n    # Iterate through the array.\n    for item in arr:\n        # Check if the current item is odd or even.\n        if sint(item % 2):\n            # If the current item is odd, add it to the odd_sum.\n            odd_sum += sint(item)\n        else:\n            # If the current item is even, add it to the even_sum.\n            even_sum += sint(item)\n            \n    # Return the sum of odd numbers and even numbers.\n    return odd_sum, even_sum\n", "response_1": "import Compiler.types\n\ndef sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers. \n    \"\"\"\n    odd_sum = Compiler.types.sint(0)\n    even_sum = Compiler.types.sint(0)\n    for item in arr:\n        if item % 2:\n            odd_sum += item\n        else:\n            even_sum += item\n    return odd_sum, even_sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "distance", "response_0": "import Compiler.types\nfrom Compiler.types import sint, sfix\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(vec1)):\n        sum += (vec1[i]-vec2[i])**2\n    return sum.sqrt()\n", "response_1": "import Compiler\nimport mpc_math\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum_val = sint(0)\n    for i in range(len(vec1)):\n        sum_val += mpc_math.pow_fx((vec1[i]-vec2[i]), 2)\n    return mpc_math.sqrt(sum_val)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "num_occurrence", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    # Initialize the counter to 0\n    count = sint(0)\n\n    # Iterate over the array\n    for item in arr:\n        # Check if the item is equal to the target\n        if item == target:\n            # If so, increment the count\n            count = count + 1\n\n    return count\n", "response_1": "Compiler.types import *\n\ndef num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sint.Array(1)\n    count[0] = 0\n\n    for item in arr:\n        if item == target:\n            count[0] = count[0] + 1\n\n    return count[0]\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "palindrome", "response_0": "import Compiler.types as ct\n\ndef palindrome(arr: ct.Array(None, ct.sint)) -> ct.sint:\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    length = len(arr)\n    flag = ct.sint(1)\n    for i in range(length):\n        flag &= (arr[i] == arr[length - 1 - i])\n    return flag\n", "response_1": "import Compiler\nfrom Compiler.types import sfix, sint\n\ndef palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    flag = sint(1)\n    for i in range(len(arr)):\n        flag = flag & (arr[i] == arr[len(arr) - 1 - i])\n    return flag\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array. \n    \"\"\"\n    num = sint(0)\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            if arr[i]>arr[j]:\n                num = num + 1\n    return num\n\n# This code will be executed by the MP-SPDZ party with the given index.\n# The function parameters are inputs to the function.\n# For instance, if we are the party with index 0, we receive the inputs to\n# the function from the other parties.\nif __name__ == '__main__':\n    import sys\n    arr = list(map(sint, sys.argv[1:]))\n    output = reverse_order_pair(arr)\n    print(output)\n\n", "response_1": "from Compiler.types import sint\nfrom Compiler.sorting import radix_sort\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array. \n    \"\"\"\n    num = sint(0)\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            if arr[i]>arr[j]:\n                num = num + 1\n    return num\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_of_cubes", "response_0": "from Compiler.types import sint, sfix, cint, sbitint\nimport mpc_math\n\ndef sum_of_cubes_MPC(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sint.Array(len(arr)) \n    ret.assign_all(0) \n    for i in range(len(arr)):\n        ret[i] = mpc_math.pow_fx(arr[i], 3)\n    return ret.secure_sum()\n\n", "response_1": "import Compiler.types\n\ndef sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = Compiler.types.sfix()\n    for item in arr:\n        ret += item ** 3\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "max_element", "response_0": "import Compiler\nfrom Compiler.types import sint\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = current.max(item)\n    \n    return current\n", "response_1": "def max_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    from Compiler.types import sfix, sint\n    current = a[0]\n    for item in a:\n        current = current.bit_and(current >= item)\n    \n    return current\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_if_else", "response_0": "import Compiler.types as sint\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns Ture, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i].if_else(if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "response_1": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns Ture, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    # MP-SPDZ does not support loops\n    # Therefore, you need to define the array operation explicitly\n    for i in range(len(arr)):\n        arr[i] = if_func(arr[i]) + (1 - predicator(arr[i])) * (arr[i] - if_func(arr[i]))\n        arr[i] = else_func(arr[i]) + predicator(arr[i])) * (arr[i] - else_func(arr[i]))\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "inf_norm", "response_0": "from Compiler.types import sint\nimport mpc_math\n\ndef inf_norm(vec: list):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    sum = sint(0)\n    for item in vec:\n        sum = mpc_math.max(sum, abs(item))\n    return sum\n", "response_1": "from Compiler import types\n\ndef inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    sum = vec[0]\n    for item in vec:\n        sum = types.sfix.max(sum, item)\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_inc", "response_0": "from Compiler.types import Array\nfrom Compiler.library import for_range\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for_range(Array(len(arr)), lambda i: arr[i] += 1)\n    return arr\n", "response_1": "from Compiler.types import Array\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for i in range(arr.size()):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint, Array\n\ndef count_rises(arr: Array(length, sint)) -> sint:\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sint(0)\n    for i in range(length - 1):\n        if arr[i] < arr[i+1]:\n            count = count + 1\n    return count\n", "response_1": "from Compiler.types import Array, sint\n\ndef count_rises(arr: Array):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sint(0)\n    for i in range(len(arr)-1):\n        if arr[i]<arr[i+1]:\n            count += 1\n    return count\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "skip_at_zero", "response_0": "from Compiler.types import *\n\ndef skip_at_zero(array: sint.Array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    for i in range(len(array)):\n        array[i].cond_add(1, array[i] != 0)\n    return array\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    for i in range(len(array)):\n        if array[i]==0:\n            continue\n        array[i] += sint(1)\n    return array\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_intersect", "response_0": "def array_intersect(p,q):\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    length_p = len(p)\n    length_q = len(q)\n    result = sint(0)\n    for i in range(length_p):\n        for j in range(length_q):\n            result |= (p[i] == q[j]).get_bit()\n    return result.if_else(True, False)\n", "response_1": "from Compiler.types import sfix, sint\n\ndef array_intersect(p,q):\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    flag = sint(0)\n    for i in range(len(p)):\n        for j in range(len(q)):\n            flag = flag.bit_or(p[i].bit_and(q[j]))\n    return flag\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import tree_reduce\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    def squared_sum(a, b):\n        return a + b*b\n\n    sum = tree_reduce(squared_sum, vec)\n    return sfix.sqrt_fx(sum)\n", "response_1": "from Compiler.types import sfix\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0.0)\n    for item in vec:\n        sum += item**2\n    return sum.sqrt()\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_between", "response_0": "import Compiler.types as sint\n\ndef sum_between(arr: sint.Array, l: sint.sint, u: sint.sint) -> sint.sint:\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sint.sint(0)\n    for item in arr:\n        if l <= item and item <= u:\n            sum += item\n    return sum\n", "response_1": "import Compiler.types\n\ndef sum_between(arr: Compiler.types.sfix, l: Compiler.types.sfix, u: Compiler.types.sfix) -> Compiler.types.sfix:\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = Compiler.types.sfix(0)\n    for item in arr:\n        if l <= item and item <= u:\n            sum += item\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "largest_gap", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.library import tree_reduce\n\ndef largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = sfix.get_random(sfix, 0, 1)\n    for i in range(len(arr)-1):\n        if abs(arr[i+1]-arr[i]) > cur:\n            cur = abs(arr[i+1]-arr[i])\n    return cur\n", "response_1": "def largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    from Compiler.types import sint\n    cur = sint(0)\n    for i in range(len(arr)-1):\n        if abs(arr[i+1]-arr[i]) > cur:\n            cur = abs(arr[i+1]-arr[i])\n    return cur\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "totally_dominate", "response_0": "from Compiler.types import Array\n\ndef totally_dominate(a,b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    for i in range(len(a)):\n        if a[i]<amin:\n            amin = a[i]\n    for i in range(len(b)):\n        if b[i]>bmax:\n            bmax = b[i]\n    return amin>=bmax\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    for i in range(len(a)):\n        if a[i] < amin:\n            amin = a[i]\n    for i in range(len(b)):\n        if b[i] > bmax:\n            bmax = b[i]\n    return amin >= bmax\n\nsint_array_a = sint.Array(10)\nsint_array_b = sint.Array(10)\n\nsint_array_a[0:], sint_array_b[0:] = sint.input_from(0), sint.input_from(1)\n\n# Call the function\noutput = totally_dominate(sint_array_a, sint_array_b)\n\n# Output the result\noutput.output_as(sint)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "element_count", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.sorting import radix_sort\n\ndef element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    ret = sint.Array(1)  # Initialize the return value to 0\n    for item in arr:\n        if item == target:\n            ret += sint.Array([1])  # Increment the return value by 1\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    \"\"\"\n    Count the numer of times the target element occurs in the array. \n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        if item == target:\n            ret = ret + sint(1)\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "is_subarray", "response_0": "import Compiler\nfrom Compiler.types import Array\nfrom Compiler.oram import OptimalORAM\n\ndef is_subarray(c,d):\n    \"\"\"\n    Return wether the first array is a continuous subarray of the second array.\n    \"\"\"\n    size_c = c.length\n    size_d = d.length\n    for i in range(size_d-size_c+1):\n        flag = True\n        for j in range(size_c):\n            flag = flag and d[i+j]==c[j]\n        if flag:\n            return True\n    return False\n\nc = Array(None, int)\nd = Array(None, int)\nprint(is_subarray(c,d))\n", "response_1": "from Compiler.types import Array, sint, cint\n\ndef is_subarray(c: Array(None, sint), d: Array(None, sint)) -> cint:\n    \"\"\"\n    Return wether the first array is a continuous subarray of the second array.\n    \"\"\"\n    for i in range(len(d)):\n        if len(c)<=len(d)-i:\n            flag = cint(True)\n            for j in range(len(c)):\n                flag = flag & (d[i+j]==c[j])\n            if flag:\n                return cint(True)\n    return cint(False)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import Array, sint\n\ndef exists_5_or_7(arr: Array(len(arr), sint)):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    for item in arr:\n        if (item == 5) | (item == 7):\n            return True\n    return False\n", "response_1": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    for item in arr:\n        if item.eq(5).bit_or(item.eq(7)):\n            return sint(1)\n    return sint(0)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "variance", "response_0": "length = sfix(len(arr), 0)\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.sorting import radix_sort\n\ndef variance(arr):\n    \"\"\"\n    Return the variance of the array. \n    \"\"\"\n    average = sint(0)\n    variance = sfix(0)\n    length = len(arr)\n    for item in arr:\n        average += item * (2**-length) \n    for item in arr:\n        variance += (item-average)**2 * (2**-length)\n    return variance\n\nradix_sort(arr)\nvariance(arr)\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "is_ascending", "response_0": "from Compiler.types import Array\n\ndef is_ascending(arr: Array(None, 'sint')):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    for i in range(len(arr)-1):\n        if arr[i]>=arr[i+1]:\n            return False\n    return True\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import tree_reduce\n\ndef is_ascending(arr):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    for i in range(len(arr)-1):\n        if arr[i]>=arr[i+1]:\n            return sfix(0)\n    return sfix(1)\n\ndef main():\n    length = sfix.get_random(10)\n    arr = [sfix.get_random(100) for _ in range(length)]\n    arr = tree_reduce(lambda x, y: x.min(y), arr)\n    ascending = is_ascending(arr)\n    ascending.output()\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "xor_all", "response_0": "from Compiler.types import sint\n\ndef xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = sint(arr[0])\n    for i in range(1,len(arr)):\n        ret = ret.bit_xor(arr[i])\n    return ret\n", "response_1": "import Compiler.types as ct\n\ndef xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1,len(arr)):\n        ret = ct_bitwise_xor(ret, arr[i])\n    return ret\n\ndef ct_bitwise_xor(a, b):\n    \"\"\"\n    Custom function for bitwise XOR operation on two numbers.\n    It uses the bitwise XOR operator (^) which is equivalent to the XOR operation in MP-SPDZ.\n    \"\"\"\n    return a ^ b\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "upper_bound", "response_0": "import Compiler.types\n\ndef upper_bound(arr,x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = Compiler.types.sint(-1)\n    distance = Compiler.types.sfix()\n    found = Compiler.types.sbitint(0)\n\n    for i in Compiler.types.get_range(len(arr)):\n        if arr[i] > x:\n            if not found or (arr[i]-x) < distance:\n                ret = i\n                distance = arr[i]-x\n                found = Compiler.types.sbitint(1)\n    return ret\n", "response_1": "import Compiler.types as t\n\ndef upper_bound(arr,x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = t.cint(-1)\n    distance = t.sfix(0)\n    found = False\n    for i in range(len(arr)):\n        if arr[i]>x:\n            if not found or arr[i]-x<distance:\n                ret = i\n                distance = arr[i]-x\n                found = True\n    return ret\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler.types import sint\n\ndef array_process_then_sum(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        sum = sum + arr[i]\n    return sum\n", "response_1": "from Compiler.types import sfix, sint, Array\nfrom Compiler.library import for_range\n\ndef array_process_then_sum(arr: Array(len(arr), sfix), func: function):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = sint(0)\n    for i in for_range(0, len(arr)):\n        arr[i] = func(arr[i])\n        sum = sum + arr[i]\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "average", "response_0": "from Compiler.types import sint\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        sum += arr[i]\n    ret = sum/len(arr)\n    return ret\n", "response_1": "import Compiler.types\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = 0\n    length = len(arr)\n    for i in range(length):\n        sum = sum + arr[i]\n    ret = sum/length\n    return ret\n\ncompiler = Compiler(avverage)\n\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "array_filter", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\nfrom Compiler.library import Vectorize\n\ndef array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    @Vectorize(arr, sint)\n    def _vec_filter(idx):\n        arr[idx] = sint(arr[idx]) if predicator(arr[idx]) else sint(0)\n\n    for_range(0, len(arr), _vec_filter)\n    return arr\n", "response_1": "from Compiler.types import Array, sint\n\ndef array_filter(arr: Array(sint, len(arr)), predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns Ture, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = sint(arr[i] if predicator(arr[i]) else 0)\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_up", "response_0": "from Compiler.types import sfix, sint\nimport Compiler.library as lib\n\ndef sum_up(array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    sum = sint(0)\n    for num in array:\n        sum += num\n    return sum\n", "response_1": "# Import necessary modules\nfrom Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_up(array: sint.Array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    sum = sint(0)\n    for i in for_range(0, len(array)):\n        sum = sum + array[i]\n    return sum\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "negative_to_zero", "response_0": "from Compiler.types import Array\n\ndef negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    array_type = array.value_type\n    array_length = array.length\n    array = Array.create_from(array)\n\n    for i in range(array_length):\n        if array[i] >= 0:\n            continue\n        array[i] = array_type(0)\n\n    return array\n", "response_1": "def negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    length = len(array)\n    for i in range(length):\n        if array[i] >= 0:\n            continue\n        array[i] = 0\n    return array\n\nfrom Compiler.types import sfix\n\ndef mpc_negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the MPC array to zero\n    \"\"\"\n    length = len(array)\n    for i in range(length):\n        if array[i] >= 0:\n            continue\n        array[i] = 0\n    return array\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "sum_only_positive_to_ten", "response_0": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = 0\n    for i in range(len(array)):\n        if array[i]<=0:\n            continue\n        if sum >= 10:\n            break\n        sum = sum + array[i]\n    return sum\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range, print_ln\n\ndef sum_only_positive_to_ten(array):\n    sum_reg = sint(0)\n\n    @for_range(sint(0), sint(len(array)), name='i')\n    def compute_sum(i):\n        nonlocal sum_reg\n        if array[i] <= 0:\n            return\n        if sum_reg >= 10:\n            return\n        sum_reg += array[i]\n\n    return sum_reg\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
{"test_name": "bubble_sort", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.sorting import radix_sort\n\ndef radix_sort_mpc(arr):\n    \"\"\"\n    Perform radix sort to the array. \n    \"\"\"\n    radix_sort(arr, sfix)\n    return arr\n\n", "response_1": "def bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array.\n    \"\"\"\n    from Compiler.types import sint\n    length = len(arr)\n    for i in range(length-1):\n        for j in range(length-1-i):\n            if arr[j]>=arr[j+1]:\n                temp = arr[j]\n                arr[j] = arr[j+1]\n                arr[j+1] = temp\n    return arr\n", "model_name": "deepseek-ai/deepseek-coder-33b-instruct"}
