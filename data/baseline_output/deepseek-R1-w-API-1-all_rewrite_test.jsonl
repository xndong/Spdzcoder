{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    new_arr = arr.value_type.Array(arr.length)\n    # Copy elements before index\n    new_arr.assign(arr.get_part(0, index), base=0)\n    # Copy elements after index\n    after_length = arr.length - index - 1\n    new_arr.assign(arr.get_part(index + 1, after_length), base=index)\n    # Add original element at index to last position\n    new_arr[arr.length - 1] = arr[index]\n    return new_arr\n", "response_1": "def move_to_end(arr, index):\n    n = arr.length\n    new_arr = arr.value_type.Array(n)\n    @for_range(n)\n    def _(i):\n        cond1 = i < index\n        cond2 = (i >= index) * (i < (n - 1))\n        cond3 = i == (n - 1)\n        val = cond1 * arr[i] + cond2 * arr[i + 1] + cond3 * arr[index]\n        new_arr[i] = val\n    return new_arr\n", "model_name": "deepseek-r1"}
{"test_name": "second_largest", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef second_largest(arr):\n    a = MemValue(arr[0])\n    b = MemValue(arr[1])\n    n = len(arr)\n    \n    @for_range(2, n)\n    def _(i):\n        current = arr[i]\n        cond1 = (current > a.read()) | (current > b.read())\n        cond2 = a.read() < b.read()\n        \n        new_a = cond1.if_else(cond2.if_else(current, a.read()), a.read())\n        new_b = cond1.if_else(cond2.if_else(b.read(), current), b.read())\n        \n        a.write(new_a)\n        b.write(new_b)\n    \n    return (a.read() < b.read()).if_else(a.read(), b.read())\n", "response_1": "from library import for_range\n\ndef second_largest(arr):\n    first = arr[0]\n    second = arr[1]\n    \n    @for_range(2, len(arr))\n    def _(i):\n        current = arr[i]\n        cond_or = (current > first).bit_or(current > second)\n        smaller_cond = first < second\n        \n        new_first = cond_or.if_else(\n            smaller_cond.if_else(current, first),\n            first\n        )\n        new_second = cond_or.if_else(\n            smaller_cond.if_else(second, current),\n            second\n        )\n        \n        first.update(new_first)\n        second.update(new_second)\n    \n    return (first < second).if_else(first, second)\n", "model_name": "deepseek-r1"}
{"test_name": "exists_true", "response_0": "from Compiler.library import tree_reduce\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    return tree_reduce(lambda x, y: x.bit_or(y), arr.get_vector())\n", "response_1": "from library import tree_reduce\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    return tree_reduce(lambda x, y: x.bit_or(y), arr.get_vector())\n", "model_name": "deepseek-r1"}
{"test_name": "array_indicator", "response_0": "from Compiler.types import Array\n\ndef array_indicator(arr, predicator):\n    vec = arr.get_vector()\n    ret_vec = [predicator(e) for e in vec]\n    return Array.create_from(ret_vec)\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef array_indicator(arr):\n    length = len(arr)\n    value_type = type(arr.value_type) if hasattr(arr, 'value_type') else sint\n    ret = value_type.Array(length)\n    \n    @for_range(length)\n    def _(i):\n        e = arr[i]\n        ret[i] = e != 0  # Example predicate, replace with actual condition\n    \n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "inner_product", "response_0": "from Compiler.library import tree_reduce\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    product_vector = vec1.get_vector() * vec2.get_vector()\n    summation = tree_reduce(lambda a, b: a + b, product_vector)\n    return summation\n", "response_1": "from Compiler.library import tree_reduce\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret arrays.\n    \"\"\"\n    products = vec1[:] * vec2[:]\n    summation = tree_reduce(lambda a, b: a + b, products)\n    return summation\n", "model_name": "deepseek-r1"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    n = a.length\n    shifted = a.same_shape()\n    for i in range(n):\n        src_index = (i - 1) % n\n        shifted[i] = a[src_index]\n    return shifted\n", "response_1": "from Compiler.types import *\n\ndef array_shift(a):\n    n = len(a)\n    shifted = a.value_type.Array(n)\n    for i in range(n):\n        j = (i - 1) % n\n        shifted[i] = a[j]\n    return shifted\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        cmp = arr[i] > bound\n        ret[i] = cmp.if_else(sint(1), sint(0))\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] > bound)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "count_rises_2", "response_0": "from library import for_range\n\ndef count_rises(arr):\n    n = arr.length\n    flag = sint.Array(n - 1)\n    \n    @for_range(n - 1)\n    def _(i):\n        comparison = arr[i] < arr[i + 1]\n        flag[i] = comparison.if_else(sint(1), sint(0))\n    \n    count = sum(flag.get_vector())\n    return count\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint, MemValue\n\ndef count_rises(arr):\n    count = MemValue(sint(0))\n    n = len(arr)\n    \n    def loop_body(i):\n        cmp_result = arr[i] < arr[i+1]\n        summand = cmp_result.if_else(sint(1), sint(0))\n        count.iadd(summand)\n    \n    for_range(n-1)(loop_body)\n    return count.read()\n", "model_name": "deepseek-r1"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef choppy_plus_minus(arr):\n    n = arr.length\n    result = type(arr[0]).Array(n)\n    for i in range(n):\n        if i % 2:\n            result[i] = arr[i] + 1\n        else:\n            result[i] = arr[i] - 1\n    return result\n", "response_1": "def choppy_plus_minus(arr):\n    length = arr.length\n    for i in range(length):\n        if i % 2 == 0:\n            arr[i] = arr[i] - 1\n        else:\n            arr[i] = arr[i] + 1\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    # Check if a is zero (secret condition)\n    a_zero = a == 0\n    # Handle linear case (a=0)\n    b_non_zero = b != 0\n    linear_result = b_non_zero.if_else(sint(1), sint(0))\n    \n    # Handle quadratic case (a\u22600)\n    discriminant = b * b - 4 * a * c\n    gt_zero = discriminant > 0\n    eq_zero = discriminant == 0\n    \n    # Nested conditionals for discriminant evaluation\n    quad_result = gt_zero.if_else(sint(2), eq_zero.if_else(sint(1), sint(0)))\n    \n    # Final result selection using secure multiplexer\n    return a_zero.if_else(linear_result, quad_result)\n", "response_1": "from library import if_else\n\ndef how_many_roots(a, b, c):\n    a_zero = a == 0\n    b_zero = b == 0\n    \n    # Handle a=0 case\n    linear_case = b_zero.if_else(sint(0), sint(1))\n    \n    # Compute discriminant\n    disc = b * b - 4 * a * c\n    disc_gt_zero = disc > 0\n    disc_eq_zero = disc == 0\n    \n    # Handle quadratic cases\n    quadratic_case = disc_gt_zero.if_else(\n        sint(2),\n        disc_eq_zero.if_else(sint(1), sint(0))\n    )\n    \n    return a_zero.if_else(linear_case, quadratic_case)\n", "model_name": "deepseek-r1"}
{"test_name": "count_satisfied", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint, MemValue\n\ndef count_satisfied(arr, predicator):\n    \"\"\"Count the number of elements satisfying the predicate\"\"\"\n    n = arr.length\n    flags = sint.Array(n)\n    \n    # Generate secret binary flags\n    @for_range(n)\n    def _(i):\n        flags[i] = predicator(arr[i]).if_else(sint(1), sint(0))\n    \n    # Sum flags using memory value for accumulation\n    sum_total = MemValue(sint(0))\n    @for_range(n)\n    def _(j):\n        sum_total.iadd(flags[j])\n        \n    return sum_total.read()\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\nfrom Compiler import for_range\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    n = len(arr)\n    flag = sint.Array(n)\n    \n    @for_range(n)\n    def _(i):\n        flag[i] = predicator(arr[i])\n    \n    summmation = tree_reduce(lambda a, b: a + b, flag.get_vector())\n    return summmation\n", "model_name": "deepseek-r1"}
{"test_name": "traverse_and_sum", "response_0": "from library import tree_reduce\n\ndef traverse_and_sum(arr1, arr2):\n    # Get element-wise product vectors using vectorized multiplication\n    product_vector = arr1.get_vector() * arr2.get_vector()\n    \n    # Sum all elements using binary tree reduction for efficiency\n    total_sum = tree_reduce(lambda a,b: a + b, product_vector)\n    \n    return total_sum\n", "response_1": "from Compiler.library import tree_reduce\n\ndef traverse_and_sum(arr1, arr2):\n    product_vector = arr1.get_vector() * arr2.get_vector()\n    return tree_reduce(lambda a,b: a + b, product_vector)\n", "model_name": "deepseek-r1"}
{"test_name": "array_round", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef array_round(arr):\n    n = len(arr)\n    res = sint.Array(n)\n    \n    @for_range(n)\n    def _(i):\n        res[i] = sint(arr[i])\n    \n    return res\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.library import *\n\ndef array_round(arr):\n    ret = sint.Array(len(arr))\n    vec = arr.get_vector()\n    half = 1 << (sfix.f - 1)\n    rounded = (vec.v + half) >> sfix.f\n    ret.assign_vector(rounded)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater_eq", "response_0": "from Compiler import library\n\ndef array_greater_eq(arr, brr):\n    n = len(arr)\n    ret = sint.Array(n)\n    @library.for_range(n)\n    def _(i):\n        ret[i] = sint(arr[i] >= brr[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    n = arr.length\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = sint(arr[i] >= brr[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "indicate_negative", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef indicate_negative(arr):\n    length = len(arr)\n    ret = sint.Array(length)\n    @for_range(length)\n    def _(i):\n        ret[i] = sint(arr[i] < 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    n = arr.length\n    ret = sint.Array(n)\n    for i in range(n):\n        # Compare element to zero and convert boolean to 0/1 secret integer\n        ret[i] = (arr[i] < 0).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b):\n    max_len = max(len(a), len(b))\n    value_type = type(a[0]) if len(a) > 0 else (type(b[0]) if len(b) > 0 else sint)\n    \n    a_pad = a.get_vector()\n    if len(a) < max_len:\n        a_pad += [value_type(0)] * (max_len - len(a))\n    \n    b_pad = b.get_vector()\n    if len(b) < max_len:\n        b_pad += [value_type(0)] * (max_len - len(b))\n    \n    result = [x - y for x, y in zip(a_pad, b_pad)]\n    return value_type.Array.create_from(result)\n", "response_1": "from Compiler.types import *\n\ndef array_subtract(a, b):\n    len_a = a.length\n    len_b = b.length\n    max_len = max(len_a, len_b)\n    min_len = min(len_a, len_b)\n    value_type = type(a[0])\n    result = value_type.Array(max_len)\n    \n    for i in range(min_len):\n        result[i] = a[i] - b[i]\n    \n    if len_a > len_b:\n        for i in range(min_len, max_len):\n            result[i] = a[i]\n    else:\n        for i in range(min_len, max_len):\n            result[i] = -b[i]\n    \n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    result = arr.same_shape()\n    for i in range(arr.length):\n        result[i] = func(arr[i])\n    return result\n", "response_1": "def array_process(arr):\n    \"\"\"\n    Process all elements in the input array with element-wise operations.\n    \"\"\"\n    processed = [e * e for e in arr.get_vector()]  # Replace '*' with actual operation\n    new_arr = arr.same_shape()\n    new_arr.assign_vector(processed)\n    return new_arr\n", "model_name": "deepseek-r1"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = a.length\n    shifted_vector = a.get_vector(n-1, 1) + a.get_vector(0, n-1)\n    result = a.same_shape()\n    result.assign_vector(shifted_vector)\n    return result\n", "response_1": "from Compiler.types import Array\n\ndef array_shift(a):\n    n = a.length\n    last_part = a.get_part(n - 1, 1)\n    rest_part = a.get_part(0, n - 1)\n    return last_part.concat(rest_part)\n", "model_name": "deepseek-r1"}
{"test_name": "compare_and_select", "response_0": "from Compiler.types import *\n\ndef compare_and_select(a, b):\n    a_vec = a.get_vector()\n    b_vec = b.get_vector()\n    result_vec = [x.max(y) for x,y in zip(a_vec, b_vec)]\n    return a.value_type.Array.create_from(result_vec)\n", "response_1": "def compare_and_select(a, b):\n    ret_array = a.same_shape()\n    for i in range(len(a)):\n        ret_array[i] = a[i].max(b[i])\n    return ret_array\n", "model_name": "deepseek-r1"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b, len_a, len_b):\n    max_len = max(len_a, len_b)\n    new_a = sfix.Array(max_len)\n    new_b = sfix.Array(max_len)\n    \n    new_a.assign_vector(a.get_vector())\n    new_b.assign_vector(b.get_vector())\n    \n    @for_range(len_a, max_len)\n    def _(i):\n        new_a[i] = sfix(0)\n        \n    @for_range(len_b, max_len)\n    def _(i):\n        new_b[i] = sfix(0)\n    \n    return sfix.Array.create_from(new_a.get_vector() - new_b.get_vector())\n", "response_1": "from library import for_range\nfrom compiler.types import sfix, Array\n\ndef array_subtract(a, b):\n    max_len = max(a.length, b.length)\n    \n    # Pad first array with zeros if needed\n    padded_a = sfix.Array(max_len)\n    padded_a.assign(a.get_vector())\n    @for_range(a.length, max_len)\n    def _(i):\n        padded_a[i] = sfix(0)\n    \n    # Pad second array with zeros if needed\n    padded_b = sfix.Array(max_len)\n    padded_b.assign(b.get_vector())\n    @for_range(b.length, max_len)\n    def _(i):\n        padded_b[i] = sfix(0)\n    \n    # Perform element-wise subtraction\n    result = sfix.Array(max_len)\n    @for_range(max_len)\n    def _(i):\n        result[i] = padded_a[i] - padded_b[i]\n    \n    return Array.create_from(result.get_vector())\n", "model_name": "deepseek-r1"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c.concat(c)\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c.concat(c)\n", "model_name": "deepseek-r1"}
{"test_name": "zeros", "response_0": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = cint.Array(num)\n    array.assign_all(0)\n    return array\n", "response_1": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = cfix.Array(num)\n    array.assign_all(0)\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "clip", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sfix, cfix\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    upper_bound = cfix(upper_bound)\n    lower_bound = cfix(lower_bound)\n    n = len(arr)\n    result = sfix.Array(n)\n    \n    @for_range(n)\n    def _(i):\n        x = arr[i]\n        clipped = x.max(lower_bound).min(upper_bound)\n        result[i] = clipped\n    \n    return result\n", "response_1": "def clip(arr, upper_bound=1, lower_bound=-1):\n    n = len(arr)\n    result = sfix.Array(n)\n    s_upper = sfix(upper_bound)\n    s_lower = sfix(lower_bound)\n    \n    @for_range(n)\n    def _(i):\n        x = arr[i]\n        cond_upper = x >= s_upper\n        cond_lower = x > s_lower\n        clipped = cond_upper.if_else(s_upper, cond_lower.if_else(x, s_lower))\n        result[i] = clipped\n        \n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "count_satisfied_2", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    flags = []\n    for element in arr:\n        flags.append(predicator(element))\n    summation = tree_reduce(lambda a,b: a + b, flags)\n    return summation\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef count_satisfied(arr):\n    \"\"\"\n    Count the number of secret integer elements satisfying a predicate.\n    Replace the comparison operation with the actual predicate condition.\n    \"\"\"\n    summation = sint(0)\n    for i in range(len(arr)):\n        # Replace 'arr[i] != 0' with actual predicate condition\n        flag = (arr[i] != 0)\n        summation += flag\n    return summation\n", "model_name": "deepseek-r1"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint\nfrom Compiler.types import Array\nfrom Compiler.library import sum\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    count = sint(0)\n    n = len(arr)\n    for i in range(n):\n        current = arr[i]\n        sub_arr = arr.get_vector(i, n - i)\n        comparisons = current > sub_arr\n        sum_bits = sum([bit.if_else(sint(1), sint(0)) for bit in comparisons])\n        count += sum_bits\n    return count\n", "response_1": "from library import for_range\nfrom compiler.types import sint\n\ndef reverse_order_pair(arr):\n    n = arr.length\n    count = sint(0)\n    \n    @for_range(n)\n    def _(i):\n        remaining = n - i - 1\n        @for_range(remaining)\n        def _(j):\n            current_j = i + 1 + j\n            count.iadd(arr[i] > arr[current_j])\n    \n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    result = arr.same_shape()\n    result.assign_vector(arr.get_vector() + 1)\n    return result\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    incremented = arr.get_vector() + 1\n    return sint.Array.create_from(incremented)\n", "model_name": "deepseek-r1"}
{"test_name": "count_rises", "response_0": "from Compiler import library\n\ndef count_rises(arr):\n    count = arr.value_type(0)\n    n = arr.length\n    for i in library.for_range(n - 1):\n        count += (arr[i] < arr[i+1]).if_else(arr.value_type(1), arr.value_type(0))\n    return count\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef count_rises(arr):\n    count = sint(0)\n    n = len(arr)\n    for i in for_range(n - 1):\n        x = arr[i]\n        y = arr[i + 1]\n        count += (x < y).if_else(sint(1), sint(0))\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "array_process_2", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import *\n\ndef array_process(arr):\n    result = arr.same_shape()\n    @for_range(arr.length)\n    def _(i):\n        result[i] = arr[i]  # Replace with actual processing function\n    return result\n", "response_1": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    processed = [func(x) for x in arr.get_vector()]\n    return type(arr).create_from(processed)\n", "model_name": "deepseek-r1"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    from mpc_math import sqrt\n    from library import tree_reduce\n    \n    squared = [x * x for x in vec.get_vector()]\n    sum_squares = tree_reduce(lambda a,b: a + b, squared)\n    return sqrt(sum_squares)\n", "response_1": "from library import mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum_squares = sfix(0)\n    for x in vec:\n        sum_squares += x * x\n    return mpc_math.sqrt(sum_squares)\n", "model_name": "deepseek-r1"}
{"test_name": "totally_dominate", "response_0": "from library import tree_reduce\n\ndef totally_dominate(a, b):\n    amin = tree_reduce(lambda x, y: x.min(y), a)\n    bmax = tree_reduce(lambda x, y: x.max(y), b)\n    return sint(amin >= bmax)\n", "response_1": "from Compiler.library import tree_reduce\n\ndef totally_dominate(a, b):\n    a_min = tree_reduce(lambda x,y: x.min(y), a.get_vector())\n    b_max = tree_reduce(lambda x,y: x.max(y), b.get_vector())\n    return (a_min >= b_max).reveal()\n", "model_name": "deepseek-r1"}
{"test_name": "inner_product_2", "response_0": "from Compiler import library\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    product_vector = vec1.get_vector() * vec2.get_vector()\n    return library.tree_reduce(lambda a, b: a + b, product_vector)\n", "response_1": "from Compiler.library import tree_reduce\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    products = vec1.get_vector() * vec2.get_vector()\n    return tree_reduce(lambda a, b: a + b, products)\n", "model_name": "deepseek-r1"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    ret_type = a.value_type\n    ret = ret_type.Array(len(indices))\n    for j in range(len(indices)):\n        ret[j] = a[indices[j]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    ret = a.value_type.Array(len(indices))\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "exists_5_or_7", "response_0": "from library import tree_reduce\nfrom Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    vec = arr.get_vector()\n    is_5_or_7 = (vec == 5) | (vec == 7)\n    return tree_reduce(lambda a,b: a | b, is_5_or_7)\n", "response_1": "from Compiler.library import tree_reduce\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    n = arr.length\n    flags = []\n    for i in range(n):\n        item = arr[i]\n        flag = (item == 5) | (item == 7)\n        flags.append(flag)\n    any_flag = tree_reduce(lambda a, b: a | b, flags)\n    return sint(any_flag)\n", "model_name": "deepseek-r1"}
{"test_name": "remove_by_index", "response_0": "from Compiler.types import Array\n\ndef remove_by_index(arr, index):\n    new_length = arr.length - 1\n    ret = arr.value_type.Array(new_length)\n    first_part = arr.get_part(0, index)\n    second_part = arr.get_part(index + 1, new_length - index)\n    ret.assign(first_part, base=0)\n    ret.assign(second_part, base=index)\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    # Get the original array's length (must be known at compile time)\n    N = arr.length\n    # Create a new array of length N-1\n    ret = type(arr)(N - 1)\n    # Populate the new array while skipping the index\n    for i in range(N - 1):\n        # Calculate original index: j = i if i < index else i+1\n        j = i + (i >= index)\n        ret[i] = arr[j]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "average", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import tree_reduce\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = tree_reduce(lambda a, b: a + b, arr.get_vector())\n    length = arr.length if arr.length is not None else 0\n    return summmation / length\n", "response_1": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef average(arr):\n    summation = sum(arr.get_vector())\n    length = cfix(arr.sizes[0] if isinstance(arr, (MultiArray, Matrix)) else arr.length)\n    return summation / length\n", "model_name": "deepseek-r1"}
