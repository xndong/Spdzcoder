{"test_name": "indicate_positive", "response_0": "def indicate_positive(arr):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        comp = arr[i] > 0\n        ret[i] = comp.if_else(sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef indicate_positive(arr):\n    n = arr.length if isinstance(arr, Array) else len(arr)\n    ret = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        is_positive = arr[i] > 0\n        ret[i] = is_positive.if_else(sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_xor", "response_0": "from Compiler.types import sint\n\ndef array_xor(a, b):\n    \"\"\"\n    Compute the elementwise XOR of the two input vectors.\n    \"\"\"\n    ret = sint.Array(len(a))\n    for i in range(len(a)):\n        ret[i] = a[i].bit_xor(b[i])\n    return ret\n", "response_1": "def array_xor(a, b):\n    ret = sint.Array(len(a))\n    for i in range(len(a)):\n        ret[i] = a[i].bit_xor(b[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "interlaced_placement", "response_0": "def interlaced_placement(a, b):\n    n = a.length\n    ret_type = type(a)\n    ret = ret_type.Array(2 * n)\n    \n    @for_range(2 * n)\n    def _(i):\n        idx = i // 2\n        if i % 2:\n            ret[i] = b[idx - 1]\n        else:\n            ret[i] = a[idx]\n    \n    return ret\n", "response_1": "def interlaced_placement(a, b):\n    interleaved = []\n    for i in range(len(a)):\n        interleaved.append(a[i])\n        interleaved.append(b[i])\n    return sint.Array.create_from(interleaved)\n", "model_name": "deepseek-r1"}
{"test_name": "array_and", "response_0": "def array_and(a, b):\n    \"\"\"\n    Compute the elementwise AND of two secret integer arrays.\n    \"\"\"\n    return sint.Array.create_from(a.get_vector().bit_and(b.get_vector()))\n", "response_1": "from Compiler.types import sint\n\ndef array_and(a, b):\n    \"\"\"\n    Compute the elementwise AND of the two input vectors.\n    \"\"\"\n    length = len(a)\n    result = sint.Array(length)\n    for i in range(length):\n        result[i] = a[i].bit_and(b[i])\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "array_indicator", "response_0": "from Compiler.GC.types import sbitint\nfrom Compiler.library import *\n\ndef array_indicator(arr, predicator):\n    ret = sbitint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        # Replace with actual predicate logic using arr[i]\n        # Example: ret[i] = (arr[i] > 5).if_else(sint(1), sint(0))\n        condition = predicator(arr[i])  # predicator should return sbit/sintbit\n        ret[i] = condition.if_else(sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef array_greater_than_scalar(arr, bound):\n    ret = sbitint.Array(arr.length)\n    @for_range(arr.length)\n    def _(i):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        comparison = arr[i] > bound\n        ret[i] = comparison.if_else(sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_no_greater_than_scalar", "response_0": "from Compiler.types import sint\n\ndef array_no_greater_than_scalar(arr, bound):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] <= bound)\n    return ret\n", "response_1": "from Compiler.types import *\nfrom Compiler.GC.types import sbitint\nfrom Compiler.library import *\n\ndef array_no_greater_than_scalar(arr, bound):\n    ret = sbitint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] <= bound\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    \"\"\"\n    Reverse the input array and concatenate it to the original array.\n    \"\"\"\n    reversed_vector = a.get_reverse_vector()\n    reversed_arr = type(a).create_from(reversed_vector)\n    return a.concat(reversed_arr)\n", "response_1": "from Compiler.types import Array\n\ndef reverse_and_concat(a):\n    reversed_vector = a.get_reverse_vector()\n    reversed_array = a.value_type.Array.create_from(reversed_vector)\n    return a.concat(reversed_array)\n", "model_name": "deepseek-r1"}
{"test_name": "array_round", "response_0": "def array_round(arr):\n    from Compiler.types import sint, sfix\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        x = arr[i]\n        int_part = sint(x)\n        fractional_part = x - int_part\n        is_negative = x < 0\n        has_fraction = (fractional_part != 0)\n        adjustment = is_negative.bit_and(has_fraction)\n        floor_part = int_part - adjustment.if_else(1, 0)\n        adjusted_fractional = x - floor_part\n        round_up = adjusted_fractional >= 0.5\n        ret[i] = floor_part + round_up.if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef array_round(arr):\n    n = len(arr)\n    result = sint.Array(n)\n    @for_range_opt(n)\n    def _(i):\n        x = arr[i]\n        int_trunc = x.get_int()\n        fractional_trunc = x - int_trunc\n        is_negative = x < 0\n        has_fraction = fractional_trunc != 0\n        adjustment = is_negative * has_fraction\n        floor = int_trunc - adjustment\n        fractional = x - sfix(floor)\n        round_up = fractional >= 0.5\n        result[i] = floor + round_up.if_else(1, 0)\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater_eq", "response_0": "from library import for_range\n\ndef array_greater_eq(arr, brr):\n    n = len(arr)\n    ret = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        comparison = arr[i] >= brr[i]\n        ret[i] = comparison.if_else(sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef array_greater_eq(arr, brr):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] >= brr[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "reverse", "response_0": "def reverse(arr):\n    n = arr.length\n    ret = arr.same_shape()\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "response_1": "def reverse(arr):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    reversed_arr = arr.same_shape()\n    for i in range(len(arr)):\n        reversed_arr[i] = arr[len(arr)-1 - i]\n    return reversed_arr.create_from(reversed_arr.get_vector())\n", "model_name": "deepseek-r1"}
{"test_name": "indicate_negative", "response_0": "from Compiler.library import for_range\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        is_negative = arr[i] < 0\n        ret[i] = is_negative.if_else(sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef indicate_negative(arr):\n    n = arr.length\n    ret = sint.Array(n)\n    for i in range(n):\n        # Compare element with 0 and convert result to secret integer\n        ret[i] = sint(arr[i] < 0)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "max_sub_sequence", "response_0": "from Compiler import types\nfrom Compiler.library import for_range\n\ndef max_sub_sequence(arr):\n    n = len(arr)\n    partial_max = types.sint.Array(n)\n    suffix_max = types.sint.Array(n)\n    \n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    \n    @for_range(1, n)\n    def _(i):\n        prev_suffix = suffix_max[i-1]\n        condition = prev_suffix >= 0\n        new_suffix = condition.if_else(prev_suffix + arr[i], arr[i])\n        suffix_max[i] = new_suffix\n        \n        prev_partial = partial_max[i-1]\n        partial_max[i] = prev_partial.max(new_suffix)\n    \n    return partial_max[n-1]\n", "response_1": "from Compiler import library\nfrom Compiler.types import sint\n\ndef max_sub_sequence(arr):\n    n = len(arr)\n    partial_max = sint.Array(n)\n    suffix_max = sint.Array(n)\n    \n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    \n    def loop_body(i):\n        suffix_prev = suffix_max[i-1]\n        cond_suffix = (suffix_prev >= 0)\n        new_suffix = cond_suffix.if_else(suffix_prev + arr[i], arr[i])\n        suffix_max[i] = new_suffix\n        \n        partial_prev = partial_max[i-1]\n        cond_partial = (partial_prev >= new_suffix)\n        new_partial = cond_partial.if_else(partial_prev, new_suffix)\n        partial_max[i] = new_partial\n    \n    library.for_range(1, n)(loop_body)\n    \n    return partial_max[n-1]\n", "model_name": "deepseek-r1"}
{"test_name": "compare_and_select", "response_0": "from Compiler import library\nfrom Compiler.types import *\n\ndef compare_and_select(a, b):\n    ret_array = a.same_shape()\n    @library.for_range(a.length)\n    def _(i):\n        ret_array[i] = a[i].max(b[i])\n    return ret_array\n", "response_1": "from Compiler.types import sint, Array\n\ndef compare_and_select(a, b):\n    length = len(a)\n    ret_array = Array(length, sint)\n    for i in range(length):\n        ret_array[i] = (a[i] > b[i]).if_else(a[i], b[i])\n    return ret_array\n", "model_name": "deepseek-r1"}
{"test_name": "count_element_frequency", "response_0": "from Compiler import library\nfrom Compiler.types import sint\n\ndef count_element_frequency(l):\n    n = len(l)\n    ret = sint.Array(n)\n    \n    @library.for_range(n)\n    def _(i):\n        current = l[i]\n        count = sint(0)\n        \n        @library.for_range(n)\n        def _(j):\n            eq = (l[j] == current)\n            count.iadd(eq.if_else(sint(1), sint(0)))\n            \n        ret[i] = count\n        \n    return ret\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef count_element_frequency(l):\n    n = l.length\n    ret = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        sum_total = MemValue(sint(0))\n        @for_range(n)\n        def _(j):\n            eq = l[j] == l[i]\n            sum_total.iadd(eq.if_else(sint(1), sint(0)))\n        ret[i] = sum_total.read()\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_or", "response_0": "def array_or(a, b):\n    ret = sint.Array(len(a))\n    for i in range(len(a)):\n        ret[i] = sint((a[i] != 0) | (b[i] != 0))\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_or(a, b):\n    ret = sint.Array(len(a))\n    for i in range(len(a)):\n        ret[i] = a[i].bit_or(b[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "stock_predicator", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef stock_predicator(days):\n    n = len(days)\n    lowest = sint.Array(n)\n    partial_max = sint.Array(n)\n    \n    lowest[0] = days[0]\n    partial_max.assign_all(sint(0))\n    \n    @for_range(1, n)\n    def _(i):\n        prev_low = lowest[i-1]\n        current_price = days[i]\n        \n        # Update lowest price\n        new_low = prev_low.min(current_price)\n        lowest[i] = new_low\n        \n        # Calculate potential profit\n        profit = current_price - prev_low\n        \n        # Update maximum profit\n        prev_max = partial_max[i-1]\n        new_max = prev_max.max(profit)\n        partial_max[i] = new_max\n    \n    return partial_max[n-1]\n", "response_1": "from library import for_range\n\ndef stock_predicator(days):\n    n = len(days)\n    lowest = sint.Array(n)\n    partial_max = sint.Array(n)\n    \n    lowest[0] = days[0]\n    partial_max.assign_all(sint(0))\n    \n    @for_range(n-1)\n    def _(i):\n        current_i = i + 1\n        lowest_prev = lowest[current_i - 1]\n        day_i = days[current_i]\n        \n        # Update lowest price\n        is_lower = (lowest_prev <= day_i)\n        lowest_i = is_lower.if_else(lowest_prev, day_i)\n        lowest[current_i] = lowest_i\n        \n        # Calculate current profit potential\n        current_profit = day_i - lowest_prev\n        \n        # Update maximum profit tracking\n        partial_max_prev = partial_max[current_i - 1]\n        is_higher = (partial_max_prev >= current_profit)\n        partial_max_i = is_higher.if_else(partial_max_prev, current_profit)\n        partial_max[current_i] = partial_max_i\n    \n    # Return max profit or 0 if negative\n    return partial_max[n-1].max(0)\n", "model_name": "deepseek-r1"}
{"test_name": "len5_inc_array", "response_0": "def len5_inc_array(init):\n    ret = sint.Array(5)\n    @for_range(5)\n    def _(i):\n        ret[i] = init + i\n    return ret\n", "response_1": "def len5_inc_array(init):\n    \"\"\"\n    Return an increase-by-one array with given initial element and length 5.\n    \"\"\"\n    return sint.Array.create_from([init + i for i in range(5)])\n", "model_name": "deepseek-r1"}
{"test_name": "cut_first_five", "response_0": "def cut_first_five(arr):\n    ret = sint.Array(5)\n    ret.assign_all(sint(0))\n    input_vector = arr.get_vector()\n    input_length = len(input_vector)\n    upper = min(5, input_length)\n    @for_range_opt(upper)\n    def _(i):\n        ret[i] = input_vector[i]\n    return ret\n", "response_1": "def cut_first_five(arr):\n    ret = arr.value_type.Array(5)\n    ret.assign_all(0)\n    for i in range(min(5, arr.length)):\n        ret[i] = arr[i]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "max_pooling_1d", "response_0": "from library import for_range\nfrom Compiler.types import sint, MemValue\n\ndef max_pooling_1d(vec, step):\n    ret_length = vec.length // step\n    ret = sint.Array(ret_length)\n    \n    @for_range(ret_length)\n    def _(i):\n        start_idx = i * step\n        current_max = MemValue(vec[start_idx])\n        @for_range(1, step)\n        def _(j):\n            element = vec[start_idx + j]\n            cond = element > current_max.read()\n            new_max = cond.if_else(element, current_max.read())\n            current_max.write(new_max)\n        ret[i] = current_max.read()\n    return ret\n", "response_1": "def max_pooling_1d(vec, step):\n    ret_length = len(vec) // step\n    ret = vec.value_type.Array(ret_length)\n    \n    for i in range(ret_length):\n        start = i * step\n        current_max = vec[start]\n        for j in range(1, step):\n            current_max = current_max.max(vec[start + j])\n        ret[i] = current_max\n    \n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_greater(arr, brr):\n    n = arr.length if 'length' in dir(arr) else len(arr)\n    ret = sint.Array(n)\n    for i in for_range(n):\n        greater = arr[i] > brr[i]\n        ret[i] = greater.if_else(sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater(arr, brr):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = (arr[i] > brr[i]).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "dumb_concat", "response_0": "def dumb_concat(arr, brr):\n    ret_length = arr.length + brr.length\n    ret = Array(ret_length, arr.value_type)\n    ret.assign(arr, 0)\n    ret.assign(brr, arr.length)\n    return ret\n", "response_1": "from Compiler.types import Array\n\ndef dumb_concat(arr, brr):\n    ret = arr.value_type.Array(arr.length + brr.length)\n    ret.assign(arr, 0)\n    ret.assign(brr, arr.length)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "indicator_if_else", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef indicator_if_else(a, b, ind):\n    c = sint.Array(len(ind))\n    @for_range(len(ind))\n    def _(i):\n        c[i] = ind[i].if_else(a[i], b[i])\n    return c\n", "response_1": "def indicator_if_else(a, b, ind):\n    c = sint.Array(len(ind))\n    for i in range(len(ind)):\n        c[i] = ind[i].if_else(a[i], b[i])\n    return c\n", "model_name": "deepseek-r1"}
{"test_name": "elementwise_multiplication", "response_0": "def elementwise_multiplication(a, b):\n    result = a.same_shape()\n    result.assign_vector(a.get_vector() * b.get_vector())\n    return result\n", "response_1": "def elementwise_multiplication(a, b):\n    result = a.same_shape()\n    result.assign_vector(a.get_vector() * b.get_vector())\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    ret = a.value_type.Array(len(indices))\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    ret = a.value_type.Array(len(indices))\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "inc_array", "response_0": "from Compiler.types import cint\n\ndef inc_array(num):\n    return cint.Array.create_from([cint(i+1) for i in range(num)])\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef inc_array(num):\n    arr = cint.Array(num)\n    @for_range(num)\n    def _(i):\n        arr[i] = i + 1\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "cut_last_five", "response_0": "def cut_last_five(arr):\n    ret = sint.Array(5)\n    ret.assign_all(sint(0))\n    vec = arr.get_vector()\n    arr_len = len(vec)\n    for i in range(5):\n        idx = arr_len - 1 - i\n        cond = idx >= 0\n        element = cond.if_else(vec[idx], sint(0))\n        ret[4 - i] = element\n    return ret.create_from(ret.get_vector())\n", "response_1": "from Compiler import library\nfrom Compiler.types import sint\n\ndef cut_last_five(arr):\n    ret = sint.Array(5)\n    ret.assign_all(0)\n    @library.for_range(5)\n    def _(i):\n        if i < arr.length:\n            src_idx = arr.length - 1 - i\n            dest_idx = 4 - i\n            ret[dest_idx] = arr[src_idx]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "average_pooling_1d", "response_0": "def average_pooling_1d(vec, step):\n    ret_length = vec.length // step\n    ret = sfix.Array(ret_length)\n    \n    @for_range(ret_length)\n    def _(i):\n        avg = sfix(0)\n        @for_range(step)\n        def _(j):\n            avg += vec[i * step + j] / cfix(step)\n        ret[i] = avg\n        \n    return ret\n", "response_1": "from compiler.library import for_range\nfrom types import sfix\n\ndef average_pooling_1d(vec, step):\n    ret_length = len(vec) // step\n    ret = sfix.Array(ret_length)\n    \n    @for_range(ret_length)\n    def _(i):\n        total = sfix(0)\n        @for_range(step)\n        def _(j):\n            total += vec[i * step + j]\n        ret[i] = total / step\n    \n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_relu", "response_0": "from Compiler.types import *\n\ndef array_relu(arr):\n    \"\"\"\n    Apply ReLU function elementwisely to the input array.\n    \"\"\"\n    length = len(arr)\n    ret = arr.value_type.Array(length)\n    for i in range(length):\n        ret[i] = arr[i].max(0)\n    return ret\n", "response_1": "from Compiler.types import Array\n\ndef array_relu(arr):\n    ret = arr.same_shape()\n    for i in range(len(arr)):\n        ret[i] = arr[i].max(0)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    temp = arr[index]\n    n = len(arr)\n    for j in range(n - 1):\n        if j >= index:\n            arr[j] = arr[j + 1]\n    arr[n - 1] = temp\n    return arr\n", "response_1": "from Compiler.types import Array\n\ndef move_to_end(arr, index, n):\n    temp = arr[index]\n    shift_size = n - (index + 1)\n    shift_vector = arr.get_vector(index + 1, shift_size)\n    arr.assign_vector(shift_vector, index)\n    arr[n - 1] = temp\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "set_to_zero", "response_0": "def set_to_zero(arr, index):\n    for i in range(len(arr)):\n        cond = i == index\n        zero = arr.value_type(0)\n        arr[i] = cond.if_else(zero, arr[i])\n    return arr\n", "response_1": "from Compiler.types import *\n\ndef set_to_zero(arr, index):\n    arr[index].update(arr.value_type(0))\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "last_partial_sum", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef last_partial_sum(arr, n):\n    start = arr.length - n\n    total = arr.value_type(0)\n    for i in for_range(n):\n        total += arr[start + i]\n    return total\n", "response_1": "from Compiler.types import MemValue\nfrom Compiler.library import for_range\n\ndef last_partial_sum(arr, n):\n    ret = MemValue(arr.value_type.hard_conv(0))\n    start_idx = arr.length - n\n    @for_range(n)\n    def _(i):\n        ret.iadd(arr[start_idx + i])\n    return ret.read()\n", "model_name": "deepseek-r1"}
{"test_name": "permute_by_indices", "response_0": "from Compiler.oram import OptimalORAM\n\ndef permute_by_indices(a, indices):\n    ret = type(a).Array(len(a))\n    oram = OptimalORAM(len(a), value_type=type(a[0]))\n    for i in range(len(a)):\n        oram[i] = a[i]\n    for i in range(len(a)):\n        ret[i] = oram[indices[i]]\n    return ret\n", "response_1": "from Compiler.oram import OptimalORAM\n\ndef permute_by_indices(a, indices):\n    \"\"\"\n    Permute the input array a by the indices using oblivious RAM access.\n    The i'th element in the returned array will be a[indices[i]].\n    \"\"\"\n    oram = OptimalORAM(len(a), value_type=a.value_type)\n    for i in range(len(a)):\n        oram[i] = a[i]\n    \n    ret = a.same_shape()\n    for i in range(len(a)):\n        ret[i] = oram[indices[i]]\n    \n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "get_rank", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint, MemValue\n\ndef get_rank(arr, index):\n    rank = MemValue(sint(0))\n    target = arr[index]\n    n = len(arr)\n    \n    def loop_body(i):\n        cmp_result = arr[i] < target\n        incr = cmp_result.if_else(sint(1), sint(0))\n        rank.iadd(incr)\n    \n    for_range(n)(loop_body)\n    return rank.read()\n", "response_1": "from library import sint\n\ndef get_rank(arr, index):\n    elem = arr[index]\n    rank = sint(0)\n    for i in range(arr.length):\n        rank += (arr[i] < elem).if_else(sint(1), sint(0))\n    return rank\n", "model_name": "deepseek-r1"}
{"test_name": "interchange_by_indices", "response_0": "def interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange two elements in a MP-SPDZ Array using public indices.\n    Assumes arr is of type Array and indices are public (cint/int).\n    \"\"\"\n    temp = arr[index1]\n    arr[index1].update(arr[index2])\n    arr[index2].update(temp)\n    return arr\n", "response_1": "def interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange two elements in the array using public indices.\n    Works for any basic type Array (sint/cint/sfix/cfix).\n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2].update(temp)\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "increase_by", "response_0": "def increase_by(arr, index, k):\n    arr.assign_vector(arr.get_vector() + k, base=index)\n    return arr\n", "response_1": "from Compiler.types import *\n\ndef increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] += k\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "retrieve_by_index", "response_0": "def retrieve_by_index(arr, index):\n    return arr[index]\n", "response_1": "def retrieve_by_index(arr, index):\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is guaranteed to be legal. \n    \"\"\"\n    return arr[index]\n", "model_name": "deepseek-r1"}
{"test_name": "scale_by", "response_0": "def scale_by(arr, index, k):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n", "response_1": "def scale_by(arr, index, k):\n    arr.assign_vector(arr.get_vector() + arr.get_vector(index) * k - arr.get_vector(index), base=index)\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "take_opposite_to", "response_0": "def take_opposite_to(arr, index):\n    arr[index].update(-arr[index])\n    return arr\n", "response_1": "from Compiler.types import sint, Array\n\ndef take_opposite_to(arr, index):\n    arr[index].update(-arr[index])\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "array_rank", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef array_rank(l):\n    n = l.length\n    ret = sint.Array(n)\n    ret.assign_all(sint(0))\n    \n    @for_range(n)\n    def _(i):\n        @for_range(n)\n        def _(j):\n            comparison = l[j] < l[i]\n            increment = comparison.if_else(sint(1), sint(0))\n            ret[i].iadd(increment)\n    \n    return ret\n", "response_1": "def array_rank(l):\n    n = len(l)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        for j in range(n):\n            cmp = l[j] < l[i]\n            ret[i] += cmp.if_else(sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "remove_by_index", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef remove_by_index(arr, index):\n    n = arr.length\n    ret = arr.value_type.Array(n - 1)\n    @for_range(n - 1)\n    def _(i):\n        cond = i < index\n        ret[i] = cond.if_else(arr[i], arr[i+1])\n    return ret\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef remove_by_index(arr, index):\n    new_len = len(arr) - 1\n    ret = sint.Array(new_len)\n    \n    @for_range(new_len)\n    def _(i):\n        cond = i < index\n        ret[i] = cond.if_else(arr[i], arr[i+1])\n        \n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "process_by_index", "response_0": "from Compiler.types import *\n\ndef process_by_index(arr, index, func):\n    \"\"\"\n    Process the element in the input array with given index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    element = arr[index]\n    processed = func(element)\n    arr[index] = processed\n    return arr\n", "response_1": "from Compiler.types import *\n\ndef process_by_index(arr, index):\n    # Process element at given public index\n    element = arr[index]\n    processed_element = element  # Replace with actual processing logic\n    arr[index] = processed_element\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "sum_by_indices", "response_0": "def sum_by_indices(arr, indices):\n    sum = arr.value_type(0)\n    for index in indices:\n        sum += arr[index]\n    return sum\n", "response_1": "def sum_by_indices(arr, indices):\n    sum = arr.value_type(0)\n    for index in indices:\n        sum += arr[index]\n    return sum\n", "model_name": "deepseek-r1"}
