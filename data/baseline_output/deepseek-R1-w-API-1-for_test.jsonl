{"test_name": "multiply_first_five", "response_0": "from Compiler.types import sint\n\ndef multiply_first_five(array):\n    prod = sint(1)\n    elements = array.get_vector()\n    selected = elements[:5]\n    for elem in selected:\n        prod *= elem\n    return prod\n", "response_1": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef multiply_first_five(array):\n    loop_limit = min(5, array.length)\n    prod = array.value_type(1)\n    for i in range(loop_limit):\n        prod *= array[i]\n    return prod\n", "model_name": "deepseek-r1"}
{"test_name": "second_largest", "response_0": "from library import for_range\n\ndef second_largest(arr):\n    # Initialize with the first two elements\n    largest = arr[0].max(arr[1])\n    second = arr[0].min(arr[1])\n    \n    # Iterate through remaining elements starting from index 2\n    @for_range(2, arr.length)\n    def _(i):\n        current = arr[i]\n        # Secret comparison for >= largest\n        condition1 = current >= largest\n        new_largest = condition1.if_else(current, largest)\n        temp_second = condition1.if_else(largest, second)\n        \n        # Secret comparison for >= second\n        condition2 = current >= temp_second\n        new_second = condition2.if_else(current, temp_second)\n        \n        # Update persistent values\n        largest.update(new_largest)\n        second.update(new_second)\n    \n    return second\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef second_largest(arr):\n    # Initialize with first two elements\n    cond_init = arr[0] >= arr[1]\n    largest = cond_init.if_else(arr[0], arr[1])\n    second = cond_init.if_else(arr[1], arr[0])\n\n    # Iterate through remaining elements\n    for i in range(2, len(arr)):\n        current = arr[i]\n        # Check if current is greater than largest\n        cond1 = current >= largest\n        new_largest = cond1.if_else(current, largest)\n        \n        # Determine new second largest\n        temp_second = cond1.if_else(largest, second)\n        cond2 = current >= temp_second\n        new_second = cond2.if_else(current, temp_second)\n        \n        # Update values\n        largest.update(new_largest)\n        second.update(new_second)\n    \n    return second\n", "model_name": "deepseek-r1"}
{"test_name": "partial_sum", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef partial_sum(arr):\n    partial = sint(0)\n    for i in for_range(arr.length):\n        partial += arr[i]\n        arr[i].update(partial)\n    return arr\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import MemValue\n\ndef partial_sum(arr):\n    partial = MemValue(arr.value_type(0))\n    @for_range(arr.length)\n    def _(i):\n        partial.iadd(arr[i])\n        arr[i] = partial\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "max_adjacent_product", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import MemValue\n\ndef max_adjacent_product(arr):\n    n = len(arr)\n    cur = MemValue(arr[0] * arr[1])\n    \n    @for_range(n-1)\n    def _(i):\n        product = arr[i] * arr[i+1]\n        current_max = cur.read()\n        new_max = (product > current_max).if_else(product, current_max)\n        cur.write(new_max)\n    \n    return cur.read()\n", "response_1": "from Compiler.library import tree_reduce, for_range\n\ndef max_adjacent_product(arr):\n    n = arr.length\n    products = arr.value_type.Array(n-1)\n    \n    @for_range(n-1)\n    def _(i):\n        products[i] = arr[i] * arr[i+1]\n    \n    max_prod = tree_reduce(lambda a, b: a.max(b), products)\n    return max_prod\n", "model_name": "deepseek-r1"}
{"test_name": "argmax", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef argmax(a):\n    current = a[0]\n    index = sint(0)\n    n = len(a)\n    for i in for_range(n):\n        condition = a[i] > current\n        index = condition.if_else(sint(i), index)\n        current = condition.if_else(a[i], current)\n    return index\n", "response_1": "from library import for_range\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max value of an array.\n    \"\"\"\n    current = a[0]\n    index = sint(0)\n    n = len(a)\n    \n    def loop_body(i):\n        nonlocal current, index\n        element = a[i]\n        condition = current >= element\n        i_sint = sint(i)\n        new_index = condition.if_else(index, i_sint)\n        new_current = condition.if_else(current, element)\n        index.update(new_index)\n        current.update(new_current)\n    \n    for_range(n)(loop_body)\n    return index\n", "model_name": "deepseek-r1"}
{"test_name": "count_distinct", "response_0": "def count_distinct(arr):\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            eq = arr[j] == arr[i]\n            unique *= 1 - sint(eq)\n        counter += unique\n    return counter\n", "response_1": "from library import for_range\nfrom types import sint, MemValue\n\ndef count_distinct(arr):\n    counter = MemValue(sint(0))\n    n = arr.length\n    @for_range(n)\n    def _(i):\n        unique = MemValue(sint(1))\n        @for_range(i)\n        def _(j):\n            eq = (arr[j] == arr[i]).if_else(sint(1), sint(0))\n            unique.write(unique.read() * (sint(1) - eq))\n        counter.iadd(unique.read())\n    return counter.read()\n", "model_name": "deepseek-r1"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    ret = sint(0)\n    for i in range(len(arr)):\n        ret = ret.bit_or(arr[i])\n    return ret\n", "response_1": "def exists_true(arr):\n    ret = sint(0)\n    for item in arr:\n        ret = ret.bit_or(item)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "range", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import MemValue, sint\n\ndef range(arr):\n    max_val = MemValue(arr[0])\n    min_val = MemValue(arr[0])\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        current = arr[i]\n        max_val.write(max_val.read().max(current))\n        min_val.write(min_val.read().min(current))\n    \n    return max_val.read() - min_val.read()\n", "response_1": "def range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for i in range(arr.length):\n        item = arr[i]\n        max_value = max_value.max(item)\n        min_value = min_value.min(item)\n    return max_value - min_value\n", "model_name": "deepseek-r1"}
{"test_name": "count_larger_than_5", "response_0": "from library import for_range\nfrom types import sint, MemValue\n\ndef count_larger_than_5(arr):\n    counter = MemValue(sint(0))\n    n = arr.length\n    @for_range(n)\n    def _(i):\n        item = arr[i]\n        is_larger = item > 5\n        counter.iadd(sint(is_larger))\n    return counter.read()\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef count_larger_than_5(arr):\n    counter = sint(0)\n    n = len(arr)\n    @for_range(n)\n    def _(i):\n        counter.iadd(sint(arr[i] > 5))\n    return counter\n", "model_name": "deepseek-r1"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr):\n    max_val = sint(0)\n    total_sum = sint(0)\n    for item in arr:\n        abs_item = item.abs()\n        max_val = max_val.max(abs_item)\n        total_sum += abs_item\n    return (2 * max_val > total_sum).if_else(sint(1), sint(0))\n", "response_1": "from library import MemValue, for_range\nfrom types import sint\n\ndef exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements.\n    \"\"\"\n    max_val = MemValue(sint(0))\n    total_sum = MemValue(sint(0))\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        abs_item = abs(arr[i])\n        current_max = max_val.read()\n        new_max = (abs_item > current_max).if_else(abs_item, current_max)\n        max_val.write(new_max)\n        total_sum.iadd(abs_item)\n    \n    return (2 * max_val.read()) > total_sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "greedy_picker", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef greedy_picker(items, captivity):\n    num = MemValue(sint(0))\n    current_captivity = MemValue(sint(captivity))\n    \n    @for_range(len(items))\n    def _(i):\n        item = items[i]\n        condition = item <= current_captivity.read()\n        cond_sint = sint(condition)\n        new_capt = current_captivity.read() - item * cond_sint\n        current_captivity.write(new_capt)\n        num.write(num.read() + cond_sint)\n    \n    return num.read()\n", "response_1": "from Compiler.types import sint, MemValue\nfrom Compiler.library import for_range\n\ndef greedy_picker(items, captivity):\n    num = MemValue(sint(0))\n    cap = MemValue(captivity)\n    n = len(items)\n    for i in range(n):\n        item = items[i]\n        condition = (item <= cap.read()).bit_to_arithmetic(sint)\n        new_cap = cap.read() - condition * item\n        new_num = num.read() + condition\n        cap.write(new_cap)\n        num.write(new_num)\n    return num.read()\n", "model_name": "deepseek-r1"}
{"test_name": "scalar_add_array", "response_0": "from Compiler.library import tree_reduce\n\ndef scalar_add_array(s, l):\n    vec = l.get_vector()\n    total = tree_reduce(lambda a, b: a + b, vec)\n    return s + total\n", "response_1": "from library import for_range, MemValue\n\ndef scalar_add_array(s, l):\n    sum = MemValue(s)\n    @for_range(l.length)\n    def _(i):\n        sum.iadd(l[i])\n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "is_equidistant_seq", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.GC.types import sbitint\n\ndef is_equidistant_seq(arr):\n    n = arr.length\n    if n <= 1:\n        return sbitint(1)\n    d = arr[1] - arr[0]\n    flag = sbitint.MemValue(sbitint(1))\n    @for_range(1, n-1)\n    def _(i):\n        current_d = arr[i+1] - arr[i]\n        eq = (current_d == d)\n        flag.write(flag.read() & eq)\n    return flag.read()\n", "response_1": "from Compiler.library import if_, for_range\nfrom Compiler.types import MemValue, sint\n\ndef is_equidistant_seq(arr):\n    n = len(arr)\n    flag = sint(0)\n    @if_(n > 1)\n    def _():\n        d = MemValue(arr[1] - arr[0])\n        for i in for_range(n-1):\n            current_diff = arr[i+1] - arr[i]\n            if i > 0:\n                check = (current_diff != d.read()).if_else(sint(1), sint(0))\n                flag.update(flag.bit_or(check))\n            d.write(current_diff)\n    return (flag == 0)\n", "model_name": "deepseek-r1"}
{"test_name": "inner_product", "response_0": "from Compiler.library import tree_reduce\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    product = vec1.get_vector() * vec2.get_vector()\n    return tree_reduce(lambda a, b: a + b, product)\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    products = vec1.get_vector() * vec2.get_vector()\n    return tree_reduce(lambda a, b: a + b, products)\n", "model_name": "deepseek-r1"}
{"test_name": "more_distinct_nonnegative", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef more_distinct_nonnegative(arr):\n    n = len(arr)\n    nonnegative_counter = MemValue(sint(0))\n    negative_counter = MemValue(sint(0))\n    \n    @for_range_opt(n)\n    def _(i):\n        any_duplicate = MemValue(sint(0))\n        \n        @for_range_opt(i)\n        def _(j):\n            eq = arr[j] == arr[i]\n            current = any_duplicate.read()\n            any_duplicate.write(current | eq)\n        \n        unique = sint(1) - any_duplicate.read()\n        is_nonnegative = arr[i] >= 0\n        delta_nonneg = unique * is_nonnegative\n        delta_neg = unique * (sint(1) - is_nonnegative)\n        \n        nonnegative_counter.write(nonnegative_counter.read() + delta_nonneg)\n        negative_counter.write(negative_counter.read() + delta_neg)\n    \n    return nonnegative_counter.read() > negative_counter.read()\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef more_distinct_nonnegative(arr):\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    n = len(arr)\n    \n    for i in for_range(n):\n        sum_eq = sint(0)\n        for j in for_range(i):\n            eq = arr[j] == arr[i]\n            sum_eq += eq.if_else(sint(1), sint(0))\n        is_unique = sum_eq == 0\n        is_nonnegative = arr[i] >= 0\n        \n        add_nonneg = is_unique.bit_and(is_nonnegative).if_else(sint(1), sint(0))\n        nonnegative_counter += add_nonneg\n        \n        add_neg = is_unique.bit_and(~is_nonnegative).if_else(sint(1), sint(0))\n        negative_counter += add_neg\n    \n    return nonnegative_counter > negative_counter\n", "model_name": "deepseek-r1"}
{"test_name": "flip_positives", "response_0": "from Compiler.library import for_range\n\ndef flip_positives(array):\n    n = len(array)\n    @for_range(n)\n    def _(i):\n        val = array[i]\n        condition = val > 0\n        array[i] = condition.if_else(-val, val)\n    return array\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef flip_positives(array):\n    n = len(array)\n    @for_range(n)\n    def _(i):\n        x = array[i]\n        cond = x > 0\n        array[i] = cond.if_else(-x, x)\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "divide_and_plus", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef divide_and_plus(x):\n    x_mem = MemValue(x)\n    @for_range(4)\n    def _(i):\n        current = x_mem.read()\n        x_mem.write(current / 2 + 1)\n    return x_mem.read()\n", "response_1": "def divide_and_plus(x):\n    for i in range(4):\n        x = x / 2.0\n        x = x + 1.0\n    return x\n", "model_name": "deepseek-r1"}
{"test_name": "array_log2", "response_0": "from library import for_range\nfrom mpc_math import log_fx\n\ndef array_log2(arr):\n    for i in for_range(len(arr)):\n        arr[i] = log_fx(arr[i], 2)\n    return arr\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.library import for_range\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    n = len(arr)\n    for i in for_range(n):\n        arr[i] = mpc_math.log_fx(arr[i], 2)\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "sum_to_ten", "response_0": "from Compiler.types import sint\nfrom Compiler.library import *\n\ndef sum_to_ten(array):\n    sum_val = sint(0)\n    n = len(array)\n    for i in range(n):\n        current = array[i]\n        condition = sum_val < 10\n        sum_val = condition.if_else(sum_val + current, sum_val)\n    return sum_val\n", "response_1": "from library import for_range\nfrom types import sint, MemValue\n\ndef sum_to_ten(array):\n    sum = MemValue(sint(0))\n    @for_range(len(array))\n    def _(i):\n        current_sum = sum.read()\n        condition = current_sum < 10\n        flag = sint(condition)\n        sum.write(current_sum + flag * array[i])\n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    n = len(arr)\n    @for_range(n)\n    def _(i):\n        if i % 2:\n            arr[i] += 1\n        else:\n            arr[i] -= 1\n    return arr\n", "response_1": "from Compiler.library import for_range\n\ndef choppy_plus_minus(arr):\n    n = len(arr)\n    @for_range(n)\n    def _(i):\n        if i % 2:\n            arr[i] += 1\n        else:\n            arr[i] -= 1\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "min_element", "response_0": "def min_element(a):\n    current = a[0]\n    for i in range(1, a.length):\n        item = a[i]\n        condition = current <= item\n        current = condition.if_else(current, item)\n    return current\n", "response_1": "from library import for_range\n\ndef min_element(a):\n    \"\"\"\n    Return the minimum value of a secret integer array.\n    \"\"\"\n    current = a[0]\n    n = len(a)\n    \n    def loop_body(i):\n        nonlocal current\n        item = a[i]\n        current = current.min(item)\n    \n    for_range(n)(loop_body)\n    return current\n", "model_name": "deepseek-r1"}
{"test_name": "soft_max", "response_0": "from Compiler.types import *\nfrom Compiler import mpc_math\n\ndef soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array.\n    \"\"\"\n    denominator = sfix(0)\n    for item in arr:\n        denominator += mpc_math.exp_fx(item)\n    \n    brr = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        brr[i] = mpc_math.exp_fx(arr[i]) / denominator\n    \n    return brr\n", "response_1": "from Compiler import mpc_math\nimport math\n\ndef soft_max(arr):\n    e = cfix(math.e)\n    denominator = sfix(0)\n    \n    # Compute denominator sum\n    for item in arr:\n        exp_val = mpc_math.pow_fx(e, item)\n        denominator += exp_val\n    \n    # Compute softmax values\n    brr = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        exp_i = mpc_math.pow_fx(e, arr[i])\n        brr[i] = exp_i / denominator\n    \n    return brr\n", "model_name": "deepseek-r1"}
{"test_name": "count_reverse_pair_with_break", "response_0": "from library import for_range, MemValue\nfrom types import sint, cfix\n\ndef count_reverse_pair_with_break(arr):\n    count = MemValue(sint(0))\n    break_flag = MemValue(sint(0))\n    n = arr.length\n    for i in for_range(1, n):\n        old_break = break_flag.read()\n        current_break = (arr[i] > cfix(10)).if_else(sint(1), sint(0))\n        new_break = old_break.bit_or(current_break)\n        break_flag.write(new_break)\n        mask = (1 - old_break) * (1 - current_break)\n        for j in for_range(i):\n            gt = (arr[j] > arr[i]).if_else(sint(1), sint(0))\n            count.write(count.read() + gt * mask)\n    return count.read()\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef count_reverse_pair_with_break(arr):\n    n = len(arr)\n    count = sint(0)\n    break_flag = sint(0)\n    \n    def outer_loop(i):\n        nonlocal count, break_flag\n        current_cond = arr[i] > 10\n        mask = 1 - break_flag\n        effective_cond = current_cond * mask\n        break_flag += effective_cond\n        inner_mask = mask * (1 - current_cond)\n        \n        def inner_loop(j):\n            cmp = arr[j] > arr[i]\n            is_valid = j < i\n            count += cmp * is_valid * inner_mask\n            \n        for_range(n)(inner_loop)\n    \n    for_range(1, n)(outer_loop)\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "sum_unique", "response_0": "from compiler.library import for_range\nfrom compiler.types import sint, MemValue\n\ndef sum_unique(arr):\n    n = len(arr)\n    sum = MemValue(sint(0))\n    \n    @for_range(n)\n    def _(i):\n        not_unique = MemValue(sint(0))\n        @for_range(n)\n        def _(j):\n            if j != i:\n                eq = (arr[j] == arr[i])\n                eq_sint = eq.if_else(sint(1), sint(0))\n                not_unique.iadd(eq_sint)\n        unique = (not_unique.read() == 0).if_else(sint(1), sint(0))\n        sum.iadd(arr[i] * unique)\n    \n    return sum.read()\n", "response_1": "from library import for_range\n\ndef sum_unique(arr):\n    sum = sint(0)\n    n = len(arr)\n    for i in for_range(n):\n        count = sint(0)\n        for j in for_range(n):\n            if j != i:\n                eq = (arr[j] == arr[i])\n                count += sint(eq)\n        unique = (count == 0)\n        sum += unique.if_else(arr[i], sint(0))\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "check_sum", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef check_sum(array, target):\n    sum = sint(0)\n    for i in for_range(len(array)):\n        sum += array[i]\n    return sum == target\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef check_sum(array, target):\n    sum = sint(0)\n    for i in range(len(array)):\n        sum += array[i]\n    return sum == target\n", "model_name": "deepseek-r1"}
{"test_name": "prod", "response_0": "from library import for_range\nfrom types import MemValue\n\ndef prod(array):\n    product = MemValue(array.value_type(1))\n    @for_range(array.length)\n    def _(i):\n        product.write(product.read() * array[i])\n    return product.read()\n", "response_1": "from Compiler.types import sint, MemValue\nfrom Compiler.library import for_range\n\ndef prod(array):\n    product = MemValue(sint(1))\n    @for_range(array.length)\n    def _(i):\n        product.write(product.read() * array[i])\n    return product.read()\n", "model_name": "deepseek-r1"}
{"test_name": "sum_till_negative", "response_0": "from Compiler.types import sint, MemValue\n\ndef sum_till_negative(array):\n    sum_total = MemValue(sint(0))\n    stop_flag = MemValue(sint(0))\n    \n    for i in range(len(array)):\n        current = array[i]\n        is_neg = current < 0\n        active = (1 - stop_flag) * (1 - is_neg)\n        sum_total.iadd(current * active)\n        new_stop = stop_flag + is_neg - stop_flag * is_neg\n        stop_flag.update(new_stop)\n    \n    return sum_total.read()\n", "response_1": "from Compiler import library\nfrom Compiler.types import sint\n\ndef sum_till_negative(array):\n    sum_val = sint(0)\n    flag = sint(0)\n    n = len(array)\n    for i in library.for_range(n):\n        element = array[i]\n        is_negative = element < 0\n        is_negative_sint = is_negative.if_else(sint(1), sint(0))\n        not_seen = sint(1) - flag\n        add_to_sum = not_seen * (sint(1) - is_negative_sint)\n        sum_val += element * add_to_sum\n        flag += is_negative_sint * (sint(1) - flag)\n    return sum_val\n", "model_name": "deepseek-r1"}
{"test_name": "count_satisfied", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import MemValue, sint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicate.\n    \"\"\"\n    sum = MemValue(sint(0))\n    @for_range(len(arr))\n    def _(i):\n        condition = predicator(arr[i])\n        sum.iadd(condition.if_else(sint(1), sint(0)))\n    return sum.read()\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef count_satisfied(arr):\n    sum = sint(0)\n    for i in for_range(len(arr)):\n        sum += (arr[i] != 0).if_else(1, 0)  # Replace comparison with actual predicate\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "standard_deviation", "response_0": "import mpc_math\nfrom library import for_range\n\ndef standard_deviation(arr):\n    len_arr = len(arr)\n    average = sfix(0)\n    variance = sfix(0)\n    \n    @for_range(len_arr)\n    def _(i):\n        average.update(average + arr[i] / len_arr)\n    \n    @for_range(len_arr)\n    def _(j):\n        diff = arr[j] - average\n        variance.update(variance + (diff * diff) / len_arr)\n    \n    return mpc_math.sqrt(variance)\n", "response_1": "from Compiler import mpc_math\n\ndef standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array.\n    \"\"\"\n    average = sfix(0)\n    variance = sfix(0)\n    n = arr.length\n    \n    for i in range(n):\n        average += arr[i] / n\n        \n    for i in range(n):\n        diff = arr[i] - average\n        variance += (diff * diff) / n\n        \n    return mpc_math.sqrt(variance)\n", "model_name": "deepseek-r1"}
{"test_name": "dominate", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef dominate(a, b):\n    n = len(a)\n    comparisons = sintbit.Array(n)\n    for i in range(n):\n        comparisons[i] = a[i] < b[i]\n    any_less = tree_reduce(lambda x, y: x.bit_or(y), comparisons)\n    return any_less.bit_not()\n", "response_1": "from Compiler.library import tree_reduce\nfrom Compiler.types import sint\n\ndef dominate(a, b):\n    vec_a = a.get_vector()\n    vec_b = b.get_vector()\n    comparisons = vec_a < vec_b\n    any_lt = tree_reduce(lambda x, y: x | y, comparisons)\n    return any_lt.bit_not()\n", "model_name": "deepseek-r1"}
{"test_name": "rescale", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef rescale(brr):\n    max_abs = sfix(0)\n    for item in brr.get_vector():\n        abs_item = item.abs()\n        max_abs = max_abs.max(abs_item)\n    \n    @for_range(len(brr))\n    def _(i):\n        brr[i] = brr[i] / max_asc\n    \n    return brr\n", "response_1": "from library import tree_reduce\n\ndef rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    # Convert array to vector and compute absolute values\n    abs_vector = brr[:].abs()\n    \n    # Securely compute maximum absolute value using tree reduction\n    max_abs = tree_reduce(lambda a,b: a.max(b), abs_vector)\n    \n    # Divide all elements by max_abs using element-wise operations\n    n = len(brr)\n    @for_range(n)\n    def _(i):\n        brr[i] = brr[i] / max_abs\n        \n    return brr\n", "model_name": "deepseek-r1"}
{"test_name": "array_minus7", "response_0": "from library import for_range\n\ndef array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    n = len(arr)\n    @for_range(n)\n    def _(i):\n        arr[i] = arr[i] - 7\n    return arr\n", "response_1": "def array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    vec = arr.get_vector()\n    vec -= 7\n    arr.assign_vector(vec)\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    sum = sint(0)\n    for i in range(arr1.length):\n        for j in range(arr2.length):\n            product = arr1[i] * arr2[j]\n            sum += product\n    return sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef traverse_and_sum(arr1, arr2):\n    sum = sint.MemValue(sint(0))\n    for i in for_range(arr1.length):\n        for j in for_range(arr2.length):\n            product = arr1[i] * arr2[j]\n            sum.iadd(product)\n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef longest_nondec_subseq(a):\n    max_length = sint(0)\n    cur_length = sint(0)\n    n = len(a)\n    for i in for_range(n):\n        if i == 0:\n            cur_length.update(sint(1))\n        else:\n            c = a[i] >= a[i-1]\n            new_cur = c.if_else(cur_length + 1, sint(1))\n            new_max = c.if_else(max_length, max_length.max(cur_length))\n            cur_length.update(new_cur)\n            max_length.update(new_max)\n    final_max = max_length.max(cur_length)\n    return final_max\n", "response_1": "def longest_nondec_subseq(a):\n    max_length = sint(0)\n    cur_length = sint(0)\n    n = len(a)\n    for i in range(n):\n        if i == 0:\n            cur_length = sint(1)\n        else:\n            condition = a[i] >= a[i-1]\n            new_cur = condition.if_else(cur_length + 1, sint(1))\n            new_max_candidate = max_length.max(cur_length)\n            new_max = condition.if_else(max_length, new_max_candidate)\n            cur_length = new_cur\n            max_length = new_max\n    max_length = max_length.max(cur_length)\n    return max_length\n", "model_name": "deepseek-r1"}
{"test_name": "sum_but_skip_biggest", "response_0": "from library import sum\n\ndef sum_but_skip_biggest(array):\n    sum_total = sum(array.get_vector())\n    current_max = array[0]\n    sum_new_max = current_max\n    for i in range(1, len(array)):\n        current = array[i]\n        cond = current > current_max\n        sum_new_max += cond.if_else(current, sint(0))\n        current_max = current_max.max(current)\n    return sum_total - sum_new_max\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef sum_but_skip_biggest(array):\n    sum = MemValue(sint(0))\n    biggest = MemValue(array[0])\n    n = len(array)\n    \n    @for_range(n)\n    def _(i):\n        current = array[i]\n        current_biggest = biggest.read()\n        \n        # Compute comparison and multiplier\n        is_bigger = current >= current_biggest\n        multiplier = is_bigger.bit_not().if_else(sint(1), sint(0))\n        \n        # Update sum and biggest\n        sum.write(sum.read() + current * multiplier)\n        new_biggest = current.max(current_biggest)\n        biggest.write(new_biggest)\n    \n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "second_test", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef second_test(arr):\n    count = sint(0)\n    @for_range(1, len(arr))\n    def _(i):\n        cmp = arr[0] < arr[i]\n        count.iadd(cmp.if_else(1, 0))\n    return count == 1\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef second_test(arr):\n    count = MemValue(sint(0))\n    n = len(arr)\n    @for_range(1, n)\n    def _(i):\n        count.iadd(sint(arr[0] < arr[i]))\n    return count.read() == 1\n", "model_name": "deepseek-r1"}
{"test_name": "Manhattan_distance", "response_0": "from Compiler.types import sfix, MemValue\nfrom Compiler.library import for_range\n\ndef Manhattan_distance(a, b):\n    ret = MemValue(sfix(0))\n    @for_range(len(a))\n    def _(i):\n        diff = a[i] - b[i]\n        ret.iadd(diff.abs())\n    return ret.read()\n", "response_1": "def Manhattan_distance(a, b):\n    \"\"\"Compute the Manhattan distance of the two vectors.\"\"\"\n    ret = a.value_type(0)\n    for i in range(len(a)):\n        diff = a[i] - b[i]\n        ret += diff.abs()\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "deal_with_only_positive", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef deal_with_only_positive(array):\n    sum = sint(0)\n    sign = sint(1)\n    n = len(array)\n    \n    for i in for_range(n):\n        element = array[i]\n        is_positive = element > 0\n        is_positive_sint = is_positive.if_else(sint(1), sint(0))\n        contribution = is_positive_sint * sign * element\n        sum += contribution\n        sign = sign * (sint(1) - 2 * is_positive_sint)\n    \n    return sum\n", "response_1": "from library import for_range, if_\nfrom compiler.types import sint, MemValue\n\ndef deal_with_only_positive(array):\n    sum = MemValue(sint(0))\n    sign = MemValue(sint(1))\n    n = len(array)\n    \n    def loop_body(i):\n        element = array[i]\n        is_positive = element > 0\n        @if_(is_positive)\n        def _():\n            current_sign = sign.read()\n            sum.iadd(current_sign * element)\n            sign.write(-current_sign)\n    \n    for_range(n)(loop_body)\n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef compare_and_return(arr, brr):\n    ret = sint(-1)\n    found = sint(0)\n    n = len(arr)\n    for i in for_range(n):\n        current_match = (arr[i] == brr[i]).if_else(sint(1), sint(0))\n        is_first_match = current_match * (1 - found)\n        ret = ret * (1 - is_first_match) + sint(i) * is_first_match\n        found += is_first_match\n    return ret\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint, MemValue\n\ndef compare_and_return(arr, brr):\n    ret = MemValue(sint(-1))\n    n = len(arr)\n    @for_range(n)\n    def _(i):\n        current_ret = ret.read()\n        match = arr[i] == brr[i]\n        needs_update = match & (current_ret == -1)\n        new_ret = needs_update.if_else(sint(i), current_ret)\n        ret.write(new_ret)\n    return ret.read()\n", "model_name": "deepseek-r1"}
{"test_name": "sum_odd_positive", "response_0": "def sum_odd_positive(arr):\n    sum = sint(0)\n    for item in arr:\n        is_odd = item & 1\n        is_positive = (item > 0).if_else(sint(1), sint(0))\n        mask = is_odd * is_positive\n        sum += item * mask\n    return sum\n", "response_1": "from library import for_range\nfrom Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        item = arr[i]\n        is_odd = item.bit_and(1)  # Secret bitwise AND with 1 to check odd\n        is_positive = item > 0     # Secret comparison for positivity\n        sum.iadd(is_odd * is_positive * item)  # Logical AND via multiplication\n        \n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "two_sum", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef two_sum(arr, target):\n    n = len(arr)\n    found = MemValue(sbitint(0))\n    @for_range(n)\n    def _(i):\n        @for_range(n)\n        def _(j):\n            sum_ij = arr[i] + arr[j]\n            cond = sum_ij.equal(target)\n            current = found.read()\n            found.write(current.bit_or(cond))\n    return found.read().reveal()\n", "response_1": "from library import for_range\nfrom Compiler.types import sint, MemValue, sbitint\n\ndef two_sum(arr, target):\n    n = len(arr)\n    flag = MemValue(sbitint(0))\n    @for_range(n)\n    def _(i):\n        @for_range(n)\n        def _(j):\n            sum_val = arr[i] + arr[j]\n            cond = sum_val == target\n            current = flag.read()\n            flag.write(current | cond)\n    return flag.read().reveal()\n", "model_name": "deepseek-r1"}
{"test_name": "seq_search", "response_0": "def seq_search(arr, target):\n    index = sint(-1)\n    for i in range(len(arr)):\n        match = arr[i] == target\n        index = match.if_else(sint(i), index)\n    return index\n", "response_1": "def seq_search(arr, target):\n    found = sint(0)\n    result = sint(-1)\n    for i in range(len(arr)):\n        current = arr[i]\n        match = current == target\n        match_sint = match.if_else(sint(1), sint(0))\n        not_found = 1 - found\n        condition = match_sint * not_found\n        result = condition.if_else(sint(i), result)\n        found += condition\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "choppy_array", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef choppy_array(arr):\n    n = arr.length\n    result = MemValue(sbitint(1))\n    \n    @for_range(n)\n    def _(i):\n        @for_range(n - i)\n        def _(j_offset):\n            j = i + j_offset\n            if i % 2 == 0:\n                violation = arr[j] < arr[i]\n            else:\n                violation = arr[j] > arr[i]\n            current = result.read()\n            result.write(current & (~violation))\n    \n    return result.read()\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint, cint\n\ndef choppy_array(arr):\n    n = len(arr)\n    flag = sint(1)\n    for i in for_range(n):\n        remaining = n - i\n        is_even = (i % 2) == 0\n        is_even_cint = cint(is_even)\n        for j in for_range(remaining):\n            current = i + j\n            violation_even = sint(arr[current] < arr[i])\n            violation_odd = sint(arr[current] > arr[i])\n            violation = violation_even * is_even_cint + violation_odd * (cint(1) - is_even_cint)\n            flag *= sint(1) - violation\n    return sint(flag == 1)\n", "model_name": "deepseek-r1"}
{"test_name": "array_process", "response_0": "from Compiler.library import for_range\n\ndef array_process(arr):\n    n = len(arr)\n    for i in for_range(n):\n        arr[i] = arr[i].function()  # Replace .function() with actual MP-SPDZ operation\n    return arr\n", "response_1": "from Compiler.library import for_range\n\ndef array_process(arr):\n    @for_range(arr.length)\n    def _(i):\n        arr[i] = func(arr[i])\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "normalize", "response_0": "from Compiler.types import MemValue, sfix\nfrom Compiler.library import for_range\nfrom mpc_math import sqrt\n\ndef normalize(vec, n):\n    \"\"\"\n    Normalize the vector using MP-SPDZ types and operations.\n    \"\"\"\n    sum_squares = MemValue(sfix(0))\n    \n    @for_range(n)\n    def _(i):\n        sum_squares.iadd(vec[i] ** 2)\n    \n    base = sqrt(sum_squares.read())\n    \n    @for_range(n)\n    def _(i):\n        vec[i].update(vec[i] / base)\n    \n    return vec\n", "response_1": "from Compiler.library import *\nfrom Compiler import mpc_math\n\ndef normalize(vec):\n    \"\"\"\n    Normalize the vector using MP-SPDZ operations\n    \"\"\"\n    sum_squares = MemValue(sfix(0))\n    \n    # Compute sum of squares\n    @for_range(len(vec))\n    def _(i):\n        sum_squares.iadd(vec[i] ** 2)\n    \n    # Calculate reciprocal of L2 norm\n    l2_norm = mpc_math.sqrt(sum_squares.read())\n    inv_norm = 1 / l2_norm\n    \n    # Normalize vector elements\n    @for_range(len(vec))\n    def _(i):\n        vec[i] = vec[i] * inv_norm\n    \n    return vec\n", "model_name": "deepseek-r1"}
{"test_name": "impatient_merchant", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef impatient_merchant(days):\n    net = sint(0)\n    orig_price = sint(0)\n    can_buy = sint(1)\n    \n    for i in range(len(days)):\n        current_can_buy = can_buy\n        condition = (days[i] > orig_price).bit_to_arithmetic()\n        \n        # Buy case calculations\n        buy_net = net - days[i]\n        buy_orig = days[i]\n        buy_can = sint(0)\n        \n        # Sell case calculations\n        sell_net = net + days[i] * condition\n        sell_orig = orig_price\n        sell_can = condition\n        \n        # Update values using oblivious selection\n        net = current_can_buy.if_else(buy_net, sell_net)\n        orig_price = current_can_buy.if_else(buy_orig, sell_orig)\n        can_buy = current_can_buy.if_else(buy_can, sell_can)\n    \n    return net\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint, MemValue\n\ndef impatient_merchant(days):\n    net = MemValue(sint(0))\n    orig_price = MemValue(sint(0))\n    can_buy = MemValue(sint(1))\n    n = len(days)\n    \n    @for_range(n)\n    def _(i):\n        current_can_buy = can_buy.read()\n        current_orig_price = orig_price.read()\n        \n        buy_cond = current_can_buy\n        sell_cond = (days[i] > current_orig_price).if_else(sint(1), sint(0)) * (sint(1) - current_can_buy)\n        \n        net.write(net.read() - days[i] * buy_cond + days[i] * sell_cond)\n        orig_price.write(current_orig_price * (sint(1) - buy_cond) + days[i] * buy_cond)\n        can_buy.write(buy_cond.if_else(sint(0), sell_cond.if_else(sint(1), current_can_buy)))\n    \n    return net.read()\n", "model_name": "deepseek-r1"}
{"test_name": "array_shift", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef array_shift(a):\n    n = len(a)\n    temp = a[n - 1]\n    for i in range(n - 1):\n        a[n - i - 1] = a[n - i - 2]\n    a[0] = temp\n    return a\n", "response_1": "from Compiler.types import *\n\ndef array_shift(a):\n    n = a.length\n    shifted_vector = a.get_vector(n-1, 1) + a.get_vector(0, n-1)\n    a.assign_vector(shifted_vector)\n    return a\n", "model_name": "deepseek-r1"}
{"test_name": "array_double", "response_0": "from Compiler.library import for_range\n\ndef array_double(arr):\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef array_double(arr):\n    for i in for_range(arr.length):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef stop_at_zero(array):\n    continue_flag = MemValue(sint(1))\n    for i in range(len(array)):\n        current = array[i]\n        is_zero = sint.bit_type(current == 0)\n        add_value = continue_flag.read() * (1 - is_zero)\n        array[i] = current + add_value\n        new_flag = continue_flag.read() * (1 - is_zero)\n        continue_flag.write(new_flag)\n    return array\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef stop_at_zero(array):\n    n = len(array)\n    flag = MemValue(sint(0))\n    \n    @for_range(n)\n    def _(i):\n        current = array[i]\n        zero_check = current == 0\n        not_stopped = flag.read().bit_not()\n        \n        # Calculate if we should increment (not stopped and not zero)\n        increment = not_stopped.bit_and(zero_check.bit_not())\n        array[i] += increment\n        \n        # Update stopped flag (once set, remains set)\n        new_flag = flag.read().bit_or(zero_check.bit_and(not_stopped))\n        flag.write(new_flag)\n        \n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "array_not", "response_0": "from Compiler.library import for_range\n\ndef array_not(arr):\n    n = arr.length\n    @for_range(n)\n    def _(i):\n        arr[i] = arr[i].bit_not()\n    return arr\n", "response_1": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    arr.assign_vector(arr.get_vector().bit_not())\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "array_process_then_clip", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sfix, Array\n\ndef array_process_then_clip(arr: Array, func):\n    @for_range(len(arr))\n    def _(i):\n        val = func(arr[i])\n        arr[i] = val.min(10).max(-10)\n    return arr\n", "response_1": "from library import for_range\nfrom compiler.types import sfix\n\ndef array_process_then_clip(arr):\n    \"\"\"Process elements with func then clip to [-10,10] range\"\"\"\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        # Apply processing function - replace with actual func implementation\n        processed = arr[i]  # Placeholder for func(arr[i])\n        \n        # Clip using element-wise min/max operations\n        clipped = processed.min(10)\n        clipped = clipped.max(-10)\n        \n        arr[i] = clipped\n    \n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "add_and_count_positive", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef add_and_count_positive(array, k):\n    count = MemValue(sint(0))\n    n = len(array)\n    \n    @for_range(n)\n    def _(i):\n        # Add k to each array element\n        array[i] += k\n        # Convert comparison result to sint(1) or sint(0) and accumulate\n        count.iadd((array[i] > 0).if_else(sint(1), sint(0)))\n    \n    return array, count\n", "response_1": "def add_and_count_positive(array, k):\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] += k\n        count += (array[i] > 0).if_else(sint(1), sint(0))\n    return array, count\n", "model_name": "deepseek-r1"}
{"test_name": "array_subtract", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef array_subtract(a, b):\n    a_len = a.length\n    b_len = b.length\n    max_len = max(a_len, b_len)\n    result_type = a.value_type\n    result = result_type.Array(max_len)\n    \n    @for_range(max_len)\n    def _(i):\n        if_then(and_(i < a_len, i < b_len))\n        result[i] = a[i] - b[i]\n        else_if(i < a_len)\n        result[i] = a[i]\n        else()\n        result[i] = -b[i]\n        end_if()\n    return result\n", "response_1": "def array_subtract(a, b):\n    max_len = max(a.length, b.length)\n    min_len = min(a.length, b.length)\n    result = a.value_type.Array(max_len)\n    \n    @for_range(min_len)\n    def _(i):\n        result[i] = a[i] - b[i]\n    \n    if a.length > b.length:\n        @for_range(a.length - b.length)\n        def _(i):\n            result[b.length + i] = a[b.length + i]\n    else:\n        @for_range(b.length - a.length)\n        def _(i):\n            result[a.length + i] = -b[a.length + i]\n    \n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "lower_bound", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef lower_bound(arr, x):\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        cond = arr[i] <= x\n        cond_sint = cond.if_else(sint(1), sint(0))\n        current_distance = x - arr[i]\n        masked_distance = current_distance * cond_sint\n        \n        not_found = (found == 0)\n        distance_less = (masked_distance < distance)\n        inner_cond = not_found.bit_or(distance_less)\n        update_cond = cond.bit_and(inner_cond)\n        update_cond_sint = update_cond.if_else(sint(1), sint(0))\n        \n        current_ret = update_cond.if_else(sint(i), ret)\n        current_dist = update_cond.if_else(masked_distance, distance)\n        new_found = found.max(update_cond_sint)\n        \n        ret.update(current_ret)\n        distance.update(current_dist)\n        found.update(new_found)\n    \n    return ret\n", "response_1": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef lower_bound(arr, x):\n    n = len(arr)\n    ret = sint(-1)\n    distance = sfix(0)\n    found = sint(0)\n    for i in range(n):\n        current = arr[i]\n        cond1 = current <= x\n        cond1_sint = sint(cond1)\n        current_diff = x - current\n        cond_diff = current_diff < distance\n        cond_diff_sint = sint(cond_diff)\n        cond2_num = (1 - found) + cond_diff_sint\n        cond2 = cond2_num >= 1\n        cond2_sint = sint(cond2)\n        cond = cond1_sint * cond2_sint\n        cond_sfix = sfix.load_int(cond)\n        ret = ret * (1 - cond) + sint(i) * cond\n        distance = distance * (sfix(1) - cond_sfix) + current_diff * cond_sfix\n        found = found * (1 - cond) + cond\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "argmin", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef argmin(a):\n    \"\"\"\n    Return the index of the min value of a secret array\n    \"\"\"\n    current = a[0]\n    index = sint(0)\n    n = len(a)\n    \n    def update(i):\n        nonlocal current, index\n        smaller = a[i] < current\n        new_index = smaller.if_else(sint(i), index)\n        new_current = smaller.if_else(a[i], current)\n        index.update(new_index)\n        current.update(new_current)\n    \n    for_range(n)(update)\n    return index\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef argmin(a):\n    current = a[0]\n    index = sint(0)\n    n = len(a)\n    for i in range(n):\n        condition = a[i] < current\n        index = condition.if_else(sint(i), index)\n        current = condition.if_else(a[i], current)\n    return index\n", "model_name": "deepseek-r1"}
{"test_name": "independent_robbery", "response_0": "from library import for_range\n\ndef independent_robbery(houses):\n    n = houses.length\n    dp = sint.Array(n)\n    dp.assign_all(sint(0))\n    dp[0] = houses[0]\n    dp[1] = dp[1].max(dp[0])\n    \n    @for_range(2, n)\n    def _(i):\n        option = dp[i-2] + houses[i]\n        dp[i] = option.max(dp[i-1])\n    \n    return dp[n-1]\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef independent_robbery(houses):\n    n = houses.length\n    dp = sint.Array(n)\n    \n    dp[0] = houses[0]\n    dp[1] = houses[0].max(houses[1])\n    \n    @for_range(2, n)\n    def _(i):\n        prev_two = dp[i-2] + houses[i]\n        current_max = prev_two.max(dp[i-1])\n        dp[i] = current_max\n    \n    return dp[n-1]\n", "model_name": "deepseek-r1"}
{"test_name": "sum_odd_and_odd", "response_0": "from library import for_range, if_\nfrom types import sint\n\ndef sum_odd_and_odd(arr):\n    sum = sint(0)\n    n = arr.length\n    @for_range(n)\n    def _(i):\n        @if_(i % 2 != 0)\n        def _():\n            @for_range(i)\n            def _(j):\n                @if_(j % 2 != 0)\n                def _():\n                    sum.iadd(arr[j])\n    return sum\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef sum_odd_and_odd(arr):\n    sum = sint(0)\n    n = arr.length\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            sum += arr[j]\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "is_monotonous", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint, MemValue\n\ndef is_monotonous(arr):\n    n = len(arr)\n    if n <= 1:\n        return True\n    d = MemValue(arr[1] - arr[0])\n    violated = MemValue(sint(0))\n    \n    @for_range(n-2)\n    def _(j):\n        i = j + 1\n        current_diff = arr[i+1] - arr[i]\n        product = current_diff * d.read()\n        is_violated = sint(product <= 0)\n        new_violated = violated.read().bit_or(is_violated)\n        violated.write(new_violated)\n        d.write(current_diff)\n    \n    return violated.read() == 0\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef is_monotonous(arr):\n    n = len(arr)\n    d = MemValue(sint(0))\n    flag = MemValue(sint(0))\n    \n    for i in for_range(n-1):\n        current_diff = arr[i+1] - arr[i]\n        @if_(i > 0)\n        def _(j=i):\n            product = current_diff * d.read()\n            leq_zero = (product <= 0)\n            flag.write(flag.read() + leq_zero)\n        d.write(current_diff)\n    \n    return (flag.read() == 0).if_else(sint(1), sint(0))\n", "model_name": "deepseek-r1"}
{"test_name": "positive_count_negative_sum", "response_0": "def positive_count_negative_sum(arr):\n    count = sint(0)\n    sum_neg = sint(0)\n    for i in for_range(len(arr)):\n        item = arr[i]\n        # Check for positive and accumulate count\n        is_positive = item > 0\n        count += sint(is_positive)\n        # Check for negative and accumulate sum\n        is_negative = item < 0\n        sum_neg += item * sint(is_negative)\n    return count, sum_neg\n", "response_1": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    count = sint(0)\n    sum_neg = sint(0)\n    for item in arr:\n        is_positive = item > 0\n        count += is_positive.if_else(sint(1), sint(0))\n        is_negative = item < 0\n        sum_neg += is_negative.if_else(item, sint(0))\n    return (count, sum_neg)\n", "model_name": "deepseek-r1"}
{"test_name": "sum_even", "response_0": "from Compiler.types import sint\nfrom Compiler.library import *\n\ndef sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for i in range(arr.length):\n        item = arr[i]\n        # Even check using bitwise AND and arithmetic operations\n        mask = 1 - (item & 1)  # 1 for even, 0 for odd\n        sum += item * mask\n    return sum\n", "response_1": "def sum_even(arr):\n    sum = sint(0)\n    for item in arr:\n        is_even = (item % 2 == 0)\n        sum += is_even.if_else(item, sint(0))\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "one_norm", "response_0": "from Compiler.types import sfix\n\ndef one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec)):\n        sum += abs(vec[i])\n    return sum\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef one_norm(vec):\n    sum = MemValue(vec.value_type(0))\n    @for_range(len(vec))\n    def _(i):\n        sum.iadd(abs(vec[i]))\n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "array_floor", "response_0": "def array_floor(arr):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i])\n    return ret\n", "response_1": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        floor_val = arr[i].v >> sfix.f\n        ret[i] = floor_val\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "three_five", "response_0": "def three_five(arr):\n    has3 = sint(0)\n    for item in arr:\n        eq3 = item.equal(3)\n        has3 = has3.bit_or(eq3)\n    \n    has5 = sint(0)\n    for item in arr:\n        eq5 = item.equal(5)\n        has5 = has5.bit_or(eq5)\n    \n    both = has3.bit_and(has5)\n    neither = (1 - has3).bit_and(1 - has5)\n    result = both.bit_or(neither)\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef three_five(arr):\n    has3 = sint(0)\n    has5 = sint(0)\n    for item in arr:\n        has3 = has3.bit_or(item == 3)\n        has5 = has5.bit_or(item == 5)\n    both = has3.bit_and(has5)\n    neither = (1 - has3).bit_and(1 - has5)\n    return both.bit_or(neither)\n", "model_name": "deepseek-r1"}
{"test_name": "num_above_average", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef num_above_average(arr):\n    sum = MemValue(sfix(0))\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        sum.iadd(arr[i])\n    \n    avg = sum.read() / n\n    count = MemValue(sint(0))\n    \n    @for_range(n)\n    def _(j):\n        comp = arr[j] >= avg\n        count.iadd(comp.if_else(1, 0))\n    \n    return count.read()\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value.\n    \"\"\"\n    sum = sfix(0)\n    n = len(arr)\n    \n    # Calculate sum of elements\n    for i in range(n):\n        sum += arr[i]\n    \n    # Compute average\n    avg = sum / n\n    \n    # Count elements >= average\n    count = sint(0)\n    for i in range(n):\n        is_above = (arr[i] >= avg).if_else(sint(1), sint(0))\n        count += is_above\n    \n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "clip", "response_0": "from Compiler.library import for_range_opt\nfrom Compiler.types import sfix, cfix\n\ndef clip(arr, upper_bound=cfix(1), lower_bound=cfix(-1)):\n    @for_range_opt(arr.length)\n    def _(i):\n        element = arr[i]\n        # Clip lower bound\n        clipped = (element < lower_bound).if_else(lower_bound, element)\n        # Clip upper bound\n        clipped = (clipped > upper_bound).if_else(upper_bound, clipped)\n        arr[i] = clipped\n    return arr\n", "response_1": "from Compiler import library\n\ndef clip(arr, upper_bound=1.0, lower_bound=-1.0):\n    n = len(arr)\n    @library.for_range(n)\n    def _(i):\n        x = arr[i]\n        value_type = x.type\n        lb = value_type(lower_bound)\n        ub = value_type(upper_bound)\n        cond_lower = x < lb\n        x = cond_lower.if_else(lb, x)\n        cond_upper = x > ub\n        x = cond_upper.if_else(ub, x)\n        arr[i] = x\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "from Compiler.library import *\nfrom Compiler.types import sint\n\ndef sum_with_certain_element_skipped(array):\n    sum = MemValue(sint(0))\n    n = len(array)\n    \n    @for_range(n)\n    def _(i):\n        current_sum = sum.read()\n        element = array[i]\n        sum_plus = current_sum + element\n        \n        # Compute condition flags\n        ge5 = sum_plus >= 5\n        le10 = sum_plus <= 10\n        in_range = ge5.bit_and(le10)\n        \n        # Convert condition mask to arithmetic secret integer\n        mask = sint(1) - sint(in_range)\n        \n        # Update sum using arithmetic mask\n        new_sum = current_sum + element * mask\n        sum.write(new_sum)\n    \n    return sum.read()\n", "response_1": "from Compiler.types import sint, MemValue\nfrom Compiler.library import for_range\n\ndef sum_with_certain_element_skipped(array):\n    sum = MemValue(sint(0))\n    @for_range(array.length)\n    def _(i):\n        current_sum = sum.read()\n        element = array[i]\n        temp_sum = current_sum + element\n        condition = (temp_sum >= 5) * (temp_sum <= 10)\n        multiplier = 1 - sint(condition)\n        sum.write(current_sum + element * multiplier)\n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.types import sint\nfrom Compiler.library import *\n\ndef sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for i in range(arr.length):\n        item = arr[i]\n        mod = item % 2\n        odd_sum += mod.if_else(item, 0)\n        even_sum += (1 - mod).if_else(item, 0)\n    return odd_sum, even_sum\n", "response_1": "def sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for i in range(len(arr)):\n        item = arr[i]\n        mod = item % 2\n        odd_sum += mod * item\n        even_sum += (1 - mod) * item\n    return odd_sum, even_sum\n", "model_name": "deepseek-r1"}
{"test_name": "distance", "response_0": "from Compiler.library import *\nfrom Compiler import mpc_math\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two secret vectors.\n    \"\"\"\n    sum_sq = MemValue(sfix(0))\n    n = len(vec1)\n    \n    @for_range(n)\n    def _(i):\n        diff = vec1[i] - vec2[i]\n        sum_sq.iadd(diff * diff)\n    \n    return mpc_math.sqrt(sum_sq.read())\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sfix, Array\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum_sq = sfix(0)\n    for i in range(vec1.length):\n        diff = vec1[i] - vec2[i]\n        sum_sq += diff * diff\n    return mpc_math.sqrt(sum_sq)\n", "model_name": "deepseek-r1"}
{"test_name": "num_occurrence", "response_0": "from Compiler.library import *\nfrom Compiler.types import sint\n\ndef num_occurrence(arr, target):\n    count = sint(0)\n    @for_range(arr.length)\n    def _(i):\n        eq = arr[i] == target\n        count.iadd(eq.if_else(sint(1), sint(0)))\n    return count\n", "response_1": "def num_occurrence(arr, target):\n    \"\"\"Return the number of occurrences of the target in the given array.\"\"\"\n    count = sint(0)\n    for i in range(arr.length):\n        count += sint(arr[i] == target)\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "palindrome", "response_0": "from Compiler.types import *\ndef palindrome(arr):\n    n = len(arr)\n    flag = sint(1)\n    for i in range(n):\n        j = n - 1 - i\n        cmp = (arr[i] == arr[j])\n        flag = flag * cmp.if_else(sint(1), sint(0))\n    return flag\n", "response_1": "def palindrome(arr):\n    flag = sbitint(1)\n    n = len(arr)\n    for i in range(n):\n        cmp = (arr[i] == arr[n - 1 - i])\n        flag = flag.bit_and(cmp)\n    return flag\n", "model_name": "deepseek-r1"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef reverse_order_pair(arr):\n    num = MemValue(sint(0))\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        @for_range(i+1, n)\n        def _(j):\n            cmp = arr[i] > arr[j]\n            num.iadd(cmp.bit_to_arithmetic())\n    \n    return num.read()\n", "response_1": "from library import for_range\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    num = sint(0)\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        @for_range(n)\n        def _(j):\n            @if_(j > i)\n            def _():\n                cmp = (arr[i] > arr[j])\n                num.iadd(cmp.if_else(1, 0))\n    return num\n", "model_name": "deepseek-r1"}
{"test_name": "sum_of_cubes", "response_0": "def sum_of_cubes(arr):\n    ret = sint(0)\n    for i in range(arr.length):\n        ret += arr[i] ** 3\n    return ret\n", "response_1": "def sum_of_cubes(arr):\n    ret = sint(0)\n    for i in range(len(arr)):\n        ret += arr[i] ** 3\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "max_element", "response_0": "from library import tree_reduce\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    return tree_reduce(lambda x, y: x.max(y), a)\n", "response_1": "from Compiler.library import tree_reduce\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    return tree_reduce(lambda x, y: x.max(y), a)\n", "model_name": "deepseek-r1"}
{"test_name": "array_if_else", "response_0": "from library import for_range\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"Conditionally apply functions to secret array elements.\"\"\"\n    @for_range(len(arr))\n    def _(i):\n        x = arr[i]\n        condition = predicator(x)\n        true_val = if_func(x)\n        false_val = else_func(x)\n        arr[i] = condition.if_else(true_val, false_val)\n    return arr\n", "response_1": "from Compiler.library import for_range\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    n = len(arr)\n    @for_range(n)\n    def _(i):\n        x = arr[i]\n        cond = predicator(x)\n        if_val = if_func(x)\n        else_val = else_func(x)\n        arr[i] = cond.if_else(if_val, else_val)\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "inf_norm", "response_0": "from Compiler.types import sfix\n\ndef inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    max_val = sfix(0)\n    for i in range(len(vec)):\n        current_abs = abs(vec[i])\n        max_val = max_val.max(current_abs)\n    return max_val\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import MemValue\n\ndef inf_norm(vec):\n    max_val = MemValue(abs(vec[0]))\n    @for_range(1, len(vec))\n    def _(i):\n        current_abs = abs(vec[i])\n        max_val.write(max_val.read().max(current_abs))\n    return max_val.read()\n", "model_name": "deepseek-r1"}
{"test_name": "array_inc", "response_0": "from Compiler.library import *\n\ndef array_inc(arr):\n    @for_range(len(arr))\n    def _(i):\n        arr[i] += 1\n    return arr\n", "response_1": "from Compiler.library import for_range\n\ndef array_inc(arr):\n    @for_range(arr.length)\n    def _(i):\n        arr[i] += 1\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "count_rises", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef count_rises(arr):\n    \"\"\"Count the number of rises in the array using secret integers.\"\"\"\n    count = sint(0)\n    n = len(arr)\n    \n    def loop_body(i):\n        count.update(count + (arr[i] < arr[i + 1]))\n    \n    for_range(n - 1)(loop_body)\n    return count\n", "response_1": "def count_rises(arr):\n    count = sint(0)\n    for i in range(len(arr)-1):\n        count += (arr[i] < arr[i+1])\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "skip_at_zero", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef skip_at_zero(array):\n    for i in for_range(array.length):\n        cond = array[i] != 0\n        array[i] += cond.if_else(sint(1), sint(0))\n    return array\n", "response_1": "from Compiler.types import sint, Array\n\ndef skip_at_zero(array):\n    for i in range(len(array)):\n        array[i] += sint(array[i] != 0)\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "array_intersect", "response_0": "from Compiler.types import *\nfrom Compiler.GC.types import sbitint\nfrom Compiler.library import *\n\ndef array_intersect(p, q):\n    result = sbitint(0)\n    for i in range(len(p)):\n        for j in range(len(q)):\n            eq = p[i] == q[j]\n            result = result.bit_or(eq)\n    return result.reveal()\n", "response_1": "from Compiler.types import sint, sbitint, MemValue\nfrom Compiler.library import for_range\n\ndef array_intersect(p, q, n, m):\n    result = MemValue(sbitint(0))\n    @for_range(n)\n    def _(i):\n        @for_range(m)\n        def _(j):\n            eq = p[i] == q[j]\n            result.write(result.read() | eq)\n    return result.read()\n", "model_name": "deepseek-r1"}
{"test_name": "two_norm", "response_0": "from Compiler import mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum += item ** 2\n    return mpc_math.sqrt(sum)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec)):\n        sum += vec[i] ** 2\n    return mpc_math.sqrt(sum)\n", "model_name": "deepseek-r1"}
{"test_name": "sum_between", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef sum_between(arr, length, l, u):\n    sum = sint(0)\n    @for_range(length)\n    def _(i):\n        nonlocal sum\n        item = arr[i]\n        in_lower = item >= l\n        in_upper = item <= u\n        cond = in_lower.bit_and(in_upper)\n        mask = cond.if_else(sint(1), sint(0))\n        sum += item * mask\n    return sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_between(arr, l, u):\n    sum = sint(0)\n    for i in for_range(len(arr)):\n        item = arr[i]\n        in_range = (item >= l) * (item <= u)\n        sum += in_range.if_else(sint(1), sint(0)) * item\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "largest_gap", "response_0": "def largest_gap(arr):\n    cur = MemValue(sint(0))\n    n = len(arr)\n    @for_range(n-1)\n    def _(i):\n        diff = (arr[i+1] - arr[i]).abs()\n        cur.max(diff)\n    return cur.read()\n", "response_1": "from compiler.types import sfix, Array, MemValue\nfrom library import for_range\n\ndef largest_gap(arr):\n    cur = MemValue(sfix(0))\n    n = arr.length\n    def body(i):\n        diff = (arr[i+1] - arr[i]).abs()\n        cur.write(diff.max(cur.read()))\n    for_range(n-1)(body)\n    return cur.read()\n", "model_name": "deepseek-r1"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    amin = a[0]\n    for i in range(len(a)):\n        amin = amin.min(a[i])\n    bmax = b[0]\n    for i in range(len(b)):\n        bmax = bmax.max(b[i])\n    return amin >= bmax\n", "response_1": "from library import tree_reduce\n\ndef totally_dominate(a, b):\n    amin = tree_reduce(lambda x, y: x.min(y), a)\n    bmax = tree_reduce(lambda x, y: x.max(y), b)\n    return (amin >= bmax).if_else(sint(1), sint(0))\n", "model_name": "deepseek-r1"}
{"test_name": "element_count", "response_0": "from Compiler.types import sint, MemValue\nfrom Compiler.library import for_range\n\ndef element_count(arr, target):\n    ret = MemValue(sint(0))\n    n = arr.length\n    for i in for_range(n):\n        item = arr[i]\n        match = (item == target).if_else(sint(1), sint(0))\n        ret.iadd(match)\n    return ret.read()\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef element_count(arr, target):\n    ret = sint(0)\n    for i in for_range(arr.length):\n        eq = (arr[i] == target)\n        ret += eq.if_else(sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "is_subarray", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef is_subarray(c, d):\n    result = sint(0)\n    n = len(c)\n    m = len(d)\n    \n    for i in range(m):\n        if_then(n <= m - i)\n        flag = sint(1)\n        for j in range(n):\n            eq = (d[i + j] == c[j])\n            flag *= eq.if_else(sint(1), sint(0))\n        result = result.bit_or(flag)\n        end_if()\n    \n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef is_subarray(c, d):\n    len_c = c.length\n    len_d = d.length\n    result = MemValue(sbitint(0))\n    \n    @for_range(len_d)\n    def _(i):\n        if i + len_c <= len_d:\n            match = MemValue(sbitint(1))\n            @for_range(len_c)\n            def _(j):\n                eq = (d[i + j] == c[j])\n                match.write(match.read().bit_and(eq))\n            result.write(result.read().bit_or(match.read()))\n    \n    return result.read()\n", "model_name": "deepseek-r1"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint, MemValue\n\ndef exists_5_or_7(arr):\n    result = MemValue(sint(0))\n    n = len(arr)\n    @for_range(n)\n    def _(i):\n        item = arr[i]\n        cond = (item == 5).bit_or(item == 7)\n        current = result.read()\n        result.write(current.bit_or(cond))\n    return result.read()\n", "response_1": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    found = sint(0)\n    for i in range(len(arr)):\n        eq5 = arr[i] == 5\n        eq7 = arr[i] == 7\n        found |= eq5 | eq7\n    return found\n", "model_name": "deepseek-r1"}
{"test_name": "variance", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef variance(arr):\n    \"\"\"\n    Return the variance of the array.\n    \"\"\"\n    average = sfix(0)\n    variance_val = sfix(0)\n    n = len(arr)\n    \n    for i in range(n):\n        average += arr[i] / cfix(n)\n    \n    for i in range(n):\n        diff = arr[i] - average\n        variance_val += (diff * diff) / cfix(n)\n    \n    return variance_val\n", "response_1": "def variance(arr):\n    average = sfix(0)\n    variance = sfix(0)\n    n = len(arr)\n    for item in arr:\n        average += item / n\n    for item in arr:\n        variance += (item - average)**2 / n\n    return variance\n", "model_name": "deepseek-r1"}
{"test_name": "is_ascending", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef is_ascending(arr):\n    n = arr.length\n    flag = MemValue(sbitint(0))\n    @library.for_range(n-1)\n    def _(i):\n        cmp = arr[i] >= arr[i+1]\n        current = flag.read()\n        flag.write(current.bit_or(cmp))\n    return 1 - flag.read()\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef is_ascending(arr):\n    if arr.length <= 1:\n        return sint(1)\n    flag = sbitint(0)\n    for i in range(arr.length - 1):\n        comp = arr[i] >= arr[i+1]\n        flag = flag.bit_or(comp)\n    return 1 - sint(flag)\n", "model_name": "deepseek-r1"}
{"test_name": "xor_all", "response_0": "def xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret.bit_xor(arr[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret.bit_xor(arr[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "upper_bound", "response_0": "from Compiler.types import sint, MemValue\nfrom Compiler.library import for_range\n\ndef upper_bound(arr, x):\n    ret = MemValue(sint(-1))\n    distance = MemValue(sint(0))\n    found = MemValue(sint(0))\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        elem = arr[i]\n        cond1 = elem > x\n        current_distance = distance.read()\n        current_found = found.read()\n        \n        cond2_part1 = current_found == 0\n        cond2_part2 = (elem - x) < current_distance\n        cond2 = cond2_part1.bit_or(cond2_part2)\n        \n        update_cond = cond1.bit_and(cond2)\n        update = sint(update_cond)\n        \n        new_ret = update * i + (1 - update) * ret.read()\n        new_distance = update * (elem - x) + (1 - update) * current_distance\n        new_found = update * 1 + (1 - update) * current_found\n        \n        ret.write(new_ret)\n        distance.write(new_distance)\n        found.write(new_found)\n    \n    return ret.read()\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef upper_bound(arr, x):\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        current_val = arr[i]\n        cond = current_val > x\n        new_distance = current_val - x\n        \n        found_is_zero = (found == sint(0))\n        distance_cond = new_distance < distance\n        is_better = found_is_zero.bit_or(distance_cond)\n        update_cond = cond.bit_and(is_better)\n        \n        update_cond_sint = update_cond.if_else(sint(1), sint(0))\n        \n        ret.update(update_cond.if_else(sint(i), ret))\n        distance.update(update_cond.if_else(new_distance, distance))\n        found.update(found.max(update_cond_sint))\n    \n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef array_process_then_sum(arr):\n    sum = MemValue(arr.value_type(0))\n    n = len(arr)\n    \n    @for_range(n)\n    def _(i):\n        # Apply processing function to arr[i] here\n        # Example: processed = mpc_math.sqrt(arr[i])\n        processed = ...  # Replace with actual processing logic\n        \n        arr[i] = processed\n        sum.iadd(processed)\n        \n    return sum.read()\n", "response_1": "from Compiler.types import sint, sfix, MemValue, Array\nfrom Compiler.library import for_range\n\ndef array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function,\n    then sum up the processed elements.\n    \"\"\"\n    sum = MemValue(arr.value_type(0))\n    \n    def process_element(i):\n        processed = func(arr[i])\n        arr[i] = processed\n        sum.iadd(processed)\n\n    for_range(len(arr))(process_element)\n    \n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "average", "response_0": "from library import for_range\nfrom types import sfix, MemValue\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = MemValue(sfix(0))\n    length = arr.length\n    @for_range(length)\n    def _(i):\n        sum.iadd(arr[i])\n    return sum.read() / length\n", "response_1": "from library import for_range\nfrom types import sfix, cfix, MemValue\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = MemValue(sfix(0))\n    length = arr.length\n    @for_range(length)\n    def _(i):\n        sum.iadd(arr[i])\n    return sum.read() / cfix(length)\n", "model_name": "deepseek-r1"}
{"test_name": "array_filter", "response_0": "def array_filter(arr, predicator):\n    value_type = arr.value_type\n    for i in range(len(arr)):\n        x = arr[i]\n        cond = predicator(x)\n        mask = cond.if_else(value_type(1), value_type(0))\n        arr[i] = x * mask\n    return arr\n", "response_1": "from Compiler.types import *\n\ndef array_filter(arr, predicator):\n    for i in range(len(arr)):\n        x = arr[i]\n        cond = predicator(x)\n        arr[i] = x * cond\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "sum_up", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef sum_up(array):\n    sum = MemValue(array.value_type.hard_conv(array.value_type(0)))\n    @for_range(len(array))\n    def _(i):\n        sum.iadd(array[i])\n    return sum.read()\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef sum_up(array):\n    sum = MemValue(array.value_type(0))\n    @for_range(array.length)\n    def _(i):\n        sum.iadd(array[i])\n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "negative_to_zero", "response_0": "from Compiler.library import for_range\n\ndef negative_to_zero(array):\n    n = len(array)\n    @for_range(n)\n    def _(i):\n        array[i] = array[i].max(0)\n    return array\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef negative_to_zero(array):\n    n = len(array)\n    @for_range(n)\n    def _(i):\n        cond = array[i] >= 0\n        array[i] = cond.if_else(array[i], array[i].type(0))\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "sum_only_positive_to_ten", "response_0": "from Compiler import *\nfrom Compiler.GC.types import sbitint\n\ndef sum_only_positive_to_ten(array):\n    sum_total = sfix.MemValue(0)\n    reached_flag = sbitint.MemValue(0)\n    n = len(array)\n    \n    @for_range(n)\n    def _(i):\n        current_val = array[i]\n        is_positive = current_val > 0\n        should_add = is_positive.bit_and(reached_flag.read().bit_not())\n        \n        add_amount = should_add.if_else(current_val, sfix(0))\n        sum_total.iadd(add_amount)\n        \n        new_flag = sum_total.read() >= 10\n        reached_flag.write(reached_flag.read().bit_or(new_flag))\n    \n    return sum_total.read()\n", "response_1": "def sum_only_positive_to_ten(array):\n    sum = MemValue(sint(0))\n    active = MemValue(sint(1))\n    \n    @for_range(len(array))\n    def _(i):\n        current = array[i]\n        current_sum = sum.read()\n        current_active = active.read()\n        \n        # Compute conditions as secret bits\n        positive = current > 0\n        under_limit = current_sum < 10\n        \n        # Convert secret bits to arithmetic shares\n        add_condition = (positive.bit_and(under_limit)).bit_and(current_active)\n        add_amount = current * add_condition\n        \n        # Update sum\n        new_sum = current_sum + add_amount\n        sum.write(new_sum)\n        \n        # Update active flag if threshold crossed\n        crossed = new_sum >= 10\n        active.write(current_active - (crossed.bit_and(current_active)))\n    \n    return sum.read()\n", "model_name": "deepseek-r1"}
{"test_name": "bubble_sort", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef bubble_sort(arr):\n    n = len(arr)\n    @for_range(n-1)\n    def _(i):\n        @for_range(n-1 - i)\n        def _(j):\n            condition = arr[j] >= arr[j+1]\n            swapped = condition.cond_swap(arr[j], arr[j+1])\n            arr[j].update(swapped[0])\n            arr[j+1].update(swapped[1])\n    return arr\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef bubble_sort(arr):\n    n = arr.length\n    @for_range(n-1)\n    def _(i):\n        @for_range(n-1 - i)\n        def _(j):\n            a = arr[j]\n            b = arr[j+1]\n            swap = a >= b\n            arr[j] = swap.if_else(b, a)\n            arr[j+1] = swap.if_else(a, b)\n    return arr\n", "model_name": "deepseek-r1"}
