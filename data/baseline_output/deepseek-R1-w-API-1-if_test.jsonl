{"test_name": "sin_or_cos", "response_0": "def sin_or_cos(x):\n    from Compiler import mpc_math\n    condition = x >= 0\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n    return condition.if_else(sin_val, cos_val)\n", "response_1": "def sin_or_cos(x):\n    from Compiler import mpc_math\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n    condition = x >= 0\n    return sint(condition).if_else(sin_val, cos_val)\n", "model_name": "deepseek-r1"}
{"test_name": "negative_relu", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import *\n\ndef negative_relu(input):\n    return (input < 0).if_else(input, sfix(0))\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return (input < 0).if_else(input, 0)\n", "model_name": "deepseek-r1"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    return abs(a - b) <= 1\n", "response_1": "def is_close(a, b):\n    \"\"\"\n    Return whether the two secret fixed-point inputs are close:\n    Their absolute difference is no larger than 1 (fixed-point precision)\n    \"\"\"\n    return (a - b).abs() <= sfix(1)\n", "model_name": "deepseek-r1"}
{"test_name": "hardswish", "response_0": "from Compiler.types import sfix\n\ndef hardswish(x):\n    mask_less = (x < -3).if_else(sfix(1), sfix(0))\n    mask_greater = (x > 3).if_else(sfix(1), sfix(0))\n    mask_middle = sfix(1) - mask_less - mask_greater\n    \n    term_less = sfix(0) * mask_less\n    term_greater = x * mask_greater\n    term_middle = (x * (x + 3) / 6) * mask_middle\n    \n    return term_less + term_greater + term_middle\n", "response_1": "from Compiler.types import sfix\n\ndef hardswish(x):\n    cond_lt = x < -3\n    cond_gt = x > 3\n    intermediate = x * (x + 3) / 6\n    return cond_lt.if_else(sfix(0), cond_gt.if_else(x, intermediate))\n", "model_name": "deepseek-r1"}
{"test_name": "clip_at_6", "response_0": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    clipped_lower = x.max(-6)\n    clipped = clipped_lower.min(6)\n    return clipped\n", "response_1": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    \"\"\"Return x clipped to [-6,6] using MPC-friendly operations\"\"\"\n    return x.max(-6).min(6)\n", "model_name": "deepseek-r1"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    # Compute the OR of x > 1 and x < -1\n    c1 = (x > 1).bit_or(x < -1)\n    \n    # First term: x when outside [-1,1]\n    term1 = x * c1\n    \n    # Middle range terms: 1 for positive, -1 for negative, 0 otherwise\n    middle_part = (x > 0) * sfix(1) + (x < 0) * sfix(-1)\n    \n    # Apply middle terms only when within [-1,1]\n    middle_term = middle_part * (~c1)\n    \n    # Combine both terms\n    return term1 + middle_term\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef piecewise_function(x):\n    # Evaluate conditions sequentially with nested if_else\n    return (x > 1).if_else(x, \n            (x < -1).if_else(x, \n                (x > 0).if_else(sfix(1), \n                    (x < 0).if_else(sfix(-1), sfix(0)))))\n", "model_name": "deepseek-r1"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    # First compare and swap a and b\n    swap1 = (a >= b)\n    a1, b1 = sint(swap1).cond_swap(a, b)\n    \n    # Compare and swap b1 and c\n    swap2 = (b1 >= c)\n    b2, c1 = sint(swap2).cond_swap(b1, c)\n    \n    # Final compare and swap a1 and b2\n    swap3 = (a1 >= b2)\n    a2, b3 = sint(swap3).cond_swap(a1, b2)\n    \n    return b3\n", "response_1": "from Compiler.types import sint\n\ndef middle(a, b, c):\n    # First comparison and conditional swap\n    swap = sint(a >= b)\n    a, b = swap.cond_swap(a, b)\n    \n    # Second comparison and conditional swap\n    swap = sint(b >= c)\n    b, c = swap.cond_swap(b, c)\n    \n    # Final comparison and conditional swap\n    swap = sint(a >= b)\n    a, b = swap.cond_swap(a, b)\n    \n    return b\n", "model_name": "deepseek-r1"}
{"test_name": "indicated_sin_or_cos", "response_0": "import mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True (1), return the sine value of the input, \n    otherwise return the cosine value of the input. \n    Both x and indicator are secret values (sfix/sint)\n    \"\"\"\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n    return ind.if_else(sin_val, cos_val)\n", "response_1": "from Compiler import mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True (1), return the sine value of the input,\n    otherwise return the cosine value of the input.\n    \"\"\"\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n    return ind.if_else(sin_val, cos_val)\n", "model_name": "deepseek-r1"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"Return x-2 if x-2 is no less than 0, otherwise return x\"\"\"\n    x_minus_2 = x - 2\n    condition = (x_minus_2 >= 0).if_else(1, 0)\n    return condition.if_else(x_minus_2, x)\n", "response_1": "def minus2_if_else(x):\n    x_minus_2 = x - 2\n    condition = x_minus_2 >= 0\n    return sint(condition).if_else(x_minus_2, x)\n", "model_name": "deepseek-r1"}
{"test_name": "relu6", "response_0": "from Compiler.types import sfix\n\ndef relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    return x.max(0).min(6)\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function for secret fixed-point numbers.\n    \"\"\"\n    return x.max(0).min(6)\n", "model_name": "deepseek-r1"}
{"test_name": "exp_slide", "response_0": "from Compiler import mpc_math\nimport math\n\ndef exp_slide(x):\n    e_val = cfix(math.e)\n    condition = x >= 0\n    pow_result = mpc_math.pow_fx(e_val, x)\n    add_result = x + 1\n    return condition.if_else(pow_result, add_result)\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sfix\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    condition = x >= 0\n    exp_val = mpc_math.exp_fx(x)\n    else_val = x + sfix(1)\n    return condition.if_else(exp_val, else_val)\n", "model_name": "deepseek-r1"}
{"test_name": "pass_or_not", "response_0": "from Compiler.types import sint\n\ndef pass_or_not(score):\n    condition = score >= 60\n    condition_sint = sint(condition)\n    new_score = condition_sint.if_else(score, sint(59))\n    passed = condition_sint\n    return (new_score, passed)\n", "response_1": "from Compiler.types import sint\n\ndef pass_or_not(score):\n    passed = score >= 60\n    adjusted_score = passed.if_else(score, sint(59))\n    return adjusted_score, passed\n", "model_name": "deepseek-r1"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef how_many_roots(a, b, c):\n    a_zero = a == 0\n    b_zero = b == 0\n    \n    linear_case = a_zero * if_else(b_zero, sint(0), sint(1))\n    \n    discriminant = b * b - 4 * a * c\n    gt = discriminant > 0\n    eq = discriminant == 0\n    \n    quad_case = (sint(1) - a_zero) * if_else(gt, sint(2), if_else(eq, sint(1), sint(0)))\n    \n    return linear_case + quad_case\n", "response_1": "from library import sfix, sint, cfix, cint\n\ndef how_many_roots(a, b, c):\n    a_is_zero = (a == 0)\n    b_is_zero = (b == 0)\n    \n    linear_case = (sint(1) - sint(b_is_zero)) * sint(a_is_zero)\n    \n    D = b * b - 4 * a * c\n    D_gt_zero = D > 0\n    D_eq_zero = D == 0\n    \n    quadratic_case = D_gt_zero.if_else(sint(2), D_eq_zero.if_else(sint(1), sint(0)))\n    \n    return sint(a_is_zero).if_else(linear_case, quadratic_case)\n", "model_name": "deepseek-r1"}
{"test_name": "elu", "response_0": "from Compiler import mpc_math\nimport math\n\ndef elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    condition = x > 0\n    e = sfix(math.e)\n    exp_term = mpc_math.pow_fx(e, x) - sfix(1)\n    return condition.if_else(x, exp_term)\n", "response_1": "from Compiler import mpc_math\nimport math\n\ndef elu(x):\n    e_val = cfix(math.e)\n    condition = x > 0\n    positive_part = x\n    negative_part = mpc_math.pow_fx(e_val, x) - 1\n    return condition.if_else(positive_part, negative_part)\n", "model_name": "deepseek-r1"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return x.max(0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function using secure maximum operation\n    \"\"\"\n    return x.max(0)\n", "model_name": "deepseek-r1"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    return (x > 0).if_else(x, x * alpha)\n", "response_1": "def leaky_relu(x, alpha):\n    # Convert comparison result to sfix via sint\n    b = x > 0\n    b_sint = sint(b)\n    b_sfix = sfix(b_sint)\n    # Calculate conditional using arithmetic operations\n    return x * (b_sfix + alpha * (sfix(1) - b_sfix))\n", "model_name": "deepseek-r1"}
{"test_name": "max", "response_0": "from Compiler.types import sint\n\ndef max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs using secure operations.\n    \"\"\"\n    return a.max(b)\n", "model_name": "deepseek-r1"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    cond1 = x > 1\n    cond2 = x < -1\n    term1 = sint(cond1) * (x - 1)\n    term2 = sint(cond2) * (-x - 1)\n    return term1 + term2\n", "response_1": "from Compiler.types import sfix\n\ndef bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function using secure MPC operations:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    gt_1 = x > 1\n    lt_minus1 = x < -1\n    return gt_1.if_else(x - 1, lt_minus1.if_else(-x - 1, sfix(0)))\n", "model_name": "deepseek-r1"}
{"test_name": "rounded_kinetic_energy", "response_0": "def rounded_kinetic_energy(m, v):\n    from Compiler import mpc_math\n    k = (m * v * v) / sfix(2)\n    k_floor = k.floor()\n    remainder = k - k_floor\n    return (remainder < sfix(0.5)).if_else(k_floor, k_floor + sfix(1))\n", "response_1": "from Compiler.types import sfix, sint\n\ndef rounded_kinetic_energy(m, v):\n    k = (m * v * v) / sfix(2)\n    k_int = k.trunc()\n    fractional_part = k - sfix(k_int)\n    rounded = k_int + sint(fractional_part >= sfix(0.5))\n    return rounded\n", "model_name": "deepseek-r1"}
{"test_name": "danger_test", "response_0": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return (origin - damage) <= 10\n", "response_1": "def danger_test(origin, damage):\n    # The Dragon Warrior is punched by his enemy!\n    # Given the Dragon Warrior's initial health and the damage he receives,\n    # decide whether the situation is dangerous.\n    # (If the health left is no more than 10, we say that the situation is dangerous)\n    return (origin - damage) <= 10\n", "model_name": "deepseek-r1"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True (1), return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    All values must be secret integers (sint).\n    \"\"\"\n    sum_val = x + y\n    product_val = x * y\n    return ind.if_else(sum_val, product_val)\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    return ind.if_else(x + y, x * y)\n", "model_name": "deepseek-r1"}
{"test_name": "median", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef median(arr, n):\n    arr.sort()\n    midpoint = n // 2\n    is_odd = n % 2\n    result = sfix(0)\n    \n    @if_public(is_odd)\n    def _():\n        result.update(arr[midpoint])\n    @else_\n    def _():\n        avg = (arr[midpoint] + arr[midpoint - 1]) * 0.5\n        result.update(avg)\n    \n    return result\n", "response_1": "def median(arr):\n    n = len(arr)\n    if n == 0:\n        crash(\"The length of the array is 0!\")\n    arr.sort()\n    half = n // 2\n    if n % 2:\n        return arr[half]\n    else:\n        return (arr[half] + arr[half - 1]) / cfix(2)\n", "model_name": "deepseek-r1"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    sum_ab = a + b\n    condition = sum_ab > 10\n    return condition.if_else(sint(10), sum_ab)\n", "response_1": "from Compiler.types import sint, sbitint\n\ndef add_upto_10(a, b):\n    s = a + b\n    overflow = s.greater_than(10)\n    return overflow.if_else(sint(10), s)\n", "model_name": "deepseek-r1"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    # Compute conditions\n    cond1 = m <= sfix(5)\n    cond2 = (m > sfix(5)) & (m <= sfix(10))\n    cond3 = m > sfix(10)\n    \n    # Convert conditions to sint for arithmetic operations\n    c1 = cond1.if_else(sint(1), sint(0))\n    c2 = cond2.if_else(sint(1), sint(0))\n    c3 = cond3.if_else(sint(1), sint(0))\n    \n    # Calculate fare components\n    base = sfix(5)\n    mid_fare = base + sfix(1.2) * (m - base)\n    upper_fare = sfix(11) + sfix(1.5) * (m - sfix(10))\n    \n    # Combine using conditional weights\n    return c1 * base + c2 * mid_fare + c3 * upper_fare\n", "response_1": "from library import sfix\n\ndef taxi_fare(m):\n    return (m <= 5).if_else(\n        sfix(5),\n        (m <= 10).if_else(\n            sfix(5) + sfix(1.2) * (m - sfix(5)),\n            sfix(11) + sfix(1.5) * (m - sfix(10))\n        )\n    )\n", "model_name": "deepseek-r1"}
{"test_name": "round", "response_0": "from mpc_math import floor_fx\n\ndef round(x):\n    return floor_fx(x + 0.5)\n", "response_1": "from Compiler.types import sfix, sint\n\ndef round(x):\n    x_plus_half = x + sfix(0.5)\n    x_trunc = sint(x_plus_half)\n    adjust = (x_plus_half < sfix(x_trunc)).if_else(sint(1), sint(0))\n    rounded = x_trunc - adjust\n    return sfix(rounded)\n", "model_name": "deepseek-r1"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    cond1 = score >= sfix(90)\n    cond2 = (score >= sfix(85)).bit_and(score < sfix(90))\n    cond3 = (score >= sfix(80)).bit_and(score < sfix(85))\n    cond4 = (score >= sfix(75)).bit_and(score < sfix(80))\n    cond5 = (score >= sfix(70)).bit_and(score < sfix(75))\n    cond6 = score < sfix(70)\n\n    c1 = cond1.if_else(sfix(4.0), sfix(0.0))\n    c2 = cond2.if_else(sfix(3.6), sfix(0.0))\n    c3 = cond3.if_else(sfix(3.3), sfix(0.0))\n    c4 = cond4.if_else(sfix(3.0), sfix(0.0))\n    c5 = cond5.if_else(sfix(2.6), sfix(0.0))\n    c6 = cond6.if_else(sfix(2.3), sfix(0.0))\n\n    return c1 + c2 + c3 + c4 + c5 + c6\n", "response_1": "from library import sfix\n\ndef gpa_calculator(score):\n    return (score >= sfix(90.0)).if_else(sfix(4.0),\n            (score >= sfix(85.0)).if_else(sfix(3.6),\n            (score >= sfix(80.0)).if_else(sfix(3.3),\n            (score >= sfix(75.0)).if_else(sfix(3.0),\n            (score >= sfix(70.0)).if_else(sfix(2.6),\n            sfix(2.3))))))\n", "model_name": "deepseek-r1"}
{"test_name": "sign", "response_0": "def sign(x):\n    # Compute positive and negative flags as sfix values\n    positive = (x > 0).if_else(sfix(1), sfix(0))\n    negative = (x < 0).if_else(sfix(-1), sfix(0))\n    # Combine using secure arithmetic operations\n    return positive + negative\n", "response_1": "def sign(x):\n    # Convert comparison results to sint using if_else\n    positive = (x > 0).if_else(sint(1), sint(0))\n    negative = (x < 0).if_else(sint(-1), sint(0))\n    return positive + negative\n", "model_name": "deepseek-r1"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    # Compute the condition (a <= b) as a secret bit and convert to sint\n    cond = sint(a <= b)\n    # Use the secret condition to select between sum and difference\n    return cond.if_else(a + b, a - b)\n", "response_1": "from Compiler.types import sint\n\ndef sum_or_difference(a, b):\n    condition = (a <= b)\n    c = sint(condition)\n    return c.if_else(a + b, a - b)\n", "model_name": "deepseek-r1"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    # XOR equivalent using arithmetic operations for secret integers\n    return control_bit + flip_bit - 2 * control_bit * flip_bit\n", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    return flip_bit.bit_xor(control_bit)\n", "model_name": "deepseek-r1"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    condition = y < 0\n    return condition.if_else(y + 1, y)\n", "response_1": "def negative_plus1(y):\n    # Convert secret comparison result to arithmetic secret integer\n    cond = sint(y < 0)\n    # Use arithmetic MUX operation for conditional selection\n    return cond.if_else(y + 1, y)\n", "model_name": "deepseek-r1"}
{"test_name": "is_a_parallelogram", "response_0": "def is_a_parallelogram(a, b, c, d):\n    same = lambda x, y: (x[0] == y[0]).bit_and(x[1] == y[1])\n    duplicate = same(a, b).bit_or(same(a, c)) \\\n                .bit_or(same(a, d)).bit_or(same(b, c)) \\\n                .bit_or(same(b, d)).bit_or(same(c, d))\n    \n    cond1 = (a[0] + b[0] == c[0] + d[0]).bit_and(a[1] + b[1] == c[1] + d[1])\n    cond2 = (a[0] + c[0] == b[0] + d[0]).bit_and(a[1] + c[1] == b[1] + d[1])\n    cond3 = (a[0] + d[0] == b[0] + c[0]).bit_and(a[1] + d[1] == b[1] + c[1])\n    \n    valid_shape = cond1.bit_or(cond2).bit_or(cond3)\n    return duplicate.bit_not().bit_and(valid_shape).if_else(sint(1), sint(0))\n", "response_1": "from library import sint\n\ndef is_a_parallelogram(a, b, c, d):\n    def same(x, y):\n        return (x[0] == y[0]).bit_and(x[1] == y[1])\n    \n    duplicates = same(a,b).bit_or(same(a,c)).bit_or(same(a,d))\\\n                .bit_or(same(b,c)).bit_or(same(b,d)).bit_or(same(c,d))\n    \n    cond1 = (a[0]+b[0] == c[0]+d[0]).bit_and(a[1]+b[1] == c[1]+d[1])\n    cond2 = (a[0]+c[0] == b[0]+d[0]).bit_and(a[1]+c[1] == b[1]+d[1])\n    cond3 = (a[0]+d[0] == b[0]+c[0]).bit_and(a[1]+d[1] == b[1]+c[1])\n    \n    valid_shape = cond1.bit_or(cond2).bit_or(cond3)\n    return valid_shape.bit_and(duplicates.bit_not())\n", "model_name": "deepseek-r1"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs using secure MPC operations.\n    \"\"\"\n    return a.min(b)\n", "model_name": "deepseek-r1"}
{"test_name": "choice_of_the_knight", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef choice_of_the_knight(x, y):\n    moves = [\n        (1, 2), (-1, 2),\n        (1, -2), (-1, -2),\n        (2, 1), (-2, 1),\n        (2, -1), (-2, -1)\n    ]\n    \n    total = sint(0)\n    \n    def check_move(dx, dy):\n        a = x + dx\n        b = y + dy\n        legal_a = (a >= 0) & (a <= 7)\n        legal_b = (b >= 0) & (b <= 7)\n        return legal_a & legal_b\n    \n    for dx, dy in moves:\n        legal = check_move(dx, dy)\n        total += sint(legal)\n    \n    return total\n", "response_1": "def choice_of_the_knight(x, y):\n    counter = sint(0)\n    deltas = [(1, 2), (-1, 2), (1, -2), (-1, -2),\n              (2, 1), (-2, 1), (2, -1), (-2, -1)]\n    for dx, dy in deltas:\n        new_x = x + dx\n        new_y = y + dy\n        x_legal = (new_x >= 0) & (new_x <= 7)\n        y_legal = (new_y >= 0) & (new_y <= 7)\n        legal = x_legal & y_legal\n        counter += sint(legal)\n    return counter\n", "model_name": "deepseek-r1"}
{"test_name": "max_sum_difference", "response_0": "from Compiler.types import sint\n\ndef max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b using MPC-safe operations.\n    \"\"\"\n    sum_val = a + b\n    diff_val = a - b\n    return sum_val.max(diff_val)\n", "response_1": "def max_sum_different(a, b):\n    return (a + b).max(a - b)\n", "model_name": "deepseek-r1"}
