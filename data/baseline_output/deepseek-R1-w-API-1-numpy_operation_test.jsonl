{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler.types import cfix\n\nstart = 0\nend = 99\nnum = 10\nstep = (end - start) / (num - 1)\na = cfix.Array.create_from([start + i * step for i in range(num)])\n", "response_1": "from Compiler.types import cfix\n\nstart = 0\nend = 99\nnum = 10\na = cfix.Array(num)\nstep = (cfix(end) - cfix(start)) / (num - 1)\n\nfor i in range(num):\n    a[i] = cfix(start) + cfix(i) * step\n", "model_name": "deepseek-r1"}
{"test_name": "more_positive", "response_0": "def more_positive(arr):\n    from Compiler.library import tree_reduce\n    vec = arr.get_vector()\n    signs = []\n    for x in vec:\n        positive = (x > 0).if_else(sint(1), sint(0))\n        negative = (x < 0).if_else(sint(-1), sint(0))\n        signs.append(positive + negative)\n    total = tree_reduce(lambda a,b: a+b, signs)\n    return total > 0\n", "response_1": "from Compiler import library\nfrom Compiler.types import sint, sfix, MemValue\n\ndef more_positive(arr):\n    total = MemValue(sint(0))\n    n = arr.length\n    @library.for_range(n)\n    def _(i):\n        x = arr[i]\n        pos = x > sfix(0)\n        neg = x < sfix(0)\n        contribution = sint(pos) - sint(neg)\n        total.iadd(contribution)\n    return total.read() > 0\n", "model_name": "deepseek-r1"}
{"test_name": "select", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint, sfix\n\ndef select(ind, a, b):\n    n = ind.length\n    result = sfix.Array(n)\n    @for_range(n)\n    def _(i):\n        result[i] = ind[i].if_else(a[i], b[i])\n    return result\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.library import for_range\n\ndef select(ind, a, b):\n    length = len(ind)\n    result = sfix.Array(length)\n    @for_range(length)\n    def _(i):\n        result[i] = ind[i].if_else(a[i], b[i])\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function using sfix operations.\n    \"\"\"\n    return y.max(0)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return y.max(0)\n", "model_name": "deepseek-r1"}
{"test_name": "cost_matrix", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sfix\n\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    rows, cols = profit_matrix.dim[0], profit_matrix.dim[1]\n    profit_vector = profit_matrix.get_vector()\n    \n    # Compute maximum value using secure reduction\n    max_val = tree_reduce(lambda a, b: a.max(b), profit_vector)\n    \n    # Create offset matrix filled with max_val\n    offset_matrix = sfix.Matrix(rows, cols)\n    offset_matrix.assign_all(max_val)\n    \n    # Compute cost matrix through vector operations\n    cost_matrix = sfix.Matrix(rows, cols)\n    cost_matrix.assign_vector(offset_matrix.get_vector() - profit_vector)\n    \n    return cost_matrix\n", "response_1": "def cost_matrix(profit_matrix):\n    from Compiler.library import tree_reduce\n    from Compiler.types import sfix\n\n    rows = profit_matrix.rows\n    cols = profit_matrix.columns\n    max_val = tree_reduce(lambda x, y: x.max(y), profit_matrix.get_vector())\n    offset_matrix = sfix.Matrix(rows, cols)\n    offset_matrix.assign_all(max_val)\n    cost_matrix = sfix.Matrix(rows, cols)\n    cost_matrix.assign_vector(offset_matrix.get_vector() - profit_matrix.get_vector())\n    return cost_matrix\n", "model_name": "deepseek-r1"}
{"test_name": "np_zeros", "response_0": "n = 10\na = cfix.Array(n)\na.assign_all(0)\n", "response_1": "n = 10\na = sint.Array(n)\na.assign_all(0)\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ function to index i-th row from 2-D Matrix.\n    \"\"\"\n    # Get row vector from Matrix using public index\n    row_vector = ndarray.get_vector(row_index, 1)\n    # Convert vector to Array maintaining value type\n    return Array.create_from(row_vector)\n", "response_1": "from Compiler.types import *\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D matrices.\n    \"\"\"\n    # Access row using public index and return as Array\n    return ndarray[row_index]\n", "model_name": "deepseek-r1"}
{"test_name": "np_zeros_2", "response_0": "from Compiler.types import *\n\ndef zeros(n):\n    arr = cint.Array(n)\n    arr.assign_all(0)\n    return arr\n", "response_1": "def zeros(n):\n    arr = cfix.Array(n)\n    arr.assign_all(0)\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_slicing_stride", "response_0": "def array_concate(ndarrayA, ndarrayB):\n    # Calculate slice lengths\n    lenA = ndarrayA.length\n    lenB = ndarrayB.length\n    viewA_len = (lenA + 1) // 2\n    viewB_len = lenB // 2\n    \n    # Create view arrays with proper types\n    viewA = type(ndarrayA.value_type).Array(viewA_len)\n    viewB = type(ndarrayB.value_type).Array(viewB_len)\n    \n    # Populate even indices from first array\n    for i in range(viewA_len):\n        viewA[i] = ndarrayA[i * 2]\n    \n    # Populate odd indices from second array\n    for i in range(viewB_len):\n        viewB[i] = ndarrayB[i * 2 + 1]\n    \n    # Concatenate using Array method\n    return viewA.concat(viewB)\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_concate(ndarrayA, ndarrayB):\n    # Collect even indices from first array\n    viewA_len = (ndarrayA.length + 1) // 2\n    viewA_elements = [ndarrayA[i] for i in range(0, ndarrayA.length, 2)]\n    viewA = Array.create_from(viewA_elements)\n    \n    # Collect odd indices from second array (starting at index 1)\n    viewB_len = ndarrayB.length // 2\n    viewB_elements = [ndarrayB[j] for j in range(1, ndarrayB.length, 2)]\n    viewB = Array.create_from(viewB_elements)\n    \n    # Concatenate both views\n    return viewA.concat(viewB)\n", "model_name": "deepseek-r1"}
{"test_name": "QR_decomposition", "response_0": "from mpc_math import sqrt\nfrom compiler.library import for_range\n\ndef QR_decomposition(mat):\n    rows, cols = mat.dim[0], mat.dim[1]\n    Q = sfix.Matrix(rows, cols)\n    \n    for k in range(cols):\n        v = mat.get_column(k)\n        for j in range(k):\n            q_j = Q.get_column(j)\n            dot = (v * q_j).sum()\n            v -= q_j * dot\n        squared_norm = (v * v).sum()\n        norm = sqrt(squared_norm)\n        inv_norm = norm.compute_reciprocal()\n        Q.set_column(k, v * inv_norm)\n    \n    return Q\n", "response_1": "def QR_decomposition(mat):\n    from Compiler.types import Matrix\n    from Compiler import mpc_math\n    from Compiler.library import for_range\n\n    rows, cols = mat.shape\n    Q = Matrix(rows, cols, mat.value_type)()\n    Q.assign(mat)\n    \n    @for_range(cols)\n    def _(j):\n        v = Q.get_column(j)\n        \n        @for_range(j)\n        def _(k):\n            u = Q.get_column(k)\n            ip = (u.transpose().dot(v))[0][0]\n            norm_sq = (u.transpose().dot(u))[0][0]\n            scale = ip * norm_sq.compute_reciprocal()\n            v[:] = v[:] - u[:] * scale\n        \n        norm_sq = (v.transpose().dot(v))[0][0]\n        norm = mpc_math.sqrt(norm_sq)\n        recip = norm.compute_reciprocal()\n        v[:] = v[:] * recip\n        Q.set_column(j, v)\n    \n    return Q\n", "model_name": "deepseek-r1"}
{"test_name": "find_nearest_index", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sfix, sint, MemValue\n\ndef find_nearest_index(array, value):\n    n = len(array)\n    min_diff = MemValue(abs(array[0] - value))\n    min_idx = MemValue(sint(0))\n    \n    def update_min(i):\n        current_diff = abs(array[i] - value)\n        smaller = current_diff < min_diff.read()\n        min_diff.write(smaller.if_else(current_diff, min_diff.read()))\n        min_idx.write(smaller.if_else(sint(i), min_idx.read()))\n    \n    for_range(1, n)(update_min)\n    return min_idx.read()\n", "response_1": "import mpc_math\n\ndef find_nearest_index(array, value):\n    min_diff = mpc_math.abs_fx(array[0] - value)\n    min_idx = sint(0)\n    for i in range(1, len(array)):\n        diff = mpc_math.abs_fx(array[i] - value)\n        smaller = diff < min_diff\n        min_diff = smaller.if_else(diff, min_diff)\n        min_idx = smaller.if_else(sint(i), min_idx)\n    return min_idx\n", "model_name": "deepseek-r1"}
{"test_name": "np_concat_simple_row", "response_0": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate two 2-D matrices along rows (axis 0)\n    using Matrix.concat() method which handles vertical stacking\n    \"\"\"\n    return ndarrayA.concat(ndarrayB)\n", "response_1": "from Compiler.types import Matrix\n\ndef array_simple_concate_rows(arrayA, arrayB):\n    result = Matrix(arrayA.rows + arrayB.rows, arrayA.columns, arrayA.value_type)\n    result.assign(arrayA, 0)\n    result.assign(arrayB, arrayA.rows)\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_copy", "response_0": "def array_copy(original):\n    copy = original.same_shape()\n    copy.assign_vector(original.get_vector())\n    return copy\n", "response_1": "from Compiler.types import *\ndef array_copy(ndarray):\n    array_copy = ndarray.same_shape()\n    array_copy.assign(ndarray)\n    return array_copy\n", "model_name": "deepseek-r1"}
{"test_name": "max_pooling", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\nfrom Compiler import util\n\ndef max_pooling(x, stride):\n    batch_size = x.sizes[0]\n    in_height = x.sizes[1]\n    in_width = x.sizes[2]\n    out_dims = (in_height // stride, in_width // stride)\n    \n    out = MultiArray([batch_size, out_dims[0], out_dims[1]], sfix)\n    \n    @for_range(batch_size)\n    def _(b):\n        @for_range(out_dims[0])\n        def _(i):\n            @for_range(out_dims[1])\n            def _(j):\n                i_start = i * stride\n                j_start = j * stride\n                \n                window = []\n                @for_range(stride)\n                def _(dr):\n                    @for_range(stride)\n                    def _(dc):\n                        window.append(x[b][i_start + dr][j_start + dc])\n                \n                out[b][i][j] = tree_reduce(lambda a,b: a.max(b), window)\n    \n    return out\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import MultiArray, MemValue\n\ndef max_pooling(x, stride):\n    batch_size = x.sizes[0]\n    in_height = x.sizes[1]\n    in_width = x.sizes[2]\n    out_height = in_height // stride\n    out_width = in_width // stride\n    out = MultiArray([batch_size, out_height, out_width], x.value_type)\n    \n    @for_range(batch_size)\n    def _(b):\n        @for_range(out_height)\n        def _(ki):\n            i = ki * stride\n            @for_range(out_width)\n            def _(kj):\n                j = kj * stride\n                current_max = MemValue(x[b, i, j])\n                @for_range(stride)\n                def _(di):\n                    @for_range(stride)\n                    def _(dj):\n                        element = x[b, i + di, j + dj]\n                        current_max.write(current_max.read().max(element))\n                out[b, ki, kj] = current_max.read()\n    return out\n", "model_name": "deepseek-r1"}
{"test_name": "array_reshape", "response_0": "from Compiler.types import cint\n\na = cint.Matrix(3, 5)\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = i * 5 + j\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\na = cint.Matrix(3, 5)\nvalues = cint.Array(15)\n@for_range(15)\ndef _(i):\n    values[i] = i\na.assign(values)\n", "model_name": "deepseek-r1"}
{"test_name": "np_concat_simple_column", "response_0": "from Compiler.types import Matrix\n\ndef array_simple_concate_column(matrixA, matrixB):\n    \"\"\"\n    MP-SPDZ program to concatenate two 2-D matrices along columns.\n    \"\"\"\n    return matrixA.concat_columns(matrixB)\n", "response_1": "from Compiler.types import Matrix\n\ndef array_simple_concate_column(matrixA, matrixB):\n    \"\"\"\n    MP-SPDZ program to concatenate two 2D matrices column-wise.\n    \"\"\"\n    return matrixA.concat_columns(matrixB)\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "from Compiler.types import *\ndef array_dimensional_indexing(matrix, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D matrices.\n    \"\"\"\n    column_vector = matrix.get_column(column_index)\n    return matrix.value_type.Array.create_from(column_vector)\n", "response_1": "from Compiler.types import sint, Matrix\n\ndef array_dimensional_indexing(matrix, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D matrices.\n    \"\"\"\n    column_vector = matrix.get_column(column_index)\n    return sint.Array.create_from(column_vector)\n", "model_name": "deepseek-r1"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    diagonal = array.diag()\n    return array.value_type.Array.create_from(diagonal)\n", "response_1": "def diag(matrix):\n    return matrix.diag()\n", "model_name": "deepseek-r1"}
{"test_name": "np_concat_special", "response_0": "from Compiler.library import for_range\ndef array_special_concate(A, B):\n    rows_A = A.sizes[0]\n    cols_A = A.sizes[1]\n    cols_B = B.sizes[1]\n    even_cols = cols_A // 2 + cols_A % 2\n    odd_cols = cols_B // 2\n    total_cols = even_cols + odd_cols\n    result = A.value_type.Matrix(rows_A, total_cols)\n    \n    current_col = 0\n    @for_range(cols_A)\n    def _(i):\n        if i % 2 == 0:\n            result.set_column(current_col, A.get_column(i))\n            current_col.update(current_col + 1)\n    \n    @for_range(cols_B)\n    def _(i):\n        if i % 2 == 1:\n            result.set_column(current_col, B.get_column(i))\n            current_col.update(current_col + 1)\n    \n    return result\n", "response_1": "from Compiler.types import Matrix\n\ndef array_special_concate(A, B):\n    # Calculate column counts for each view\n    a_cols = (A.columns + 1) // 2\n    b_cols = B.columns // 2\n    \n    # Create result matrix with combined columns\n    result = Matrix(A.rows, a_cols + b_cols, A.value_type)\n    col_idx = 0\n    \n    # Collect even columns from A\n    for i in range(0, A.columns, 2):\n        result.set_column(col_idx, A.get_column(i))\n        col_idx += 1\n    \n    # Collect odd columns from B \n    for i in range(1, B.columns, 2):\n        result.set_column(col_idx, B.get_column(i))\n        col_idx += 1\n    \n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_arange", "response_0": "def arange(start, stop=None, step=1):\n    if stop is None:\n        stop = start\n        start = 0\n        \n    length = (stop - start + step - 1) // step\n    array = sint.Array(length)\n    \n    for i in range(length):\n        array[i] = sint(start + i * step)\n        \n    return array\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef arange(start, stop=None, step=1):\n    if stop is None:\n        stop = start\n        start = 0\n    \n    # Calculate array length using integer division\n    length = (stop - start + step - 1) // step if step > 0 else (start - stop - step - 1) // (-step)\n    length = max(0, length)\n    \n    # Create cint array with proper length\n    arr = cint.Array(length)\n    \n    @for_range_opt(length)\n    def _(i):\n        arr[i] = start + i * step\n    \n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "np_eye_2", "response_0": "from Compiler.types import *\nm = 3\nn = 5\na = Matrix(m, n, cfix)\na.assign_all(cfix(0))\nfor i in range(min(m, n)):\n    a[i][i] = cfix(1)\n", "response_1": "from Compiler.types import cint\nfrom Compiler.library import for_range\n\ndef main():\n    m = 3\n    n = 5\n    a = cint.Matrix(m, n)\n    a.assign_all(0)\n    \n    @for_range(m)\n    def _(i):\n        a[i][i] = 1\n", "model_name": "deepseek-r1"}
{"test_name": "third_smallest", "response_0": "def third_smallest(arr):\n    # Create a copy of the input array to avoid modifying original\n    sorted_arr = sint.Array(len(arr))\n    sorted_arr.assign_vector(arr.get_vector())\n    \n    # Sort the copied array in-place using radix sort\n    sorted_arr.sort()\n    \n    # Return third element (index 2) from sorted array\n    return sorted_arr[2]\n", "response_1": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    sorted_arr = arr.same_shape()\n    sorted_arr.assign_vector(arr)\n    sorted_arr.sort()\n    return sorted_arr[2]\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef array_dimensional_indexing(matrix, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D matrices using secure indexing.\n    \"\"\"\n    rows, cols = matrix.sizes[0], matrix.sizes[1]\n    result = matrix.value_type.Matrix(1, cols)\n    \n    for i in range(rows):\n        cond = (row_index == i)\n        row_vector = matrix[i].get_vector()\n        selected_row = cond.if_else(row_vector, matrix.value_type.Array(cols)(0))\n        result[0].assign_vector(result[0].get_vector() + selected_row)\n    \n    return result\n", "response_1": "def array_dimensional_indexing(matrix, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D Matrix.\n    \"\"\"\n    row_vector = matrix.get_vector(row_index, 1)\n    return matrix.value_type.Array.create_from(row_vector)\n", "model_name": "deepseek-r1"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = cint.Array.create_from(range(n))\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import cint\n\nn = 10\na = cint.Array(n)\n\n@for_range(n)\ndef _(i):\n    a[i] = i\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    row_vector = ndarray.get_vector(row_index)\n    return ndarray.value_type.Array.create_from(row_vector)\n", "response_1": "def array_dimensional_indexing(matrix, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2D Matrix.\n    \"\"\"\n    row_vector = matrix.get_vector(row_index, 1)\n    array = matrix.value_type.Array.create_from(row_vector)\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler.types import *\na_l = [0, 10, 20, 30, 40]\na = cint.Array.create_from(a_l)\n", "response_1": "from Compiler.types import *\na_l = [0,10,20,30,40]\na = cint.Array.create_from(a_l)\n", "model_name": "deepseek-r1"}
{"test_name": "np_reshape", "response_0": "from Compiler.types import Matrix, Array\nfrom Compiler.library import for_range\n\ndef array_reshape(ndarray, m, n):\n    value_type = ndarray.value_type\n    matrix = value_type.Matrix(m, n)\n    total = m * n\n    \n    @for_range(total)\n    def _(i):\n        row = i // n\n        col = i % n\n        matrix[row][col] = ndarray[i]\n    \n    return matrix\n", "response_1": "from Compiler.types import Matrix\n\ndef array_reshape(ndarray, m, n):\n    matrix = Matrix(m, n, ndarray.value_type)\n    matrix.assign_vector(ndarray.get_vector())\n    return matrix\n", "model_name": "deepseek-r1"}
{"test_name": "np_ones", "response_0": "n = 10\na = cfix.Array(n)\na.assign_all(1)\n", "response_1": "from Compiler.types import cint\n\nn = 10\na = cint.Array(n)\na.assign_all(1)\n", "model_name": "deepseek-r1"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    # Create condition mask (secret bit vector) for y != 1\n    mask = y.get_vector() != 1\n    # Element-wise multiplication with original values (1s become 0, others remain)\n    new_values = mask * y.get_vector()\n    # Update array with modified values\n    y.assign_vector(new_values)\n    return y\n", "response_1": "def set_one_to_zero(y):\n    for i in range(y.length):\n        bit = y[i] == 1\n        y[i] = bit.if_else(0, y[i])\n    return y\n", "model_name": "deepseek-r1"}
{"test_name": "np_eye", "response_0": "n = 10\na = cint.Matrix(n, n)\nfor i in range(n):\n    for j in range(n):\n        a[i][j] = cint(i == j)\n", "response_1": "n = 10\na = sint.Matrix(n, n)\n\nfor i in range(n):\n    for j in range(n):\n        a[i][j] = sint(1 if i == j else 0)\n", "model_name": "deepseek-r1"}
{"test_name": "np_diag", "response_0": "from Compiler.types import cint\n\na_l = [1, 3, 5, 2, 4, 6]\nn = len(a_l)\na = cint.Matrix(n, n)\na.assign_all(0)\nfor i in range(n):\n    a[i][i] = a_l[i]\n", "response_1": "from Compiler.types import cint\n\na_l = [1, 3, 5, 2, 4, 6]\na = cint.Matrix(6, 6)\na.assign_all(0)\n\nfor i in range(6):\n    a[i][i].update(cint(a_l[i]))\n", "model_name": "deepseek-r1"}
{"test_name": "np_advanced_integer_indexing", "response_0": "from Compiler.oram import OptimalORAM\n\ndef integer_array_indexing(array, indices):\n    size = len(array)\n    oram = OptimalORAM(size, value_type=type(array[0]))\n    \n    @for_range(size)\n    def _(j):\n        oram[sint(j)] = array[j]\n    \n    result = type(array).Array(len(indices))\n    \n    @for_range(len(indices))\n    def _(i):\n        result[i] = oram[indices[i]]\n    \n    return result\n", "response_1": "from Compiler.oram import OptimalORAM\nfrom Compiler.types import sint\n\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing a secret array using secret integer indices via ORAM.\n    \"\"\"\n    # Create ORAM with the same size as input array\n    oram = OptimalORAM(len(array))\n    \n    # Initialize ORAM with array values\n    for i in range(len(array)):\n        oram[i] = array[i]\n    \n    # Create result array of same type\n    result = sint.Array(len(indices))\n    \n    # Access ORAM with secret indices\n    for i in range(len(indices)):\n        result[i] = oram[indices[i]]\n    \n    return result\n", "model_name": "deepseek-r1"}
