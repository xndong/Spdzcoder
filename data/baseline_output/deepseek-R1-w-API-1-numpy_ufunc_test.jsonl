{"test_name": "cross_entropy_loss", "response_0": "from mpc_math import log_fx\n\ndef cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss.\n    \"\"\"\n    e = cfix(2.718281828459045)\n    total = sfix(0)\n    for i in range(len(y)):\n        yi = y[i]\n        log_term = log_fx(yi, e)\n        total += yi * log_term\n    return -total\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sfix, cfix\nimport math\n\ndef cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss.\n    \"\"\"\n    e = cfix(math.e)\n    total = sfix(0)\n    for i in range(len(y)):\n        y_i = y[i]\n        log_y_i = mpc_math.log_fx(y_i, e)\n        total += y_i * log_y_i\n    return -total\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_square_sqrt", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\nfrom Compiler import mpc_math\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Compute mean of array elements\n    sum_val = tree_reduce(lambda a, b: a + b, array.get_vector())\n    mean = sum_val / array.length\n    \n    # Calculate deviations from mean\n    deviation_vector = array.get_vector() - mean\n    deviation = sfix.Array.create_from(deviation_vector)\n    \n    # Square the deviations\n    square_vector = deviation.get_vector() ** 2\n    square = sfix.Array.create_from(square_vector)\n    \n    # Compute mean of squared deviations\n    sum_square = tree_reduce(lambda a, b: a + b, square.get_vector())\n    square_mean = sum_square / array.length\n    \n    # Calculate square root of mean squared deviations\n    rmsd = mpc_math.sqrt(square_mean)\n    return rmsd\n", "response_1": "from Compiler.library import tree_reduce\nfrom Compiler import mpc_math\nfrom Compiler.types import *\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Compute sum of elements\n    elements = array.get_vector()\n    sum_elements = tree_reduce(lambda x,y: x + y, elements)\n    n = array.length\n    mean = sum_elements / n\n    \n    # Compute deviations and squares\n    deviations = elements - mean\n    squares = [x**2 for x in deviations]\n    \n    # Compute mean of squares\n    sum_squares = tree_reduce(lambda x,y: x + y, squares)\n    square_mean = sum_squares / n\n    \n    # Compute square root of mean squares\n    rmsd = mpc_math.sqrt(square_mean)\n    return rmsd\n", "model_name": "deepseek-r1"}
{"test_name": "logsumexp", "response_0": "from Compiler.library import tree_reduce\n\ndef logsumexp(log_probs):\n    # Compute maximum element in the array\n    _max = tree_reduce(lambda a, b: a.max(b), log_probs.get_vector())\n    \n    # Subtract max from all elements and exponentiate\n    ds_vector = log_probs.get_vector() - _max\n    exp_ds_vector = ds_vector.exp()\n    \n    # Sum the exponentiated values and compute log\n    exp_sum = exp_ds_vector.sum()\n    \n    # Return logsumexp result\n    return _max + exp_sum.log()\n", "response_1": "from Compiler.library import *\nfrom mpc_math import *\n\ndef logsumexp(log_probs):\n    # Compute maximum value in log_probs array\n    _max = tree_reduce(lambda a, b: a.max(b), log_probs.get_vector())\n    \n    # Subtract max from all elements (vectorized operation)\n    ds_vector = log_probs.get_vector() - _max\n    \n    # Create new array for exponentiated values\n    exp_ds = sfix.Array(len(log_probs))\n    \n    # Compute exponentials element-wise\n    @for_range(len(log_probs))\n    def _(i):\n        exp_ds[i] = exp_fx(ds_vector[i])\n    \n    # Sum the exponentiated values and compute log\n    exp_sum = exp_ds.get_vector().sum()\n    log_sum = log_fx(exp_sum)\n    \n    # Final result with numerical stability\n    return _max + log_sum\n", "model_name": "deepseek-r1"}
{"test_name": "binary_cross_entropy_loss", "response_0": "from Compiler import library\nfrom Compiler import mpc_math\nfrom Compiler.types import sfix, cfix\n\ndef binary_cross_entropy(y_hat, y):\n    epsilon = cfix(0.001)\n    # Clip values using element-wise operations\n    y_hat_clipped = y_hat * (cfix(1) - 2 * epsilon) + epsilon\n    # Compute logarithmic terms with base 2\n    log_y_hat = mpc_math.log_fx(y_hat_clipped, cfix(2))\n    log_one_minus = mpc_math.log_fx(cfix(1) - y_hat_clipped, cfix(2))\n    # Element-wise computation of loss components\n    loss_components = y * log_y_hat + (cfix(1) - y) * log_one_minus\n    # Secure aggregation using tree reduction\n    total = library.tree_reduce(lambda a,b: a+b, loss_components.get_vector())\n    # Final loss calculation with secure fixed-point division\n    return -total / cfix(len(y_hat))\n", "response_1": "from Compiler.types import sfix, cfix\nfrom Compiler import mpc_math\nfrom Compiler.library import for_range\n\ndef binary_cross_entropy(y_hat, y):\n    epsilon = cfix(0.001)\n    n = y_hat.size\n    total = sfix(0)\n    one = cfix(1)\n    \n    for i in for_range(n):\n        yh_i = y_hat[i]\n        y_i = y[i]\n        \n        clipped = yh_i * (one - 2 * epsilon) + epsilon\n        log_term1 = mpc_math.log_fx(clipped, 2)\n        term1 = y_i * log_term1\n        \n        one_minus_clipped = one - clipped\n        log_term2 = mpc_math.log_fx(one_minus_clipped, 2)\n        term2 = (one - y_i) * log_term2\n        \n        total += term1 + term2\n    \n    loss = -total / n\n    return loss\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_less_equal", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef compute_less_equal(arrayA, arrayB):\n    n = arrayA.length\n    result = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        cmp = arrayA[i] <= arrayB[i]\n        result[i] = cmp.if_else(sint(1), sint(0))\n    return result\n", "response_1": "from Compiler.GC.types import sbitint\nfrom Compiler.types import Array\n\ndef compute_less_equal(arrayA, arrayB):\n    result = sbitint.Array(len(arrayA))\n    for i in range(len(arrayA)):\n        result[i] = arrayA[i] <= arrayB[i]\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "RMS_prop_step", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import sfix, Array\n\ndef RMS_prop_step(grads, layers):\n    alpha = sfix(0.5)\n    beta = sfix(1.0)\n    one_minus_beta = sfix(1) - beta\n    \n    s = []\n    for grad in grads:\n        s_i = sfix.Array(grad.size)\n        s_i.assign_all(sfix(0))\n        s.append(s_i)\n    \n    for i in range(len(layers)):\n        grad = grads[i]\n        layer = layers[i]\n        s_i = s[i]\n        \n        for j in range(grad.size):\n            grad_val = grad[j]\n            s_val = s_i[j]\n            \n            # Update squared gradient accumulator\n            new_s = beta * s_val + one_minus_beta * (grad_val * grad_val)\n            s_i[j] = new_s\n            \n            # Compute normalized gradient\n            sqrt_s = mpc_math.sqrt(new_s)\n            adjusted_grad = alpha * (grad_val / sqrt_s)\n            \n            # Update layer parameters\n            layer[j] += adjusted_grad\n    \n    return layers\n", "response_1": "from compiler.types import sfix, cfix, Array\nfrom compiler.library import for_range\nimport mpc_math\n\ndef RMS_prop_step(grads, layers):\n    alpha = cfix(0.5)\n    beta = cfix(1.0)\n    s = []\n    for grad in grads:\n        s_i = sfix.Array(len(grad))\n        s_i.assign_all(sfix(0))\n        s.append(s_i)\n    for i in range(len(grads)):\n        grad = grads[i]\n        s_i = s[i]\n        layer = layers[i]\n        s_new = beta * s_i.get_vector() + (cfix(1) - beta) * (grad.get_vector() ** 2)\n        s_i.assign_vector(s_new)\n        adjusted_grad = sfix.Array(len(grad))\n        @for_range(len(grad))\n        def _(j):\n            sqrt_val = mpc_math.sqrt(s_i[j])\n            adjusted_grad[j] = alpha * (grad[j] / sqrt_val)\n        layer.assign_vector(layer.get_vector() + adjusted_grad.get_vector())\n    return layers\n", "model_name": "deepseek-r1"}
{"test_name": "entropy", "response_0": "def entropy(y):\n    import mpc_math\n    n = sfix(len(y))\n    sum_total = sfix(0)\n    classes = Array.create_from(y).unique()\n    for c in classes:\n        count = sum((elem == c).if_else(sfix(1), sfix(0)) for elem in y)\n        p = count / n\n        non_zero = (count != 0)\n        term = non_zero.if_else(p * mpc_math.log2_fx(p), sfix(0))\n        sum_total += term\n    return -sum_total\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler import mpc_math\nfrom Compiler.library import for_range\n\ndef entropy(y, possible_classes):\n    \"\"\"\n    Compute the entropy of the given array over possible classes\n    \"\"\"\n    sum_ = sfix(0)\n    n = y.size\n    for class_val in possible_classes:\n        v = sint(0)\n        for elem in y:\n            v += (elem == class_val).if_else(1, 0)\n        p = sfix(v) / sfix(n)\n        log_p = mpc_math.log_fx(2, p)\n        term = -p * log_p\n        sum_ += term * (v != 0).if_else(sfix(1), sfix(0))\n    return sum_\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_exp", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler import mpc_math\n\ndef compute_softmax(array):\n    exp_array = Array.create_from([mpc_math.exp_fx(x) for x in array.get_vector()])\n    sum_exp = exp_array.get_vector().sum()\n    softmax_array = Array.create_from([x / sum_exp for x in exp_array.get_vector()])\n    return softmax_array\n", "response_1": "from Compiler.library import *\nfrom Compiler import mpc_math\n\ndef compute_softmax(array):\n    exp_array = sfix.Array(len(array))\n    @for_range(len(array))\n    def _(i):\n        exp_array[i] = mpc_math.exp_fx(array[i])\n    sum_exp = tree_reduce(lambda a, b: a + b, exp_array[:])\n    softmax = sfix.Array(len(array))\n    @for_range(len(array))\n    def _(i):\n        softmax[i] = exp_array[i] / sum_exp\n    return softmax\n", "model_name": "deepseek-r1"}
{"test_name": "tanh", "response_0": "from library import mpc_math\n\nclass Tanh():\n    def fn(self, z):\n        return mpc_math.tanh(z)\n    \n    def grad(self, x):\n        tanh_x = mpc_math.tanh(x)\n        return 1 - (tanh_x ** 2)\n", "response_1": "from Compiler import mpc_math\n\nclass Tanh:\n    def fn(self, z):\n        return mpc_math.tanh(z)\n    \n    def grad(self, x):\n        tanh_x = mpc_math.tanh(x)\n        return 1 - (tanh_x ** 2)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_tan", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import *\nfrom Compiler.library import *\n\ndef compute_tan(array):\n    # This function calculates trigonometric tangent, element-wise\n    n = len(array)\n    tan_res = Array(n, sfix)\n    @for_range(n)\n    def _(i):\n        tan_res[i] = mpc_math.tan(array[i])\n    return tan_res\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import *\n\ndef compute_tan(array):\n    \"\"\"This function calculates trigonometric tangent, element-wise.\"\"\"\n    vec = array.get_vector()\n    tan_vec = [mpc_math.tan(x) for x in vec]\n    return type(array).create_from(tan_vec)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_greater", "response_0": "from Compiler.types import sint\n\ndef compute_greater(arrayA, arrayB):\n    \"\"\"This function calculates element-wise comparison (arrayA > arrayB)\"\"\"\n    length = len(arrayA)\n    result = sint.Array(length)\n    \n    @for_range(length)\n    def _(i):\n        # Compare elements and convert sbit result to sint (1/0)\n        result[i] = (arrayA[i] > arrayB[i]).if_else(sint(1), sint(0))\n        \n    return result\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef compute_greater(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is greater than arrayB.\"\"\"\n    n = arrayA.length\n    result = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        result[i] = sint(arrayA[i] > arrayB[i])\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_maximum", "response_0": "from library import for_range\n\ndef compute_maximum(arrayA, arrayB):\n    length = len(arrayA)\n    result = type(arrayA[0]).Array(length)\n    @for_range(length)\n    def _(i):\n        result[i] = arrayA[i].max(arrayB[i])\n    return result\n", "response_1": "from Compiler.library import for_range\n\ndef compute_maximum(arrayA, arrayB):\n    result = arrayA.same_shape()\n    @for_range(arrayA.length)\n    def _(i):\n        result[i] = arrayA[i].max(arrayB[i])\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_log2", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import sfix, Array\n\ndef compute_log2(array):\n    \"\"\"This function calculates base-2 logarithm of x in the input array.\"\"\"\n    log2_array = Array(array.length, sfix)\n    for i in range(array.length):\n        log2_array[i] = mpc_math.log_fx(array[i], 2)\n    return log2_array\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_log2(array):\n    \"\"\"This function calculate base-2 logarithm of x in the input array.\"\"\"\n    log_array = Array(len(array), sfix)\n    @for_range(len(array))\n    def _(i):\n        log_array[i] = mpc_math.log_fx(array[i], 2)\n    return log_array\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_absolute", "response_0": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef obtain_absolute(array):\n    \"\"\"This function computes the absolute values in an MP-SPDZ array.\"\"\"\n    result = array.same_shape()\n    @for_range_opt(array.length)\n    def _(i):\n        result[i] = array[i].abs()\n    return result\n", "response_1": "from Compiler.types import *\nfrom Compiler.library import *\n\ndef obtain_absolute(array):\n    \"\"\"This function computes the absolute values in an MP-SPDZ array.\"\"\"\n    abs_vector = [x.abs() for x in array.get_vector()]\n    return Array.create_from(abs_vector)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_arctan", "response_0": "from mpc_math import atan\nfrom Compiler.types import *\nfrom Compiler.library import *\n\ndef compute_arctan(array):\n    arctan_res = Array(len(array), sfix)\n    @for_range(len(array))\n    def _(i):\n        arctan_res[i] = atan(array[i])\n    return arctan_res\n", "response_1": "from Compiler.types import *\nfrom Compiler import mpc_math\n\ndef compute_arctan(array):\n    \"\"\"This function calculates trigonometric inverse tangent, element-wise.\"\"\"\n    arctan_vec = mpc_math.atan(array.get_vector())\n    return type(array).create_from(arctan_vec)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_log", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import *\nimport math\n\ndef compute_log(array):\n    \"\"\"This function calculates natural logarithm for all elements in the input array.\"\"\"\n    n = len(array)\n    result = sfix.Array(n)\n    base = cfix(math.e)\n    \n    for i in range(n):\n        result[i] = mpc_math.log_fx(array[i], base)\n    \n    return result\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sfix\nimport math\n\ndef compute_log(array):\n    \"\"\"This function calculates natural logarithm for all p in the input array.\"\"\"\n    nlog = sfix.Array(len(array))\n    e = sfix(math.e)\n    for i in range(len(array)):\n        nlog[i] = mpc_math.log_fx(array[i], e)\n    return nlog\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_not_equal", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef compute_not_equal(arrayA, arrayB):\n    n = len(arrayA)\n    result = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        result[i] = (arrayA[i] != arrayB[i]).if_else(1, 0)\n    return result\n", "response_1": "def compute_not_equal(arrayA, arrayB):\n    \"\"\"This function calculates element-wise secret integer inequality comparison.\"\"\"\n    length = len(arrayA)\n    result = sint.Array(length)\n    for i in range(length):\n        result[i] = (arrayA[i] != arrayB[i]).if_else(sint(1), sint(0))\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_equal", "response_0": "from Compiler.types import Array\n\ndef compute_equal(arrayA, arrayB):\n    return Array.create_from([arrayA[i] == arrayB[i] for i in range(arrayA.length)])\n", "response_1": "def compute_equal(arrayA, arrayB):\n    length = len(arrayA)\n    eq = sint.Array(length)\n    @for_range(length)\n    def _(i):\n        eq[i] = (arrayA[i] == arrayB[i]).if_else(sint(1), sint(0))\n    return eq\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_true_divide", "response_0": "from Compiler.types import sfix, Array\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"Element-wise division between two secret fixed-point arrays.\"\"\"\n    result = Array.create_from(arrayA.get_vector() / arrayB.get_vector())\n    return result\n", "response_1": "from Compiler import types, library\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"Element-wise division between two secret fixed-point arrays.\"\"\"\n    length = len(arrayA)\n    result = types.sfix.Array(length)\n    \n    @library.for_range(length)\n    def _(i):\n        result[i] = arrayA[i] / arrayB[i]\n    \n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_greater_equal", "response_0": "from GC.types import sbitint\nfrom library import sint\n\ndef compute_greater_equal(arrayA, arrayB):\n    # Get underlying vectors for element-wise comparison\n    vec_a = arrayA.get_vector()\n    vec_b = arrayB.get_vector()\n    \n    # Perform secure element-wise >= comparison\n    comparison = vec_a >= vec_b\n    \n    # Convert result vector to sbitint Array\n    return sbitint.Array.create_from(comparison)\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import *\n\ndef compute_greater_equal(arrayA, arrayB):\n    a_vec = arrayA.get_vector()\n    b_vec = arrayB.get_vector()\n    cmp_results = a_vec >= b_vec\n    sint_results = [res.if_else(sint(1), sint(0)) for res in cmp_results]\n    return sint.Array.create_from(sint_results)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_negative", "response_0": "from Compiler.types import *\ndef negative(arrayA):\n    result = arrayA.same_shape()\n    result.assign_vector(-arrayA.get_vector())\n    return result\n", "response_1": "from Compiler.types import *\n\ndef negative(arrayA):\n    # Get vector representation and apply element-wise negation\n    negated_vector = -arrayA.get_vector()\n    # Create new array with same type and store negated values\n    return arrayA.value_type.Array.create_from(negated_vector)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_power", "response_0": "from Compiler import mpc_math\nfrom Compiler.library import for_range\n\ndef power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    n = len(arrayA)\n    result = sfix.Array(n)\n    @for_range(n)\n    def _(i):\n        result[i] = mpc_math.pow_fx(arrayA[i], arrayB[i])\n    return result\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import *\n\ndef power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    n = len(arrayA)\n    result = sfix.Array(n)\n    for i in range(n):\n        result[i] = mpc_math.pow_fx(arrayA[i], arrayB[i])\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_exp2", "response_0": "from Compiler import mpc_math\nfrom Compiler.library import *\n\ndef compute_exp2(array):\n    exp_array = sfix.Array(len(array))\n    @for_range(len(array))\n    def _(i):\n        exp_array[i] = mpc_math.pow_fx(2.0, array[i])\n    return exp_array\n", "response_1": "from Compiler import mpc_math\n\ndef compute_exp2(array):\n    exp = sfix.Array(len(array))\n    two = sfix(2.0)\n    for i in range(len(array)):\n        exp[i] = mpc_math.pow_fx(two, array[i])\n    return exp\n", "model_name": "deepseek-r1"}
{"test_name": "cross_entropy_loss_class", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import sfix, cfix, Array\n\nclass CrossEntropy():\n    def loss(self, y, y_pred):\n        log_terms = sfix.Array(len(y))\n        for i in range(len(y)):\n            log_terms[i] = mpc_math.log_fx(y_pred[i], cfix(2))\n        product = y[:] * log_terms[:]\n        cross_entropy = -product.sum()\n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        n = cfix(len(y))\n        grad = Array.create_from(y_pred[:] - y[:])\n        grad[:] /= n\n        return grad\n", "response_1": "from Compiler.types import sfix, cfix\nfrom Compiler import mpc_math\n\nclass CrossEntropy():\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss using secure fixed-point arithmetic\n        \"\"\"\n        n = y.size\n        sum_val = sfix(0)\n        for i in range(n):\n            sum_val += y[i] * mpc_math.log_fx(y_pred[i], 2)\n        return -sum_val\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient using secure fixed-point arithmetic\n        \"\"\"\n        n = y.size\n        inv_n = cfix(1) / cfix(n)\n        grad = sfix.Array(n)\n        for i in range(n):\n            grad[i] = (y_pred[i] - y[i]) * inv_n\n        return grad\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_arccos", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import sfix, Array\n\ndef compute_arccos(array):\n    \"\"\"This function calculates trigonometric inverse cosine, element-wise.\"\"\"\n    length = len(array)\n    result = sfix.Array(length)\n    for i in range(length):\n        result[i] = mpc_math.acos(array[i])\n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef compute_arccos(array):\n    \"\"\"This function calculates trigonometric inverse cosine, element-wise.\"\"\"\n    arccos_res = sfix.Array(len(array))\n    for i in range(len(array)):\n        arccos_res[i] = mpc_math.acos(array[i])\n    return arccos_res\n", "model_name": "deepseek-r1"}
{"test_name": "r2_score", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sfix\n\ndef r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score.\n    \"\"\"\n    # Compute mean of y_test\n    sum_y_test = tree_reduce(lambda a, b: a + b, y_test.get_vector())\n    mean_y_test = sum_y_test / len(y_test)\n    \n    # Compute total sum of squares\n    total_diff = [y - mean_y_test for y in y_test.get_vector()]\n    total_squared = [d * d for d in total_diff]\n    total_sum_squares = tree_reduce(lambda a, b: a + b, total_squared)\n    \n    # Compute residual sum of squares\n    residual_diff = [y_test[i] - y_hat[i] for i in range(len(y_test))]\n    residual_squared = [d * d for d in residual_diff]\n    residual_sum_squares = tree_reduce(lambda a, b: a + b, residual_squared)\n    \n    return 1 - (residual_sum_squares / total_sum_squares)\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef r2_score(y_hat, y_test):\n    # Compute mean of y_test\n    sum_ys = MemValue(sfix(0))\n    n = y_test.length\n    @for_range(n)\n    def _(i):\n        sum_ys.iadd(y_test[i])\n    mean_y = sum_ys.read() / n\n\n    # Compute total sum of squares\n    tss = MemValue(sfix(0))\n    @for_range(n)\n    def _(i):\n        diff = y_test[i] - mean_y\n        tss.iadd(diff * diff)\n\n    # Compute residual sum of squares\n    rss = MemValue(sfix(0))\n    @for_range(n)\n    def _(i):\n        diff = y_test[i] - y_hat[i]\n        rss.iadd(diff * diff)\n\n    # Calculate and return R\u00b2 score\n    return 1 - (rss.read() / tss.read())\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_arcsin", "response_0": "from Compiler import mpc_math\nfrom Compiler.library import for_range\nfrom Compiler.types import sfix, Array\n\ndef compute_arcsin(array):\n    \"\"\"This function calculates trigonometric inverse sine, element-wise.\"\"\"\n    length = len(array)\n    arcsin_res = Array.create_from([sfix(0)] * length)\n    \n    @for_range(length)\n    def _(i):\n        arcsin_res[i] = mpc_math.asin(array[i])\n        \n    return arcsin_res\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import *\n\ndef compute_arcsin(array):\n    \"\"\"This function calculate trigonometric inverse sine, element-wise.\"\"\"\n    input_vector = array.get_vector()\n    output_vector = [mpc_math.asin(x) for x in input_vector]\n    return sfix.Array.create_from(output_vector)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_true_divide2", "response_0": "from Compiler.types import sfix, Array\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"Element-wise division between two secret fixed-point arrays.\"\"\"\n    # Get vector representations for element-wise operations\n    a_vec = arrayA.get_vector()\n    b_vec = arrayB.get_vector()\n    \n    # Perform secure element-wise division\n    res_vec = a_vec / b_vec\n    \n    # Convert result vector back to Array type\n    res_array = Array.create_from(res_vec)\n    return res_array\n", "response_1": "from Compiler.types import sfix, Array\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"Element-wise division between two 1D secret fixed-point arrays.\"\"\"\n    res_vector = arrayA.get_vector() / arrayB.get_vector()\n    return sfix.Array.create_from(res_vector)\n", "model_name": "deepseek-r1"}
{"test_name": "square_error_loss", "response_0": "def squre_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    sum_sq = sfix(0)\n    size = len(y)\n    for i in range(size):\n        diff = y_pred[i] - y[i]\n        sum_sq += diff * diff\n    return sum_sq * 0.5\n", "response_1": "from Compiler.library import tree_reduce\n\ndef squre_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    diff = y_pred.get_vector() - y.get_vector()\n    squared_diff = diff * diff\n    sum_squared = tree_reduce(lambda a, b: a + b, squared_diff)\n    return 0.5 * sum_squared\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_less", "response_0": "from Compiler.types import sint\n\ndef compute_less(arrayA, arrayB):\n    a_vec = arrayA.get_vector()\n    b_vec = arrayB.get_vector()\n    less_bits = a_vec < b_vec\n    less_sints = less_bits.if_else(sint(1), sint(0))\n    return sint.Array.create_from(less_sints)\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_less(arrayA, arrayB):\n    a_vec = arrayA.get_vector()\n    b_vec = arrayB.get_vector()\n    less_bits = a_vec < b_vec\n    less_res = less_bits.if_else(sint(1), sint(0))\n    return sint.Array.create_from(less_res)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_cos", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import Array, sfix\n\ndef compute_cosine(array):\n    \"\"\"This function calculates trigonometric cosine, element-wise.\"\"\"\n    cos_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        cos_res[i] = mpc_math.cos(array[i])\n    return cos_res\n", "response_1": "from Compiler.types import *\nfrom Compiler import mpc_math\n\ndef compute_cosine(array):\n    \"\"\"This function calculates trigonometric cosine, element-wise.\"\"\"\n    cos_res = sfix.Array(len(array))\n    for i in range(len(array)):\n        cos_res[i] = mpc_math.cos(array[i])\n    return cos_res\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_sin", "response_0": "from library import mpc_math\nfrom types import *\n\ndef compute_sine(array):\n    \"\"\"This function calculates trigonometric sine, element-wise.\"\"\"\n    result = sfix.Array(len(array))\n    for i in range(len(array)):\n        result[i] = mpc_math.sin(array[i])\n    return result\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sfix, Array\n\ndef compute_sine(array):\n    \"\"\"This function calculates trigonometric sine, element-wise.\"\"\"\n    vec = array.get_vector()\n    sin_vector = mpc_math.sin(vec)\n    return Array.create_from(sin_vector)\n", "model_name": "deepseek-r1"}
{"test_name": "update_weights", "response_0": "def update_weights(m, A, X, Y):\n    A_Y_diff = A - Y\n    dot_product = X.dot(A_Y_diff)\n    dw = dot_product * (1.0 / m\n    return dw\n", "response_1": "def update_weights(m, A, X, Y):\n    A_minus_Y = A - Y\n    dot_product = X.dot(A_minus_Y)\n    scale = cfix(1) / cfix(m)\n    dw = dot_product * scale\n    return dw\n", "model_name": "deepseek-r1"}
{"test_name": "toy_layer", "response_0": "from Compiler.types import sfix, Matrix\nfrom Compiler import mpc_math\n\ndef sigmoid(x):\n    return sfix(1) / (sfix(1) + mpc_math.exp_fx(-x))\n\ndef toy_layer(input_data, weights, biases):\n    # Process first layer\n    layer1_input = input_data.dot(weights[0])\n    layer1_input.assign_vector(layer1_input.get_vector() + biases[0][:])\n    layer1_output = Matrix.create_from([sigmoid(x) for x in layer1_input.get_vector()])\n    \n    # Process second layer\n    layer2_input = layer1_output.dot(weights[1])\n    layer2_input.assign_vector(layer2_input.get_vector() + biases[1][:])\n    layer2_output = Matrix.create_from([sigmoid(x) for x in layer2_input.get_vector()])\n    \n    return layer2_output\n", "response_1": "from Compiler.types import *\nfrom Compiler import mpc_math\n\ndef sigmoid(x):\n    return (sfix(1) + mpc_math.tanh(x * cfix(0.5))) * cfix(0.5)\n\ndef toy_layer(input_data, weights, biases):\n    # Layer 1 operations\n    layer1_input = input_data.dot(weights[0])\n    layer1_input += biases[0].get_vector()\n    layer1_output = layer1_input.same_shape()\n    layer1_output.assign_vector([sigmoid(x) for x in layer1_input.get_vector()])\n    \n    # Layer 2 operations\n    layer2_input = layer1_output.dot(weights[1])\n    layer2_input += biases[1].get_vector()\n    layer2_output = layer2_input.same_shape()\n    layer2_output.assign_vector([sigmoid(x) for x in layer2_input.get_vector()])\n    \n    return layer2_output\n", "model_name": "deepseek-r1"}
