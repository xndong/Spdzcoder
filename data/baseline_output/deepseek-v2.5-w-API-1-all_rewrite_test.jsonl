{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    array = arr.get_part(0, index).concat(arr.get_part(index + 1, len(arr) - index - 1))\n    array = array.concat(arr.get_part(index, 1))\n    return array\n", "response_1": "from Compiler import types\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    array = types.Array(len(arr) - 1, arr.value_type)\n    array.assign(arr[:index])\n    array.concat(arr[index+1:])\n    array.append(arr[index])\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "second_largest", "response_0": "from Compiler import types\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    for i in range(2, len(arr)):\n        cond1 = arr[i] > arr[0]\n        cond2 = arr[i] > arr[1]\n        cond = cond1.bit_or(cond2)\n        idx = cond1.if_else(0, 1)\n        arr[idx] = cond.if_else(arr[i], arr[idx])\n    return arr[0].if_else(arr[0], arr[1])\n", "response_1": "from Compiler.types import sint, Array\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    for i in range(2, len(arr)):\n        cond1 = arr[i] > arr[0]\n        cond2 = arr[i] > arr[1]\n        cond = cond1.bit_or(cond2)\n        idx = cond1.bit_and(cond2.bit_not()).if_else(0, 1)\n        arr[idx] = cond.if_else(arr[i], arr[idx])\n    return arr[0].if_else(arr[1], arr[0])\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_true", "response_0": "from Compiler import types\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = types.sint(0)\n    for i in range(len(arr)):\n        ret = ret.bit_or(arr[i])\n    return ret\n", "response_1": "from Compiler import types\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret.bit_or(arr[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_indicator", "response_0": "from Compiler import types\n\ndef array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = types.sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = arr.same_shape()\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    lst = vec1 * vec2\n    summation = lst.sum()\n    return summation\n", "response_1": "from Compiler import types\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    lst = vec1[:] * vec2[:]\n    summation = lst.sum()\n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    length = len(a)\n    shifted_array = Array(length, sint)\n    for i in range(length):\n        shifted_array[i] = a[(i - 1) % length]\n    return shifted_array\n", "response_1": "from Compiler import types\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    length = len(a)\n    shifted_array = types.Array(length, a.value_type)\n    for i in range(length):\n        shifted_array[i] = a[(i - 1) % length]\n    return shifted_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler import types\n\ndef array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = types.sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "from Compiler import types\n\ndef array_greater_than_scalar(arr: types.Array, bound: types.sint) -> types.Array:\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = types.sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises_2", "response_0": "from Compiler.types import sint, Array\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    flag = Array(n - 1, sint)\n    \n    for i in range(n - 1):\n        flag[i] = arr[i] < arr[i + 1]\n    \n    count = sint(0)\n    for i in range(n - 1):\n        count += flag[i]\n    \n    return count\n", "response_1": "from Compiler import types\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    flag = types.sint.Array(len(arr) - 1)\n    for i in range(len(arr) - 1):\n        flag[i] = arr[i] < arr[i + 1]\n    \n    count = types.sint(0)\n    for i in range(len(arr) - 1):\n        count += flag[i]\n    \n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    for i in range(len(arr)):\n        if i % 2 == 1:\n            arr[i] += 1\n        else:\n            arr[i] -= 1\n    return arr\n", "response_1": "from Compiler import types\n\ndef choppy_plus_minus(arr: types.Array):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    length = len(arr)\n    for i in range(length):\n        if i % 2 == 1:\n            arr[i] += 1\n        else:\n            arr[i] -= 1\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sint, cint\nfrom Compiler.library import tree_reduce\n\ndef how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    a_is_zero = a == 0\n    b_is_zero = b == 0\n    discriminant = b * b - 4 * a * c\n    discriminant_positive = discriminant > 0\n    discriminant_zero = discriminant == 0\n\n    # Handle the case when a is zero\n    result_when_a_is_zero = sint(0) if b_is_zero else sint(1)\n\n    # Handle the case when a is not zero\n    result_when_a_is_not_zero = sint(2) if discriminant_positive else (sint(1) if discriminant_zero else sint(0))\n\n    # Use a conditional swap to select the correct result based on whether a is zero\n    result = a_is_zero.if_else(result_when_a_is_zero, result_when_a_is_not_zero)\n\n    return result\n", "response_1": "from Compiler.types import sint, cint\nfrom Compiler.mpc_math import pow_fx, sqrt\n\ndef how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    a_is_zero = a == 0\n    b_is_zero = b == 0\n    \n    # Case when a is zero\n    roots_when_a_is_zero = sint(0).if_else(1, 0)\n    roots = a_is_zero.if_else(roots_when_a_is_zero, sint(-1))\n    \n    # Case when a is not zero\n    discriminant = pow_fx(b, 2) - 4 * a * c\n    discriminant_positive = discriminant > 0\n    discriminant_zero = discriminant == 0\n    \n    roots_when_a_not_zero = discriminant_positive.if_else(2, discriminant_zero.if_else(1, 0))\n    roots = roots.if_else(roots_when_a_not_zero, roots)\n    \n    return roots\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint, Array\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = sint(1) if predicator(arr[i]) else sint(0)\n    \n    summation = sint(0)\n    for i in range(len(arr)):\n        summation += flag[i]\n    \n    return summation\n", "response_1": "from Compiler.types import sint, Array\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = sint(1) if predicator(arr[i]) else sint(0)\n    \n    summation = sint(0)\n    for i in range(len(arr)):\n        summation += flag[i]\n    \n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler import types\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    ret = types.Array(len(arr1), types.sfix)\n    for i in range(len(arr1)):\n        ret[i] = arr1[i] * arr2[i]\n    return ret.sum()\n", "response_1": "from Compiler import types\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    ret = types.sfix.Array(len(arr1))\n    ret.assign_vector([x * y for x, y in zip(arr1, arr2)])\n    return ret.sum()\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_round", "response_0": "from Compiler.types import sfix, sint, Array\n\ndef array_round(arr: Array):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i].round()\n    return ret\n", "response_1": "from Compiler.types import sfix, sint, Array\nimport Compiler.mpc_math as mpc_math\n\ndef array_round(arr: Array):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = mpc_math.round_sfix(arr[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater_eq", "response_0": "from Compiler.types import sint, Array\n\ndef array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    length = len(arr)\n    ret = sint.Array(length)\n    for i in range(length):\n        ret[i] = arr[i] >= brr[i]\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    length = len(arr)\n    ret = sint.Array(length)\n    \n    for i in range(length):\n        ret[i] = arr[i] >= brr[i]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sfix, sint, Array\n\ndef indicate_negative(arr: Array):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] < 0\n    return ret\n", "response_1": "from Compiler import types\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = types.sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] < 0\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract_2", "response_0": "from Compiler import types\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    a_len = len(a)\n    b_len = len(b)\n    pad_length = abs(a_len - b_len)\n    \n    if a_len < b_len:\n        pad = b.get_part(a_len, pad_length)\n        ret = a[:] - b[:a_len]\n    else:\n        pad = a.get_part(b_len, pad_length)\n        ret = a[:b_len] - b[:]\n    \n    ret.assign_vector(ret.get_vector() + pad.get_vector())\n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = abs(len_a - len_b)\n    \n    if len_a < len_b:\n        pad = [-e for e in b[-pad_length:]]\n        ret = [x - y for x, y in zip(a, b[:len_a])] + pad\n    else:\n        pad = [e for e in a[-pad_length:]]\n        ret = [x - y for x, y in zip(a[:len_b], b)] + pad\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process", "response_0": "from Compiler.types import Array, sfix\nimport Compiler.mpc_math as mpc_math\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    processed_arr = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        processed_arr[i] = func(arr[i])\n    return processed_arr\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    shifted_array = a.get_part(a.length - 1, 1).concat(a.get_part(0, a.length - 1))\n    return shifted_array\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    a = a.get_part(-1, 1).concat(a.get_part(0, a.length - 1))\n    return a\n", "model_name": "deepseek-v2.5"}
{"test_name": "compare_and_select", "response_0": "from Compiler import types\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = types.Array(len(a), types.sfix)\n    for i in range(len(a)):\n        ret_array[i] = a[i].max(b[i])\n    return ret_array\n", "response_1": "from Compiler import types\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = types.Array(len(a), types.sfix)\n    for i in range(len(a)):\n        ret_array[i] = a[i].max(b[i])\n    return ret_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract", "response_0": "from Compiler import types\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    a_len = len(a)\n    b_len = len(b)\n    diff = abs(a_len - b_len)\n    \n    if a_len < b_len:\n        pad = types.sfix.Array(diff)\n        pad.assign_all(0.0)\n        a = a.concat(pad)\n    else:\n        pad = types.sfix.Array(diff)\n        pad.assign_all(0.0)\n        b = b.concat(pad)\n    \n    ret = types.sfix.Array(a_len if a_len >= b_len else b_len)\n    ret[:] = a[:] - b[:]\n    return ret\n", "response_1": "from Compiler.types import sfix, Array\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = abs(len_a - len_b)\n    \n    if len_a < len_b:\n        a = Array.create_from(a.get_vector() + [sfix(0.0)] * pad_length)\n    else:\n        b = Array.create_from(b.get_vector() + [sfix(0.0)] * pad_length)\n    \n    ret = Array(max(len_a, len_b), sfix)\n    ret[:] = a[:] - b[:]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "repeat_array", "response_0": "from Compiler.types import Array\n\ndef repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c.concat(c)\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c.concat(c)\n", "model_name": "deepseek-v2.5"}
{"test_name": "zeros", "response_0": "from Compiler.types import sfix\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = sfix.Array(num)\n    array.assign_all(0)\n    return array\n", "response_1": "from Compiler.types import Array, sfix\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = sfix.Array(num)\n    array.assign_all(sfix(0))\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip", "response_0": "from Compiler import types\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x):\n        return upper_bound if x >= upper_bound else (x if x > lower_bound else lower_bound)\n\n    clipped_arr = types.sfix.Array(len(arr))\n    for i in range(len(arr)):\n        clipped_arr[i] = helper_func(arr[i])\n\n    return clipped_arr\n", "response_1": "from Compiler import types\n\ndef clip(arr: types.Array, upper_bound: types.sfix = types.sfix(1), lower_bound: types.sfix = types.sfix(-1)) -> types.Array:\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x: types.sfix) -> types.sfix:\n        return upper_bound if x >= upper_bound else (x if x > lower_bound else lower_bound)\n\n    result = types.sfix.Array(len(arr))\n    for i in range(len(arr)):\n        result[i] = helper_func(arr[i])\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied_2", "response_0": "from Compiler.types import sint, Array\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    \n    summation = sint(0)\n    for i in range(len(arr)):\n        summation += flag[i]\n    \n    return summation\n", "response_1": "from Compiler import types\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    flag = arr.same_shape()\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    \n    summation = types.sfix(0)\n    for i in range(len(arr)):\n        summation += flag[i]\n    \n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint, cint, Array\nfrom Compiler.library import tree_reduce\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    count = cint(0)\n    cmparr = Array(n, sint)\n    cmparr.assign_vector(arr)\n    \n    for i in range(n):\n        ndarray = Array(n - i, sint)\n        ndarray.assign_all(arr[i])\n        comparison = ndarray[:] > cmparr[i:n]\n        count += tree_reduce(lambda x, y: x + y, comparison)\n    \n    return count\n", "response_1": "from Compiler import types\nfrom Compiler.library import tree_reduce\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    count = types.sint(0)\n    cmparr = types.sint.Array(len(arr))\n    cmparr.assign(arr)\n\n    for i in range(len(arr)):\n        ndarray = types.sint.Array(len(arr) - i)\n        ndarray.assign_all(arr[i])\n        count += tree_reduce(lambda x, y: x + y, ndarray > cmparr[i:])\n\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    arr[:] += 1\n    return arr\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    arr[:] += 1\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint, Array\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)\n    brr = arr[1:]\n    for x, y in zip(arr, brr):\n        count += (x < y)\n    return count\n", "response_1": "from Compiler.types import sint, Array\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)\n    brr = arr.get_part(1, len(arr) - 1)\n    for x, y in zip(arr, brr):\n        count += (x < y)\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_2", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    arr = arr.create_from(map(func, arr.get_vector()))\n    return arr\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    arr = arr.create_from(map(func, arr.get_vector()))\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_norm", "response_0": "from Compiler import mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    vec = [item * item for item in vec]\n    return mpc_math.sqrt(sum(vec))\n", "response_1": "from Compiler import types\nimport mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    vec = types.sfix.Array(len(vec))\n    vec.assign_all(vec)\n    squared_vec = vec.create_from(vec[:] * vec[:])\n    sum_squared = squared_vec.sum()\n    return mpc_math.sqrt(sum_squared)\n", "model_name": "deepseek-v2.5"}
{"test_name": "totally_dominate", "response_0": "from Compiler import types\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    amin = a.min()\n    bmax = b.max()\n    return amin >= bmax\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import tree_reduce\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    amin = tree_reduce(lambda x, y: x.min(y), a)\n    bmax = tree_reduce(lambda x, y: x.max(y), b)\n    return amin >= bmax\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product_2", "response_0": "from Compiler import types\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    summation = types.sfix(0)\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "response_1": "from Compiler import types\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    summation = types.sfix(0)\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = a.create_from(a[i] for i in indices)\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = a.create_from([a[i] for i in indices])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint, cint, sfix, cfix, Array\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = (arr[i] == 5) | (arr[i] == 7)\n    \n    result = sint(0)\n    for i in range(len(arr)):\n        result = result | flag[i]\n    \n    return result\n", "response_1": "from Compiler import types\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = types.sint.Array(len(arr))\n    for i in range(len(arr)):\n        flag[i] = (arr[i] == 5) | (arr[i] == 7)\n    \n    return any(flag)\n", "model_name": "deepseek-v2.5"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    ret = arr.get_part(0, index).concat(arr.get_part(index + 1, arr.length - index - 1))\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    ret = arr.get_part(0, index).concat(arr.get_part(index + 1, arr.length - index - 1))\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "average", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import tree_reduce\n\ndef average(arr: Array):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summation = tree_reduce(lambda x, y: x + y, arr)\n    length = len(arr)\n    ret = summation / sfix(length)\n    return ret\n", "response_1": "from Compiler import types\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summation = types.sfix(0)\n    for element in arr:\n        summation += element\n    length = types.sfix(len(arr))\n    ret = summation / length\n    return ret\n", "model_name": "deepseek-v2.5"}
