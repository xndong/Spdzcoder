{"test_name": "sin_or_cos", "response_0": "from Compiler.types import sfix\nimport Compiler.mpc_math as mpc_math\n\ndef sin_or_cos(x: sfix) -> sfix:\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    condition = x >= 0\n    return condition.if_else(mpc_math.sin(x), mpc_math.cos(x))\n", "response_1": "from Compiler import mpc_math\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    if x >= 0:\n        return mpc_math.sin(x)\n    return mpc_math.cos(x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_relu", "response_0": "from Compiler import types\n\ndef negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, else return 0.\n    \"\"\"\n    return input.if_else(input, types.sfix(0))\n", "response_1": "from Compiler import types\n\ndef negative_relu(input: types.sfix) -> types.sfix:\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return input.if_else(input, types.sfix(0))\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_close", "response_0": "from Compiler import mpc_math\n\ndef is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    return mpc_math.abs(a - b) <= 1\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.mpc_math import abs_fx\n\ndef is_close(a: sfix, b: sfix) -> sfix:\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    return abs_fx(a - b) <= sfix(1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "hardswish", "response_0": "from Compiler import mpc_math\n\ndef hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    condition_1 = x < -3\n    condition_2 = x > 3\n    \n    result = condition_1.if_else(0, x)\n    result = condition_2.if_else(x, result)\n    \n    temp = x + 3\n    temp = x * temp\n    temp = temp / 6\n    \n    return condition_1.if_else(0, condition_2.if_else(x, temp))\n", "response_1": "from Compiler import mpc_math\n\ndef hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    less_than_neg_3 = x < -3\n    greater_than_3 = x > 3\n    in_range = 1 - less_than_neg_3.bit_or(greater_than_3)\n    \n    return less_than_neg_3.if_else(0, greater_than_3.if_else(x, x * (x + 3) / 6))\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip_at_6", "response_0": "from Compiler import types\n\ndef clip_at_6(x: types.sfix) -> types.sfix:\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    return x.max(-6).min(6)\n", "response_1": "from Compiler.types import sfix\n\ndef clip_at_6(x: sfix) -> sfix:\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    return x.max(-6).min(6)\n", "model_name": "deepseek-v2.5"}
{"test_name": "piecewise_function", "response_0": "from Compiler.types import sfix\n\ndef piecewise_function(x: sfix) -> sfix:\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    ret = sfix(0)\n    if x > sfix(1):\n        ret = x\n    elif x < sfix(-1):\n        ret = x\n    elif x > sfix(0):\n        ret = sfix(1)\n    elif x < sfix(0):\n        ret = sfix(-1)\n    else:\n        ret = sfix(0)\n    return ret\n", "response_1": "from Compiler import types\n\ndef piecewise_function(x: types.sfix):\n    ret = types.sfix(0)\n    cond1 = x > types.sfix(1)\n    cond2 = x < types.sfix(-1)\n    cond3 = x > types.sfix(0)\n    cond4 = x < types.sfix(0)\n    \n    ret = cond1.if_else(x, ret)\n    ret = cond2.if_else(x, ret)\n    ret = cond3.if_else(types.sfix(1), ret)\n    ret = cond4.if_else(types.sfix(-1), ret)\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "middle", "response_0": "from Compiler.types import sint\n\ndef middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    if a >= b:\n        temp = a\n        a = b\n        b = temp\n    if b >= c:\n        temp = b\n        b = c\n        c = temp\n    if a >= b:\n        temp = a\n        a = b\n        b = temp\n    return b\n", "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    if a >= b:\n        temp = a\n        a = b\n        b = temp\n    if b >= c:\n        temp = b\n        b = c\n        c = temp\n    if a >= b:\n        temp = a\n        a = b\n        b = temp\n    return b\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler.library import if_statement\nimport mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    result = sfix()\n    if_statement(ind, lambda: result.assign(mpc_math.sin(x)), lambda: result.assign(mpc_math.cos(x)))\n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    if ind:\n        return mpc_math.sin(x)\n    return mpc_math.cos(x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    condition = x - 2 >= 0\n    return condition.if_else(x - 2, x)\n", "response_1": "from Compiler import types\n\ndef minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    condition = x - 2 >= 0\n    return condition.if_else(x - 2, x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "relu6", "response_0": "from Compiler.types import sfix\nimport Compiler.mpc_math\n\ndef relu6(x: sfix) -> sfix:\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    return mpc_math.min(mpc_math.max(x, sfix(0)), sfix(6))\n", "response_1": "from Compiler import mpc_math\n\ndef relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    return mpc_math.max(0, mpc_math.min(x, 6))\n", "model_name": "deepseek-v2.5"}
{"test_name": "exp_slide", "response_0": "from Compiler.types import sfix\nimport Compiler.mpc_math as mpc_math\n\ndef exp_slide(x: sfix) -> sfix:\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    condition = x >= 0\n    exp_value = mpc_math.pow_fx(mpc_math.e, x)\n    result = condition.if_else(exp_value, x + 1)\n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    if x >= 0:\n        return mpc_math.pow_fx(mpc_math.e, x)\n    return x + 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "pass_or_not", "response_0": "from Compiler import types\n\ndef pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    score_if_passed = score * (score >= 60) + types.cint(59) * (score < 60)\n    passed = score >= 60\n    return score_if_passed, passed\n", "response_1": "from Compiler import types\n\ndef pass_or_not(score: types.sfix) -> (types.sfix, types.sint):\n    # Define the threshold for passing\n    threshold = types.sfix(60.0)\n    fifty_nine = types.sfix(59.0)\n\n    # Determine if the score is greater than or equal to the threshold\n    passed_condition = score >= threshold\n\n    # Use conditional assignment to set the score based on the condition\n    score = passed_condition.if_else(score, fifty_nine)\n\n    # Determine if the student passed\n    passed = passed_condition.if_else(types.sint(1), types.sint(0))\n\n    return score, passed\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_roots", "response_0": "from Compiler import types\n\ndef how_many_roots(a: types.sfix, b: types.sfix, c: types.sfix) -> types.sint:\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    zero = types.sfix(0)\n    one = types.sint(1)\n    two = types.sint(2)\n\n    if_a_zero = a == zero\n    if_b_zero = b == zero\n\n    # Handle the case when a == 0\n    result = if_a_zero.if_else(\n        if_b_zero.if_else(\n            types.sint(0),  # a == 0 and b == 0\n            one  # a == 0 and b != 0\n        ),\n        types.sint(-1)  # a != 0, will be updated later\n    )\n\n    # Handle the case when a != 0\n    discriminant = types.mpc_math.pow_fx(b, 2) - 4 * a * c\n    positive_discriminant = discriminant > zero\n    zero_discriminant = discriminant == zero\n\n    result = if_a_zero.if_else(\n        result,  # a == 0\n        positive_discriminant.if_else(\n            two,  # discriminant > 0\n            zero_discriminant.if_else(\n                one,  # discriminant == 0\n                types.sint(0)  # discriminant < 0\n            )\n        )\n    )\n\n    return result\n", "response_1": "from Compiler.types import sint, sfix\nimport Compiler.mpc_math\n\ndef how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if_a_zero = a == 0\n    if_b_zero = b == 0\n    \n    # Case when a == 0\n    result = if_a_zero.if_else(if_b_zero.if_else(sint(0), sint(1)), sint(-1))\n    \n    # Case when a != 0\n    discriminant = mpc_math.pow_fx(b, 2) - 4 * a * c\n    positive_discriminant = discriminant > 0\n    zero_discriminant = discriminant == 0\n    \n    result = result.if_else(positive_discriminant.if_else(sint(2), zero_discriminant.if_else(sint(1), sint(0))), result)\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "elu", "response_0": "from Compiler import mpc_math\n\ndef elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    return x.if_else(x, mpc_math.exp(x) - 1)\n", "response_1": "from Compiler import mpc_math\n\ndef elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    return x.if_else(x, mpc_math.exp(x) - 1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "relu", "response_0": "from Compiler import mpc_math\n\ndef relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return mpc_math.max(x, 0)\n", "response_1": "from Compiler.types import sfix\n\ndef relu(x: sfix) -> sfix:\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return x * (x > 0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "leaky_relu", "response_0": "from Compiler import mpc_math\n\ndef leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    condition = x > 0\n    return condition.if_else(x, x * alpha)\n", "response_1": "from Compiler.types import sfix, Array\nfrom Compiler.library import tree_reduce\n\ndef leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    return x.if_else(x, x * alpha)\n\n# Example usage:\n# x_array = sfix.Array(10)  # Assuming x_array is an array of sfix values\n# alpha = sfix(0.1)  # Assuming alpha is a sfix value\n# result = leaky_relu(x_array, alpha)\n", "model_name": "deepseek-v2.5"}
{"test_name": "max", "response_0": "from Compiler import types\n\ndef max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "bowl_shape", "response_0": "from Compiler import mpc_math, types\n\ndef bowl_shape(x: types.sfix) -> types.sfix:\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    cond1 = x > 1\n    cond2 = x < -1\n    \n    result = cond1.if_else(x - 1, 0)\n    result = cond2.if_else(-x - 1, result)\n    \n    return result\n", "response_1": "from Compiler.types import sfix\n\ndef bowl_shape(x: sfix) -> sfix:\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    cond1 = x > sfix(1)\n    cond2 = x < sfix(-1)\n    \n    result = sfix(0)\n    result = cond1.if_else(x - sfix(1), result)\n    result = cond2.if_else(-x - sfix(1), result)\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "rounded_kinetic_energy", "response_0": "from Compiler.types import sfix, sint\nimport Compiler.mpc_math as mpc_math\n\ndef rounded_kinetic_energy(m: sfix, v: sfix) -> sint:\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    k = m * mpc_math.pow_fx(v, 2) / 2\n    k_int = mpc_math.floor(k)\n    return k_int if (k - k_int) < 0.5 else k_int + 1\n", "response_1": "from Compiler.types import sfix, sint\nimport Compiler.mpc_math as mpc_math\n\ndef rounded_kinetic_energy(m: sfix, v: sfix) -> sint:\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    k = m * mpc_math.pow_fx(v, 2) / 2\n    k_int = mpc_math.floor(k)\n    return k_int if (k - k_int) < 0.5 else k_int + 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "danger_test", "response_0": "from Compiler.types import sint\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    return health_left <= 10\n", "response_1": "from Compiler import types\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    return health_left <= 10\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicated_sum_or_multiply", "response_0": "from Compiler import types\n\ndef indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    return ind.if_else(x + y, x * y)\n", "response_1": "from Compiler.types import sint\n\ndef indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    return ind.if_else(x + y, x * y)\n", "model_name": "deepseek-v2.5"}
{"test_name": "median", "response_0": "from Compiler import types\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    arr.sort()\n    ret = types.sfix(0)\n    \n    if len(arr) % 2:\n        ret = arr[len(arr) // 2]\n    else:\n        ret = (arr[len(arr) // 2] + arr[len(arr) // 2 - 1]) / types.sfix(2)\n    \n    return ret\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.sorting import radix_sort\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if arr.length == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array\n    radix_sort(arr, arr)\n    \n    ret = sint(0)\n    if arr.length % 2:\n        ret = arr[arr.length // 2]\n    else:\n        ret = (arr[arr.length // 2] + arr[arr.length // 2 - 1]) / 2\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "add_upto_10", "response_0": "from Compiler import types\n\ndef add_upto_10(a: types.sfix, b: types.sfix) -> types.sfix:\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    condition = sum_ab > 10\n    result = condition.if_else(10, sum_ab)\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef add_upto_10(a: sint, b: sint) -> sint:\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    condition = sum_ab > 10\n    return condition.if_else(10, sum_ab)\n", "model_name": "deepseek-v2.5"}
{"test_name": "taxi_fare", "response_0": "from Compiler.types import sfix\n\ndef taxi_fare(m: sfix) -> sfix:\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    base_fare = sfix(5)\n    rate_1 = sfix(1.2)\n    rate_2 = sfix(1.5)\n    \n    # Check if m is less than or equal to 5\n    condition_1 = m <= sfix(5)\n    # Check if m is between 5 and 10\n    condition_2 = (sfix(5) <= m) & (m <= sfix(10))\n    \n    # Calculate the fare based on the conditions\n    fare_1 = base_fare\n    fare_2 = base_fare + rate_1 * (m - sfix(5))\n    fare_3 = base_fare + rate_1 * sfix(5) + rate_2 * (m - sfix(10))\n    \n    # Use conditional selection to return the appropriate fare\n    return condition_1.if_else(fare_1, condition_2.if_else(fare_2, fare_3))\n", "response_1": "from Compiler import types\n\ndef taxi_fare(m: types.sfix):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    base_fare = types.sfix(5)\n    rate_1 = types.sfix(1.2)\n    rate_2 = types.sfix(1.5)\n    threshold_1 = types.sfix(5)\n    threshold_2 = types.sfix(10)\n\n    result = types.sfix()\n\n    # Check if m <= 5\n    condition_1 = m <= threshold_1\n    result = condition_1.if_else(base_fare, types.sfix(0))\n\n    # Check if 5 <= m <= 10\n    condition_2 = (m > threshold_1) & (m <= threshold_2)\n    part_2 = base_fare + rate_1 * (m - threshold_1)\n    result += condition_2.if_else(part_2, types.sfix(0))\n\n    # Check if m > 10\n    condition_3 = m > threshold_2\n    part_3 = base_fare + rate_1 * (threshold_2 - threshold_1) + rate_2 * (m - threshold_2)\n    result += condition_3.if_else(part_3, types.sfix(0))\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    import mpc_math\n    x_int = mpc_math.floor(x)\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "response_1": "from Compiler import mpc_math\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = mpc_math.floor_fx(x)\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "gpa_calculator", "response_0": "from Compiler.types import sfix, sint\n\ndef gpa_calculator(score: sfix):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    gpa = sfix(0.0)\n\n    gpa = gpa.if_else(4.0, gpa) if score >= 90 else gpa\n    gpa = gpa.if_else(3.6, gpa) if score >= 85 else gpa\n    gpa = gpa.if_else(3.3, gpa) if score >= 80 else gpa\n    gpa = gpa.if_else(3.0, gpa) if score >= 75 else gpa\n    gpa = gpa.if_else(2.6, gpa) if score >= 70 else gpa\n    gpa = gpa.if_else(2.3, gpa)\n\n    return gpa\n", "response_1": "from Compiler import types\n\ndef gpa_calculator(score: types.sfix):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    if score >= 90:\n        return types.sfix(4.0)\n    elif score >= 85:\n        return types.sfix(3.6)\n    elif score >= 80:\n        return types.sfix(3.3)\n    elif score >= 75:\n        return types.sfix(3.0)\n    elif score >= 70:\n        return types.sfix(2.6)\n    else:\n        return types.sfix(2.3)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sign", "response_0": "from Compiler import types\n\ndef sign(x: types.sint) -> types.sint:\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = types.sint(0)\n    one = types.sint(1)\n    neg_one = types.sint(-1)\n\n    is_zero = x == zero\n    is_positive = x > zero\n    is_negative = x < zero\n\n    return is_zero.if_else(zero, is_positive.if_else(one, neg_one))\n", "response_1": "from Compiler import types\n\ndef sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = types.sint(0)\n    one = types.sint(1)\n    minus_one = types.sint(-1)\n    \n    is_zero = x == zero\n    is_positive = x > zero\n    is_negative = x < zero\n    \n    return is_zero.if_else(zero, is_positive.if_else(one, minus_one))\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_or_difference", "response_0": "from Compiler.types import sint\n\ndef sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    condition = a <= b\n    return condition.if_else(a + b, a - b)\n", "response_1": "from Compiler.types import sint\n\ndef sum_or_difference(a: sint, b: sint) -> sint:\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    condition = a <= b\n    return condition.if_else(a + b, a - b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    return flip_bit.bit_xor(control_bit)\n", "response_1": "from Compiler.types import sint\n\ndef CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    return control_bit.if_else(flip_bit.bit_not(), flip_bit)\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_plus1", "response_0": "from Compiler import mpc_math\n\ndef negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    is_negative = mpc_math.less_than(y, 0)\n    return is_negative.if_else(y + 1, y)\n", "response_1": "from Compiler import types\n\ndef negative_plus1(y: types.sfix):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    is_negative = y < 0\n    return is_negative.if_else(y + 1, y)\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler import types\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return (x[0] == y[0]) & (x[1] == y[1])\n    \n    if same(a, b) | same(a, c) | same(a, d) | same(b, c) | same(b, d) | same(c, d):\n        return types.sint(0)\n    \n    condition1 = (a[0] + b[0] == c[0] + d[0]) & (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) & (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) & (a[1] + d[1] == b[1] + c[1])\n    \n    return condition1 | condition2 | condition3\n", "response_1": "from Compiler import types\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return types.sint(0)\n    \n    condition1 = (a[0] + b[0] == c[0] + d[0]) & (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) & (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) & (a[1] + d[1] == b[1] + c[1])\n    \n    return condition1 | condition2 | condition3\n", "model_name": "deepseek-v2.5"}
{"test_name": "min", "response_0": "from Compiler.types import sint\n\ndef min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "choice_of_the_knight", "response_0": "from Compiler.types import sint, cint\n\ndef choice_of_the_knight(x, y):\n    counter = cint(0)\n\n    def legal(a, b):\n        return (cint(0) <= a) & (a <= cint(7)) & (cint(0) <= b) & (b <= cint(7))\n\n    counter += legal(x + cint(1), y + cint(2))\n    counter += legal(x - cint(1), y + cint(2))\n    counter += legal(x + cint(1), y - cint(2))\n    counter += legal(x - cint(1), y - cint(2))\n    counter += legal(x + cint(2), y + cint(1))\n    counter += legal(x - cint(2), y + cint(1))\n    counter += legal(x + cint(2), y - cint(1))\n    counter += legal(x - cint(2), y - cint(1))\n\n    return counter\n", "response_1": "from Compiler import types\n\ndef choice_of_the_knight(x: types.sint, y: types.sint):\n    counter = types.sint(0)\n\n    def legal(a, b):\n        return (a >= 0).bit_and(a <= 7).bit_and(b >= 0).bit_and(b <= 7)\n\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n\n    return counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_sum_difference", "response_0": "from Compiler import types\n\ndef max_sum_different(a: types.sfix, b: types.sfix) -> types.sfix:\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    condition = sum_ab > diff_ab\n    return condition.if_else(sum_ab, diff_ab)\n", "response_1": "from Compiler import types\n\ndef max_sum_different(a: types.sfix, b: types.sfix) -> types.sfix:\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    condition = sum_ab > diff_ab\n    return condition.if_else(sum_ab, diff_ab)\n", "model_name": "deepseek-v2.5"}
