{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler import types\n\nstart = 0\nend = 99\nnum = 10\n\n# Create an Array of sfix type with length `num`\na = types.sfix.Array(num)\n\n# Assign values using linspace\nfor i in range(num):\n    a[i] = types.sfix(start + i * (end - start) / (num - 1))\n", "response_1": "from Compiler import types\n\nstart = 0\nend = 99\nnum = 10\n\n# Create an Array of cfix (clear fixed-point numbers)\na = types.cfix.Array(num)\n\n# Assign values using linspace equivalent\nfor i in range(num):\n    a[i] = types.cfix(start + i * (end - start) / (num - 1))\n", "model_name": "deepseek-v2.5"}
{"test_name": "more_positive", "response_0": "from Compiler import types\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    signs = arr.get_vector() > 0\n    count = signs.sum()\n    return count > 0\n", "response_1": "from Compiler import types\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    signs = arr.greater_than(0)\n    count = signs.sum()\n    return count.greater_than(0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "select", "response_0": "from Compiler.types import sfix, Array\n\ndef select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are secret fixed-point numbers.\n    \"\"\"\n    result = sfix.Array(len(a))\n    for i in range(len(a)):\n        result[i] = ind[i].if_else(a[i], b[i])\n    return result\n", "response_1": "from Compiler import types\n\ndef select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    return types.sfix.Array(len(a)).if_else(ind, a, b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_relu", "response_0": "from Compiler.types import sfix\n\ndef relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return sfix(max(y, 0))\n", "response_1": "from Compiler.types import sfix\n\ndef relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return sfix.max(y, sfix(0))\n", "model_name": "deepseek-v2.5"}
{"test_name": "cost_matrix", "response_0": "from Compiler import types\n\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    matrix_shape = profit_matrix.rows, profit_matrix.columns\n    offset_matrix = types.sfix.Matrix(matrix_shape[0], matrix_shape[1])\n    max_value = profit_matrix.max()\n    offset_matrix.assign_all(max_value)\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n", "response_1": "from Compiler import types\n\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    matrix_shape = profit_matrix.sizes\n    max_value = profit_matrix.max()\n    offset_matrix = types.sfix.Matrix(matrix_shape[0], matrix_shape[1])\n    offset_matrix.assign_all(max_value)\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_zeros", "response_0": "n = 10\na = sfix.Array(n)\na.assign_all(0)\n", "response_1": "from Compiler.types import sfix\n\nn = 10\na = sfix.Array(n)\na.assign_all(0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler.types import sint, Array, Matrix\n\ndef array_dimensional_indexing(ndarray: Matrix, row_index: sint):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index][:]\n    return array\n", "response_1": "from Compiler.types import sint, Array, Matrix\n\ndef array_dimensional_indexing(ndarray: Matrix, row_index: sint):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index][:]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    return sfix.Array(n).assign_all(0)\n", "response_1": "from Compiler.types import Array, sfix\n\ndef zeros(n):\n    return Array(n, sfix).assign_all(0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_slicing_stride", "response_0": "from Compiler import types\n\ndef array_concat(arrayA, arrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    # Create views for even indices of arrayA and odd indices of arrayB\n    viewA = arrayA.get_part(0, len(arrayA) // 2)\n    viewB = arrayB.get_part(1, len(arrayB) // 2)\n    \n    # Concatenate the two views\n    concatenated_array = viewA.concat(viewB)\n    \n    return concatenated_array\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type sint.Array\n    viewA = ndarrayA.get_part(0, len(ndarrayA) // 2)\n    viewB = ndarrayB.get_part(1, len(ndarrayB) // 2)\n    array = viewA.concat(viewB)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "QR_decomposition", "response_0": "from Compiler import types\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    q, _ = mat.qr()\n    return q\n", "response_1": "from Compiler.types import Matrix, sfix\nimport Compiler.mpc_math as mpc_math\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    q, _ = mpc_math.qr(mat)\n    return q\n", "model_name": "deepseek-v2.5"}
{"test_name": "find_nearest_index", "response_0": "from Compiler import mpc_math, types\n\ndef find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    diff = array.get_vector() - value\n    abs_diff = mpc_math.abs(diff)\n    idx = abs_diff.argmin()\n    return idx\n", "response_1": "from Compiler import types\n\ndef find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    abs_diff = types.sfix.Array(len(array))\n    abs_diff.assign_all(0)\n    for i in range(len(array)):\n        abs_diff[i] = (array[i] - value).abs()\n    \n    min_diff = abs_diff[0]\n    min_index = 0\n    for i in range(1, len(array)):\n        cond = abs_diff[i] < min_diff\n        min_diff = cond.if_else(abs_diff[i], min_diff)\n        min_index = cond.if_else(i, min_index)\n    \n    return min_index\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_simple_row", "response_0": "from Compiler.types import sint, Array, Matrix\n\ndef array_simple_concate_rows(matrixA, matrixB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    rowsA = matrixA.rows\n    colsA = matrixA.columns\n    rowsB = matrixB.rows\n    colsB = matrixB.columns\n    \n    if colsA != colsB:\n        raise ValueError(\"Both matrices must have the same number of columns\")\n    \n    result = Matrix(rowsA + rowsB, colsA, sint)\n    result.assign_vector(matrixA.get_vector())\n    result.assign_vector(matrixB.get_vector(), base=rowsA * colsA)\n    \n    return result\n", "response_1": "from Compiler import types\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    array = ndarrayA.concat_columns(ndarrayB)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    array = ndarray.same_shape()\n    array.assign(ndarray)\n    return array\n", "response_1": "def array_copy(ndarray):\n    array = ndarray.same_shape()\n    array.assign(ndarray)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_pooling", "response_0": "from Compiler.types import sint, Array, Matrix\nfrom Compiler.library import tree_reduce\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    \"\"\"\n    batch_size = x.sizes[0]\n    out_height = x.sizes[1] // stride\n    out_width = x.sizes[2] // stride\n\n    out = Matrix(batch_size, out_height, Array(out_width, sint))\n\n    for b in range(batch_size):\n        for i in range(0, x.sizes[1], stride):\n            for j in range(0, x.sizes[2], stride):\n                window = x[b].get_part(i, stride).get_part(j, stride).get_vector()\n                max_val = tree_reduce(lambda x, y: x.max(y), window)\n                out[b][i // stride][j // stride] = max_val\n\n    return out\n", "response_1": "from Compiler import types\nfrom Compiler.library import tree_reduce\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    \"\"\"\n    batch_size = x.sizes[0]\n    height = x.sizes[1]\n    width = x.sizes[2]\n    out_height = height // stride\n    out_width = width // stride\n\n    out = types.sfix.MultiArray([batch_size, out_height, out_width])\n\n    for b in range(batch_size):\n        for i in range(0, height, stride):\n            for j in range(0, width, stride):\n                window = x[b][i:i+stride][j:j+stride]\n                max_val = tree_reduce(lambda a, b: a.max(b), window.get_vector())\n                out[b][i // stride][j // stride] = max_val\n\n    return out\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_reshape", "response_0": "from Compiler import types\n\na = types.sint.Matrix(3, 5)\na.assign_all(0)\n\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = types.sint(i * 5 + j)\n", "response_1": "from Compiler import types\n\n# Create a 3x5 Matrix of secret integers\na = types.sint.Matrix(3, 5)\n\n# Assign values to the matrix\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = types.sint(i * 5 + j)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_simple_column", "response_0": "from Compiler.types import Matrix\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    array = ndarrayA.concat_columns(ndarrayB)\n    return array\n", "response_1": "from Compiler import types\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    array = ndarrayA.concat_columns(ndarrayB)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "from Compiler import types\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_column(column_index)\n    return array\n", "response_1": "from Compiler.types import Matrix, sint\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_column(column_index)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_diagonal", "response_0": "from Compiler.types import Matrix\n\ndef diag(array):\n    # Assuming 'array' is a Matrix\n    diag_matrix = array.diag()\n    return diag_matrix\n", "response_1": "from Compiler import types\n\ndef diag(array):\n    diag = types.Matrix(array.rows, array.columns, array.value_type).diag()\n    return diag\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_special", "response_0": "from Compiler import types\n\ndef array_special_concat(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1. \n    Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type Matrix with sfix entries\n    viewA = ndarrayA.get_part(0, ndarrayA.sizes[0]).get_part(0, ndarrayA.sizes[1], 2)\n    viewB = ndarrayB.get_part(0, ndarrayB.sizes[0]).get_part(1, ndarrayB.sizes[1] - 1, 2)\n    \n    # Concatenate along axis 1\n    array = viewA.concat(viewB)\n    \n    return array\n", "response_1": "from Compiler import types\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1. \n    Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type Matrix\n    viewA = ndarrayA.get_part(0, ndarrayA.rows).get_vector()[::2]\n    viewB = ndarrayB.get_part(0, ndarrayB.rows).get_vector()[1::2]\n    \n    # Concatenate the two views along axis 1\n    concatenated = types.Matrix(ndarrayA.rows, len(viewA) + len(viewB), ndarrayA.value_type)\n    concatenated.assign_vector(viewA + viewB)\n    \n    return concatenated\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_arange", "response_0": "from Compiler import types\n\ndef arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-D Array by generating a sequence of integers.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Determine the number of elements in the array\n    length = (stop - start) // step\n\n    # Create an Array of sint with the determined length\n    array = types.sint.Array(length)\n\n    # Assign values to the array\n    for i in range(length):\n        array[i] = start + i * step\n\n    return array\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    create a 1-d MP-SPDZ array by simulating numpy.arange\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    length = (stop - start) // step\n    array = sint.Array(length)\n    for i in range(length):\n        array[i] = start + i * step\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_eye_2", "response_0": "from Compiler import types\n\nm = 3\nn = 5\na = types.Matrix(m, n, types.sfix)\n\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = 1.0\n        else:\n            a[i][j] = 0.0\n", "response_1": "from Compiler import types\n\nm = 3\nn = 5\na = types.Matrix(m, n, types.sint)\n\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = 1\n        else:\n            a[i][j] = 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "third_smallest", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.sorting import radix_sort\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    sorted_arr = Array(len(arr), sint)\n    sorted_arr.assign(arr)\n    radix_sort(sorted_arr, sorted_arr)\n    return sorted_arr[2]\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.sorting import radix_sort\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Assuming arr is an Array of sint\n    sorted_arr = Array(len(arr), sint)\n    sorted_arr.assign(arr)\n    radix_sort(sorted_arr)\n    return sorted_arr[2]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "from Compiler.types import sint, Array, Matrix\n\ndef array_dimensional_indexing(ndarray: Matrix, row_index: sint):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_row(row_index)\n    return array\n", "response_1": "from Compiler.types import sint, Matrix\n\ndef array_dimensional_indexing(ndarray: Matrix, row_index: sint):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_from_intrinsic_arange", "response_0": "from Compiler import types\n\nn = 10\na = types.sint.Array(n)\na.assign_all(0)\n\nfor i in range(n):\n    a[i] = i\n", "response_1": "from Compiler import types\n\nn = 10\na = types.sint.Array(n)\na.assign_all(0)\n\nfor i in range(n):\n    a[i] = i\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "from Compiler.types import sint, Array, Matrix\n\ndef array_dimensional_indexing(ndarray: Matrix, row_index: sint):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_row(row_index)\n    return array\n", "response_1": "from Compiler.types import Matrix, sint\n\ndef array_dimensional_indexing(ndarray: Matrix, row_index: sint):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray.get_row(row_index)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler import types\n\na_l = [0, 10, 20, 30, 40]\na = types.cint.Array(5).create_from(a_l)\n", "response_1": "from Compiler.types import sint, Array\n\na_l = [0, 10, 20, 30, 40]\na = Array(5, sint)\na.assign_vector(sint.Array(a_l))\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_reshape", "response_0": "from Compiler.types import sint, Array, Matrix\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a secret integer array.\n    \"\"\"\n    # Assuming ndarray is an Array of sint\n    array = ndarray.get_vector()  # Convert Array to vector\n    reshaped_array = Matrix(m, n, sint)  # Create a new Matrix with shape (m, n)\n    reshaped_array.assign_vector(array)  # Assign the vector to the Matrix\n    return reshaped_array\n", "response_1": "from Compiler.types import Matrix\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape an array.\n    \"\"\"\n    array = Matrix(m, n, ndarray.value_type)\n    array.assign_vector(ndarray.get_vector())\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ones", "response_0": "from Compiler import types\n\nn = 10\na = types.sfix.Array(n)\na.assign_all(1)\n", "response_1": "from Compiler.types import sfix\n\nn = 10\na = sfix.Array(n)\na.assign_all(1.0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "set_one_to_zero", "response_0": "from Compiler import types\n\ndef set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    y[y == 1] = 0\n    return y\n", "response_1": "from Compiler.types import sint, Array\n\ndef set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    ones = sint(1)\n    zeros = sint(0)\n    for i in range(len(y)):\n        y[i] = y[i].if_else(zeros, y[i])\n    return y\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_eye", "response_0": "from Compiler import types\n\nn = 10\na = types.Matrix(n, n, types.sfix)\n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = 1.0\n        else:\n            a[i][j] = 0.0\n", "response_1": "from Compiler.types import Matrix\n\nn = 10\na = Matrix(n, n, sint)\n\nfor i in range(n):\n    a[i][i] = 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_diag", "response_0": "from Compiler import types\n\na_l = types.Array(6, types.cint)\na_l.assign_all([1, 3, 5, 2, 4, 6])\n\na = types.Matrix(6, 6, types.cint)\nfor i in range(6):\n    a[i][i] = a_l[i]\n", "response_1": "from Compiler.types import Matrix, cint\n\na_l = [1, 3, 5, 2, 4, 6]\na = Matrix(len(a_l), len(a_l), cint)\n\nfor i in range(len(a_l)):\n    a[i][i] = cint(a_l[i])\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_advanced_integer_indexing", "response_0": "from Compiler import types\n\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    indexing an MP-SPDZ array from an integer array.\n    \"\"\"\n    indices = types.cint.Array.create_from(indices)\n    ret_array = array[indices]\n    return ret_array\n", "response_1": "from Compiler.types import Array, sint\n\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an MP-SPDZ Array from an Array of indices.\n    \"\"\"\n    indices = Array.create_from(indices)\n    ret_array = Array(len(indices), sint)\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    return ret_array\n", "model_name": "deepseek-v2.5"}
