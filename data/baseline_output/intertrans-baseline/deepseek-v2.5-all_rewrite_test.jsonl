{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Get the length of the array\n    n = len(arr)\n    \n    # Create a new array excluding the element at the given index\n    new_arr = Array(n-1, sint)\n    for i in range(index):\n        new_arr[i] = arr[i]\n    for i in range(index+1, n):\n        new_arr[i-1] = arr[i]\n    \n    # Append the element at the given index to the end of the new array\n    final_arr = Array(n, sint)\n    for i in range(n-1):\n        final_arr[i] = new_arr[i]\n    final_arr[n-1] = arr[index]\n    \n    return final_arr\n", "response_1": "# Example usage in MP-SPDZ\narr = [sint(1), sint(2), sint(3), sint(4)]\nindex = 1\nresult = move_to_end(arr, index)\n", "model_name": "deepseek-v2.5"}
{"test_name": "second_largest", "response_0": "fromCompiler import *\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    for i in range(2, n):\n        if_cond = arr[i] > arr[0] | arr[i] > arr[1]\n        idx = arr[0] < arr[1]\n        arr[idx.if_else(0, 1)] = if_cond.if_else(arr[i], arr[idx.if_else(0, 1)])\n    \n    return (arr[0] < arr[1]).if_else(arr[0], arr[1])\n\n# Example usage in MP-SPDZ\n# arr = Array(5, sint)  # Example array with 5 elements\n# result = second_largest(arr)\n# print_ln(\"Second largest element: %s\", result.reveal())\n", "response_1": "def second_largest(arr: regint):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    for i in range(2, n):\n        if arr[i] > arr[0] or arr[i] > arr[1]:\n            idx = 0 if arr[0] < arr[1] else 1\n            arr[idx] = arr[i]\n    return arr[0] if arr[0] < arr[1] else arr[1]\n\n# Example usage in MP-SPDZ\n# arr = Array(5, sint)  # Example array of size 5\n# res = second_largest(arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret | arr[i]\n    return ret\n", "response_1": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sbit()\n    for elem in arr:\n        ret = ret | elem\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1: List[sfix], vec2: List[sfix]) -> sfix:\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    assert len(vec1) == len(vec2), \"Vectors must have the same length\"\n    product_vec = [x * y for x, y in zip(vec1, vec2)]\n    summation = sum(product_vec)\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    # Ensure the vectors have the same length\n    assert len(vec1) == len(vec2), \"Vectors must have the same length\"\n    \n    # Initialize the summation\n    summation = sfix(0)\n    \n    # Compute the inner product\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    \n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    array = Array(n, sint)\n    for i in range(n):\n        array[i] = a[(i - 1) % n]\n    return array\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    array = Array(n, sint)\n    for i in range(n):\n        array[i] = a[(i - 1) % n]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "from Compiler import mpc_math\n\ndef array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises_2", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    flag = sfix.Array(n - 1)\n    for i in range(n - 1):\n        flag[i] = sfix(1) if arr[i] < arr[i + 1] else sfix(0)\n    \n    count = sfix(0)\n    for i in range(n - 1):\n        count += flag[i]\n    \n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    flag = [sint(0)] * (n - 1)\n    \n    for i in range(n - 1):\n        flag[i] = arr[i] < arr[i + 1]\n    \n    count = sum(flag)\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            arr[i] = arr[i] - 1\n        else:\n            arr[i] = arr[i] + 1\n    return arr\n", "response_1": "from Compiler import mpc_math\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    result = []\n    for i, e in enumerate(arr):\n        # Determine if the index is odd or even\n        is_odd = i % 2\n        # Apply the modification based on the index\n        modified_e = e + is_odd - (1 - is_odd)\n        result.append(modified_e)\n    return result\n\n# Example usage in MP-SPDZ\n# arr = [sint(x) for x in [1, 2, 3, 4, 5]]\n# modified_arr = choppy_plus_minus(arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    # Check if a is zero\n    a_is_zero = s_equal(a, cint(0))\n    \n    # If a is zero, check if b is zero\n    b_is_zero = s_equal(b, cint(0))\n    \n    # Determine the number of roots when a is zero\n    roots_when_a_zero = s_if(b_is_zero, cint(0), cint(1))\n    \n    # Calculate the discriminant\n    discriminant = s_sub(s_pow(b, 2), s_mul(s_mul(cint(4), a), c))\n    \n    # Check if the discriminant is greater than zero\n    disc_greater_than_zero = s_greater_than(discriminant, cint(0))\n    \n    # Check if the discriminant is equal to zero\n    disc_equal_to_zero = s_equal(discriminant, cint(0))\n    \n    # Determine the number of roots when a is not zero\n    roots_when_a_not_zero = s_if(disc_greater_than_zero, cint(2), s_if(disc_equal_to_zero, cint(1), cint(0)))\n    \n    # Combine the results based on whether a is zero or not\n    result = s_if(a_is_zero, roots_when_a_zero, roots_when_a_not_zero)\n    \n    return result\n", "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    # Check if a is zero\n    if_a_zero = a == 0\n    # If a is zero, check if b is zero\n    if_b_zero = b == 0\n    # If both a and b are zero, return 0\n    if if_a_zero & if_b_zero:\n        return 0\n    # If a is zero but b is not, return 1\n    elif if_a_zero:\n        return 1\n    else:\n        # Compute the discriminant\n        discriminant = b**2 - 4 * a * c\n        # Check if the discriminant is greater than zero\n        if discriminant > 0:\n            return 2\n        # Check if the discriminant is equal to zero\n        elif discriminant == 0:\n            return 1\n        # If the discriminant is less than zero, return 0\n        else:\n            return 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    flag = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        flag[i] = sfix(1) if predicator(arr[i]) else sfix(0)\n    \n    summation = sfix(0)\n    for i in range(len(arr)):\n        summation += flag[i]\n    \n    return summation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    \n    summation = sint()\n    for i in range(len(arr)):\n        summation = summation + flag[i]\n    \n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "traverse_and_sum", "response_0": "# Example usage in an MP-SPDZ program\narr1 = [sfix(x) for x in [1.0, 2.0, 3.0]]\narr2 = [sfix(y) for y in [4.0, 5.0, 6.0]]\n\nresult = traverse_and_sum(arr1, arr2)\nprint_ln(\"The result is: %s\", result.reveal())\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    # Assuming arr1 and arr2 are lists of secret-shared integers or floats\n    n = len(arr1)\n    products = sfix.Array(n)  # Create an array to hold the products\n    \n    for i in range(n):\n        products[i] = arr1[i] * arr2[i]  # Multiply the elements\n    \n    # Sum all the products\n    total_sum = sfix(0)\n    for i in range(n):\n        total_sum += products[i]\n    \n    return total_sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_round", "response_0": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i].round()\n    return ret\n", "response_1": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i, e in enumerate(arr):\n        ret[i] = e.round()\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sfix)\n    for i in range(n):\n        ret[i] = arr[i] >= brr[i]\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sfix)\n    \n    for i in range(n):\n        ret[i] = arr[i] >= brr[i]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        ret[i] = arr[i] < 0\n    return ret\n", "response_1": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] < 0\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract_2", "response_0": "from Compiler import mpc_math\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the length of the longer array\n    len_a = len(a)\n    len_b = len(b)\n    max_len = max(len_a, len_b)\n\n    # Pad the shorter array with zeros\n    a_padded = a + [0] * (max_len - len_a)\n    b_padded = b + [0] * (max_len - len_b)\n\n    # Perform element-wise subtraction\n    ret = [x - y for x, y in zip(a_padded, b_padded)]\n    return ret\n", "response_1": "from Compiler import types\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the length of the longer array\n    max_len = max(len(a), len(b))\n    \n    # Pad the shorter array with zeros\n    if len(a) < max_len:\n        a += [types.sint(0)] * (max_len - len(a))\n    if len(b) < max_len:\n        b += [types.sint(0)] * (max_len - len(b))\n    \n    # Perform element-wise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    processed_arr = [func(e) for e in arr]\n    return processed_arr\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming arr is an array of secret integers (sint)\n    arr = [sint(1), sint(2), sint(3)]\n    \n    # Define a function to apply to each element\n    def square(x):\n        return x * x\n    \n    # Process the array\n    result = array_process(arr, square)\n    \n    # Output the result\n    output_array(result)\n\nmain()\n", "response_1": "# Define the function to be applied to each element\ndef square(x):\n    return x * x\n\n# Define the array\narr = Array(5, sint)  # Example array with 5 elements of type sint\narr.assign([1, 2, 3, 4, 5])  # Assign values to the array\n\n# Process the array with the square function\nprocessed_arr = array_process(arr, square)\n\n# Output the processed array\nprint_ln(\"Processed array: %s\", processed_arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_a = [a[n-1]] + a[:n-1]\n    return shifted_a\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_a = [a[-1]] + a[:-1]\n    return shifted_a\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming 'a' is a list of integers in MP-SPDZ\n    a = [int(x) for x in range(3)]  # Example: [0, 1, 2]\n    shifted_a = array_shift(a)\n    print_ln(\"Shifted array: %s\", shifted_a)\n", "model_name": "deepseek-v2.5"}
{"test_name": "compare_and_select", "response_0": "fromCompiler import *\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    n = len(a)\n    ret_array = Array(n, sint)\n    \n    for i in range(n):\n        ret_array[i] = a[i] > b[i]\n        ret_array[i] = ret_array[i].if_else(a[i], b[i])\n    \n    return ret_array\n", "response_1": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    n = len(a)\n    ret_array = Array(n, sint)\n    for i in range(n):\n        ret_array[i] = max(a[i], b[i])\n    return ret_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract", "response_0": "from Compiler import types\n\ndef array_subtract(a: types.Array, b: types.Array) -> types.Array:\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the lengths of the arrays\n    len_a = len(a)\n    len_b = len(b)\n    \n    # Pad the shorter array with zeros\n    if len_a < len_b:\n        a = a.extend([types.sint(0)] * (len_b - len_a))\n    else:\n        b = b.extend([types.sint(0)] * (len_a - len_b))\n    \n    # Perform element-wise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the length difference and create a padding array\n    len_diff = len(a) - len(b)\n    pad = [sint(0)] * abs(len_diff)\n    \n    # Pad the shorter array with zeros\n    if len_diff < 0:\n        a = a + pad\n    else:\n        b = b + pad\n    \n    # Perform element-wise subtraction\n    ret = [a[i] - b[i] for i in range(len(a))]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c + c\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c.cat(c)\n", "model_name": "deepseek-v2.5"}
{"test_name": "zeros", "response_0": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = Array(num, sint)\n    array.assign(0)\n    return array\n", "response_1": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = sfix.Array(num)\n    array.assign_all(sfix(0))\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    n = len(arr)\n    clipped_arr = Array(n, sint)\n\n    for i in range(n):\n        x = arr[i]\n        clipped_arr[i] = (upper_bound if x >= upper_bound else (x if x > lower_bound else lower_bound))\n\n    return clipped_arr\n", "response_1": "from Compiler import types\n\ndef clip(arr: types.Array, upper_bound: types.Secret, lower_bound: types.Secret) -> types.Array:\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    n = len(arr)\n    result = types.Array(n, types.Secret)\n\n    @types.vectorize\n    def helper_func(x):\n        upper_cond = x >= upper_bound\n        lower_cond = x > lower_bound\n        return upper_cond.if_else(upper_bound, lower_cond.if_else(x, lower_bound))\n\n    for i in range(n):\n        result[i] = helper_func(arr[i])\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    summation = ssum(flag)\n    return summation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Apply the predicator to each element in the array\n    flags = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        flags[i] = predicator(arr[i])\n    \n    # Sum the flags\n    summation = sfix(0)\n    for flag in flags:\n        summation += flag\n    \n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)  # Initialize count as a secret integer\n\n    for i in range(n):\n        current = arr[i]\n        for j in range(i + 1, n):\n            count += (current > arr[j])\n\n    return count\n", "response_1": "fromCompiler import *\n\ndef reverse_order_pair(arr: Array):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compare arr[i] > arr[j] securely\n            comparison = arr[i] > arr[j]\n            count = count + comparison\n\n    return count\n\n# Example usage in MP-SPDZ\n# arr = Array(sint, [sint(x) for x in [3, 1, 2, 4]])\n# result = reverse_order_pair(arr)\n# print_ln(\"Number of reverse order pairs: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] + 1\n    return arr\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises", "response_0": "from Compiler import types\n\ndef count_rises(arr: types.Array):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = types.sint(0)  # Initialize count as a secret integer\n    n = len(arr)\n    for i in range(n - 1):\n        count += arr[i] < arr[i + 1]\n    return count\n", "response_1": "from Compiler import mpc_math\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sfix(0)  # Initialize count as a fixed-point number\n    n = len(arr)\n    for i in range(n - 1):\n        count += (arr[i] < arr[i + 1])  # Increment count if arr[i] < arr[i+1]\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_2", "response_0": "fromCompiler.types import sfix\n\ndef square(x):\n    return x * x\n\narr = [sfix(2), sfix(3), sfix(4)]\nresult = array_process(arr, square)\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    # Apply the function to each element in the array\n    processed_arr = map_(func, arr)\n    return processed_arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_norm", "response_0": "fromCompiler import *\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector in MP-SPDZ.\n    \"\"\"\n    # Square each element in the vector\n    squared_vec = [item**2 for item in vec]\n    \n    # Sum the squared elements\n    sum_of_squares = sum(squared_vec)\n    \n    # Compute the square root of the sum\n    norm = cint(sum_of_squares).sqrt()\n    \n    return norm\n\n# Example usage in an MP-SPDZ program\n# vec = [cint(x) for x in [1, 2, 3, 4]]\n# result = two_norm(vec)\n# print_ln(\"The two-norm is: %s\", result.reveal())\n", "response_1": "from Compiler import types\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Assuming vec is a list of sfix (secret fixed-point) numbers\n    vec = [item**2 for item in vec]\n    return types.sfix.sqrt(sum(vec))\n", "model_name": "deepseek-v2.5"}
{"test_name": "totally_dominate", "response_0": "from Compiler import types\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Convert input lists to secure arrays\n    a_secure = types.Array(len(a), types.sint, a)\n    b_secure = types.Array(len(b), types.sint, b)\n    \n    # Compute the minimum of array a\n    amin = a_secure[0]\n    for i in range(1, len(a)):\n        amin = amin.max(a_secure[i])\n    \n    # Compute the maximum of array b\n    bmax = b_secure[0]\n    for i in range(1, len(b)):\n        bmax = bmax.min(b_secure[i])\n    \n    # Compare amin and bmax\n    return amin >= bmax\n\n# Example usage in an MP-SPDZ program\n# a = [types.sint(x) for x in [5, 6, 7]]\n# b = [types.sint(x) for x in [1, 2, 3]]\n# result = totally_dominate(a, b)\n# print_ln(\"Totally dominates: %s\", result.reveal())\n", "response_1": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Assuming a and b are lists of integers or floats\n    amin = a[0]\n    for element in a[1:]:\n        amin = min(amin, element)\n    \n    bmax = b[0]\n    for element in b[1:]:\n        bmax = max(bmax, element)\n    \n    return amin >= bmax\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    n = len(vec1)\n    summation = sint(0)\n    for i in range(n):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret-shared vectors.\n    \"\"\"\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    summation = sint(0)\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    n = len(indices)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler import types\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    # Convert the input array to a list of integers\n    arr = types.Array(len(arr), types.sint, arr)\n    \n    # Initialize a flag to False\n    flag = types.sint(0)\n    \n    # Iterate over the array\n    for i in range(len(arr)):\n        # Check if the current element is 5 or 7\n        is_5 = arr[i] == 5\n        is_7 = arr[i] == 7\n        is_5_or_7 = is_5 | is_7\n        \n        # Update the flag if we find 5 or 7\n        flag = flag | is_5_or_7\n    \n    # Convert the flag to a boolean (public output)\n    result = flag.reveal()\n    \n    # Return True if the flag is set, otherwise False\n    return result != 0\n\n# Example usage (to be run in an MP-SPDZ program)\n# arr = types.Array(5, types.sint, [1, 2, 3, 4, 5])\n# exists_5_or_7(arr)\n", "response_1": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = arr[i] == 5 or arr[i] == 7\n    return flag.any()\n", "model_name": "deepseek-v2.5"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n-1, sint)\n    for i in range(index):\n        ret[i] = arr[i]\n    for i in range(index, n-1):\n        ret[i] = arr[i+1]\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    ret = [None] * (n - 1)\n    for i in range(index):\n        ret[i] = arr[i]\n    for i in range(index + 1, n):\n        ret[i - 1] = arr[i]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = sum(arr)\n    length = len(arr)\n    ret = summmation.reveal() / length\n    return ret\n", "response_1": "template <typename T>\nT average(const vector<T>& arr) {\n    T summmation = T::zero();\n    for (size_t i = 0; i < arr.size(); ++i) {\n        summmation += arr[i];\n    }\n    T length = T(arr.size());\n    T ret = summmation / length;\n    return ret;\n}\n", "model_name": "deepseek-v2.5"}
