{"test_name": "indicate_positive", "response_0": "def indicate_positive(arr: sint):\n    \"\"\"\n    For the given array, return an array with the same size. \n    If one element in the input array is positive, \n    then the corresponding element in the returned array will be 1, \n    otherwise the element in the returned array will be 0. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] > 0\n    return ret\n", "response_1": "def indicate_positive(arr):\n    \"\"\"\n    For the given array, return an array with the same size. \n    If one element in the input array is positive, \n    then the corresponding element in the returned array will be 1, \n    otherwise the element in the returned array will be 0. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] > 0\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_xor", "response_0": "def array_xor(a, b):\n    \"\"\"\n    Compute the elementwise XOR of the two input vectors.\n    \"\"\"\n    n = len(a)\n    ret = sfix.Array(n)\n    for i in range(n):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "response_1": "def array_xor(a, b):\n    \"\"\"\n    Compute the elementwise XOR of the two input vectors.\n    \"\"\"\n    n = len(a)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "interlaced_placement", "response_0": "def interlaced_placement(a, b):\n    \"\"\"\n    Interleave the elements in two sequences.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(a)\n    ret = [sint(0) for _ in range(2 * n)]\n    for i in range(2 * n):\n        if i % 2 == 1:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "response_1": "def interlaced_placement(a, b):\n    \"\"\"\n    Interleave the elements in two sequences.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(a)\n    ret = Array(2 * n, sint)\n    for i in range(2 * n):\n        if i % 2 == 1:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_and", "response_0": "def array_and(a, b):\n    \"\"\"\n    Compute the elementwise AND of the two input vectors. \n    \"\"\"\n    n = len(a)\n    ret = sfix.Array(n)\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "def array_and(a, b):\n    \"\"\"\n    Compute the elementwise AND of the two input vectors.\n    \"\"\"\n    # Ensure the input vectors have the same length\n    assert len(a) == len(b), \"Input vectors must have the same length\"\n    \n    # Initialize the result vector with the same length\n    ret = sint.Array(len(a))\n    \n    # Perform element-wise AND operation\n    for i in range(len(a)):\n        ret[i] = a[i] & b[i]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array. \n    For each element in the input array, \n    the corresponding value in the returned array is set to be the value of the predicator. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array. \n    For each element in the input array, \n    the corresponding value in the returned array is set to be the value of the predicator. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is greater than the bound. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is greater than the bound. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_no_greater_than_scalar", "response_0": "from Compiler import types\n\ndef array_no_greater_than_scalar(arr: types.Array, bound: types.Regint) -> types.Array:\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is no greater than the bound. \n    \"\"\"\n    ret = types.Array(len(arr), types.Regint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] <= bound\n    return ret\n", "response_1": "def array_no_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is no greater than the bound. \n    \"\"\"\n    ret = Array(len(arr), sbit)\n    for i in range(len(arr)):\n        ret[i] = arr[i] <= bound\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    \"\"\"\n    Reverse the input array and concatenate it to the original array.\n    \"\"\"\n    n = len(a)\n    b = [sint(0)] * n  # Initialize the reversed array with the same length\n\n    # Reverse the array\n    for i in range(n):\n        b[i] = a[n - 1 - i]\n\n    # Concatenate the original array with the reversed array\n    result = a + b\n    return result\n", "response_1": "def reverse_and_concat(a):\n    \"\"\"\n    Reverse the input array and concatenate it to the original array. \n    \"\"\"\n    n = len(a)\n    b = Array(n, sint)\n    for i in range(n):\n        b[i] = a[n-1-i]\n    return a + b\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_round", "response_0": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    import math\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        int_part = arr[i].floor()\n        ret[i] = int_part + (arr[i] - int_part >= 0.5)\n    return ret\n", "response_1": "from Compiler import mpc_math\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        int_part = mpc_math.floor(arr[i])\n        ret[i] = int_part + (arr[i] - int_part >= 0.5)\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = arr[i].geq(brr[i])\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] >= brr[i]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "reverse", "response_0": "def reverse(arr):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "response_1": "def reverse(arr: regint, n: regint):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size. \n    If one element in the input array is negative, \n    then the corresponding element in the returned array will be 1, \n    otherwise the element in the returned array will be 0. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] < 0\n    return ret\n", "response_1": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size. \n    If one element in the input array is negative, \n    then the corresponding element in the returned array will be 1, \n    otherwise the element in the returned array will be 0. \n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] < 0\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_sub_sequence", "response_0": "def max_sub_sequence(arr: Array):\n    \"\"\"\n    Use dynamic programming to find the sum of max continuous subsequence of the input array.\n    \"\"\"\n    n = len(arr)\n    partial_max = Array(n, sint)\n    suffix_max = Array(n, sint)\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n\n    for i in range(1, n):\n        suffix_max[i] = max(suffix_max[i-1] + arr[i], arr[i])\n        partial_max[i] = max(partial_max[i-1], suffix_max[i])\n\n    return partial_max[n-1]\n", "response_1": "from Compiler import types\n\ndef max_sub_sequence(arr: types.Array):\n    \"\"\"\n    Use dynamic programming to find the sum of max continuous subsequence of the input array.\n    \"\"\"\n    n = len(arr)\n    partial_max = types.Array(n, types. sint)\n    suffix_max = types.Array(n, types. sint)\n    \n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    \n    @for_range(1, n)\n    def _(i):\n        suffix_max[i] = suffix_max[i-1] + arr[i] if suffix_max[i-1] >= 0 else arr[i]\n        partial_max[i] = partial_max[i-1] if partial_max[i-1] >= suffix_max[i] else suffix_max[i]\n    \n    return partial_max[n-1]\n", "model_name": "deepseek-v2.5"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise, \n    and save the larger value into the returned array. \n    \"\"\"\n    n = len(a)\n    ret_array = sarray(n)\n    for i in range(n):\n        ret_array[i] = a[i] > b[i]\n        ret_array[i] = ret_array[i].if_else(a[i], b[i])\n\n    return ret_array\n", "response_1": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise, \n    and save the larger value into the returned array. \n    \"\"\"\n    n = len(a)\n    ret_array = Array(n, sint)\n    \n    for i in range(n):\n        ret_array[i] = max(a[i], b[i])\n    \n    return ret_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_element_frequency", "response_0": "def count_element_frequency(l):\n    \"\"\"\n    Return an array with the same size of the original array, \n    each position of which records the number of occurrences of the element at the same position. \n    \"\"\"\n    n = len(l)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = 0\n        for j in range(n):\n            ret[i] = ret[i] + (l[j] == l[i])\n    return ret\n", "response_1": "def count_element_frequency(l):\n    \"\"\"\n    Return an array with the same size of the original array, \n    each position of which records the number of occurrences of the element at the same position. \n    \"\"\"\n    n = len(l)\n    ret = sfix.Array(n)\n    for i in range(n):\n        ret[i] = sfix(0)\n    \n    for i in range(n):\n        for j in range(n):\n            if l[j] == l[i]:\n                ret[i] = ret[i] + 1\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_or", "response_0": "def array_or(a, b):\n    \"\"\"\n    Compute the elementwise OR of the two input vectors.\n    \"\"\"\n    n = len(a)\n    ret = sfix.Array(n)\n    for i in range(n):\n        ret[i] = a[i] | b[i]\n    return ret\n", "response_1": "from Compiler import types\n\ndef array_or(a, b):\n    \"\"\"\n    Compute the elementwise OR of the two input vectors.\n    \"\"\"\n    n = len(a)\n    ret = types.Array(n, types.sint)\n    for i in range(n):\n        ret[i] = a[i] | b[i]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "stock_predicator", "response_0": "def stock_predicator(days):\n    \"\"\"\n    Given the stock price in the next few days (at least 3 days).\n    Use dynamic programming to find to days, \n    such that buying on the earlier day and selling on the later day is the most profitable\n    If all choices causes negative profits, you should return 0.\n    \"\"\"\n    n = len(days)\n    lowest = sfix.Array(n)\n    partial_max = sfix.Array(n)\n    lowest[0] = days[0]\n    for i in range(1, n):\n        lowest[i] = lowest[i-1] if lowest[i-1] <= days[i] else days[i]\n        partial_max[i] = partial_max[i-1] if partial_max[i-1] >= days[i] - lowest[i-1] else days[i] - lowest[i-1]\n    return partial_max[n-1]\n", "response_1": "def stock_predicator(days):\n    \"\"\"\n    Given the stock price in the next few days (at least 3 days).\n    Use dynamic programming to find to days, \n    such that buying on the earlier day and selling on the later day is the most profitable\n    If all choices causes negative profits, you should return 0.\n    \"\"\"\n    n = len(days)\n    lowest = sint.Array(n)\n    partial_max = sint.Array(n)\n    lowest[0] = days[0]\n\n    @for_range(1, n)\n    def _(i):\n        lowest[i] = lowest[i-1] if lowest[i-1] <= days[i] else days[i]\n        partial_max[i] = partial_max[i-1] if partial_max[i-1] >= days[i] - lowest[i-1] else days[i] - lowest[i-1]\n\n    return partial_max[n-1]\n", "model_name": "deepseek-v2.5"}
{"test_name": "len5_inc_array", "response_0": "def len5_inc_array(init):\n    \"\"\"\n    Return an increase-by-one array with given initial element and length 5.\n    \"\"\"\n    ret = [init + sint(i) for i in range(5)]\n    return ret\n", "response_1": "def len5_inc_array(init):\n    \"\"\"\n    Return an increase-by-one array with given initial element and length 5.\n    \"\"\"\n    ret = Array(5, sint)\n    for i in range(5):\n        ret[i] = init + i\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "cut_first_five", "response_0": "def cut_first_five(arr):\n    \"\"\"\n    Return the array composed of the first 5 elements of the input array. \n    If the input array does not have 5 elements, pad with 0.\n    \"\"\"\n    ret = Array(5, sint)\n    for i in range(5):\n        if i < len(arr):\n            ret[i] = arr[i]\n        else:\n            ret[i] = 0\n    return ret\n", "response_1": "def cut_first_five(arr):\n    \"\"\"\n    Return the array composed of the first 5 elements of the input array. \n    If the input array does not have 5 elements, pad with 0.\n    \"\"\"\n    ret = sfix.Array(5)\n    for i in range(5):\n        if i < len(arr):\n            ret[i] = arr[i]\n        else:\n            ret[i] = sfix(0)\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_pooling_1d", "response_0": "def max_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional max pooling on vec with step.\n    Ignoring the remaining elements in the vector.\n    \"\"\"\n    n = len(vec)\n    ret_length = n // step\n    ret = Array(ret_length, sint)\n    for i in range(ret_length):\n        max_val = vec[i * step]\n        for j in range(1, step):\n            max_val = max(max_val, vec[i * step + j])\n        ret[i] = max_val\n    return ret\n", "response_1": "def max_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional max pooling on vec with step. \n    Ignoring the remaining elements in the vector.\n    \"\"\"\n    ret_length = len(vec) // step\n    ret = Array(ret_length, sint)\n    for i in range(ret_length):\n        max_val = vec[i * step]\n        for j in range(1, step):\n            max_val = max_val.max(vec[i * step + j])\n        ret[i] = max_val\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater", "response_0": "def array_greater(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i]>brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    n = len(arr)\n    ret = sfix.Array(n)\n    \n    for i in range(n):\n        ret[i] = sfix(1) if arr[i] > brr[i] else sfix(0)\n    \n    return ret\n", "response_1": "def array_greater(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i]>brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    n = len(arr)\n    ret = sfix.Array(n)\n    for i in range(n):\n        ret[i] = sfix(1) if arr[i] > brr[i] else sfix(0)\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "dumb_concat", "response_0": "def dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    length_arr = len(arr)\n    length_brr = len(brr)\n    length = length_arr + length_brr\n    ret = sfix.Array(length)\n    \n    for i in range(length_arr):\n        ret[i] = arr[i]\n    \n    for j in range(length_brr):\n        ret[length_arr + j] = brr[j]\n    \n    return ret\n", "response_1": "def dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    length = len(arr) + len(brr)\n    ret = sfix.Array(length)  # Initialize an array of fixed-point numbers with the given length\n\n    for i in range(len(arr)):\n        ret[i] = arr[i]\n\n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicator_if_else", "response_0": "def indicator_if_else(a, b, ind):\n    \"\"\"\n    Return an array c with the same length of a and b. \n    The element of c is set to be the corresponding element of a if the indicator is 1, \n    and is set to be the corresponding element of b if the indicator is 0.\n    \"\"\"\n    n = len(ind)\n    c = sfix.Array(n)\n    for i in range(n):\n        c[i] = a[i] * ind[i] + b[i] * (1 - ind[i])\n    return c\n", "response_1": "def indicator_if_else(a, b, ind):\n    \"\"\"\n    Return an array c with the same length of a and b. \n    The element of c is set to be the corresponding element of a if the indicator is 1, \n    and is set to be the corresponding element of b if the indicator is 0.\n    \"\"\"\n    n = len(ind)\n    c = sfix.Array(n)\n    for i in range(n):\n        c[i] = a[i] * ind[i] + b[i] * (1 - ind[i])\n    return c\n", "model_name": "deepseek-v2.5"}
{"test_name": "elementwise_multiplication", "response_0": "def elementwise_multiplication(a, b):\n    \"\"\"\n    Compute the elementwise multiplication of the two input vectors.\n    \"\"\"\n    n = len(a)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "def elementwise_multiplication(a, b):\n    \"\"\"\n    Compute the elementwise multiplication of the two input vectors.\n    \"\"\"\n    n = len(a)\n    ret = sfix.Array(n)\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices. \n    The inputs are guaranteed to be legal.\n    \"\"\"\n    n = len(indices)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices. \n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "inc_array", "response_0": "def inc_array(num):\n    \"\"\"\n    Return an array with length num and elements 1 to num. \n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    arr = Array(num, sint)\n    for i in range(num):\n        arr[i] = i + 1\n    return arr\n", "response_1": "def inc_array(num):\n    \"\"\"\n    Return an array with length num and elements 1 to num. \n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    # Ensure num is a public integer\n    num = regint(num)\n    \n    # Create an array of size num\n    result = Array(num, sint)\n    \n    # Fill the array with values from 1 to num\n    for i in range(num):\n        result[i] = sint(i + 1)\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "cut_last_five", "response_0": "def cut_last_five(arr):\n    \"\"\"\n    Return the array composed of the last 5 elements of the input array. \n    If the input array does not have 5 elements, pad with 0 (at the beginning).\n    \"\"\"\n    ret = [sint(0) for i in range(5)]\n    for i in range(min(5, len(arr))):\n        ret[4 - i] = arr[len(arr) - 1 - i]\n    return ret\n", "response_1": "def cut_last_five(arr):\n    \"\"\"\n    Return the array composed of the last 5 elements of the input array. \n    If the input array does not have 5 elements, pad with 0 (at the beginning).\n    \"\"\"\n    # Initialize the result array with 5 zeros\n    ret = [sint(0) for _ in range(5)]\n    \n    # Determine the length of the input array\n    arr_len = len(arr)\n    \n    # Loop to copy the last 5 elements (or as many as available)\n    for i in range(min(5, arr_len)):\n        ret[4 - i] = arr[arr_len - 1 - i]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "average_pooling_1d", "response_0": "def average_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional average pooling on vec with step.\n    Ignoring the remaining elements in the vector.\n    \"\"\"\n    n = len(vec)\n    ret_length = n // step\n    ret = sfix.Array(ret_length)\n\n    for i in range(ret_length):\n        avg = sfix(0)\n        for j in range(step):\n            avg = avg + vec[i * step + j] / sfix(step)\n        ret[i] = avg\n\n    return ret\n", "response_1": "def average_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional average pooling on vec with step.\n    Ignoring the remaining elements in the vector.\n    \"\"\"\n    ret_length = len(vec) // step\n    ret = Array(ret_length, sint)\n    for i in range(ret_length):\n        avg = sint(0)\n        for j in range(step):\n            avg = avg + vec[i * step + j] / step\n        ret[i] = avg\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_relu", "response_0": "def array_relu(arr):\n    \"\"\"\n    Apply ReLU function elementwisely to the input array.\n    \"\"\"\n    n = len(arr)\n    ret = sfix.Array(n)\n    for i in range(n):\n        ret[i] = arr[i] if arr[i] >= 0 else sfix(0)\n    return ret\n", "response_1": "def array_relu(arr):\n    \"\"\"\n    Apply ReLU function elementwisely to the input array.\n    \"\"\"\n    ret = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i].if_else(arr[i], 0)\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "move_to_end", "response_0": "from Compiler import mpc_math\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Get the length of the array\n    n = len(arr)\n    \n    # Read the element at the given index\n    temp = arr[index]\n    \n    # Shift elements to the left from index+1 to the end\n    for i in range(index + 1, n):\n        arr[i - 1] = arr[i]\n    \n    # Place the element at the end of the array\n    arr[n - 1] = temp\n    \n    return arr\n\n# Example usage in an MP-SPDZ program\ndef main():\n    # Define an array of secret shared integers\n    arr = Array(5, sint)\n    arr[0] = sint(1)\n    arr[1] = sint(2)\n    arr[2] = sint(3)\n    arr[3] = sint(4)\n    arr[4] = sint(5)\n    \n    # Move the element at index 2 to the end\n    move_to_end(arr, 2)\n    \n    # Output the modified array\n    print_ln('Modified array: %s', arr.reveal())\n", "response_1": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    temp = arr[index]\n    for i in range(index + 1, n):\n        arr[i - 1] = arr[i]\n    arr[n - 1] = temp\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "set_to_zero", "response_0": "def set_to_zero(arr, index):\n    \"\"\"\n    Set the element in the input array with given index to zero.\n    The input index is guaranteed to be legal. \n    \"\"\"\n    arr[index] = sint(0)\n    return arr\n", "response_1": "def set_to_zero(arr, index):\n    \"\"\"\n    Set the element in the input array with given index to zero.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = sint(0)  # sint represents a secret integer\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "last_partial_sum", "response_0": "def last_partial_sum(arr, n):\n    \"\"\"\n    Return the sum of the last n elements in the input array.\n    n is guaranteed to be legal.\n    \"\"\"\n    ret = sfix(0)\n    for i in range(len(arr) - n, len(arr)):\n        ret = ret + arr[i]\n    return ret\n", "response_1": "def last_partial_sum(arr, n):\n    \"\"\"\n    Return the sum of the last n elements in the input array.\n    n is guaranteed to be legal.\n    \"\"\"\n    ret = sfix(0)  # Initialize the return value as a fixed-point number\n    start_index = len(arr) - n  # Calculate the starting index\n    for i in range(start_index, len(arr)):\n        ret = ret + arr[i]  # Accumulate the sum\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "permute_by_indices", "response_0": "def permute_by_indices(a, indices):\n    \"\"\"\n    Permute the input array a by the indices. \n    The i'th element in the returned array will be a[indices[i]]. \n    The input indices are guaranteed to be a legal permutation. \n    \"\"\"\n    n = len(a)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def permute_by_indices(a, indices):\n    \"\"\"\n    Permute the input array a by the indices. \n    The i'th element in the returned array will be a[indices[i]]. \n    The input indices are guaranteed to be a legal permutation. \n    \"\"\"\n    n = len(a)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "get_rank", "response_0": "def get_rank(arr, index):\n    \"\"\"\n    Get the rank in the array of the element (how many elements are smaller than the element) with given index.\n    \"\"\"\n    rank = sfix(0)  # Initialize rank as a fixed-point number\n    for i in range(len(arr)):\n        if arr[i] < arr[index]:\n            rank = rank + sfix(1)  # Increment rank by 1\n    return rank\n", "response_1": "def get_rank(arr, index):\n    \"\"\"\n    Get the rank in the array of the element (how many elements are smaller than the element) with given index.\n    \"\"\"\n    rank = sint(0)\n    for i in range(len(arr)):\n        rank = rank + (arr[i] < arr[index])\n    return rank\n", "model_name": "deepseek-v2.5"}
{"test_name": "interchange_by_indices", "response_0": "def interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange the two elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "response_1": "def interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange the two elements in the array with given indices. \n    The input indices are guaranteed to be legal. \n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "increase_by", "response_0": "def increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] + k\n    return arr\n", "response_1": "def increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] + k\n    return arr\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming arr and k are already defined and arr is a list of sfix or sint\n    arr = sfix.Array(10)  # Example: an array of 10 elements\n    index = sint(3)       # Example: index is a secret integer\n    k = sfix(5.0)         # Example: k is a secret fixed-point number\n\n    # Call the function\n    result = increase_by(arr, index, k)\n\n    # Output the result\n    print_ln(\"Resulting array: %s\", result)\n", "model_name": "deepseek-v2.5"}
{"test_name": "retrieve_by_index", "response_0": "def retrieve_by_index(arr: Array[sint], index: sint) -> sint:\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is guaranteed to be legal. \n    \"\"\"\n    return arr[index]\n", "response_1": "# Example usage in MP-SPDZ\nfrom Compiler import types\n\n# Define an array of secret integers\narr = types.sintArray(5)  # Create an array of 5 secret integers\n\n# Assign values to the array (for example)\nfor i in range(5):\n    arr[i] = types.sint(i + 1)  # Assign values 1 through 5\n\n# Define a clear integer index\nindex = types.cint(2)  # Example index\n\n# Retrieve the element by index\nresult = retrieve_by_index(arr, index)\n\n# Print the result (in a secure computation context)\nprint_ln(\"The retrieved element is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "scale_by", "response_0": "def scale_by(arr, index, k):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n\n# MP-SPDZ version\ndef scale_by_mpspdz(arr, index, k):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k in MP-SPDZ.\n    \"\"\"\n    arr[index] = arr[index].__mul__(k)\n    return arr\n", "response_1": "def scale_by(arr: sint, index: int, k: sint):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "take_opposite_to", "response_0": "def take_opposite_to(arr, index):\n    \"\"\"\n    Take opposite to the element in the array with given index. \n    The input index is guaranteed to be legal. \n    \"\"\"\n    arr[index] = -arr[index]\n    return arr\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming arr is a list of secret-shared integers\n    arr = [sint(1), sint(2), sint(3)]  # Example array\n    index = 1  # Example index\n\n    # Call the function\n    result = take_opposite_to(arr, index)\n\n    # Output the result\n    print_ln(\"Resulting array: %s\", [result[i].reveal() for i in range(len(result))])\n", "response_1": "def take_opposite_to(arr, index):\n    \"\"\"\n    Take opposite to the element in the array with given index. \n    The input index is guaranteed to be legal. \n    \"\"\"\n    arr[index] = -arr[index]\n    return arr\n\n# Example usage in MP-SPDZ\nfrom Compiler import types\n\ndef main():\n    # Assuming arr is a list of secret shared integers\n    arr = types.sint.Array(10)  # Example array of size 10\n    index = 5  # Example index\n\n    # Call the function\n    result = take_opposite_to(arr, index)\n\n    # Optionally, you can print the result\n    print_ln(\"Resulting array: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_rank", "response_0": "def array_rank(l):\n    \"\"\"\n    Return an array with the same size of the original array, \n    each position of which records the number of elements smaller than the element at the same position. \n    \"\"\"\n    n = len(l)\n    ret = [sint(0) for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            # Compare l[j] < l[i] and add to ret[i] if true\n            ret[i] = ret[i] + (l[j] < l[i])\n    \n    return ret\n", "response_1": "def array_rank(l):\n    \"\"\"\n    Return an array with the same size of the original array, \n    each position of which records the number of elements smaller than the element at the same position. \n    \"\"\"\n    n = len(l)\n    ret = sfix.Array(n)  # Create an array of fixed-point numbers\n    for i in range(n):\n        ret[i] = sfix(0)  # Initialize each element to 0\n\n    for i in range(n):\n        for j in range(n):\n            # Secure comparison and increment\n            ret[i] = ret[i] + sfix(l[j] < l[i])\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n-1, sint)\n    for i in range(n-1):\n        if_then(i < index, lambda: ret[i] = arr[i])\n        else_then(lambda: ret[i] = arr[i+1])\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n - 1, sint)\n\n    for i in range(n - 1):\n        if_then(i < index, lambda: ret[i].assign(arr[i]))\n        else_then(lambda: ret[i].assign(arr[i + 1]))\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "process_by_index", "response_0": "# Example usage in an MP-SPDZ program\nfromCompiler import *\n\ndef increment(x):\n    return x + 1\n\ndef main():\n    # Initialize a secret shared array\n    arr = [sint(1), sint(2), sint(3)]\n    index = sint(1)  # Secret shared index\n\n    # Process the element at the given index\n    arr = process_by_index(arr, index, increment)\n\n    # Output the result (not shown here, as MP-SPDZ programs typically end with a secure computation)\n    return arr\n", "response_1": "# Define a simple function that adds a secret integer to the element\ndef add_secret_value(x, secret_value):\n    return x + secret_value\n\n# Example usage in an MP-SPDZ program\nfrom Compiler import types\n\n# Define the array and the index\narr = types.Array(5, types.sint)\nindex = types.sint(2)  # Example index\n\n# Define the secret value to add\nsecret_value = types.sint(10)\n\n# Define the function to apply\nfunc = lambda x: add_secret_value(x, secret_value)\n\n# Process the array\nresult_arr = process_by_index(arr, index, func)\n\n# Output the result (in a real MP-SPDZ program, you would use print_ln or similar)\nprint_ln(\"Resulting array: %s\", result_arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_by_indices", "response_0": "def sum_by_indices(arr, indices):\n    \"\"\"\n    Compute the sum of elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for index in indices:\n        sum = sum + arr[index]\n    return sum\n", "response_1": "def sum_by_indices(arr, indices):\n    \"\"\"\n    Compute the sum of elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for index in indices:\n        sum = sum + arr[index]\n    return sum\n", "model_name": "deepseek-v2.5"}
