{"test_name": "multiply_first_five", "response_0": "def multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = 1\n    for i in range(min(5, len(array))):\n        prod *= array[i]\n    return prod\n", "response_1": "def multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sfix(1)\n    for i in range(len(array)):\n        prod *= array[i]\n        if i >= 4:\n            break\n    return prod\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    n = 10  # Example size of the array\n    array = [sfix(random.random()) for _ in range(n)]  # Example array with random elements\n    result = multiply_first_five(array)\n    print_ln(\"The product of the first five elements is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "second_largest", "response_0": "fromCompiler import *\n\ndef second_largest(arr: Array):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    largest = Array(2, sint)\n    largest[0] = arr[0] if arr[0] >= arr[1] else arr[1]\n    largest[1] = arr[1] if arr[0] >= arr[1] else arr[0]\n\n    @for_range(2, n)\n    def _(i):\n        cond1 = arr[i] >= largest[0]\n        cond2 = arr[i] >= largest[1]\n        largest[1] = cond1.if_else(largest[0], largest[1])\n        largest[0] = cond1.if_else(arr[i], largest[0])\n        largest[1] = cond2.if_else(arr[i], largest[1])\n\n    return largest[1]\n", "response_1": "def second_largest(arr):\n    n = len(arr)\n    if n < 2:\n        raise ValueError(\"Array must have at least two elements\")\n\n    largest = arr[0]\n    second = arr[1]\n\n    if_then(second > largest, lambda: (largest, second) = (second, largest))\n\n    for i in range(2, n):\n        if_then(arr[i] >= largest, lambda: (second, largest) = (largest, arr[i]))\n        elif_then(arr[i] >= second, lambda: second = arr[i])\n\n    return second\n", "model_name": "deepseek-v2.5"}
{"test_name": "partial_sum", "response_0": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    for i in range(1, n):\n        arr[i] = arr[i] + arr[i - 1]\n    return arr\n", "response_1": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    partial = sint(0)\n    for i in range(n):\n        partial += arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_adjacent_product", "response_0": "def max_adjacent_product(arr: Array):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2.\n    \"\"\"\n    n = len(arr)\n    cur = arr[0] * arr[1]\n    for i in range(n - 1):\n        temp = arr[i] * arr[i + 1]\n        cur = max(cur, temp)\n    return cur\n", "response_1": "def max_adjacent_product(arr: Array):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2. \n    \"\"\"\n    n = len(arr)\n    cur = arr[0] * arr[1]\n    for i in range(1, n-1):\n        product = arr[i] * arr[i+1]\n        cur = max(cur, product)\n    return cur\n", "model_name": "deepseek-v2.5"}
{"test_name": "argmax", "response_0": "from Compiler import mpc_math\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max value of an array in MP-SPDZ.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = cint(0)\n\n    for i in range(1, n):\n        comparison = current >= a[i]\n        index = mpc_math.if_else(comparison, index, i)\n        current = mpc_math.if_else(comparison, current, a[i])\n\n    return index\n", "response_1": "fromCompiler import *\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max value of an array.\n    \"\"\"\n    current = a[0]\n    index = cint(0)\n    for i in range(len(a)):\n        # Secure comparison to determine the new index\n        new_index = if_else(current >= a[i], index, cint(i))\n        # Secure comparison to determine the new max value\n        new_current = if_else(current >= a[i], current, a[i])\n        index = new_index\n        current = new_current\n    return index\n\n# Example usage in an MP-SPDZ program\nif __name__ == \"__main__\":\n    # Example array\n    a = [cint(3), cint(7), cint(2), cint(5)]\n    # Compute the argmax\n    result = argmax(a)\n    # Output the result\n    print_ln(\"The index of the max value is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_distinct", "response_0": "from Compiler import mpc_math\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    n = len(arr)\n    counter = sfix(0)\n\n    for i in range(n):\n        unique = sfix(1)\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = sfix(0)\n                break\n        counter = counter + unique\n\n    return counter\n", "response_1": "def count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    n = len(arr)\n    counter = sfix(0)\n\n    for i in range(n):\n        unique = sfix(1)\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = sfix(0)\n        counter = counter + unique\n\n    return counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sbit(0)  # Initialize ret as a secret bit with value 0\n    for item in arr:\n        ret = ret | item  # Perform a secure OR operation\n    return ret\n", "response_1": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sfix(0)\n    for item in arr:\n        ret = ret + (item != 0)\n    return ret > 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "range", "response_0": "from Compiler import types\n\ndef range(arr: types.Array):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n\n    @for_range(len(arr))\n    def _(i):\n        nonlocal max_value, min_value\n        item = arr[i]\n        max_value = types.max(max_value, item)\n        min_value = types.min(min_value, item)\n\n    return max_value - min_value\n", "response_1": "from Compiler import types\n\ndef range(arr: types.Array):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr[1:]:\n        max_value = max(max_value, item)\n        min_value = min(min_value, item)\n    return max_value - min_value\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_larger_than_5", "response_0": "def count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5. \n    \"\"\"\n    counter = sfix(0)  # Initialize counter as a fixed-point number\n    for item in arr:\n        if item > sfix(5):  # Compare item with 5 as a fixed-point number\n            counter = counter + sfix(1)  # Increment counter\n    return counter\n", "response_1": "fromCompiler import *\n\ndef count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5. \n    \"\"\"\n    counter = sint(0)\n    for item in arr:\n        if_statement = item > 5\n        counter = counter + if_statement\n    return counter\n\n# Example usage in an MP-SPDZ program\nif __name__ == \"__main__\":\n    arr = Array(10, sint)\n    # Assume arr is populated with secret shared data\n    result = count_larger_than_5(arr)\n    print_ln(\"Number of elements larger than 5: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = sint(0)\n    sum = sint(0)\n    for item in arr:\n        abs_item = abs(item)\n        max = max(max, abs_item)\n        sum = sum + abs_item\n    return 2 * max > sum\n", "response_1": "def exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = sint(0)\n    sum = sint(0)\n    for item in arr:\n        max = max(abs(item), max)\n        sum = sum + abs(item)\n    return 2 * max > sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "greedy_picker", "response_0": "def greedy_picker(items, captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    for item in items:\n        if_statement = item <= captivity\n        captivity = if_statement * (captivity - item) + (1 - if_statement) * captivity\n        num = if_statement * (num + 1) + (1 - if_statement) * num\n    return num\n", "response_1": "def greedy_picker(items, captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    for item in items:\n        # Check if the current item can fit in the bag\n        can_pick = item <= captivity\n        # Update the bag's capacity if the item is picked\n        captivity = can_pick.if_else(captivity - item, captivity)\n        # Increment the number of picked items\n        num = num + can_pick.if_else(1, 0)\n    return num\n", "model_name": "deepseek-v2.5"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    result = s\n    for item in l:\n        result = result + item\n    return result\n", "response_1": "def scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n\n# Example usage in MP-SPDZ\ns = sfix(5)  # Example scalar\nl = [sfix(1), sfix(2), sfix(3)]  # Example array\nresult = scalar_add_array(s, l)\nprint_ln(\"Result: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_equidistant_seq", "response_0": "bool is_equidistant_seq(const vector<int>& arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    int d = arr[1] - arr[0];\n    for (int i = 1; i < n - 1; i++) {\n        if (arr[i + 1] - arr[i] != d) {\n            return false;\n        }\n    }\n    return true;\n}\n", "response_1": "def is_equidistant_seq(arr):\n    n = len(arr)\n    if n <= 1:\n        return True\n\n    d = arr[1] - arr[0]\n    for i in range(1, n-1):\n        if arr[i+1] - arr[i] != d:\n            return False\n    return True\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    \n    sum = sfix(0)  # Initialize sum as a secret fixed-point number\n    for i in range(len(vec1)):\n        sum = sum + vec1[i] * vec2[i]\n    return sum\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays in MP-SPDZ.\n    \"\"\"\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for i in range(len(vec1)):\n        sum = sum + vec1[i] * vec2[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "more_distinct_nonnegative", "response_0": "def more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    nonnegative_counter = sfix(0)\n    negative_counter = sfix(0)\n    n = len(arr)\n    for i in range(n):\n        unique = sfix(1)\n        for j in range(i):\n            unique = unique & (arr[j] != arr[i])\n        if_statement = unique & (arr[i] >= sfix(0))\n        nonnegative_counter = nonnegative_counter + if_statement\n        negative_counter = negative_counter + (sfix(1) - if_statement)\n    return nonnegative_counter > negative_counter\n", "response_1": "def more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    n = len(arr)\n    for i in range(n):\n        unique = True\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = False\n        if unique:\n            if arr[i] >= 0:\n                nonnegative_counter = nonnegative_counter + 1\n            else:\n                negative_counter = negative_counter + 1\n    return nonnegative_counter > negative_counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "flip_positives", "response_0": "def flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        array[i] = -array[i]\n    return array\n\n# MP-SPDZ version\ndef flip_positives_mpspdz(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        if_statement(array[i] > 0, array[i] = -array[i])\n    return array\n", "response_1": "def flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        array[i] = -array[i]\n    return array\n\n# MP-SPDZ specific code\nfrom Compiler import types\n\ndef flip_positives_mpspdz(array: types.Array):\n    \"\"\"\n    Flip the positive elements in the array (MP-SPDZ version)\n    \"\"\"\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        array[i] = -array[i]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "divide_and_plus", "response_0": "# MP-SPDZ program: divide_and_plus.mpc\n\n# Define the function using MP-SPDZ syntax\ndef divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n\n# Example usage in MP-SPDZ\n# Assume x is an input variable\nx = sfix.get_input_from(0)  # Get input from party 0\nresult = divide_and_plus(x)\nprint_ln(\"Result: %s\", result.reveal())\n", "response_1": "from Compiler import types\n\ndef main():\n    x = types.sint(10)  # Example input, replace with actual input\n    result = divide_and_plus(x)\n    print_ln(\"Result: %s\", result.reveal())\n\nmain()\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_log2", "response_0": "def array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    from Compiler import mpc_math\n    for i in range(len(arr)):\n        arr[i] = mpc_math.log2(arr[i])\n    return arr\n", "response_1": "from Compiler import mpc_math\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = mpc_math.log2(arr[i])\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_to_ten", "response_0": "def sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        sum += array[i]\n        if sum >= 10:\n            break\n    return sum\n", "response_1": "def sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        sum += array[i]\n        if sum >= 10:\n            break\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "def choppy_plus_minus(arr):\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "min_element", "response_0": "from Compiler import types\n\ndef min_element(a):\n    \"\"\"\n    Return the minimum value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a[1:]:\n        current = types.minimum(current, item)\n    \n    return current\n", "response_1": "def min_element(a):\n    \"\"\"\n    Return the minimum value of an array.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    for i in range(1, n):\n        current = current.if_else(current <= a[i], a[i])\n    \n    return current\n", "model_name": "deepseek-v2.5"}
{"test_name": "soft_max", "response_0": "def soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    from math import e\n    from Compiler import types\n\n    # Assuming arr is a list of secret-shared values\n    arr = types.sint.Array(len(arr))\n\n    # Compute the denominator\n    denominator = types.sint(0)\n    for item in arr:\n        denominator += item.exp()\n\n    # Compute the soft-max values\n    brr = arr.copy()\n    for i in range(len(arr)):\n        brr[i] = arr[i].exp() / denominator\n\n    return brr\n", "response_1": "from Compiler import mpc_math\n\ndef soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array.\n    \"\"\"\n    # Calculate the denominator\n    denominator = mpc_math.log_sum_exp(arr)\n    \n    # Calculate the softmax values\n    brr = arr.copy()\n    for i in range(len(arr)):\n        brr[i] = mpc_math.exp(arr[i]) / denominator\n    \n    return brr\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_reverse_pair_with_break", "response_0": "#include \"math.h\"\n#include \"arr.h\"\n\ntemplate<class sint, class sgf2n>\nsint count_reverse_pair_with_break(const vector<sint>& arr) {\n    sint count = sint(0);\n    int n = arr.size();\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > sint(10)) {\n            break;\n        }\n        for (int j = 0; j < i; j++) {\n            if (arr[j] > arr[i]) {\n                count += sint(1);\n            }\n        }\n    }\n    return count;\n}\n", "response_1": "def count_reverse_pair_with_break(arr):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    \"\"\"\n    count = sfix(0)\n    n = len(arr)\n    for i in range(1, n):\n        if arr[i] > sfix(10):\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count += 1\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_unique", "response_0": "def sum_unique(arr: Array):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    n = len(arr)\n    sum = sint(0)\n    for i in range(n):\n        unique = true\n        for j in range(n):\n            if arr[j] == arr[i] and j != i:\n                unique = false\n                break\n        if unique:\n            sum = sum + arr[i]\n    return sum\n", "response_1": "def sum_unique(arr):\n    n = len(arr)\n    sum = sfix(0)\n\n    for i in range(n):\n        unique = sfix(1)\n        for j in range(n):\n            if j != i:\n                unique = unique & (arr[j] != arr[i])\n        sum = sum + unique * arr[i]\n\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "check_sum", "response_0": "from Compiler import mpc_math\n\ndef check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = mpc_math.sum(array)\n    return sum == target\n", "response_1": "def check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = array[0]\n    for i in range(1, len(array)):\n        sum = sum + array[i]\n    return sum == target\n", "model_name": "deepseek-v2.5"}
{"test_name": "prod", "response_0": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    prod = sfix(1)\n    for num in array:\n        prod = prod * num\n    return prod\n", "response_1": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array. \n    \"\"\"\n    prod = 1\n    for num in array:\n        prod = prod * num\n    return prod\n\n# MP-SPDZ equivalent\ndef prod_mpspdz(array):\n    \"\"\"\n    Multiply together all elements in the array using MP-SPDZ operations.\n    \"\"\"\n    prod = sfix(1)  # Initialize product with a secret fixed-point number 1\n    for num in array:\n        prod = prod * num  # Multiply the current product by the next element\n    return prod\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_till_negative", "response_0": "def sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = 0\n    for i in range(len(array)):\n        if array[i] < 0:\n            break\n        sum += array[i]\n    return sum\n\n# MP-SPDZ equivalent\ndef sum_till_negative_mpspdz(array):\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i] < sfix(0):\n            break\n        sum += array[i]\n    return sum\n", "response_1": "def sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        if array[i].reveal() < 0:\n            break\n        sum += array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secure integer\n    for i in range(len(arr)):\n        if predicator(arr[i]):\n            sum = sum + 1\n    return sum\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for i in range(len(arr)):\n        if predicator(arr[i]):\n            sum = sum + 1\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "standard_deviation", "response_0": "def standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    average = ssum(arr) / n\n    variance = ssum([(x - average) ** 2 for x in arr]) / n\n    return sqrt(variance)\n", "response_1": "fromCompiler import *\nimport math\n\ndef standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array.\n    \"\"\"\n    n = len(arr)\n    average = sfix.Array(n).zero_array()\n    variance = sfix.Array(n).zero_array()\n\n    # Compute the average\n    for i in range(n):\n        average += arr[i] / sfix(n)\n\n    # Compute the variance\n    for i in range(n):\n        variance += (arr[i] - average) ** 2 / sfix(n)\n\n    # Compute the standard deviation\n    return math.sqrt(variance.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "dominate", "response_0": "def dominate(a, b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    n = len(a)\n    ret = sfix.Array(n, 0)\n    for i in range(n):\n        ret[i] = a[i] >= b[i]\n    return ret.all()\n", "response_1": "def dominate(a, b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    n = len(a)\n    ret = sint(1)  # Initialize ret to True\n    for i in range(n):\n        ret = ret * (sint(1) - (a[i] < b[i]))  # If a[i] < b[i], ret becomes 0\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = 0\n    for item in brr:\n        if abs(item) > max_abs:\n            max_abs = abs(item)\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n\n# MP-SPDZ version of the rescale function\ndef rescale_mpspdz(brr):\n    max_abs = sfloat(0)\n    for item in brr:\n        if abs(item) > max_abs:\n            max_abs = abs(item)\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "response_1": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = sfix(0)\n    for item in brr:\n        max_abs = max(max_abs, abs(item))\n    \n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    \n    return brr\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_minus7", "response_0": "from Compiler import mpc_math\n\ndef array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n\ndef main():\n    # Example usage in MP-SPDZ\n    arr = Array(10, sint)  # Create an array of 10 secret integers\n    arr = array_minus7(arr)\n    # Further processing or output can be done here\n", "response_1": "def array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] - cint(7)\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    n1 = len(arr1)\n    n2 = len(arr2)\n    for i in range(n1):\n        for j in range(n2):\n            sum = sum + arr1[i] * arr2[j]\n    return sum\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum = sum + arr1[i] * arr2[j]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "longest_nondec_subseq", "response_0": "def longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    n = len(a)\n    max_length = sint(0)\n    cur_length = sint(0)\n\n    for i in range(n):\n        if i == 0:\n            cur_length = sint(1)\n        else:\n            cond = a[i] >= a[i-1]\n            cur_length = cond * (cur_length + 1) + (1 - cond) * 1\n        \n        max_length = max_length.max(cur_length)\n    \n    return max_length\n", "response_1": "def longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    max_length = sint(0)\n    cur_length = sint(0)\n    n = len(a)\n\n    for i in range(n):\n        if i == 0:\n            cur_length = sint(1)\n        else:\n            cond = a[i] >= a[i - 1]\n            cur_length = cur_length + 1 if cond else sint(1)\n            max_length = max_length if max_length >= cur_length else cur_length\n\n    max_length = max_length if max_length >= cur_length else cur_length\n    return max_length\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_but_skip_biggest", "response_0": "def sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        if array[i] >= biggest:\n            biggest = array[i]\n        else:\n            sum = sum + array[i]\n    return sum\n", "response_1": "def sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        if array[i] >= biggest:\n            biggest = array[i]\n            continue\n        sum += array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "second_test", "response_0": "from Compiler import mpc_math\n\ndef second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)  # Initialize count as a secret integer\n    first_element = arr[0]  # Get the first element\n\n    for i in range(1, len(arr)):\n        # Compare the first element with each subsequent element\n        is_smaller = first_element < arr[i]\n        # Increment count if the first element is smaller\n        count = count + is_smaller\n\n    # Check if count is exactly 1\n    result = count == 1\n    return result\n", "response_1": "def second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)  # Initialize count as a secret integer\n    for i in range(1, len(arr)):\n        # Compare the first element with the current element\n        if_condition = arr[0] < arr[i]\n        count = count + if_condition\n    \n    # Check if count is exactly 1\n    result = count == 1\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "Manhattan_distance", "response_0": "def Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    n = len(a)\n    ret = sint(0)\n    for i in range(n):\n        ret = ret + abs(a[i] - b[i])\n    return ret\n", "response_1": "def Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two secret-shared vectors.\n    \"\"\"\n    n = len(a)\n    ret = sfloat(0)  # Initialize the result as a secret-shared float\n    for i in range(n):\n        diff = a[i] - b[i]  # Compute the difference\n        abs_diff = abs_s(diff)  # Compute the absolute value of the difference\n        ret = ret + abs_diff  # Accumulate the result\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "deal_with_only_positive", "response_0": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sfix(1)\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        sum = sum + sign * array[i]\n        sign = (-1) * sign\n    return sum\n", "response_1": "def deal_with_only_positive(array: Array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sfix(1)\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i] <= sfix(0):\n            continue\n        sum = sum + sign * array[i]\n        sign = sfix(-1) * sign\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "compare_and_return", "response_0": "def compare_and_return(arr, brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    for i in range(n):\n        cond = arr[i] == brr[i]\n        ret = cond.if_else(i, ret)\n        if cond:\n            break\n    return ret\n", "response_1": "def compare_and_return(arr, brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    for i in range(n):\n        if arr[i] == brr[i]:\n            ret = i\n            break\n    return ret\n\n# Example usage in MP-SPDZ\n# Assuming arr and brr are arrays of secret shared integers\ndef main():\n    # Define the size of the arrays\n    n = 5\n    \n    # Initialize secret shared arrays\n    arr = sfix.Array(n)\n    brr = sfix.Array(n)\n    \n    # Fill the arrays with secret shared values (example values)\n    for i in range(n):\n        arr[i] = sfix.get_input_from(0)\n        brr[i] = sfix.get_input_from(1)\n    \n    # Call the compare_and_return function\n    result = compare_and_return(arr, brr)\n    \n    # Output the result\n    print_ln(\"The first index with matching elements is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_odd_positive", "response_0": "from Compiler import types\n\ndef sum_odd_positive(arr: types.Array):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = types.sint(0)\n    for item in arr:\n        if item.reveal() % 2 == 1 and item.reveal() > 0:\n            sum = sum + item\n    return sum\n", "response_1": "from Compiler import types\n\n# Assuming arr is a list of sfix numbers\narr = [sfix(3.5), sfix(-2.0), sfix(5.0), sfix(4.0), sfix(7.5)]\n\n# Call the function\nresult = sum_odd_positive(arr)\n\n# Print the result (for debugging purposes)\nprint_ln(\"The sum of odd positive numbers is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_sum", "response_0": "def two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            if arr[i] + arr[j] == target:\n                return True\n    return False\n\n# Assuming arr and target are already defined as MP-SPDZ secure types\narr = sfix.Array(n)  # Example of how to define an array of fixed-point numbers\ntarget = sfix(some_value)  # Example of how to define a fixed-point number\n\nresult = two_sum(arr, target)\nprint_ln(\"Result: %s\", result.reveal())\n", "response_1": "from Compiler import mpc_math\n\ndef two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            # Sum the elements at indices i and j\n            sum_ij = arr[i] + arr[j]\n            # Compare the sum with the target\n            if_cond = sum_ij == target\n            # If the condition is met, return True\n            if mpc_math.is_zero(if_cond) == False:\n                return True\n    return False\n", "model_name": "deepseek-v2.5"}
{"test_name": "seq_search", "response_0": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Compare the current element with the target\n        cond = arr[i] == target\n        # If the condition is met, return the index\n        if_then(cond, lambda: return_op(i))\n    # If the target is not found, return -1\n    return_op(-1)\n", "response_1": "from Compiler import mpc_math\n\ndef seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Compare the current element with the target\n        found = mpc_math.eq(arr[i], target)\n        # If found, return the index\n        if_statement = mpc_math.if_else(found, i, -1)\n        if mpc_math.reveal(found):\n            return if_statement\n    # If not found, return -1\n    return -1\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_array", "response_0": "from Compiler import mpc_math\n\ndef choppy_array(arr):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i):\n            if i % 2 == 1:\n                # Odd index: should be the largest of the remaining\n                cond = arr[i + j] > arr[i]\n                if cond.reveal():\n                    return False\n            else:\n                # Even index: should be the smallest of the remaining\n                cond = arr[i + j] < arr[i]\n                if cond.reveal():\n                    return False\n    return True\n", "response_1": "def choppy_array(arr):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(len(arr)-i):\n            if i%2 and arr[i+j]>arr[i]:\n                return False\n            if (not i%2) and arr[i+j]<arr[i]:\n                return False\n    return True\n\n# MP-SPDZ version\ndef choppy_array_mpspdz(arr):\n    n = len(arr)\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i; j++) {\n            if (i % 2 == 1 && arr[i + j] > arr[i]) {\n                return false;\n            }\n            if (i % 2 == 0 && arr[i + j] < arr[i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process", "response_0": "# Define a secure function (example: square each element)\ndef secure_square(x):\n    return x * x\n\n# Create an array of secret-shared values\narr = Array(10, sfix)  # Example: array of 10 secret-fixed-point numbers\n\n# Process the array\nprocessed_arr = array_process(arr, secure_square)\n", "response_1": "from Compiler import mpc_math\n\ndef array_process(arr):\n    \"\"\"\n    Process all elements in the input array by squaring each element.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = mpc_math.pow(arr[i], 2)\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "normalize", "response_0": "def normalize(vec):\n    \"\"\"\n    Normalize the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item**2\n    base = sum.sqrt()\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "response_1": "def normalize(vec):\n    \"\"\"\n    Normalize the vector in a secure multi-party computation context.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item**2\n    base = sqrt(sum)\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "model_name": "deepseek-v2.5"}
{"test_name": "impatient_merchant", "response_0": "def impatient_merchant(days):\n    can_buy = sfix(1)  # Initialize can_buy as a secret fixed-point number with value 1 (True)\n    net = sfix(0)      # Initialize net as a secret fixed-point number with value 0\n    orig_price = sfix(0)  # Initialize orig_price as a secret fixed-point number with value 0\n\n    for i in range(len(days)):\n        if can_buy == 1:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = sfix(0)  # Set can_buy to False\n        else:\n            if days[i] > orig_price:\n                net = net + days[i]\n                can_buy = sfix(1)  # Set can_buy to True\n\n    return net\n", "response_1": "def impatient_merchant(days):\n    \"\"\"\n    You are given the prices of some goods in consecutive days. \n    Here's an impatient merchant who will buy the good at the first days, \n    and sell it until its price becomes higher than its original cost. \n    Then he will buy the good in the next day and repeat the above process. \n    The good left in the hand of the merchant in the last day will worth nothing.\n    You should calculate the net value the impatient merchant can earn.\n    \"\"\"\n    can_buy = sfix.Array(1)\n    net = sfix(0)\n    orig_price = sfix(0)\n    can_buy[0] = 1\n\n    n = len(days)\n    for i in range(n):\n        if_statement = can_buy[0] == 1\n        net = if_statement.if_else(net - days[i], net)\n        orig_price = if_statement.if_else(days[i], orig_price)\n        can_buy[0] = if_statement.if_else(0, can_buy[0])\n\n        else_statement = can_buy[0] == 0\n        sell_condition = days[i] > orig_price\n        net = else_statement.if_else(sell_condition.if_else(net + days[i], net), net)\n        can_buy[0] = else_statement.if_else(sell_condition.if_else(1, can_buy[0]), can_buy[0])\n\n    return net\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1, 0, -1):\n        a[i] = a[i-1]\n    a[0] = temp\n    return a\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1, 0, -1):\n        a[i] = a[i-1]\n    a[0] = temp\n    return a\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_double", "response_0": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] * 2\n    return arr\n\n# Example usage in MP-SPDZ\nn = 5\narr = Array(n, sint)\n# Initialize the array with some values\nfor i in range(n):\n    arr[i] = sint(i)\n\n# Call the function\nresult = array_double(arr)\n", "response_1": "void array_double(int64_t* arr, int64_t size) {\n    for (int i = 0; i < size; i++) {\n        arr[i] = arr[i] * 2;\n    }\n}\n", "model_name": "deepseek-v2.5"}
{"test_name": "stop_at_zero", "response_0": "def stop_at_zero(array: Array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        if_then(array[i] == 0)\n            break\n        end_if\n        array[i] = array[i] + 1\n    return array\n", "response_1": "def stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    for i in range(len(array)):\n        # Check if the current element is zero\n        if array[i] == cint(0):\n            break\n        # Add 1 to the current element\n        array[i] = array[i] + cint(1)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = 1 - arr[i]\n    return arr\n", "response_1": "from Compiler import types\n\ndef main():\n    # Assuming arr is a list of secret-shared boolean values\n    arr = types.Array(10, types.sint)  # Example: an array of 10 secret integers\n    arr = array_not(arr)\n    # Further processing or output of arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_then_clip", "response_0": "from Compiler import types\n\ndef array_process_then_clip(arr: types.Array, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome into the range [-10, 10]\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = types.max(arr[i], -10)\n        arr[i] = types.min(arr[i], 10)\n    return arr\n", "response_1": "from Compiler import mpc_math\nfrom Compiler import types\n\ndef array_process_then_clip(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome into the range [-10, 10]\n    \"\"\"\n    # Process each element with the given function\n    processed_arr = [func(arr[i]) for i in range(len(arr))]\n    \n    # Clip each element to the range [-10, 10]\n    clipped_arr = [types.sint() for _ in range(len(processed_arr))]\n    for i in range(len(processed_arr)):\n        # Use secure comparison and selection to clip the values\n        clipped_arr[i] = mpc_math.max(types.sint(-10), mpc_math.min(types.sint(10), processed_arr[i]))\n    \n    return clipped_arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "add_and_count_positive", "response_0": "def add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array.\n    Return both the output array and the count.\n    \"\"\"\n    n = len(array)\n    count = sint(0)\n\n    for i in range(n):\n        array[i] = array[i] + k\n        if array[i].greater_than(0):\n            count = count + 1\n\n    return array, count\n", "response_1": "fromCompiler import *\n\ndef add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    n = len(array)\n    output_array = Array(n, sint)\n    count = sint(0)\n\n    for i in range(n):\n        output_array[i] = array[i] + k\n        count = count + (output_array[i] > 0)\n\n    return output_array, count\n\n# Example usage:\n# array = Array(5, sint)\n# k = sint(2)\n# output_array, count = add_and_count_positive(array, k)\n# print_ln(\"Output array: %s\", output_array)\n# print_ln(\"Count of positive numbers: %s\", count)\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    \n    # Determine the maximum length\n    max_len = max(n, m)\n    \n    # Initialize the result array with zeros\n    ret = Array(max_len, sint)\n    \n    # Subtract elementwise\n    for i in range(min(n, m)):\n        ret[i] = a[i] - b[i]\n    \n    # Handle the remaining elements if a is longer\n    if n > m:\n        for i in range(m, n):\n            ret[i] = a[i]\n    \n    # Handle the remaining elements if b is longer\n    elif m > n:\n        for i in range(n, m):\n            ret[i] = -b[i]\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    \n    if n > m:\n        ret = [sint(0) for _ in range(n)]\n        for i in range(m):\n            ret[i] = a[i] - b[i]\n        for i in range(n - m):\n            ret[m + i] = a[m + i]\n    else:\n        ret = [sint(0) for _ in range(m)]\n        for i in range(n):\n            ret[i] = a[i] - b[i]\n        for i in range(m - n):\n            ret[n + i] = -b[n + i]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "lower_bound", "response_0": "def lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = x + 1  # Initialize distance to a value greater than x\n    found = False\n\n    for i in range(n):\n        cond = arr[i] <= x\n        new_distance = x - arr[i]\n        cond2 = (not found) | (new_distance < distance)\n        ret = cond & cond2 & (i != -1)\n        distance = cond2.if_else(new_distance, distance)\n        found = found | cond\n\n    return ret\n", "response_1": "def lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = x\n    found = False\n\n    for i in range(n):\n        cond1 = arr[i] <= x\n        cond2 = not found or (x - arr[i]) < distance\n        cond = cond1 & cond2\n        ret = cond.if_else(i, ret)\n        distance = cond.if_else(x - arr[i], distance)\n        found = found | cond\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "argmin", "response_0": "from Compiler import mpc_math\n\ndef argmin(a):\n    \"\"\"\n    Return the index of the minimum value of a secret-shared array.\n    \"\"\"\n    n = len(a)\n    current_index = sint(0)\n    current_value = a[0]\n\n    for i in range(1, n):\n        # Compare current_value with a[i]\n        comparison = mpc_math.lt(a[i], current_value)\n        # Update current_value and current_index based on the comparison\n        current_value = comparison.if_else(a[i], current_value)\n        current_index = comparison.if_else(sint(i), current_index)\n\n    return current_index\n", "response_1": "def argmin(a):\n    \"\"\"\n    Return the index of the minimum value of an array.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = cint(0)\n    for i in range(1, n):\n        cond = current <= a[i]\n        index = cond.if_else(index, i)\n        current = cond.if_else(current, a[i])\n    return index\n", "model_name": "deepseek-v2.5"}
{"test_name": "independent_robbery", "response_0": "def independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem in MP-SPDZ.\n    \"\"\"\n    n = len(houses)\n    dp = sfix.Array(n)\n    dp[0] = houses[0]\n    dp[1] = max(houses[1], dp[0])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-2] + houses[i], dp[i-1])\n\n    return dp[n-1]\n", "response_1": "def independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem in MP-SPDZ.\n    \"\"\"\n    n = len(houses)\n    dp = sfix.Array(n)  # Initialize an array of secret-shared fixed-point numbers\n\n    dp[0] = houses[0]\n    dp[1] = houses[1] if houses[1] >= houses[0] else houses[0]\n\n    for i in range(2, n):\n        option1 = dp[i-2] + houses[i]\n        option2 = dp[i-1]\n        dp[i] = option1 if option1 >= option2 else option2\n\n    return dp[n-1]\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_odd_and_odd", "response_0": "def sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    n = len(arr)\n    sum = sfix(0)\n    for i in range(1, n, 2):\n        for j in range(1, i, 2):\n            sum += arr[j]\n    return sum\n", "response_1": "def sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            sum += arr[j]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_monotonous", "response_0": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    d = sint(0)\n    for i in range(n-1):\n        if i > 0 and (arr[i+1] - arr[i]) * d <= 0:\n            return sbool(False)\n        d = arr[i+1] - arr[i]\n    return sbool(True)\n", "response_1": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    d = sint(0)\n    for i in range(n-1):\n        if i > 0:\n            if (arr[i+1] - arr[i]) * d <= 0:\n                return sbool(False)\n        d = arr[i+1] - arr[i]\n    return sbool(True)\n\n# Example usage in MP-SPDZ\nn = 5\narr = Array(n, sint)\n# Initialize arr with some values\n# arr = [sint(1), sint(2), sint(3), sint(4), sint(5)]\n# or use input_array to take input from parties\n\nresult = is_monotonous(arr)\nprint_ln(\"Is the array monotonous: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "positive_count_negative_sum", "response_0": "def positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint(0)\n    sum = sint(0)\n    for item in arr:\n        if_statement = item > 0\n        count = count + if_statement\n        if_statement = item < 0\n        sum = sum + item * if_statement\n    return count, sum\n", "response_1": "from Compiler import mpc_math\n\ndef positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint(0)\n    sum = sint(0)\n\n    for item in arr:\n        # Check if item is positive\n        if_statement = item > 0\n        count = count + if_statement.if_else(1, 0)\n\n        # Check if item is negative\n        if_statement = item < 0\n        sum = sum + if_statement.if_else(item, 0)\n\n    return count, sum\n\n# Example usage\nif __name__ == \"__main__\":\n    # Assuming arr is a list of sint elements\n    arr = [sint(1), sint(-2), sint(3), sint(-4), sint(5)]\n    count, sum = positive_count_negative_sum(arr)\n    print_ln(\"Count of positive elements: %s\", count.reveal())\n    print_ln(\"Sum of negative elements: %s\", sum.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_even", "response_0": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        if item.reveal() % 2 == 0:\n            sum = sum + item\n    return sum\n", "response_1": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for item in arr:\n        if item % 2 == 0:\n            sum = sum + item\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sint(0)\n    for item in vec:\n        sum = sum + abs(item)\n    return sum\n", "response_1": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sint(0)\n    for item in vec:\n        sum = sum + abs(item)\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_floor", "response_0": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    ret = [sint(0) for i in range(len(arr))]\n    for i in range(len(arr)):\n        ret[i] = arr[i].floor()\n    return ret\n", "response_1": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    from Compiler import math\n    from Compiler import array\n\n    ret = array.create_with_length(len(arr), sint(0))\n    for i in range(len(arr)):\n        ret[i] = math.floor(arr[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "three_five", "response_0": "from Compiler import types\n\ndef three_five(arr: types.Array):\n    \"\"\"\n    If the input array contains both/neither 3 and/or 5, return True, \n    otherwise return False. \n    \"\"\"\n    has3 = types.sint(0)\n    has5 = types.sint(0)\n\n    for i in range(len(arr)):\n        has3 = has3 | (arr[i] == 3)\n        has5 = has5 | (arr[i] == 5)\n\n    return (has3 & has5) | ((~has3) & (~has5))\n", "response_1": "def three_five(arr):\n    \"\"\"\n    If the input array contain both/neither 3 and/or 5, return True, \n    otherwise return False. \n    \"\"\"\n    has3 = sfix(0)\n    has5 = sfix(0)\n    for item in arr:\n        has3 = has3 | (item == 3)\n        has5 = has5 | (item == 5)\n    return (has3 & has5) | ((~has3) & (~has5))\n", "model_name": "deepseek-v2.5"}
{"test_name": "num_above_average", "response_0": "def num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    n = len(arr)\n    sum = ssum(arr)  # Sum of all elements in the array\n    avg = sum / n  # Average value\n    count = 0\n    for i in range(n):\n        count = count + (arr[i] >= avg)\n    return count\n", "response_1": "def num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    # Assuming arr is a list of secret-shared integers\n    n = len(arr)\n    sum = sfix(0)\n    for i in range(n):\n        sum = sum + arr[i]\n    avg = sum / sfix(n)\n    count = sfix(0)\n    for item in arr:\n        count = count + (item >= avg)\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip", "response_0": "def clip(arr: Array, upper_bound: sfix, lower_bound: sfix) -> Array:\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = max(min(arr[i], upper_bound), lower_bound)\n    return arr\n", "response_1": "from Compiler import types\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    n = len(arr)\n    clipped_arr = types.sint.Array(n)\n\n    for i in range(n):\n        clipped_arr[i] = types.sint.if_else(arr[i] < lower_bound, lower_bound, arr[i])\n        clipped_arr[i] = types.sint.if_else(clipped_arr[i] > upper_bound, upper_bound, clipped_arr[i])\n\n    return clipped_arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "from Compiler import mpc_math\n\ndef sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        temp_sum = sum + array[i]\n        if_condition = (sint(5) <= temp_sum) & (temp_sum <= sint(10))\n        sum = sum + array[i] * (1 - if_condition)\n    return sum\n", "response_1": "def sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(array)):\n        if_statement = (sum + array[i]) >= sfix(5) and (sum + array[i]) <= sfix(10)\n        if not if_statement:\n            sum = sum + array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_of_odd_and_even", "response_0": "def sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers. \n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        if item.reveal() % 2:\n            odd_sum = odd_sum + item\n        else:\n            even_sum = even_sum + item\n    return odd_sum, even_sum\n", "response_1": "def sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers.\n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        if item & 1:\n            odd_sum = odd_sum + item\n        else:\n            even_sum = even_sum + item\n    return odd_sum, even_sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "distance", "response_0": "def distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        sum = sum + (vec1[i] - vec2[i])**2\n    return sqrt(sum)\n", "response_1": "from Compiler import mpc_math\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors in MP-SPDZ.\n    \"\"\"\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    \n    sum = regint(0)\n    for i in range(len(vec1)):\n        sum = sum + (vec1[i] - vec2[i]) ** 2\n    \n    return mpc_math.sqrt(sum)\n", "model_name": "deepseek-v2.5"}
{"test_name": "num_occurrence", "response_0": "def num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sfix(0)  # Initialize count as a secret fixed-point number\n    for item in arr:\n        # Check if item is equal to target\n        is_equal = item == target\n        # Increment count if item is equal to target\n        count = count + is_equal\n    return count\n", "response_1": "def num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sint(0)\n    for i in range(len(arr)):\n        if arr[i] == target:\n            count = count + 1\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "palindrome", "response_0": "def palindrome(arr: sint):\n    \"\"\"\n    Check whether the array is a palindrome in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    flag = sint(1)\n    for i in range(n):\n        flag = flag & (arr[i] == arr[n - 1 - i])\n    return flag\n", "response_1": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    flag = sfix.Array(len(arr), sfix(1))  # Initialize flag array with 1s\n    for i in range(len(arr)):\n        flag[i] = arr[i] == arr[len(arr) - 1 - i]\n    \n    result = sfix(1)\n    for i in range(len(arr)):\n        result = result * flag[i]\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler import types\n\ndef reverse_order_pair(arr: types.Array):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    num = types.sint()\n    for i in range(n):\n        for j in range(i + 1, n):\n            condition = arr[i] > arr[j]\n            num = num + condition\n    return num\n", "response_1": "from Compiler import mpc_math\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array. \n    \"\"\"\n    num = sint(0)  # Initialize the counter as a secret integer\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            # Compare arr[i] and arr[j] securely\n            cond = arr[i] > arr[j]\n            # Increment num if the condition is true\n            num = num + cond\n    return num\n\n# Example usage in an MP-SPDZ program\nif __name__ == \"__main__\":\n    # Assuming arr is a list of secret integers\n    arr = [sint(x) for x in [5, 3, 2, 4, 1]]\n    result = reverse_order_pair(arr)\n    # Print the result (MP-SPDZ provides secure output functions)\n    print_ln(\"Number of reverse order pairs: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_of_cubes", "response_0": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sfix(0)  # Initialize the result as a fixed-point number\n    for item in arr:\n        ret = ret + item**3\n    return ret\n", "response_1": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sint(0)  # Initialize the result as a secret integer\n    for item in arr:\n        ret = ret + item**3\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_element", "response_0": "from Compiler import mpc_math\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    for i in range(1, len(a)):\n        current = mpc_math.max(current, a[i])\n    \n    return current\n", "response_1": "def max_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    for i in range(1, len(a)):\n        current = current.max(a[i])\n    \n    return current\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_if_else", "response_0": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array,\n    if the predicator returns True, then apply the if-function to the element,\n    otherwise apply the else-function to the element.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        cond = predicator(arr[i])\n        arr[i] = cond.if_else(if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "response_1": "def array_if_else(arr: sint, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    n = len(arr)\n    result = sfix.Array(n)\n    for i in range(n):\n        # Apply the predicator function to the current element\n        pred_result = predicator(arr[i])\n        # Use the select operation to apply if_func or else_func based on the predicator result\n        result[i] = pred_result.if_else(if_func(arr[i]), else_func(arr[i]))\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "inf_norm", "response_0": "def inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector in MP-SPDZ.\n    \"\"\"\n    max_val = sfix(0)  # Initialize the maximum value with a secure fixed-point number\n    for item in vec:\n        abs_item = abs(item)  # Compute the absolute value of the current item\n        max_val = max(max_val, abs_item)  # Update the maximum value securely\n    return max_val\n", "response_1": "def inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    max_val = sfix(0)  # Initialize max_val with a secret fixed-point number\n    for item in vec:\n        max_val = max(max_val, abs(item))\n    return max_val\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming arr is an array of secret integers\n    arr = Array(10, sint)\n    \n    # Initialize the array (example)\n    for i in range(len(arr)):\n        arr[i] = sint(i)\n    \n    # Call the function\n    result = array_inc(arr)\n    \n    # Output the result (example)\n    for i in range(len(arr)):\n        print_ln(\"%s\", result[i].reveal())\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] + 1\n    return arr\n\n# Example usage in MP-SPDZ\nn = 5\narr = sint.Array(n)\n# Assuming arr is already populated with secret shared values\nresult = array_inc(arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises", "response_0": "def count_rises(arr: sint):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n    for i in range(n - 1):\n        if arr[i] < arr[i + 1]:\n            count = count + 1\n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sfix(0)  # Initialize count as a secure fixed-point number\n    for i in range(len(arr) - 1):\n        if arr[i] < arr[i + 1]:\n            count = count + 1\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "skip_at_zero", "response_0": "def skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        if array[i] == 0:\n            continue\n        array[i] = array[i] + 1\n    return array\n", "response_1": "def skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        if_statement = array[i] == 0\n        array[i] = array[i] + if_statement.if_else(0, 1)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_intersect", "response_0": "fromCompiler import *\n\ndef array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    n = len(p)\n    m = len(q)\n    for i in range(n):\n        for j in range(m):\n            if p[i] == q[j]:\n                return sbool(1)\n    return sbool(0)\n", "response_1": "def array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element.\n    \"\"\"\n    for i in range(len(p)):\n        for j in range(len(q)):\n            if p[i] == q[j]:\n                return 1  # Return 1 to indicate True\n    return 0  # Return 0 to indicate False\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum += item**2\n    return sqrt(sum)\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfloat(0)\n    for item in vec:\n        sum = sum + item**2\n    return sqrt(sum)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_between", "response_0": "def sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sfix(0)\n    for item in arr:\n        if_statement = item >= l\n        if_statement = if_statement & (item <= u)\n        sum = sum + if_statement.if_else(item, sfix(0))\n    return sum\n", "response_1": "def sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sfix(0)  # Initialize sum as a fixed-point number\n    for item in arr:\n        if item >= l and item <= u:\n            sum = sum + item\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "largest_gap", "response_0": "def largest_gap(arr: Array):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = sint(0)\n    for i in range(len(arr) - 1):\n        diff = abs(arr[i + 1] - arr[i])\n        cur = max(cur, diff)\n    return cur\n", "response_1": "def largest_gap(arr: regint):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = 0\n    for i in range(len(arr)-1):\n        diff = abs(arr[i+1] - arr[i])\n        if diff > cur:\n            cur = diff\n    return cur\n", "model_name": "deepseek-v2.5"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    n = len(a)\n    m = len(b)\n    \n    # Initialize amin and bmax\n    amin = a[0]\n    bmax = b[0]\n    \n    # Find the minimum of array a\n    for i in range(1, n):\n        amin = max(amin, a[i])\n    \n    # Find the maximum of array b\n    for i in range(1, m):\n        bmax = min(bmax, b[i])\n    \n    # Check if amin >= bmax\n    return amin >= bmax\n", "response_1": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    # Initialize minimum of a and maximum of b\n    amin = a[0]\n    bmax = b[0]\n\n    # Compute the minimum of array a\n    for i in range(1, len(a)):\n        amin = amin.max(a[i])\n\n    # Compute the maximum of array b\n    for i in range(1, len(b)):\n        bmax = bmax.min(b[i])\n\n    # Check if the minimum of a is greater than or equal to the maximum of b\n    return amin >= bmax\n", "model_name": "deepseek-v2.5"}
{"test_name": "element_count", "response_0": "def element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    int ret = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == target) {\n            ret += 1;\n        }\n    }\n    return ret;\n", "response_1": "def element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    ret = sint(0)\n    for i in range(len(arr)):\n        if arr[i] == target:\n            ret = ret + 1\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_subarray", "response_0": "def is_subarray(c, d):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    n = len(d)\n    m = len(c)\n    for i in range(n):\n        if m <= n - i:\n            flag = True\n            for j in range(m):\n                flag = flag and (d[i + j] == c[j])\n            if flag:\n                return True\n    return False\n\n# Example usage in MP-SPDZ\n# c = Array(m, sint)\n# d = Array(n, sint)\n# result = is_subarray(c, d)\n", "response_1": "fromCompiler import *\n\ndef is_subarray(c: Array, d: Array) -> sbit:\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    n = len(d)\n    m = len(c)\n    for i in range(n):\n        if m <= n - i:\n            flag = sbit(True)\n            for j in range(m):\n                flag = flag & (d[i + j] == c[j])\n            if flag:\n                return sbit(True)\n    return sbit(False)\n\n# Example usage in MP-SPDZ\n# c = Array(len(c), sint)\n# d = Array(len(d), sint)\n# result = is_subarray(c, d)\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler import mpc_math\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    for item in arr:\n        # Check if the item is equal to 5 or 7\n        is_5 = mpc_math.eq_plain(item, 5)\n        is_7 = mpc_math.eq_plain(item, 7)\n        if is_5.reveal() or is_7.reveal():\n            return True\n    return False\n", "response_1": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    for item in arr:\n        is_5 = item == 5\n        is_7 = item == 7\n        if_cond = is_5 + is_7\n        if if_cond.reveal():\n            return True\n    return False\n", "model_name": "deepseek-v2.5"}
{"test_name": "variance", "response_0": "from Compiler import types\n\ndef variance(arr: types.Array):\n    \"\"\"\n    Return the variance of the array.\n    \"\"\"\n    n = len(arr)\n    average = types.sint()\n    variance = types.sint()\n\n    # Calculate the average\n    for item in arr:\n        average += item / n\n\n    # Calculate the variance\n    for item in arr:\n        variance += (item - average) ** 2 / n\n\n    return variance\n", "response_1": "def variance(arr):\n    \"\"\"\n    Return the variance of the array. \n    \"\"\"\n    n = len(arr)\n    average = sfix(0)\n    variance = sfix(0)\n\n    # Calculate the average\n    for item in arr:\n        average += item / sfix(n)\n\n    # Calculate the variance\n    for item in arr:\n        variance += (item - average) ** 2 / sfix(n)\n\n    return variance\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_ascending", "response_0": "def is_ascending(arr):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    n = len(arr)\n    if n == 1:\n        return sbool(1)\n\n    for i in range(n-1):\n        # Compare arr[i] and arr[i+1]\n        cmp = arr[i] < arr[i+1]\n        if i == 0:\n            result = cmp\n        else:\n            result = result & cmp\n\n    return result\n", "response_1": "from Compiler import types\n\ndef is_ascending(arr: types.Array):\n    n = len(arr)\n    if n == 1:\n        return types.sint(1)  # Return True if the array has only one element\n\n    for i in range(n-1):\n        # Compare arr[i] < arr[i+1]\n        if_condition = arr[i] < arr[i+1]\n        if not if_condition.reveal():\n            return types.sint(0)  # Return False if not strictly ascending\n    return types.sint(1)  # Return True if strictly ascending\n", "model_name": "deepseek-v2.5"}
{"test_name": "xor_all", "response_0": "from Compiler import types\n\ndef xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n\n# Example usage\narr = [types.sint(0), types.sint(1), types.sint(1), types.sint(0)]\nresult = xor_all(arr)\nprint_ln(\"The result of XOR all elements is: %s\", result.reveal())\n", "response_1": "def xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "upper_bound", "response_0": "def upper_bound(arr, x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = -1\n    found = False\n\n    for i in range(n):\n        cond1 = arr[i] > x\n        cond2 = not found\n        cond3 = arr[i] - x < distance\n        cond = cond1 & (cond2 | cond3)\n        ret = cond.if_else(i, ret)\n        distance = cond.if_else(arr[i] - x, distance)\n        found = found | cond1\n\n    return ret\n", "response_1": "def upper_bound(arr: regint, x: sfix):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = sfix(0)\n    found = regint(0)\n\n    for i in range(n):\n        if arr[i] > x:\n            if found == 0 or arr[i] - x < distance:\n                ret = i\n                distance = arr[i] - x\n                found = 1\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_then_sum", "response_0": "def array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = sfix(0)  # Initialize sum as a secret-shared fixed-point number\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])  # Apply the function to the element\n        sum = sum + arr[i]  # Add the processed element to the sum\n    return sum\n", "response_1": "def array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        sum = sum + arr[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sfix(0)  # Initialize sum as a secret fixed-point number\n    length = len(arr)  # Length of the array\n    for i in range(length):\n        sum = sum + arr[i]  # Accumulate the sum\n    ret = sum / sfix(length)  # Divide the sum by the length\n    return ret\n", "response_1": "def average(arr):\n    \"\"\"\n    Compute the average value of the array in MP-SPDZ.\n    \"\"\"\n    sum = sfix(0)  # Initialize sum as a secret fixed-point number\n    length = len(arr)  # Get the length of the array\n\n    for i in range(length):\n        sum = sum + arr[i]  # Accumulate the sum\n\n    ret = sum / sfix(length)  # Divide the sum by the length\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_filter", "response_0": "def array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        cond = predicator(arr[i])\n        arr[i] = arr[i] * cond\n    return arr\n", "response_1": "fromCompiler import *\n\ndef array_filter(arr, predicator):\n    for i in range(len(arr)):\n        arr[i] = arr[i] * predicator(arr[i])\n    return arr\n\n# Example usage in an MP-SPDZ program\nn = 10\narr = Array(n, sint)\narr = arr.alloc_slots(n)\n\n# Initialize arr with some values\nfor i in range(n):\n    arr[i] = sint(i)\n\n# Define a predicator function\ndef predicator(x):\n    return x > sint(5)\n\n# Apply the filter\nresult = array_filter(arr, predicator)\n\n# Output the result\nfor i in range(n):\n    print_ln(\"%s\", result[i].reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_up", "response_0": "def sum_up(array):\n    \"\"\"\n    The sum_up function in MP-SPDZ\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        sum = sum + array[i]\n    return sum\n", "response_1": "def sum_up(array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for i in range(len(array)):\n        sum = sum + array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_to_zero", "response_0": "def negative_to_zero(array: sint):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        array[i] = array[i].if_else(0, array[i])\n    return array\n", "response_1": "def negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        array[i] = array[i] * (array[i] >= 0)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_only_positive_to_ten", "response_0": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        if sum >= 10:\n            break\n        sum = sum + array[i]\n    return sum\n", "response_1": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    n = len(array)\n    for i in range(n):\n        element = array[i]\n        if_statement = element > 0\n        sum = if_statement * (sum + element) + (1 - if_statement) * sum\n        if_statement_break = sum >= 10\n        if if_statement_break:\n            break\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "bubble_sort", "response_0": "def bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            # Compare arr[j] and arr[j+1]\n            if_statement = arr[j] >= arr[j+1]\n            # Swap arr[j] and arr[j+1] if the condition is true\n            temp = arr[j]\n            arr[j] = if_statement * arr[j+1] + (1 - if_statement) * arr[j]\n            arr[j+1] = if_statement * temp + (1 - if_statement) * arr[j+1]\n    return arr\n", "response_1": "def bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array. \n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            # Secure comparison\n            if arr[j] >= arr[j + 1]:\n                # Secure swap\n                temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n    return arr\n", "model_name": "deepseek-v2.5"}
