{"test_name": "sin_or_cos", "response_0": "from Compiler import types\n\ndef sin_or_cos(x: types.sfix):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Check if x is nonnegative\n    is_nonnegative = x >= 0\n    \n    # Compute sin(x) and cos(x)\n    sin_x = types.math.sin(x)\n    cos_x = types.math.cos(x)\n    \n    # Return sin(x) if x is nonnegative, otherwise return cos(x)\n    return is_nonnegative.if_else(sin_x, cos_x)\n", "response_1": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Assuming x is a secret fixed-point number\n    x = sfix(x)\n    \n    # Initialize result\n    result = sfix()\n    \n    # Check if x is nonnegative\n    cond = x >= 0\n    \n    # If x is nonnegative, compute sin(x)\n    if_then(cond)\n    result = sin(x)\n    else_then()\n    result = cos(x)\n    end_if()\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    # Compare the input with 0\n    less_than_zero = input < 0\n    \n    # Use the comparison result to select the output\n    return input * less_than_zero\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return input.if_else(input, 0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_close", "response_0": "from Compiler import mpc_math\n\ndef is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    difference = a - b\n    abs_difference = mpc_math.abs(difference)\n    return abs_difference <= 1\n", "response_1": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    return (a - b).abs() <= 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "hardswish", "response_0": "def hardswish(x):\n    \"\"\"\n    Hardswish function in MP-SPDZ.\n    \"\"\"\n    # Define constants\n    minus_three = sfix(-3.0)\n    plus_three = sfix(3.0)\n    six = sfix(6.0)\n\n    # Initialize result\n    result = sfix()\n\n    # Conditional checks\n    cond1 = x < minus_three\n    cond2 = x > plus_three\n\n    # Compute result based on conditions\n    result = cond1.if_else(sfix(0.0), result)\n    result = cond2.if_else(x, result)\n\n    # Compute the else part\n    else_part = x * (x + plus_three) / six\n    result = (~(cond1 | cond2)).if_else(else_part, result)\n\n    return result\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    return (x + 3).maximum(0).minimum(x) * x / 6\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    return x.max(-6).min(6)\n", "response_1": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    return (x + 6).min((x - 6).max(x))\n", "model_name": "deepseek-v2.5"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    ret = 0\n    if_then(x > 1)\n        ret = x\n    else_then\n        if_then(x < -1)\n            ret = x\n        else_then\n            if_then(x > 0)\n                ret = 1\n            else_then\n                if_then(x < 0)\n                    ret = -1\n                else_then\n                    ret = 0\n                end_if\n            end_if\n        end_if\n    end_if\n    return ret\n", "response_1": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    ret = sint(0)\n    if_then(x > 1)\n    ret = x\n    elif_then(x < -1)\n    ret = x\n    elif_then(x > 0)\n    ret = sint(1)\n    elif_then(x < 0)\n    ret = sint(-1)\n    else_then()\n    ret = sint(0)\n    end_if()\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "middle", "response_0": "fromCompiler import *\n\ndef main():\n    # Example inputs\n    a = sint(5)\n    b = sint(3)\n    c = sint(7)\n\n    # Call the middle function\n    result = middle(a, b, c)\n\n    # Output the result\n    print_ln(\"The middle value is: %s\", result.reveal())\n\nmain()\n", "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    # Compare and swap a and b if a >= b\n    cond1 = a >= b\n    a, b = cond1.if_else(b, a), cond1.if_else(a, b)\n    \n    # Compare and swap b and c if b >= c\n    cond2 = b >= c\n    b, c = cond2.if_else(c, b), cond2.if_else(b, c)\n    \n    # Compare and swap a and b if a >= b\n    cond3 = a >= b\n    a, b = cond3.if_else(b, a), cond3.if_else(a, b)\n    \n    return b\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicated_sin_or_cos", "response_0": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    if_then(ind)\n    result = sin(x)\n    else_then()\n    result = cos(x)\n    end_if()\n    return result\n", "response_1": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    if ind:\n        return sint.sin(x)\n    return sint.cos(x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    # Compute x-2\n    x_minus_2 = x - 2\n    \n    # Check if x-2 is no less than 0\n    condition = x_minus_2 >= 0\n    \n    # Use conditional assignment\n    result = condition * x_minus_2 + (1 - condition) * x\n    \n    return result\n", "response_1": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    condition = x - 2 >= 0\n    return cond(condition, x - 2, x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    return max(0, min(x, 6))\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    # Check if x is less than 0\n    less_than_zero = x < 0\n    # Check if x is greater than 6\n    greater_than_six = x > 6\n    \n    # Return 0 if x is less than 0\n    result = (less_than_zero * 0) + ((1 - less_than_zero) * x)\n    # Clamp the result to 6 if x is greater than 6\n    result = (greater_than_six * 6) + ((1 - greater_than_six) * result)\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "exp_slide", "response_0": "from Compiler import types\nfrom Compiler import mpc_math\n\ndef exp_slide(x: types.sint) -> types.sint:\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    # Check if x is nonnegative\n    is_nonnegative = x >= 0\n    \n    # Compute e^x if x is nonnegative\n    exp_result = mpc_math.pow(mpc_math.e, x)\n    \n    # Compute x+1 if x is negative\n    add_result = x + 1\n    \n    # Select the appropriate result based on the condition\n    return types.select(is_nonnegative, exp_result, add_result)\n", "response_1": "from Compiler import types\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    # Check if x is non-negative\n    cond = x >= 0\n    \n    # Compute e^x using exp2 (2^x) and then adjust\n    exp_val = types.exp2(x * types.log2(math.e))\n    \n    # Compute x + 1\n    plus_one = x + 1\n    \n    # Use if_then to return the appropriate value\n    return types.if_then(cond, exp_val, plus_one)\n", "model_name": "deepseek-v2.5"}
{"test_name": "pass_or_not", "response_0": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Assume score is a secret shared integer\n    score = sfix(score)\n\n    # Define the passing threshold\n    threshold = sfix(60)\n\n    # Determine if the score is greater than or equal to the threshold\n    passed = score >= threshold\n\n    # If the student did not pass, set the score to 59\n    not_passed_score = sfix(59)\n    score = score.if_else(score, not_passed_score)\n\n    # Convert the boolean result to an integer (True -> 1, False -> 0)\n    passed = passed.if_else(sfix(1), sfix(0))\n\n    return score, passed\n", "response_1": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Initialize the score and passed variables\n    score = sint(score)\n    passed = sint(0)  # Initialize to False\n\n    # Check if the score is greater than or equal to 60\n    @if_(score >= 60)\n    def _():\n        passed = sint(1)  # Set to True\n    @else_\n    def _():\n        score = sint(59)  # Set score to 59\n    end_if\n\n    # Return the score and passed status\n    return score, passed\n\n# Example usage in MP-SPDZ\n# score_input = cint(70)  # Example input\n# result_score, result_passed = pass_or_not(score_input)\n# print_ln(\"Score: %s, Passed: %s\", result_score.reveal(), result_passed.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return cint(0)\n        else:\n            return cint(1)\n    discriminant = b**2 - 4 * a * c\n    if discriminant > 0:\n        return cint(2)\n    elif discriminant == 0:\n        return cint(1)\n    else:\n        return cint(0)\n", "response_1": "from Compiler import mpc_math\n\ndef how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    discriminant = mpc_math.pow2(b) - 4 * a * c\n    if discriminant > 0:\n        return 2\n    elif discriminant == 0:\n        return 1\n    else:\n        return 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "elu", "response_0": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    if x > 0:\n        return x\n    else:\n        return exp(x) - 1\n", "response_1": "def elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    import math\n    if_else(x > 0, lambda: x, lambda: math.exp(x) - 1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function in MP-SPDZ\n    \"\"\"\n    return x * (x > 0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return x * (x > 0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    return x.if_else(x, x * alpha)\n", "response_1": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    # Use the sbit datatype for conditional operations\n    condition = x > 0\n    # Use the conditional_select function to select between x and x*alpha\n    return condition.if_else(x, x * alpha)\n", "model_name": "deepseek-v2.5"}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    # Assuming a and b are secret integers (sint)\n    if_cond = sint_geq(a, b)  # Compare a and b\n    result = if_cond * a + (1 - if_cond) * b  # Select the maximum value\n    return result\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # MP-SPDZ uses `>` and `<` for comparison\n    cond1 = x > 1\n    cond2 = x < -1\n\n    # MP-SPDZ uses `if_else` for conditional statements\n    result = if_else(cond1, x - 1, if_else(cond2, -x - 1, 0))\n\n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function in MP-SPDZ:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Use secure comparison and conditional operations\n    cond1 = x > 1\n    cond2 = x < -1\n    \n    # Compute the results based on conditions\n    result1 = x - 1\n    result2 = -x - 1\n    result3 = 0\n    \n    # Use secure conditional selection\n    result = cond1.if_else(result1, cond2.if_else(result2, result3))\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "rounded_kinetic_energy", "response_0": "from compiler import *\nfrom floatingpoint import *\n\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    k = m * v**2 / 2\n    k_int = sfix.floor(k)\n    return k_int + sfix(1) if (k - k_int) >= sfix(0.5) else k_int\n", "response_1": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    k = m * v**2 / 2\n    k_int = sint(k).floor()\n    return k_int + (k - k_int) >= 0.5\n", "model_name": "deepseek-v2.5"}
{"test_name": "danger_test", "response_0": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return origin - damage <= 10\n\n# MP-SPDZ program\n\nfrom Compiler import mpc_math\n\ndef main():\n    # Inputs\n    origin = sint()\n    damage = sint()\n    input(origin)\n    input(damage)\n\n    # Compute the remaining health\n    remaining_health = origin - damage\n\n    # Check if the situation is dangerous\n    dangerous = remaining_health <= 10\n\n    # Output the result\n    output(dangerous)\n\nmain()\n", "response_1": "from Compiler import types\n\ndef danger_test(origin: types.sint, damage: types.sint) -> types.sint:\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    dangerous = health_left <= 10\n    return dangerous\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    # Convert the indicator to a bit\n    ind_bit = ind.bit_decompose(1)[0]\n    \n    # Compute the sum and the product\n    sum_result = x + y\n    product_result = x * y\n    \n    # Use the indicator bit to select the result\n    result = sum_result * ind_bit + product_result * (1 - ind_bit)\n    \n    return result\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    return if_else(ind, x + y, x * y)\n", "model_name": "deepseek-v2.5"}
{"test_name": "median", "response_0": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr) == 0:\n        print_ln(\"The length of the array is 0!\")\n        return -1  # Return an error code\n\n    # Sort the array (assuming a sorting function is available)\n    sorted_arr = sort(arr)\n\n    ret = 0\n    if len(sorted_arr) % 2 == 1: \n        ret = sorted_arr[len(sorted_arr) // 2]\n    else:\n        ret = (sorted_arr[len(sorted_arr) // 2] + sorted_arr[len(sorted_arr) // 2 - 1]) / 2\n    return ret\n", "response_1": "def median(arr):\n    \"\"\"\n    Return the median of the secret-shared array. \n    Check first whether the array is empty\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        # In MP-SPDZ, we cannot raise an exception, so we return a special value\n        return -1\n\n    # Securely sort the array\n    sorted_arr = secure_sort(arr)\n\n    ret = sfix(0)\n    if n % 2 == 1:\n        ret = sorted_arr[n // 2]\n    else:\n        ret = (sorted_arr[n // 2] + sorted_arr[n // 2 - 1]) / 2\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "add_upto_10", "response_0": "from Compiler import mpc_math\n\ndef add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    clipped_sum = mpc_math.min(sum_ab, 10)\n    return clipped_sum\n", "response_1": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    result = smax(sum_ab, 10)\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    # Base fare\n    base_fare = sfix(5)\n    \n    # Calculate the fare based on the miles\n    fare = sfix(0)\n    \n    # First 5 miles\n    if_condition_1 = m <= sfix(5)\n    fare = if_condition_1.if_else(base_fare, fare)\n    \n    # Miles between 5 and 10\n    if_condition_2 = (sfix(5) < m) * (m <= sfix(10))\n    fare = if_condition_2.if_else(base_fare + sfix(1.2) * (m - sfix(5)), fare)\n    \n    # Miles beyond 10\n    if_condition_3 = m > sfix(10)\n    fare = if_condition_3.if_else(sfix(11) + sfix(1.5) * (m - sfix(10)), fare)\n    \n    return fare\n", "response_1": "#include \"math.h\"\n\ndef taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    if_then(m <= 5,\n        return_value = 5\n    )\n    elif_then(5 <= m <= 10,\n        return_value = 5 + 1.2 * (m - 5)\n    )\n    else:\n        return_value = 11 + 1.5 * (m - 10)\n    return return_value\n", "model_name": "deepseek-v2.5"}
{"test_name": "round", "response_0": "from math import floor\n\ndef round_mpspdz(x):\n    \"\"\"\n    Round x to the nearest integer in MP-SPDZ.\n    \"\"\"\n    x_int = floor(x)\n    return x_int + (x - x_int >= 0.5)\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = sfix.floor(x)\n    return x_int if (x - x_int) < sfix(0.5) else x_int + 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    if_statement = regint()\n    gpa = sfix()\n\n    if_statement = score >= 90\n    gpa = if_statement * 4.0 + (1 - if_statement) * gpa\n\n    if_statement = score >= 85\n    gpa = if_statement * 3.6 + (1 - if_statement) * gpa\n\n    if_statement = score >= 80\n    gpa = if_statement * 3.3 + (1 - if_statement) * gpa\n\n    if_statement = score >= 75\n    gpa = if_statement * 3.0 + (1 - if_statement) * gpa\n\n    if_statement = score >= 70\n    gpa = if_statement * 2.6 + (1 - if_statement) * gpa\n\n    if_statement = score < 70\n    gpa = if_statement * 2.3 + (1 - if_statement) * gpa\n\n    return gpa\n", "response_1": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    if score >= 90:\n        return 4.0\n    elif score >= 85:\n        return 3.6\n    elif score >= 80:\n        return 3.3\n    elif score >= 75:\n        return 3.0\n    elif score >= 70:\n        return 2.6\n    else:\n        return 2.3\n", "model_name": "deepseek-v2.5"}
{"test_name": "sign", "response_0": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    neg_one = sint(-1)\n    \n    is_zero = x == zero\n    is_positive = x > zero\n    is_negative = x < zero\n    \n    return is_zero.if_else(zero, is_positive.if_else(one, neg_one))\n", "response_1": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sfix(0)\n    one = sfix(1)\n    neg_one = sfix(-1)\n\n    is_zero = x == zero\n    is_positive = x > zero\n\n    result = sfix(0)\n    result = result.if_else(one, neg_one, is_positive)\n    result = result.if_else(zero, result, is_zero)\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    # Compare a and b securely\n    cmp = a <= b\n    # Use the comparison result to choose the sum or difference\n    result = cmp.if_else(a + b, a - b)\n    return result\n", "response_1": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    if_condition = a <= b\n    result = if_condition.if_else(a + b, a - b)\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "CNOT", "response_0": "from Compiler import mpc_math\n\ndef CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ.\n    \"\"\"\n    # control_bit and flip_bit are secret-shared bits\n    # sbit is used for the not operation\n    # if_else is used for conditional operations\n    return control_bit.if_else(~flip_bit, flip_bit)\n", "response_1": "from Compiler import mpc_math\n\ndef CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ.\n    \"\"\"\n    # In MP-SPDZ, we use the `if_else` function to conditionally apply operations.\n    return mpc_math.if_else(control_bit, not flip_bit, flip_bit)\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Check if y is negative\n    is_negative = y < 0\n    \n    # Compute y+1\n    y_plus_1 = y + 1\n    \n    # Use a conditional select to return y+1 if y is negative, otherwise return y\n    return sfix.if_else(is_negative, y_plus_1, y)\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Secure comparison to check if y is less than 0\n    is_negative = y < 0\n    \n    # Conditional addition based on the comparison result\n    result = y + is_negative\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_a_parallelogram", "response_0": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices,\n    return whether the four vertices can form a parallelogram.\n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n    \n    return (a[0] + b[0] == c[0] + d[0] and a[1] + b[1] == c[1] + d[1]) or \\\n           (a[0] + c[0] == b[0] + d[0] and a[1] + c[1] == b[1] + d[1]) or \\\n           (a[0] + d[0] == b[0] + c[0] and a[1] + d[1] == b[1] + c[1])\n", "response_1": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    if_statement = (same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d))\n    if if_statement.reveal():\n        return False\n    \n    condition1 = (a[0] + b[0] == c[0] + d[0]) & (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) & (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) & (a[1] + d[1] == b[1] + c[1])\n    \n    return (condition1 | condition2 | condition3).reveal()\n", "model_name": "deepseek-v2.5"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    if_comp = a <= b\n    return if_comp * a + (1 - if_comp) * b\n", "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sint(0)\n\n    def legal(a, b):\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    counter = counter + (legal(x + 1, y + 2) == 1)\n    counter = counter + (legal(x - 1, y + 2) == 1)\n    counter = counter + (legal(x + 1, y - 2) == 1)\n    counter = counter + (legal(x - 1, y - 2) == 1)\n    counter = counter + (legal(x + 2, y + 1) == 1)\n    counter = counter + (legal(x - 2, y + 1) == 1)\n    counter = counter + (legal(x + 2, y - 1) == 1)\n    counter = counter + (legal(x - 2, y - 1) == 1)\n\n    return counter\n", "response_1": "def choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    int counter = 0;\n\n    def legal(a, b):\n        return (a >= 0 and a <= 7 and b >= 0 and b <= 7);\n\n    if (legal(x + 1, y + 2)):\n        counter += 1;\n    if (legal(x - 1, y + 2)):\n        counter += 1;\n    if (legal(x + 1, y - 2)):\n        counter += 1;\n    if (legal(x - 1, y - 2)):\n        counter += 1;\n    if (legal(x + 2, y + 1)):\n        counter += 1;\n    if (legal(x - 2, y + 1)):\n        counter += 1;\n    if (legal(x + 2, y - 1)):\n        counter += 1;\n    if (legal(x - 2, y - 1)):\n        counter += 1;\n\n    return counter;\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    max_val = smax(sum_ab, diff_ab)\n    return max_val\n", "response_1": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    if_condition = sum_ab > diff_ab\n    return if_condition.if_else(sum_ab, diff_ab)\n", "model_name": "deepseek-v2.5"}
