{"test_name": "next_integer", "response_0": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return t.floor_plain() + 1\n", "response_1": "from Compiler import mpc_math\n\ndef next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return mpc_math.floor(t) + 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "father_and_son", "response_0": "fromCompiler import *\n\ndef father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    # Calculate the difference between father's age and twice the son's age\n    difference = father_age - (son_age * 2)\n    \n    # Return the absolute value of the difference\n    return abs(difference)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Input values (these would be secret-shared in a real MP-SPDZ program)\n    father_age = sfix(40)  # Example: father's age\n    son_age = sfix(15)     # Example: son's age\n    \n    # Compute the result\n    result = father_and_son(father_age, son_age)\n    \n    # Output the result\n    print_ln(\"The age of the father will be twice the age of the son in %s years.\", result.reveal())\n", "response_1": "fromCompiler import *\n\ndef father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    # Calculate the difference between father's age and twice the son's age\n    age_difference = father_age - (son_age * 2)\n    \n    # Return the absolute value of the difference\n    return abs(age_difference)\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Input values (these would be secret-shared in a real MP-SPDZ program)\n    father_age = sint(35)  # Example value for father's age\n    son_age = sint(10)      # Example value for son's age\n\n    # Compute the result\n    result = father_and_son(father_age, son_age)\n\n    # Output the result (in a real MP-SPDZ program, this would be done securely)\n    print_ln(\"The age difference is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "triangle_area", "response_0": "fromCompiler import *\n\n# Assuming side and height are secret-shared values\nside = sfix.get_input_from(0)\nheight = sfix.get_input_from(1)\n\n# Compute the area of the triangle\narea = triangle_area(side, height)\n\n# Output the result\nprint_ln(\"The area of the triangle is: %s\", area.reveal())\n", "response_1": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the size of the triangle.\n    \"\"\"\n    return side * height / 2\n\n# Example usage in MP-SPDZ\nside = sfix.get_input_from(0)  # Assuming side is input from party 0\nheight = sfix.get_input_from(1)  # Assuming height is input from party 1\narea = triangle_area(side, height)\nprint_ln(\"The area of the triangle is: %s\", area.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "sin_plus_cos", "response_0": "def sin_plus_cos(a):\n    \"\"\"\n    Return sin(a)+cos(a)\n    \"\"\"\n    return sin(a) + cos(a)\n", "response_1": "def sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    return sin(a) + cos(a)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sigmoid", "response_0": "def sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    from Compiler import mpc_math\n    return 1 / (1 + mpc_math.exp(-x))\n", "response_1": "def sigmoid(x):\n    \"\"\"\n    sigmoid function in MP-SPDZ\n    \"\"\"\n    return 1 / (1 + pow(e, -x))\n", "model_name": "deepseek-v2.5"}
{"test_name": "self_exponent", "response_0": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return k ** k\n", "response_1": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return k ** k\n", "model_name": "deepseek-v2.5"}
{"test_name": "silu", "response_0": "def silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    return x / (1 + (~(x)))\n", "response_1": "from Compiler import mpc_math\n\ndef silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    return x / (1 + mpc_math.exp(-x))\n", "model_name": "deepseek-v2.5"}
{"test_name": "Gaussian_bracket", "response_0": "from Compiler import mpc_math\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = mpc_math.floor(x)\n    return x - x_int\n", "response_1": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = int(x)  # Convert x to an integer\n    return x - x_int\n", "model_name": "deepseek-v2.5"}
{"test_name": "asin_and_square", "response_0": "def asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome. \n    \"\"\"\n    return (regint.asin(x)) ** 2\n", "response_1": "def asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    import mpc_math\n    return mpc_math.pow(mpc_math.asin(x), 2)\n", "model_name": "deepseek-v2.5"}
{"test_name": "cylinder_surface", "response_0": "def cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    # Define pi as a constant\n    pi = 3.141592653589793\n    \n    # Calculate the surface area of the cylinder\n    surface_area = 2 * pi * r**2 + 2 * pi * r * h\n    \n    return surface_area\n", "response_1": "from Compiler import floatingpoint\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area. \n    \"\"\"\n    pi = floatingpoint.PI()\n    return 2 * pi * r**2 + 2 * pi * r * h\n", "model_name": "deepseek-v2.5"}
{"test_name": "radian_to_degree", "response_0": "from Compiler import types\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    pi = types.cfix(program.pi)\n    return r / pi * types.cint(180)\n", "response_1": "from Compiler import types\n\ndef radian_to_degree(r: types.sint) -> types.sint:\n    \"\"\"\n    Converting radian to degree in MP-SPDZ\n    \"\"\"\n    pi = 3.141592653589793  # Approximate value of pi\n    return r * 180 / pi\n", "model_name": "deepseek-v2.5"}
{"test_name": "square_root", "response_0": "def square_root(a):\n    \"\"\"\n    Securely compute the square root of the input 'a'.\n    \"\"\"\n    return a.sqrt()\n", "response_1": "def square_root(a):\n    \"\"\"\n    return the square root of the input. \n    \"\"\"\n    return a.sqrt()\n", "model_name": "deepseek-v2.5"}
{"test_name": "cosine_theorem", "response_0": "from Compiler import mpc_math\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    # Compute the cosine of the angle\n    cos_rad = mpc_math.cos(rad)\n    \n    # Compute the square of the third edge using the cosine theorem\n    third_edge_sq = a**2 + b**2 - 2 * a * b * cos_rad\n    \n    # Compute the square root to get the length of the third edge\n    third_edge = mpc_math.sqrt(third_edge_sq)\n    \n    return third_edge\n", "response_1": "def cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    return sqrt(a**2 + b**2 - 2 * a * b * cos(rad))\n", "model_name": "deepseek-v2.5"}
{"test_name": "lights_states", "response_0": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return 2 ** num\n", "response_1": "# lights_states.mpc\n\n# Define the function to compute the total number of possible states for a given number of lights\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    return (1 << num)  # Equivalent to 2^num in MP-SPDZ\n\n# Example usage\nif __name__ == \"__main__\":\n    num = sint(5)  # Example input: 5 lights\n    result = lights_states(num)\n    print_ln(\"The total number of possible states is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "degree_to_radian", "response_0": "from Compiler import floatingpoint\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    pi = floatingpoint.PI()\n    return d * (pi / 180)\n", "response_1": "from Compiler import types\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    pi = types.cint(3141592653589793)  # Approximation of pi * 10^15\n    return (d * pi) / (180 * 10**15)\n", "model_name": "deepseek-v2.5"}
{"test_name": "Fah_to_Cel", "response_0": "fromCompiler import *\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - 32) / 1.8\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Input temperature in Fahrenheit\n    F = sfix.get_input_from(0)\n    \n    # Convert to Celsius\n    C = Fah_to_Cel(F)\n    \n    # Output the result\n    print_ln(\"The temperature in Celsius is: %s\", C.reveal())\n", "response_1": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - 32) / 1.8\n\n# Example usage in MP-SPDZ\n# Assuming F is a fixed-point or integer input\nF = sfix(100)  # Example input in Fahrenheit\nC = Fah_to_Cel(F)\nprint_ln(\"Celsius temperature: %s\", C.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "elliptic_area", "response_0": "fromCompiler import *\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area. \n    \"\"\"\n    # Use MP-SPDZ's constant for pi\n    pi = sfloat.pi()\n    return pi * a * b\n", "response_1": "from Compiler import types\n\ndef elliptic_area(a: types.sint, b: types.sint):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    # Define pi with sufficient precision for fixed-point arithmetic\n    pi = types.sint(3.141592653589793)\n    \n    # Calculate the area using secure multiplication\n    area = pi * a * b\n    \n    return area\n", "model_name": "deepseek-v2.5"}
{"test_name": "floor", "response_0": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    return z.floor_fix()\n", "response_1": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Assuming z is of type sfix (secret fixed-point number)\n    return z.floor()\n", "model_name": "deepseek-v2.5"}
{"test_name": "log_and_cube", "response_0": "from program import *\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    # Compute log base 2 of x\n    log_result = log2(x)\n    \n    # Compute the cube of the log result\n    cube_result = pow(log_result, 3)\n    \n    return cube_result\n", "response_1": "from Compiler import mpc_math\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    log_result = mpc_math.log2(x)\n    cube_result = log_result ** 3\n    return cube_result\n", "model_name": "deepseek-v2.5"}
{"test_name": "floor_and_square", "response_0": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    # Assuming z is of type sint\n    return z**2\n", "response_1": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    # Assuming z is a secret integer (sint)\n    # Floor operation: convert to clear integer and back to secret integer\n    floor_z = sint(int(z.reveal()))\n    \n    # Square the result\n    return floor_z * floor_z\n", "model_name": "deepseek-v2.5"}
{"test_name": "meters_to_feet", "response_0": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * 3.2808\n\n# MP-SPDZ program\n\nfrom Compiler import mpc_math\n\ndef meters_to_feet_mpspdz(m):\n    # Convert the length in meters to the length in feet\n    return mpc_math.mult(m, 3.2808)\n\n# Example usage in MP-SPDZ\n# m = sint(10)  # Example input, replace with actual input\n# result = meters_to_feet_mpspdz(m)\n# print_ln(\"Result: %s\", result.reveal())\n", "response_1": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * sfloat(3.2808)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sphere_area", "response_0": "from Compiler import types\n\ndef sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    # Define pi as a constant\n    pi = types.cfloat(3.141592653589793)\n    \n    # Compute the area of the sphere\n    area = 4 * pi * r**2\n    \n    return area\n", "response_1": "from Compiler import types\nfrom Compiler import library\n\ndef sphere_area(r: types.sint) -> types.sint:\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    # Define pi using MP-SPDZ's fixed-point arithmetic\n    pi = library.load_int_to_secret(3141592653589793)\n    \n    # Square the radius\n    r_squared = r * r\n    \n    # Multiply by 4 * pi\n    area = 4 * pi * r_squared\n    \n    # Scale back to the original precision\n    area = area / library.load_int_to_secret(10**15)\n    \n    return area\n", "model_name": "deepseek-v2.5"}
{"test_name": "coarse_abs", "response_0": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    # Compute the absolute value of x\n    abs_x = abs(x)\n    \n    # Round the absolute value to zero (integer truncation)\n    return sint.get_raw_input_from(0, abs_x)\n", "response_1": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = abs(x)\n    return cint(abs_x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_chickens", "response_0": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - (legs - heads * 2) / 2\n\n# Example usage in MP-SPDZ\nheads = sfix.Array(1)\nlegs = sfix.Array(1)\n\n# Assume heads and legs are secret-shared values\nheads[0] = sfix(40)  # Example value for heads\nlegs[0] = sfix(100)  # Example value for legs\n\n# Compute the number of chickens\nchickens = how_many_chickens(heads[0], legs[0])\n\n# Output the result\nprint_ln(\"Number of chickens: %s\", chickens.reveal())\n", "response_1": "# Assuming heads and legs are of type sint\nheads = sint(10)\nlegs = sint(32)\n\nchickens = how_many_chickens(heads, legs)\nprint_ln(\"Number of chickens: %s\", chickens.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "interest_calculator", "response_0": "from Compiler import mpc_math\n\ndef interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get. \n    \"\"\"\n    # Calculate (1 + ratio)^months\n    one_plus_ratio = 1 + ratio\n    power_result = mpc_math.pow(one_plus_ratio, months)\n    \n    # Calculate (power_result - 1) * capital\n    interest = (power_result - 1) * capital\n    \n    return interest\n", "response_1": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get. \n    \"\"\"\n    # Assuming capital, ratio, and months are secret integers or floating-point numbers\n    # In MP-SPDZ, we use sint for secret integers and sfloat for secret floating-point numbers\n    \n    # Calculate (1 + ratio)^months\n    growth_factor = sfloat.pow(sfloat(1) + ratio, months)\n    \n    # Calculate the interest\n    interest = (growth_factor - sfloat(1)) * capital\n    \n    return interest\n", "model_name": "deepseek-v2.5"}
{"test_name": "circle_area", "response_0": "from Compiler import types\n\ndef circle_area(r: types.sint) -> types.sint:\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    import math\n    pi = types.sint(math.pi)\n    return pi * r * r\n\n# Example usage:\n# r = types.sint(5)\n# area = circle_area(r)\n# print_ln(\"Area: %s\", area.reveal())\n", "response_1": "from Compiler import types\n\ndef circle_area(r: types.sfix) -> types.sfix:\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = types.sfix(3.141592653589793)  # Approximate value of pi\n    return pi * r * r\n", "model_name": "deepseek-v2.5"}
{"test_name": "cube_and_square_root", "response_0": "def cube_and_square_root(x: sfix):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    return sqrt(pow(x, 3))\n", "response_1": "def cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    # Compute the cube of x\n    cube = x ** 3\n    # Compute the square root of the cube\n    result = sqrt(cube)\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = sfloat.floor(x)\n    return sfloat.if_else((x - x_int) < 0.5, x_int, x_int + 1)\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = x.floor()\n    return x_int + (x - x_int >= sf.Fraction(1, 2)).if_else(1, 0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "cryptic_adjustment", "response_0": "from compiler.types import sfix\nfrom compiler.library import sqrt\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor wants to adjust the pessimistic score of his students' mid-term exam.\n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    # Ensure origin is a secret fixed-point number\n    origin = sfix(origin)\n    \n    # Apply the adjustment formula\n    adjusted_score = 10 * sqrt(10 * sqrt(origin))\n    \n    return adjusted_score\n", "response_1": "from Compiler import types\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor want to adjust the pessimistic score of his students mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    # Ensure the input is of the correct type\n    origin = types.sint(origin)\n    \n    # Perform the computation\n    intermediate = types.sqrt(origin)\n    intermediate = 10 * intermediate\n    intermediate = types.sqrt(intermediate)\n    result = 10 * intermediate\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "specific_pow", "response_0": "from Compiler import floatingpoint\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    # Define the scaling factor (e.g., 20 bits for precision)\n    k = 20\n\n    # Convert x to a fixed-point number\n    x_fp = floatingpoint.FixedPt(x, k)\n\n    # Compute x^2.5 using fixed-point arithmetic\n    x_sq = x_fp * x_fp\n    x_sqrt = floatingpoint.sqrt(x_fp)\n    x_pow = x_sq * x_sqrt\n\n    # Convert the result back to an integer (if needed)\n    return x_pow.v\n", "response_1": "from Compiler import mpc_math\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5).\n    \"\"\"\n    # Compute x^2\n    x_squared = x * x\n    \n    # Compute x^(0.5) using secure square root\n    x_sqrt = mpc_math.sqrt(x)\n    \n    # Compute x^(2.5) as x^2 * x^(0.5)\n    result = x_squared * x_sqrt\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "soft_plus", "response_0": "def soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    return log(1 + exp(x))\n", "response_1": "def soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    return log(1 + exp(x))\n", "model_name": "deepseek-v2.5"}
{"test_name": "ball_volume", "response_0": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    # MP-SPDZ uses mpc_math.pi for the constant pi\n    from mpc_math import pi\n    return pi * r**3 * 4 / 3\n\n# Example usage:\n# r = sfix(5)  # Example input, sfix is a fixed-point secret shared number\n# volume = ball_volume(r)\n# print_ln(\"Volume: %s\", volume.reveal())\n", "response_1": "fromCompiler import *\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    return math.pi * r**3 * 4 / 3\n", "model_name": "deepseek-v2.5"}
{"test_name": "Heron", "response_0": "from math import sqrt\n\ndef Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    area = sqrt(p * (p - a) * (p - b) * (p - c))\n    return area\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Input values can be secure integers or floats depending on the context\n    a = sint(10)  # Example secure integer input\n    b = sint(12)\n    c = sint(14)\n    \n    # Compute the area using Heron's formula\n    area = Heron(a, b, c)\n    \n    # Output the result\n    print_ln(\"The area of the triangle is: %s\", area.reveal())\n", "response_1": "def Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    a = sfix(a)\n    b = sfix(b)\n    c = sfix(c)\n    p = (a + b + c) / 2\n    return sqrt(p * (p - a) * (p - b) * (p - c))\n", "model_name": "deepseek-v2.5"}
{"test_name": "next_perfect_square", "response_0": "from Compiler import types\n\ndef next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    # Assuming x is a clear (public) integer\n    x = types.cint(x)\n    \n    # Compute the square root of x\n    sqrt_x = types.sqrt(x)\n    \n    # Floor the square root and add 1\n    next_sqrt = types.floor(sqrt_x) + 1\n    \n    # Compute the next perfect square\n    next_square = next_sqrt * next_sqrt\n    \n    return next_square\n", "response_1": "def next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    sqrt_x = sfloat.sqrt(x)\n    floor_sqrt_x = sfloat.floor(sqrt_x)\n    next_sqrt = floor_sqrt_x + 1\n    return next_sqrt * next_sqrt\n", "model_name": "deepseek-v2.5"}
{"test_name": "pi_to_the_x", "response_0": "# MP-SPDZ program: pi_to_the_x.mpc\n\n# Import the necessary modules\nfrom Compiler import floatingpoint\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x using fixed-point arithmetic.\n    \"\"\"\n    # Define the fixed-point precision\n    k = 20  # Number of bits for fractional part\n    f = 2**k\n\n    # Approximate the value of pi in fixed-point\n    pi_fixed = floatingpoint.FixedPt(3.141592653589793, k, f)\n\n    # Compute pi^x using fixed-point arithmetic\n    result_fixed = floatingpoint.pow(pi_fixed, x)\n\n    # Return the result as a fixed-point number\n    return result_fixed\n\n# Example usage (this part should be in a separate Python script or interactive session)\n# x = floatingpoint.FixedPt(2, k, f)  # Example input: x = 2\n# result = pi_to_the_x(x)\n# print_ln(\"pi^x = %s\", result.reveal())\n", "response_1": "from Compiler import types\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    # Define pi with a high precision\n    pi = types.cint(3.14159265358979323846)\n    \n    # Compute pi^x using MP-SPDZ's pow function\n    result = types.pow(pi, x)\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "spring_rocket", "response_0": "def spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = sfix(9.8)\n    return sqrt(2 * m * g * height / k)\n", "response_1": "from math import sqrt\n\ndef spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = 9.8\n    return sqrt(2 * m * g * height / k)\n\n# Example usage in MP-SPDZ\n# height, m, k should be provided as inputs to the program\n# result = spring_rocket(height, m, k)\n# print_ln(\"The minimum length the spring should be compressed is: %s\", result)\n", "model_name": "deepseek-v2.5"}
{"test_name": "cone_volume", "response_0": "from Compiler import types\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    # Define the constant pi\n    pi = types.cint(3141592653589793)  # Approximation of pi * 10^15\n    pi = pi * types.cint(1) / types.cint(10**15)\n\n    # Compute the volume of the cone\n    volume = pi * r * r * h / types.cint(3)\n    return volume\n\n# Example usage in an MP-SPDZ program\nr = types.sint(5)  # Example radius\nh = types.sint(10)  # Example height\nvolume = cone_volume(r, h)\nprint_ln(\"The volume of the cone is: %s\", volume.reveal())\n", "response_1": "def cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = regint(3141592653589793)  # Approximation of pi * 10^15\n    volume = (pi * r * r * h) / (3 * 10**15)\n    return volume\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_rabbits", "response_0": "from Compiler import mpc_math\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem using secure integers.\n    \"\"\"\n    # Ensure that heads and legs are secure integers\n    heads = mpc_math.int_fix(heads)\n    legs = mpc_math.int_fix(legs)\n\n    # Compute the number of rabbits\n    rabbits = (legs - heads * 2) // 2\n    return rabbits\n", "response_1": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2).floor_div(2)\n", "model_name": "deepseek-v2.5"}
