{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler import types\n\n# Define the range and number of points\nstart = 0\nend = 99\nnum = 10\n\n# Calculate the step size\nstep = (end - start) / (num - 1)\n\n# Generate the linspace array\na = [start + i * step for i in range(num)]\n\n# Convert the list to an MP-SPDZ array if needed\na_mpc = types.Array(num, types.sint)\nfor i in range(num):\n    a_mpc[i] = types.sint(a[i])\n", "response_1": "from Compiler import mpc_math\n\n# Define the start, end, and number of points\nstart = sfix(0)\nend = sfix(99)\nnum = 10\n\n# Calculate the step size\nstep = (end - start) / (num - 1)\n\n# Initialize the array\na = [sfix(0) for _ in range(num)]\n\n# Fill the array with values from start to end\nfor i in range(num):\n    a[i] = start + i * step\n\n# Now 'a' contains the values from start to end with 'num' points\n", "model_name": "deepseek-v2.5"}
{"test_name": "more_positive", "response_0": "fromCompiler import *\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    signs = Array(len(arr), sint)\n    for i in range(len(arr)):\n        signs[i] = arr[i] > 0\n    \n    count = sint()\n    for sign in signs:\n        count += sign\n    \n    return count > 0\n", "response_1": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    count = sint(0)  # Initialize count as a secret integer\n    for x in arr:\n        count += (x > 0)  # Increment count if the element is positive\n    return count > 0  # Return whether count is positive\n", "model_name": "deepseek-v2.5"}
{"test_name": "select", "response_0": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    import mpc_math  # Import MP-SPDZ math functions\n\n    # Assuming ind, a, and b are lists of sfix (secret fixed-point) values\n    result = []\n    for i in range(len(ind)):\n        result.append(mpc_math.if_else(ind[i], a[i], b[i]))\n    return result\n", "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    return [ai if indi else bi for ai, bi, indi in zip(a, b, ind)]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return max(y, 0)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return (y + abs(y)) / 2\n", "model_name": "deepseek-v2.5"}
{"test_name": "cost_matrix", "response_0": "fromCompiler import *\n\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    # Assuming profit_matrix is a 2D array of sint or sfix\n    matrix_shape = profit_matrix.sizes()  # Get the shape of the matrix\n    max_value = profit_matrix.max()  # Compute the maximum value in the matrix\n    \n    # Create an offset matrix with the same shape as profit_matrix\n    offset_matrix = [max_value] * (matrix_shape[0] * matrix_shape[1])\n    \n    # Convert offset_matrix to a 2D array\n    offset_matrix = sint.Matrix(matrix_shape[0], matrix_shape[1], offset_matrix)\n    \n    # Compute the cost matrix\n    cost_matrix = offset_matrix - profit_matrix\n    \n    return cost_matrix\n", "response_1": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix in MP-SPDZ.\n    \"\"\"\n    # Find the maximum value in the profit matrix\n    max_profit = profit_matrix.max()\n    \n    # Create an offset matrix with the same shape as profit_matrix\n    offset_matrix = sfix.Array(profit_matrix.sizes)\n    offset_matrix.assign_all(max_profit)\n    \n    # Compute the cost matrix\n    cost_matrix = offset_matrix - profit_matrix\n    \n    return cost_matrix\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_zeros", "response_0": "n = 10\na = sfix.Array(n)\nfor i in range(n):\n    a[i] = sfix(0)\n", "response_1": "n = 10\na = [sint(0) for _ in range(n)]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler import types\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array of type sint (secret integer)\n    array = ndarray[row_index]\n    return array\n\n# Example usage in MP-SPDZ context\n# ndarray = types.Matrix(rows, cols, types.sint)  # Define a 2-D array\n# row_index = types.sint(index)  # Define the row index\n# result = array_dimensional_indexing(ndarray, row_index)\n", "response_1": "# MP-SPDZ program to index i-th row from a 2-D array\n\n# Define the function to index the i-th row from a 2-D array\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array of sfix or sint elements\n    # row_index is an integer (sfix or sint)\n    \n    # Get the number of columns in the 2-D array\n    num_cols = len(ndarray[0])\n    \n    # Initialize an empty list to store the row elements\n    row_elements = [None] * num_cols\n    \n    # Extract the i-th row elements\n    for col_index in range(num_cols):\n        row_elements[col_index] = ndarray[row_index][col_index]\n    \n    return row_elements\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    return [sint() for _ in range(n)]\n", "response_1": "def zeros(n):\n    return [0] * n\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_slicing_stride", "response_0": "def array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays.\n    Collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    # Get the length of the arrays\n    lenA = len(ndarrayA)\n    lenB = len(ndarrayB)\n    \n    # Collect even index elements from the first array\n    viewA = []\n    for i in range(0, lenA, 2):\n        viewA.append(ndarrayA[i])\n    \n    # Collect odd index elements from the second array\n    viewB = []\n    for i in range(1, lenB, 2):\n        viewB.append(ndarrayB[i])\n    \n    # Concatenate the two lists\n    array = viewA + viewB\n    \n    # Convert the list to an MP-SPDZ array (if needed)\n    # Note: MP-SPDZ does not have a direct equivalent of np.concatenate, so we use list concatenation.\n    return array\n", "response_1": "def array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. \n    Collect all the even index elements from the first array and \n    collect all the odd index elements from the second array.\n    \"\"\"\n    # Get the length of the arrays\n    lenA = len(ndarrayA)\n    lenB = len(ndarrayB)\n    \n    # Collect even index elements from the first array\n    viewA = [ndarrayA[i] for i in range(0, lenA, 2)]\n    \n    # Collect odd index elements from the second array\n    viewB = [ndarrayB[i] for i in range(1, lenB, 2)]\n    \n    # Concatenate the two lists\n    array = viewA + viewB\n    \n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "QR_decomposition", "response_0": "def QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix in MP-SPDZ.\n    \"\"\"\n    from Compiler import mpc_math\n\n    # Assuming mat is a list of lists representing a matrix\n    n = len(mat)\n    m = len(mat[0]) if n > 0 else 0\n\n    # Initialize Q and R matrices\n    Q = [[mpc_math.zero_matrix() for _ in range(m)] for _ in range(n)]\n    R = [[mpc_math.zero_matrix() for _ in range(m)] for _ in range(n)]\n\n    # Perform Gram-Schmidt process to compute Q and R\n    for j in range(m):\n        # v is the j-th column of the input matrix\n        v = [mat[i][j] for i in range(n)]\n\n        for i in range(j):\n            R[i][j] = mpc_math.dot_product([Q[k][i] for k in range(n)], v)\n            v = [v[k] - R[i][j] * Q[k][i] for k in range(n)]\n\n        R[j][j] = mpc_math.norm(v)\n        for k in range(n):\n            Q[k][j] = v[k] / R[j][j]\n\n    return Q\n", "response_1": "def QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    from Compiler import mpc_math\n    from Compiler import matrix\n\n    # Perform QR decomposition using MP-SPDZ's matrix operations\n    q, _ = mpc_math.qr_decomposition(mat)\n    return q\n", "model_name": "deepseek-v2.5"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    min_diff = array[0] - value\n    min_diff = abs(min_diff)\n    idx = 0\n\n    for i in range(1, len(array)):\n        diff = array[i] - value\n        diff = abs(diff)\n        comparison = diff < min_diff\n        min_diff = comparison * diff + (1 - comparison) * min_diff\n        idx = comparison * i + (1 - comparison) * idx\n\n    return idx\n", "response_1": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    min_diff = array[0] - value\n    min_index = 0\n\n    for i in range(1, len(array)):\n        diff = array[i] - value\n        min_diff, min_index = (diff, i) if diff < min_diff else (min_diff, min_index)\n\n    return min_index\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_simple_row", "response_0": "from Compiler import mpc_math\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are already defined as MP-SPDZ arrays\n    # Concatenate the arrays along axis 0\n    concatenated_array = ndarrayA.concat(ndarrayB)\n    return concatenated_array\n", "response_1": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are lists of lists of sint or sfix\n    rowsA = len(ndarrayA)\n    colsA = len(ndarrayA[0]) if rowsA > 0 else 0\n    rowsB = len(ndarrayB)\n    colsB = len(ndarrayB[0]) if rowsB > 0 else 0\n\n    # Check if the number of columns in both arrays is the same\n    if colsA != colsB:\n        raise ValueError(\"Number of columns in both arrays must be the same\")\n\n    # Initialize the result array\n    result = []\n\n    # Copy elements from ndarrayA\n    for row in ndarrayA:\n        result.append(row)\n\n    # Copy elements from ndarrayB\n    for row in ndarrayB:\n        result.append(row)\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    array = [x for x in ndarray]\n    return array\n", "response_1": "def array_copy(ndarray):\n    array = Array(len(ndarray), sint)\n    array.assign(ndarray)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_pooling", "response_0": "def max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    \"\"\"\n    batch_size = len(x)\n    height = len(x[0])\n    width = len(x[0][0])\n    out_height = height // stride\n    out_width = width // stride\n    out = sfix.Matrix(batch_size, out_height, out_width)\n    \n    for b in range(batch_size):\n        for i in range(0, height, stride):\n            for j in range(0, width, stride):\n                # Initialize the max value with the first element of the window\n                max_val = x[b][i][j]\n                for k in range(stride):\n                    for l in range(stride):\n                        max_val = max(max_val, x[b][i + k][j + l])\n                out[b][i // stride][j // stride] = max_val\n    return out\n", "response_1": "from Compiler import mpc_math\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    \"\"\"\n    batch_size, height, width = x.shape\n    out_height = height // stride\n    out_width = width // stride\n    \n    # Initialize the output array\n    out = sfix.Matrix((batch_size, out_height, out_width))\n    \n    for b in range(batch_size):\n        for i in range(0, height, stride):\n            for j in range(0, width, stride):\n                # Extract the sub-array\n                sub_array = x[b, i:i+stride, j:j+stride]\n                # Compute the max value in the sub-array\n                out[b, i // stride, j // stride] = mpc_math.max(sub_array)\n    \n    return out\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_reshape", "response_0": "from Compiler import mpc_math\nfrom Compiler import types\n\n# Define the array dimensions\nrows = 3\ncols = 5\n\n# Create a 2D array with values from 0 to 14\na = types.Matrix(rows, cols, mpc_math.seq(0, 14))\n\n# Reshape the array to a 3x5 matrix\na = a.reshape(rows, cols)\n", "response_1": "from Compiler import types\n\n# Define a 2D array with 3 rows and 5 columns\na = types.Matrix(3, 5, types.sint)\n\n# Initialize the matrix with values from 0 to 14\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = types.sint(i * 5 + j)\n\n# Print the matrix (for debugging purposes)\nprint_ln('Matrix a:')\nfor i in range(3):\n    print_ln(' '.join(str(a[i][j].reveal()) for j in range(5)))\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_simple_column", "response_0": "def array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type sarray\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n    \n    # Initialize the result array\n    result = sarray(rows, colsA + colsB)\n    \n    # Copy elements from ndarrayA\n    for i in range(rows):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from ndarrayB\n    for i in range(rows):\n        for j in range(colsB):\n            result[i][colsA + j] = ndarrayB[i][j]\n    \n    return result\n", "response_1": "def array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Get the dimensions of the input arrays\n    rows_A, cols_A = ndarrayA.sizes[0], ndarrayA.sizes[1]\n    rows_B, cols_B = ndarrayB.sizes[0], ndarrayB.sizes[1]\n\n    # Ensure that the number of rows in both arrays is the same\n    if rows_A != rows_B:\n        raise ValueError(\"Both arrays must have the same number of rows\")\n\n    # Create a new array to hold the concatenated result\n    result_cols = cols_A + cols_B\n    result = sfix.Matrix(rows_A, result_cols)\n\n    # Copy elements from ndarrayA to the result array\n    for i in range(rows_A):\n        for j in range(cols_A):\n            result[i][j] = ndarrayA[i][j]\n\n    # Copy elements from ndarrayB to the result array\n    for i in range(rows_A):\n        for j in range(cols_B):\n            result[i][cols_A + j] = ndarrayB[i][j]\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a list of lists representing a 2D array\n    num_rows = len(ndarray)\n    column = [ndarray[i][column_index] for i in range(num_rows)]\n    return column\n", "response_1": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array in MP-SPDZ\n    array = ndarray[:, column_index]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    n = len(array)\n    diag = [array[i][i] for i in range(n)]\n    return diag\n", "response_1": "def diag(array):\n    # Assuming 'array' is a 2D array of secure integers or floats\n    n = len(array)\n    diagonal = [array[i][i] for i in range(n)]\n    return diagonal\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_special", "response_0": "fromCompiler import *\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    Collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type sfix (or sint if integers are used)\n    # and have the same number of rows\n\n    # Collect even columns from ndarrayA\n    viewA = [ndarrayA[i][::2] for i in range(len(ndarrayA))]\n\n    # Collect odd columns from ndarrayB\n    viewB = [ndarrayB[i][1:][::2] for i in range(len(ndarrayB))]\n\n    # Concatenate viewA and viewB along axis 1\n    array = [viewA[i] + viewB[i] for i in range(len(viewA))]\n\n    return array\n", "response_1": "from Compiler import types\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type types.Matrix\n    # Get the dimensions of the arrays\n    rows, colsA = ndarrayA.sizes\n    _, colsB = ndarrayB.sizes\n\n    # Collect all the even columns from the first array\n    even_cols_A = [ndarrayA[i][j] for i in range(rows) for j in range(0, colsA, 2)]\n    even_cols_A = types.Matrix(rows, len(even_cols_A) // rows, even_cols_A)\n\n    # Collect all the odd columns from the second array\n    odd_cols_B = [ndarrayB[i][j] for i in range(rows) for j in range(1, colsB, 2)]\n    odd_cols_B = types.Matrix(rows, len(odd_cols_B) // rows, odd_cols_B)\n\n    # Concatenate the even columns from A and the odd columns from B along axis 1\n    result = types.Matrix(rows, even_cols_A.sizes[1] + odd_cols_B.sizes[1])\n    for i in range(rows):\n        for j in range(even_cols_A.sizes[1]):\n            result[i][j] = even_cols_A[i][j]\n        for j in range(odd_cols_B.sizes[1]):\n            result[i][even_cols_A.sizes[1] + j] = odd_cols_B[i][j]\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_arange", "response_0": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-d array by manually generating the range.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Determine the number of elements in the array\n    num_elements = (stop - start + step - 1) // step\n\n    # Initialize an array of the appropriate size\n    array = Array(num_elements, sint)\n\n    # Fill the array with values from start to stop with the given step\n    for i in range(num_elements):\n        array[i] = start + i * step\n\n    return array\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-d array similar to numpy.arange in MP-SPDZ.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Determine the number of elements in the array\n    length = (stop - start + step - 1) // step\n\n    # Initialize an array of the determined length\n    array = sint(length)\n\n    # Fill the array with values from start to stop with the given step\n    for i in range(length):\n        array[i] = start + i * step\n\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_eye_2", "response_0": "from Compiler import mpc_math\n\n# Define the dimensions of the array\nm = 3\nn = 5\n\n# Initialize a matrix with zeros\na = [[0] * n for _ in range(m)]\n\n# Set the diagonal elements to 1\nfor i in range(min(m, n)):\n    a[i][i] = 1\n\n# Print the matrix (for debugging purposes)\nfor row in a:\n    print_ln(\"%s\", row)\n", "response_1": "from Compiler import types\n\nm = 3\nn = 5\n\n# Create a 2-dimensional array filled with zeros\na = types.Matrix(m, n, types.sint)\n\n# Set the diagonal elements to 1\nfor i in range(min(m, n)):\n    a[i][i] = 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "third_smallest", "response_0": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Sort the array securely\n    sorted_arr = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        sorted_arr[i] = arr[i]\n    sorted_arr.sort()\n    \n    # Return the third smallest element\n    return sorted_arr[2]\n", "response_1": "fromCompiler import *\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    sorted_arr = sorted(arr)\n    return sorted_arr[2]\n\ndef main():\n    # Example usage\n    arr = Array(5, sint)\n    arr.input_from(0)  # Input the array elements from player 0\n    result = third_smallest(arr)\n    print_ln(\"The third smallest element is: %s\", result.reveal())\n\nif __name__ == \"__main__\":\n    main()\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "from Compiler import mpc_math\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array in MP-SPDZ\n    # row_index is a secure integer or public integer\n    array = ndarray[row_index]\n    return array\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_from_intrinsic_arange", "response_0": "from Compiler import mpc_math\n\nn = 10\na = [mpc_math.sint(i) for i in range(n)]\n", "response_1": "n = 10\na = sfix.Array(n)\n\nfor i in range(n):\n    a[i] = i\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array in MP-SPDZ\n    array = ndarray[row_index]\n    return array\n", "response_1": "from Compiler import mpc_math\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index, :]\n    return array\n\n# Example usage\n# Assuming ndarray is a 2-D sarray and row_index is an sint\n# ndarray = sarray([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n# row_index = sint(1)\n# result = array_dimensional_indexing(ndarray, row_index)\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler import types\n\n# Create a list of clear integers\na_l = [0, 10, 20, 30, 40]\n\n# Convert the list to an array of secret integers\na = types.Array(5, types.sint)\na.assign(a_l)\n", "response_1": "from Compiler import types\n\n# Define the length of the array\nlength = 5\n\n# Create a list with the desired values\na_l = [0, 10, 20, 30, 40]\n\n# Convert the list to a fixed-size array in MP-SPDZ\na = types.Array(length, types. sint)\nfor i in range(length):\n    a[i] = a_l[i]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_reshape", "response_0": "def array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape an array.\n    \"\"\"\n    array = ndarray.reshape(m, n)\n    return array\n", "response_1": "def array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape an array.\n    \"\"\"\n    # Assuming ndarray is already an MP-SPDZ array\n    reshaped_array = sfix.Matrix(m, n)\n    for i in range(m):\n        for j in range(n):\n            reshaped_array[i][j] = ndarray[i * n + j]\n    return reshaped_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ones", "response_0": "fromCompiler import Array\n\nn = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = sint(1)\n", "response_1": "n = 10\na = sint.Array(n)\na.assign(1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "set_one_to_zero", "response_0": "from Compiler import types\n\ndef main():\n    # Assuming y is a list of sint\n    y = [types.sint(1), types.sint(0), types.sint(1), types.sint(2)]\n    result = set_one_to_zero(y)\n    # Output the result\n    for i in range(len(result)):\n        print_ln(\"%s\", result[i].reveal())\n\nif __name__ == \"__main__\":\n    main()\n", "response_1": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    # Create a mask where elements equal to 1 are True\n    mask = y == 1\n    # Use the mask to set the corresponding elements to 0\n    y = y * (1 - mask)\n    return y\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_eye", "response_0": "fromCompiler import Array, sint\n\n# Define the size of the square matrix\nn = 10\n\n# Initialize a 2-dimensional array with zeros\na = Array(n, Array(n, sint))\n\n# Set the diagonal elements to 1\nfor i in range(n):\n    a[i][i] = sint(1)\n", "response_1": "n = 10\na = [[regint(1 if i == j else 0) for j in range(n)] for i in range(n)]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_diag", "response_0": "fromCompiler import *\n\n# Define the diagonal elements\na_l = [sint(1), sint(3), sint(5), sint(2), sint(4), sint(6)]\n\n# Get the length of the list\nn = len(a_l)\n\n# Initialize an empty matrix of size n x n\na = [[sint(0) for _ in range(n)] for _ in range(n)]\n\n# Fill the diagonal with the elements from a_l\nfor i in range(n):\n    a[i][i] = a_l[i]\n\n# Now `a` is the diagonal matrix with the given elements on the diagonal\n", "response_1": "from Compiler import mpc_math\n\n# Define the list a_l\na_l = [1, 3, 5, 2, 4, 6]\n\n# Convert the list to an array of integers\na_l = [sint(x) for x in a_l]\n\n# Get the size of the list\nn = len(a_l)\n\n# Initialize an empty matrix of size n x n\na = [[sint(0) for _ in range(n)] for _ in range(n)]\n\n# Fill the diagonal of the matrix with the elements from a_l\nfor i in range(n):\n    a[i][i] = a_l[i]\n\n# Now 'a' is the diagonal matrix with elements from a_l\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_advanced_integer_indexing", "response_0": "from Compiler import mpc_math\n\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing a secret array from a secret integer array in MP-SPDZ.\n    \"\"\"\n    # Ensure indices is a secret array\n    if not isinstance(indices, sarray):\n        indices = sarray(indices)\n    \n    # Ensure array is a secret array\n    if not isinstance(array, sarray):\n        array = sarray(array)\n    \n    # Initialize a secret array to store the result\n    ret_array = sarray(len(indices), sint)\n    \n    # Perform the indexing operation\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    \n    return ret_array\n", "response_1": "def integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing a secure array from a secure integer array in MP-SPDZ.\n    \"\"\"\n    # Ensure indices is a secure array\n    indices = sfix.Array(indices)\n    \n    # Initialize the result array with the same length as indices\n    ret_array = sfix.Array(len(indices))\n    \n    # Perform the indexing operation\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    \n    return ret_array\n", "model_name": "deepseek-v2.5"}
