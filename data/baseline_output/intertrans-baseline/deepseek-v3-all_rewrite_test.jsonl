{"test_name": "move_to_end", "response_0": "from Compiler import types\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array without the element at the given index\n    new_array = arr[:index] + arr[index+1:]\n    \n    # Append the element at the given index to the new array\n    new_array.append(arr[index])\n    \n    return new_array\n", "response_1": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array excluding the element at the given index\n    new_array = Array(len(arr) - 1, arr[0].__class__)\n    for i in range(len(arr)):\n        if i < index:\n            new_array[i] = arr[i]\n        elif i > index:\n            new_array[i - 1] = arr[i]\n    \n    # Append the element at the given index to the new array\n    new_array.append(arr[index])\n    \n    return new_array\n", "model_name": "deepseek-v3"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    for i in range(2, n):\n        if arr[i] > arr[0] or arr[i] > arr[1]:\n            idx = 0 if arr[0] < arr[1] else 1\n            arr[idx] = arr[i]\n    return arr[0] if arr[0] < arr[1] else arr[1]\n", "response_1": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    for i in range(2, n):\n        if arr[i] > arr[0] or arr[i] > arr[1]:\n            idx = sint(0) if arr[0] < arr[1] else sint(1)\n            arr[idx] = arr[i]\n    return arr[0] if arr[0] < arr[1] else arr[1]\n", "model_name": "deepseek-v3"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    # Initialize the result as False (0)\n    ret = sbit(0)\n    \n    # Iterate over each element in the array\n    for element in arr:\n        # Use OR operation to check if any element is True (1)\n        ret = ret | element\n    \n    return ret\n", "response_1": "from Compiler import types\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    # Initialize the result as False\n    ret = types.sint(0)\n    \n    # Iterate over the array and compute the OR of all elements\n    for elem in arr:\n        ret = ret | elem\n    \n    # Return the result\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), sfix)  # Initialize an array of the same length as `arr`\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), sbool)  # Assuming the predicator returns a boolean value\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    # Initialize the summation variable\n    summation = sfix(0)\n    \n    # Iterate over the vectors and compute the element-wise product\n    for i in range(len(vec1)):\n        product = vec1[i] * vec2[i]\n        summation += product\n    \n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    # Initialize the summation variable\n    summation = sfix(0)\n    \n    # Iterate over the elements of the vectors\n    for i in range(len(vec1)):\n        # Multiply corresponding elements and add to the summation\n        summation += vec1[i] * vec2[i]\n    \n    # Return the computed inner product\n    return summation\n", "model_name": "deepseek-v3"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, sint)\n    for i in range(n):\n        shifted_array[i] = a[(i - 1) % n]\n    return shifted_array\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, sint)\n    for i in range(n):\n        shifted_array[i] = a[(i-1) % n]\n    return shifted_array\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), 'bool')\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sbool)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "count_rises_2", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    for i in range(n - 1):\n        flag = arr[i] < arr[i + 1]\n        count += flag\n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        flag = arr[i] < arr[i + 1]\n        count += flag\n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    for i in range(len(arr)):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    result = Array(len(arr), sint)\n    for i in range(len(arr)):\n        if i % 2 == 1:\n            result[i] = arr[i] + 1\n        else:\n            result[i] = arr[i] - 1\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    if a == 0:\n        return if_else(b == 0, 0, 1)\n    else:\n        discriminant = b * b - 4 * a * c\n        return if_else(discriminant > 0, 2, if_else(discriminant == 0, 1, 0))\n", "response_1": "program how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    if a == 0:\n        return if_else(b == 0, 0, 1)\n    else:\n        discriminant = b * b - 4 * a * c\n        return if_else(discriminant > 0, 2, if_else(discriminant == 0, 1, 0))\n", "model_name": "deepseek-v3"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    # Initialize a sum variable\n    summmation = sint(0)\n    \n    # Iterate over the array\n    for e in arr:\n        # Apply the predicator and add to the sum if the predicator returns True\n        summmation += predicator(e).if_else(sint(1), sint(0))\n    \n    # Return the sum\n    return summmation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize a secret-shared array to store the flags\n    flag = Array(len(arr), sint)\n    \n    # Compute the flags based on the predicator\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    \n    # Sum the flags to get the count of elements that satisfy the predicator\n    summmation = sum(flag)\n    \n    return summmation\n", "model_name": "deepseek-v3"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    ret = sfix.Array(len(arr1))\n    for i in range(len(arr1)):\n        ret[i] = arr1[i] * arr2[i]\n    return sum(ret)\n", "response_1": "from Compiler import types\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    # Ensure the arrays are of the same length\n    assert len(arr1) == len(arr2), \"Arrays must be of the same length\"\n    \n    # Initialize the sum to 0\n    total_sum = types.sint(0)\n    \n    # Iterate over the arrays and compute the sum of products\n    for x, y in zip(arr1, arr2):\n        product = x * y\n        total_sum += product\n    \n    return total_sum\n", "model_name": "deepseek-v3"}
{"test_name": "array_round", "response_0": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        # Add 0.5 and then truncate to get the nearest integer\n        ret[i] = (arr[i] + 0.5).trunc()\n    return ret\n", "response_1": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = sint.round(arr[i])\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = (arr[i] >= brr[i]).if_else(sint(1), sint(0))\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        ret[i] = sfix(arr[i] >= brr[i])\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sint)  # Create an array of secret integers with the same length as arr\n    for i in range(len(arr)):\n        ret[i] = if_else(arr[i] < 0, 1, 0)  # Use if_else to check if the element is negative\n    return ret\n", "response_1": "from util import if_else\nfrom Compiler.types import Array, sint\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = if_else(arr[i] < 0, sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    max_len = max(len_a, len_b)\n    \n    # Pad the shorter array with zeros\n    a_padded = Array(max_len, sint)\n    b_padded = Array(max_len, sint)\n    \n    for i in range(max_len):\n        if i < len_a:\n            a_padded[i] = a[i]\n        else:\n            a_padded[i] = sint(0)\n        \n        if i < len_b:\n            b_padded[i] = b[i]\n        else:\n            b_padded[i] = sint(0)\n    \n    # Subtract elementwise\n    result = Array(max_len, sint)\n    for i in range(max_len):\n        result[i] = a_padded[i] - b_padded[i]\n    \n    return result\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = abs(len_a - len_b)\n    \n    # Pad the shorter array with zeros\n    if len_a < len_b:\n        pad = b[-pad_length:]\n        pad = [-e for e in pad]\n        a += [sfix(0) for _ in range(pad_length)]\n    elif len_a > len_b:\n        pad = a[-pad_length:]\n        pad = [e for e in pad]\n        b += [sfix(0) for _ in range(pad_length)]\n    else:\n        pad = []\n    \n    # Perform elementwise subtraction\n    ret = [x - y for x, y in zip(a, b)] + pad\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    result = Array(len(arr), sfix)  # Create an array to store the results\n    for i in range(len(arr)):\n        result[i] = func(arr[i])  # Apply the function to each element\n    return result\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    # Initialize an empty array to store the results\n    result = Array(len(arr), sfix)\n    \n    # Iterate over the input array and apply the function to each element\n    for i in range(len(arr)):\n        result[i] = func(arr[i])\n    \n    # Return the processed array\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, sfix)\n    shifted_array[0] = a[-1]\n    for i in range(1, n):\n        shifted_array[i] = a[i-1]\n    return shifted_array\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, a[0].type)\n    shifted_array[0] = a[-1]\n    for i in range(1, n):\n        shifted_array[i] = a[i - 1]\n    return shifted_array\n", "model_name": "deepseek-v3"}
{"test_name": "compare_and_select", "response_0": "from Compiler.library import *\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = Array(len(a), sfix)\n    for i in range(len(a)):\n        ret_array[i] = if_else(a[i] > b[i], a[i], b[i])\n    return ret_array\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = Array(len(a), sfix)\n    for i in range(len(a)):\n        ret_array[i] = if_else(a[i] > b[i], a[i], b[i])\n    return ret_array\n", "model_name": "deepseek-v3"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    max_len = max(len_a, len_b)\n    \n    # Pad the shorter array with 0s\n    if len_a < max_len:\n        a = a + [sfix(0.0)] * (max_len - len_a)\n    if len_b < max_len:\n        b = b + [sfix(0.0)] * (max_len - len_b)\n    \n    # Perform element-wise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = max(len_a, len_b) - min(len_a, len_b)\n    \n    # Pad the shorter array with 0s\n    if len_a < len_b:\n        a = a + [sfix(0.0)] * pad_length\n    else:\n        b = b + [sfix(0.0)] * pad_length\n    \n    # Perform elementwise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    :param c: Array of secret-shared values\n    :return: Array of secret-shared values, which is the input array concatenated with itself\n    \"\"\"\n    return c + c\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c + c\n", "model_name": "deepseek-v3"}
{"test_name": "zeros", "response_0": "from Compiler.library import Array\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = Array(num, sint)\n    for i in range(num):\n        array[i] = sint(0)\n    return array\n", "response_1": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = Array(num, sgf2n)\n    for i in range(num):\n        array[i] = 0\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    # Define the helper function to clip a single value\n    def helper_func(x):\n        return sgf2n(upper_bound) if x >= sgf2n(upper_bound) else (x if x > sgf2n(lower_bound) else sgf2n(lower_bound))\n    \n    # Apply the helper function to each element in the array\n    clipped_arr = Array(len(arr), sgf2n)\n    for i in range(len(arr)):\n        clipped_arr[i] = helper_func(arr[i])\n    \n    return clipped_arr\n", "response_1": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    clipped_arr = Array(len(arr), sfix)\n    \n    for i in range(len(arr)):\n        x = arr[i]\n        # Check if x is greater than or equal to upper_bound\n        is_upper = x >= upper_bound\n        # Check if x is less than or equal to lower_bound\n        is_lower = x <= lower_bound\n        # Compute the clipped value\n        clipped_value = is_upper.if_else(upper_bound, is_lower.if_else(lower_bound, x))\n        clipped_arr[i] = clipped_value\n    \n    return clipped_arr\n", "model_name": "deepseek-v3"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize the sum to 0\n    summmation = 0\n    \n    # Iterate over each element in the array\n    for element in arr:\n        # Apply the predicator to the element\n        flag = predicator(element)\n        # Add the result to the sum\n        summmation += flag\n    \n    return summmation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Apply the predicator to each element in the array\n    flag = [predicator(x) for x in arr]\n    \n    # Sum the boolean values (True is treated as 1, False as 0)\n    summmation = sum(flag)\n    \n    return summmation\n", "model_name": "deepseek-v3"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array securely.\n    \"\"\"\n    n = len(arr)\n    count = sfix(0)\n    \n    for i in range(n):\n        ndarray = Array(n - i, sfix)\n        for j in range(n - i):\n            ndarray[j] = arr[i]\n        cmp = Array(n - i, sfix)\n        for j in range(n - i):\n            cmp[j] = arr[i + j]\n        for j in range(n - i):\n            count += ndarray[j] > cmp[j]\n    \n    return count\n", "response_1": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    # Create a new array to store the incremented values\n    result = Array(len(arr), sint)\n    \n    # Iterate over the array and increment each element by 1\n    for i in range(len(arr)):\n        result[i] = arr[i] + 1\n    \n    return result\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    result = Array(n, sint)\n    for i in range(n):\n        result[i] = arr[i] + 1\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)\n    n = len(arr)\n    for i in range(n - 1):\n        x = arr[i]\n        y = arr[i + 1]\n        count += if_else(x < y, 1, 0)\n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sfix(0)\n    n = len(arr)\n    for i in range(n - 1):\n        count += (arr[i] < arr[i + 1]).if_else(sfix(1), sfix(0))\n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "array_process_2", "response_0": "from Compiler.library import *\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    result = Array(len(arr), arr[0].reg_type)\n    @for_range(len(arr))\n    def _(i):\n        result[i] = func(arr[i])\n    return result\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    result = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        result[i] = func(arr[i])\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Square each element in the vector\n    vec_squared = [x * x for x in vec]\n    \n    # Sum the squared elements\n    sum_squared = sum(vec_squared)\n    \n    # Compute the square root using the `sqrt` function\n    norm = sqrt(sum_squared)\n    \n    return norm\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Square each element in the vector\n    squared_vec = [x * x for x in vec]\n    \n    # Sum the squared elements\n    sum_squared = sum(squared_vec)\n    \n    # Compute the square root of the sum\n    result = sqrt(sum_squared)\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Compute the minimum value in array a\n    amin = min(a)\n    \n    # Compute the maximum value in array b\n    bmax = max(b)\n    \n    # Check if amin is greater than or equal to bmax\n    result = amin >= bmax\n    \n    return result\n", "response_1": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Compute the minimum value in array a\n    amin = min(a)\n    \n    # Compute the maximum value in array b\n    bmax = max(b)\n    \n    # Check if amin >= bmax\n    return amin >= bmax\n", "model_name": "deepseek-v3"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    summation = sfix(0)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    summation = sfix(0)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "model_name": "deepseek-v3"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)  # Initialize an array of the same length as indices\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]  # Assign the corresponding element from a to ret\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), a.value_type)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = [sint(0)] * len(arr)\n    for i in range(len(arr)):\n        flag[i] = (arr[i] == 5) + (arr[i] == 7)\n    result = sint(0)\n    for i in range(len(flag)):\n        result = result + flag[i]\n    return result > 0\n", "response_1": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    # Initialize a flag to False\n    flag = sbit(False)\n    \n    # Iterate over the array\n    for item in arr:\n        # Check if the item is 5 or 7\n        is_5_or_7 = (item == 5) | (item == 7)\n        # Update the flag using logical OR\n        flag = flag | is_5_or_7\n    \n    # Return the final flag\n    return flag\n", "model_name": "deepseek-v3"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(arr) - 1, sint)\n    j = 0\n    for i in range(len(arr)):\n        if i != index:\n            ret[j] = arr[i]\n            j += 1\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array to store the result\n    ret = Array(len(arr) - 1, arr.value_type)\n    \n    # Copy elements before the index\n    for i in range(index):\n        ret[i] = arr[i]\n    \n    # Copy elements after the index\n    for i in range(index + 1, len(arr)):\n        ret[i - 1] = arr[i]\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = sum(arr)\n    length = len(arr)\n    ret = summmation / length\n    return ret\n", "response_1": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = sum(arr)\n    length = len(arr)\n    ret = summmation / length\n    return ret\n", "model_name": "deepseek-v3"}
