{"test_name": "indicate_positive", "response_0": "def indicate_positive(arr):\n    \"\"\"\n    For the given array, return an array with the same size. \n    If one element in the input array is positive, \n    then the corresponding element in the returned array will be 1, \n    otherwise the element in the returned array will be 0. \n    \"\"\"\n    ret = Array(len(arr), sint)  # Initialize an array of secret integers\n    for i in range(len(arr)):\n        ret[i] = arr[i] > 0  # MP-SPDZ automatically converts boolean to 1 or 0\n    return ret\n", "response_1": "def indicate_positive(arr):\n    \"\"\"\n    For the given array, return an array with the same size. \n    If one element in the input array is positive, \n    then the corresponding element in the returned array will be 1, \n    otherwise the element in the returned array will be 0. \n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = if_else(arr[i] > 0, 1, 0)\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_xor", "response_0": "def array_xor(a, b):\n    \"\"\"\n    Compute the elementwise XOR of the two input vectors.\n    \"\"\"\n    ret = Array(len(a), sint)\n    for i in range(len(ret)):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "response_1": "def array_xor(a, b):\n    \"\"\"\n    Compute the elementwise XOR of the two input vectors.\n    \"\"\"\n    ret = Array(len(a), sgf2n)\n    for i in range(len(ret)):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "interlaced_placement", "response_0": "def interlaced_placement(a, b):\n    \"\"\"\n    Interleave the elements in two sequences.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(a)\n    ret = Array(n * 2, sint)  # Initialize an array of size 2n with secret integers\n    @for_range(n * 2)\n    def _(i):\n        if_then(i % 2 == 1)\n        ret[i] = b[(i - 1) // 2]\n        else_then()\n        ret[i] = a[i // 2]\n        end_if()\n    return ret\n", "response_1": "def interlaced_placement(a, b):\n    \"\"\"\n    Interleave the elements in two sequences.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = Array(len(a) * 2, sfix)  # Initialize an array of the appropriate size\n    for i in range(len(a) * 2):\n        if i % 2:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_and", "response_0": "def array_and(a, b):\n    \"\"\"\n    Compute the elementwise AND of the two input vectors.\n    \"\"\"\n    ret = Array(len(a), sbit)\n    for i in range(len(a)):\n        ret[i] = a[i] & b[i]\n    return ret\n", "response_1": "def array_and(a, b):\n    \"\"\"\n    Compute the elementwise AND of the two input vectors.\n    \"\"\"\n    ret = Array(len(a), sgf2n)\n    for i in range(len(a)):\n        ret[i] = a[i] * b[i]  # In MP-SPDZ, AND is represented by multiplication\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array. \n    For each element in the input array, \n    the corresponding value in the returned array is set to be the value of the predicator. \n    \"\"\"\n    ret = Array(len(arr), sbool)\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array. \n    For each element in the input array, \n    the corresponding value in the returned array is set to be the value of the predicator. \n    \"\"\"\n    ret = Array(len(arr), sbool)\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler import types\n\ndef array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is greater than the bound. \n    \"\"\"\n    ret = types.Array(len(arr), types.sint)  # Create an array of secret integers\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound  # Compare each element with the bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is greater than the bound. \n    \"\"\"\n    ret = Array(len(arr), sbool)  # Initialize an array of sbool (secret boolean) with the same length as arr\n    @for_range(len(arr))  # Loop over the array\n    def _(i):\n        ret[i] = arr[i] > bound  # Compare each element with the bound and store the result in ret\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_no_greater_than_scalar", "response_0": "def array_no_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is no greater than the bound.\n    \"\"\"\n    # Initialize the result array with False values\n    ret = Array(len(arr), sint)\n    \n    # Iterate over the array and compare each element with the bound\n    for i in range(len(arr)):\n        ret[i] = arr[i] <= bound\n    \n    return ret\n", "response_1": "def array_no_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is no greater than the bound. \n    \"\"\"\n    ret = Array(len(arr), sbool)\n    for i in range(len(arr)):\n        ret[i] = arr[i] <= bound\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    \"\"\"\n    Reverse the input array and concatenate it to the original array.\n    \"\"\"\n    n = len(a)\n    b = Array(n, sfix)\n    for i in range(n):\n        b[i] = a[n-1-i]\n    return a + b\n", "response_1": "def reverse_and_concat(a):\n    \"\"\"\n    Reverse the input array and concatenate it to the original array.\n    \"\"\"\n    n = len(a)\n    b = Array(n, sint)  # Create an array to store the reversed elements\n    for i in range(n):\n        b[i] = a[n-1-i]  # Reverse the array\n    return a + b  # Concatenate the original array and the reversed array\n", "model_name": "deepseek-v3"}
{"test_name": "array_round", "response_0": "from util import if_else\nfrom Compiler.types import sint, Array\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    Assumes arr is an Array of sint representing fixed-point numbers.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    \n    for i in range(n):\n        # Assuming the fixed-point number is scaled by 1000\n        scaled_value = arr[i]\n        int_part = scaled_value // 1000\n        fractional_part = scaled_value % 1000\n        \n        # Determine if the fractional part is >= 500\n        rounded = if_else(fractional_part >= 500, int_part + 1, int_part)\n        ret[i] = rounded\n    \n    return ret\n", "response_1": "from Compiler.types import sint, sfloat\nfrom Compiler.library import print_ln\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    arr: Array of sfloat values.\n    Returns: Array of sint values.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    \n    for i in range(n):\n        int_part = arr[i].floor()  # Get the integer part of the floating-point number\n        fractional_part = arr[i] - int_part  # Get the fractional part\n        # If fractional part is greater than or equal to 0.5, round up\n        ret[i] = int_part + (fractional_part >= 0.5).if_else(1, 0)\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    ret = Array(len(arr), sint)  # Initialize an array of secret integers with the same length as arr\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] >= brr[i])  # Set ret[i] to 1 if arr[i] >= brr[i], otherwise 0\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    ret = Array(len(arr), sint)  # Initialize an array of secret integers with the same length as arr and brr\n    for i in range(len(arr)):\n        ret[i] = (arr[i] >= brr[i]).if_else(sint(1), sint(0))  # Compare arr[i] and brr[i], and set ret[i] accordingly\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "reverse", "response_0": "def reverse(arr):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sfix)\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "response_1": "from Compiler import types\n\ndef reverse(arr):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    length = arr.length\n    ret = types.Array(length, arr.value_type)\n    for i in range(length):\n        ret[i] = arr[length - 1 - i]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size. \n    If one element in the input array is negative, \n    then the corresponding element in the returned array will be 1, \n    otherwise the element in the returned array will be 0. \n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] < 0)\n    return ret\n", "response_1": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size. \n    If one element in the input array is negative, \n    then the corresponding element in the returned array will be 1, \n    otherwise the element in the returned array will be 0. \n    \"\"\"\n    ret = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        ret[i] = (arr[i] < 0).if_else(sfix(1), sfix(0))\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "max_sub_sequence", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import print_ln\n\ndef max_sub_sequence(arr):\n    \"\"\"\n    Use dynamic programming to find the sum of max continuous subsequence of the input array.\n    \"\"\"\n    n = len(arr)\n    partial_max = Array(n, sint)\n    suffix_max = Array(n, sint)\n    \n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    \n    for i in range(1, n):\n        suffix_max[i] = arr[i] + (suffix_max[i-1] if suffix_max[i-1] >= 0 else 0)\n        partial_max[i] = partial_max[i-1] if partial_max[i-1] >= suffix_max[i] else suffix_max[i]\n    \n    return partial_max[n-1]\n\n# Example usage:\n# arr = Array(5, sint)\n# arr[0], arr[1], arr[2], arr[3], arr[4] = sint(1), sint(-2), sint(3), sint(5), sint(-1)\n# result = max_sub_sequence(arr)\n# print_ln(\"The maximum subsequence sum is: %s\", result)\n", "response_1": "def max_sub_sequence(arr):\n    \"\"\"\n    Use dynamic programming to find the sum of max continuous subsequence of the input array.\n    \"\"\"\n    n = len(arr)\n    partial_max = Array(n, sint)\n    suffix_max = Array(n, sint)\n    \n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    \n    for i in range(1, n):\n        suffix_max[i] = if_else(suffix_max[i-1] >= 0, suffix_max[i-1] + arr[i], arr[i])\n        partial_max[i] = if_else(partial_max[i-1] >= suffix_max[i], partial_max[i-1], suffix_max[i])\n    \n    return partial_max[n-1]\n", "model_name": "deepseek-v3"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise, \n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = Array(len(a), sint)  # Initialize an array of secure integers\n    for i in range(len(a)):\n        # Use the mux function to select the larger value\n        ret_array[i] = mux(a[i] > b[i], a[i], b[i])\n    \n    return ret_array\n", "response_1": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two secret-shared arrays elementwise, \n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = Array(len(a), sint)\n    for i in range(len(a)):\n        ret_array[i] = sint.if_else(a[i] > b[i], a[i], b[i])\n    \n    return ret_array\n", "model_name": "deepseek-v3"}
{"test_name": "count_element_frequency", "response_0": "from Compiler import types\n\ndef count_element_frequency(l):\n    \"\"\"\n    Return an array with the same size of the original array, \n    each position of which records the number of occurrences of the element at the same position. \n    \"\"\"\n    ret = types.Array(len(l), types.sint)\n    ret.assign_all(0)\n    \n    for i in range(len(l)):\n        for j in range(len(l)):\n            if l[j].equal(l[i]):\n                ret[i] = ret[i] + 1\n                \n    return ret\n", "response_1": "program count_element_frequency(l):\n    # Initialize the return array with zeros\n    ret = Array(len(l), sint(0))\n    \n    # Iterate over each element in the list\n    for i in range(len(l)):\n        # Count the occurrences of the current element\n        for j in range(len(l)):\n            if l[j] == l[i]:\n                ret[i] = ret[i] + 1\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_or", "response_0": "def array_or(a, b):\n    \"\"\"\n    Compute the elementwise OR of the two input vectors.\n    \"\"\"\n    ret = Array(len(a), sgf2n)\n    for i in range(len(a)):\n        ret[i] = a[i] + b[i] + a[i] * b[i]\n    return ret\n", "response_1": "def array_or(a, b):\n    \"\"\"\n    Compute the elementwise OR of the two input vectors.\n    \"\"\"\n    ret = Array(len(a), sint)\n    for i in range(len(a)):\n        ret[i] = a[i] + b[i] - a[i] * b[i]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "stock_predicator", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import print_ln, for_range\n\ndef stock_predictor(days):\n    \"\"\"\n    Given the stock price in the next few days (at least 3 days).\n    Use dynamic programming to find the days,\n    such that buying on the earlier day and selling on the later day is the most profitable.\n    If all choices cause negative profits, return 0.\n    \"\"\"\n    n = len(days)\n    lowest = Array(n, sfix)\n    partial_max = Array(n, sfix)\n\n    lowest[0] = days[0]\n    partial_max[0] = sfix(0)\n\n    @for_range(1, n)\n    def _(i):\n        lowest[i] = sfix.min(lowest[i-1], days[i])\n        profit = days[i] - lowest[i-1]\n        partial_max[i] = sfix.max(partial_max[i-1], profit)\n\n    return partial_max[n-1]\n", "response_1": "# Assuming 'days' is a list of secret-shared integers representing stock prices\ndef stock_predicator(days):\n    # Initialize arrays for the lowest price and partial maximum profit\n    lowest = Array(len(days), sint)\n    partial_max = Array(len(days), sint)\n\n    # Set the initial values\n    lowest[0] = days[0]\n    partial_max[0] = 0\n\n    # Iterate through the days to compute the lowest price and partial maximum profit\n    for i in range(1, len(days)):\n        # Compute the lowest price up to day i\n        lowest[i] = if_else(lowest[i-1] <= days[i], lowest[i-1], days[i])\n        \n        # Compute the maximum profit up to day i\n        current_profit = days[i] - lowest[i-1]\n        partial_max[i] = if_else(partial_max[i-1] >= current_profit, partial_max[i-1], current_profit)\n\n    # Return the maximum profit found\n    return partial_max[len(days)-1]\n", "model_name": "deepseek-v3"}
{"test_name": "len5_inc_array", "response_0": "def len5_inc_array(init):\n    \"\"\"\n    Return an increase-by-one array with given initial element and length 5.\n    \"\"\"\n    ret = Array(5, sint)  # Create an array of 5 secret integers\n    @for_range(5)\n    def _(i):\n        ret[i] = init + i  # Assign init + i to each element\n    return ret\n", "response_1": "def len5_inc_array(init):\n    \"\"\"\n    Return an increase-by-one array with given initial element and length 5.\n    \"\"\"\n    ret = Array(5, sint)  # Define an array of size 5 with elements of type sint (secret integer)\n    for i in range(5):\n        ret[i] = init + i  # Assign the value init + i to the i-th element of the array\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "cut_first_five", "response_0": "def cut_first_five(arr):\n    \"\"\"\n    Return the array composed of the first 5 elements of the input array. \n    If the input array does not have 5 elements, pad with 0.\n    \"\"\"\n    ret = Array(5, sint(0))  # Initialize an array of 5 elements with 0\n    for i in range(5):\n        if i < len(arr):\n            ret[i] = arr[i]\n        else:\n            ret[i] = sint(0)  # Pad with 0 if the input array is shorter than 5\n    return ret\n", "response_1": "def cut_first_five(arr):\n    \"\"\"\n    Return the array composed of the first 5 elements of the input array. \n    If the input array does not have 5 elements, pad with 0.\n    \"\"\"\n    ret = Array(5, sfix)  # Initialize an array of size 5 with sfix type (secure fixed-point)\n    for i in range(5):\n        if i < len(arr):\n            ret[i] = arr[i]\n        else:\n            ret[i] = sfix(0)  # Pad with 0 if the input array is shorter than 5\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "max_pooling_1d", "response_0": "def max_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional max pooling on vec with step.\n    Ignoring the remaining elements in the vector.\n    \"\"\"\n    ret_length = len(vec) // step\n    ret = Array(ret_length, sint)\n    \n    for i in range(ret_length):\n        max_val = vec[i * step]\n        for j in range(step):\n            current_val = vec[i * step + j]\n            max_val = if_else(current_val > max_val, current_val, max_val)\n        ret[i] = max_val\n    \n    return ret\n", "response_1": "def max_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional max pooling on vec with step.\n    Ignoring the remaining elements in the vector.\n    \"\"\"\n    ret_length = len(vec) // step\n    ret = sint.Array(ret_length)\n    \n    for i in range(ret_length):\n        max_val = vec[i * step]\n        for j in range(step):\n            max_val = max(max_val, vec[i * step + j])\n        ret[i] = max_val\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater", "response_0": "def array_greater(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i]>brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    ret = Array(len(arr), sint)  # Initialize an array of secret integers\n    for i in range(len(arr)):\n        ret[i] = arr[i] > brr[i]  # MP-SPDZ directly supports comparison operations\n    return ret\n", "response_1": "def array_greater(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size. \n    For index i, if arr[i]>brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0. \n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    ret = Array(len(arr), sgf2n)  # Initialize an array of the same length as arr and brr\n    for i in range(len(arr)):\n        ret[i] = arr[i] > brr[i]  # Compare elements and store the result in ret[i]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "dumb_concat", "response_0": "def dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    length = len(arr) + len(brr)\n    ret = Array(length, sint)  # Initialize an array of 'sint' type with the calculated length\n\n    # Copy elements from the first array 'arr' to 'ret'\n    for i in range(len(arr)):\n        ret[i] = arr[i]\n\n    # Copy elements from the second array 'brr' to 'ret'\n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n\n    return ret\n", "response_1": "def dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    length = len(arr) + len(brr)\n    ret = Array(length, sint)\n    \n    for i in range(len(arr)):\n        ret[i] = arr[i]\n    \n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "indicator_if_else", "response_0": "from Compiler import types\n\ndef indicator_if_else(a, b, ind):\n    \"\"\"\n    Return an array c with the same length of a and b.\n    The element of c is set to be the corresponding element of a if the indicator is 1,\n    and is set to be the corresponding element of b if the indicator is 0.\n    \"\"\"\n    c = types.Array(len(ind), types.sint)\n    for i in range(len(ind)):\n        c[i] = a[i] * ind[i] + b[i] * (1 - ind[i])\n    return c\n", "response_1": "def indicator_if_else(a, b, ind):\n    \"\"\"\n    Return an array c with the same length of a and b.\n    The element of c is set to be the corresponding element of a if the indicator is 1,\n    and is set to be the corresponding element of b if the indicator is 0.\n    \"\"\"\n    c = Array(len(ind))\n    for i in range(len(ind)):\n        c[i] = if_else(ind[i], a[i], b[i])\n    return c\n", "model_name": "deepseek-v3"}
{"test_name": "elementwise_multiplication", "response_0": "def elementwise_multiplication(a, b):\n    \"\"\"\n    Compute the elementwise multiplication of the two input vectors.\n    \"\"\"\n    ret = Array(len(a), sint)  # Create an array of secret integers with the same length as a\n    @for_range(len(a))  # Loop over the length of the input vectors\n    def _(i):\n        ret[i] = a[i] * b[i]  # Perform elementwise multiplication\n    return ret\n", "response_1": "def elementwise_multiplication(a, b):\n    \"\"\"\n    Compute the elementwise multiplication of the two input vectors.\n    \"\"\"\n    ret = Array(len(a), sint)\n    for i in range(len(ret)):\n        ret[i] = a[i] * b[i]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices. \n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices. \n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "inc_array", "response_0": "def inc_array(num):\n    \"\"\"\n    Return an array with length num and elements 1 to num.\n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    arr = Array(num, sint)  # Create an array of size 'num' with secret integers\n    @for_range(num)\n    def _(i):\n        arr[i] = sint(i + 1)  # Assign i+1 to each element in the array\n    return arr\n", "response_1": "def inc_array(num):\n    \"\"\"\n    Return an array with length num and elements 1 to num.\n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    arr = Array(num, sint)  # Create an array of size num with secret integers\n    @for_range(num)\n    def _(i):\n        arr[i] = sint(i + 1)  # Assign i+1 to each element in the array\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "cut_last_five", "response_0": "def cut_last_five(arr):\n    \"\"\"\n    Return the array composed of the last 5 elements of the input array. \n    If the input array does not have 5 elements, pad with 0 (at the beginning).\n    \"\"\"\n    ret = Array(5, sint(0))  # Initialize an array of size 5 with zeros\n    n = len(arr)\n    for i in range(5):\n        if i < n:\n            ret[4 - i] = arr[n - 1 - i]\n        else:\n            ret[4 - i] = sint(0)\n    return ret\n", "response_1": "def cut_last_five(arr):\n    \"\"\"\n    Return the array composed of the last 5 elements of the input array.\n    If the input array does not have 5 elements, pad with 0 (at the beginning).\n    \"\"\"\n    ret = Array(5, sint(0))  # Initialize an array of 5 elements with 0\n    n = len(arr)\n    for i in range(5):\n        if i < n:\n            ret[4 - i] = arr[n - 1 - i]\n        else:\n            ret[4 - i] = sint(0)  # Pad with 0 if the input array is shorter than 5\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "average_pooling_1d", "response_0": "def average_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional average pooling on vec with step.\n    Ignoring the remaining elements in the vector.\n    \"\"\"\n    ret_length = len(vec) // step\n    ret = Array(ret_length, sfix)\n    \n    @for_range(ret_length)\n    def _(i):\n        avg = sfix(0)\n        @for_range(step)\n        def _(j):\n            avg = avg + vec[i * step + j] / step\n        ret[i] = avg\n    \n    return ret\n", "response_1": "def average_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional average pooling on vec with step. \n    Ignoring the remaining elements in the vector.\n    \"\"\"\n    ret_length = len(vec) // step\n    ret = Array(ret_length, sfix)  # Create an array of sfix type with ret_length elements\n    \n    for i in range(ret_length):\n        avg = sfix(0)\n        for j in range(step):\n            avg = avg + vec[i * step + j] / step\n        ret[i] = avg\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_relu", "response_0": "from Compiler.library import *\n\ndef array_relu(arr):\n    \"\"\"\n    Apply ReLU function elementwisely to the input array.\n    \"\"\"\n    ret = Array(len(arr), sfix)  # Create an array of the same length as arr with sfix type\n    @for_range(len(arr))\n    def _(i):\n        # Use the mux function to select between arr[i] and 0 based on the condition arr[i] >= 0\n        ret[i] = mux(arr[i] >= 0, arr[i], 0)\n    return ret\n", "response_1": "def array_relu(arr):\n    \"\"\"\n    Apply ReLU function elementwisely to the input array.\n    \"\"\"\n    ret = Array(len(arr), sfix)  # Initialize an array of the same length as input\n    @for_range(len(arr))  # Iterate over the array\n    def _(i):\n        ret[i] = arr[i].greater_equal(0).if_else(arr[i], 0)  # Apply ReLU\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "move_to_end", "response_0": "from Compiler.library import Array, for_range\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    temp = arr[index]\n    \n    @for_range(n - index - 1)\n    def _(i):\n        arr[index + i] = arr[index + i + 1]\n    \n    arr[n - 1] = temp\n    return arr\n", "response_1": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    temp = arr[index]\n    @for_range(len(arr) - index - 1)\n    def _(i):\n        arr[index + i] = arr[index + i + 1]\n    arr[len(arr) - 1] = temp\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "set_to_zero", "response_0": "def set_to_zero(arr, index):\n    \"\"\"\n    Set the element in the input array with given index to zero.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    # Create a zero value with the same type as the array elements\n    zero = sfix(0)\n    \n    # Assign zero to the specified index in the array\n    arr[index] = zero\n    \n    return arr\n", "response_1": "def set_to_zero(arr, index):\n    \"\"\"\n    Set the element in the input array with given index to zero.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = sfix(0)\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "last_partial_sum", "response_0": "def last_partial_sum(arr, n):\n    \"\"\"\n    Return the sum of the last n elements in the input array.\n    n is guaranteed to be legal.\n    \"\"\"\n    ret = 0\n    start = len(arr) - n\n    for i in range(start, len(arr)):\n        ret = ret + arr[i]\n    return ret\n", "response_1": "def last_partial_sum(arr, n):\n    \"\"\"\n    Return the sum of the last n elements in the input array.\n    n is guaranteed to be legal.\n    \"\"\"\n    ret = 0\n    for i in range(len(arr) - n, len(arr)):\n        ret = ret + arr[i]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "permute_by_indices", "response_0": "def permute_by_indices(a, indices):\n    \"\"\"\n    Permute the input array a by the indices. \n    The i'th element in the returned array will be a[indices[i]]. \n    The input indices are guaranteed to be a legal permutation. \n    \"\"\"\n    ret = Array(len(a), sint)  # Initialize an array of the same length as 'a' with secret integers\n    @for_range(len(a))  # Loop over the length of 'a'\n    def _(i):\n        ret[i] = a[indices[i]]  # Assign the permuted value to the result array\n    return ret\n", "response_1": "def permute_by_indices(a, indices):\n    \"\"\"\n    Permute the input array a by the indices.\n    The i'th element in the returned array will be a[indices[i]].\n    The input indices are guaranteed to be a legal permutation.\n    \"\"\"\n    ret = Array(len(a), sint)  # Initialize an array of the same length as a with secret integers\n    @for_range(len(a))\n    def _(i):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "get_rank", "response_0": "def get_rank(arr, index):\n    \"\"\"\n    Get the rank in the array of the element (how many elements are smaller than the element) with given index.\n    \"\"\"\n    rank = sint(0)  # Initialize rank as a secret integer\n    for item in arr:\n        rank += (item < arr[index])  # Increment rank if the condition is true\n    return rank\n", "response_1": "def get_rank(arr, index):\n    \"\"\"\n    Get the rank in the array of the element (how many elements are smaller than the element) with given index.\n    \"\"\"\n    rank = sint(0)\n    for i in range(len(arr)):\n        rank += (arr[i] < arr[index]).if_else(1, 0)\n    return rank\n", "model_name": "deepseek-v3"}
{"test_name": "interchange_by_indices", "response_0": "def interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange the two elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "response_1": "def interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange the two elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "increase_by", "response_0": "def increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] + k\n    return arr\n", "response_1": "def increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] + k\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "retrieve_by_index", "response_0": "def retrieve_by_index(arr, index):\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    return arr[index]\n", "response_1": "def retrieve_by_index(arr, index):\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    return arr[index]\n", "model_name": "deepseek-v3"}
{"test_name": "scale_by", "response_0": "def scale_by(arr, index, k):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n", "response_1": "def scale_by(arr, index, k):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "take_opposite_to", "response_0": "def take_opposite_to(arr, index):\n    \"\"\"\n    Take opposite to the element in the array with given index. \n    The input index is guaranteed to be legal. \n    \"\"\"\n    arr[index] = -arr[index]\n    return arr\n", "response_1": "def take_opposite_to(arr, index):\n    \"\"\"\n    Take opposite to the element in the array with given index. \n    The input index is guaranteed to be legal. \n    \"\"\"\n    arr[index] = -arr[index]\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "array_rank", "response_0": "def array_rank(l):\n    \"\"\"\n    Return an array with the same size of the original array, \n    each position of which records the number of elements smaller than the element at the same position. \n    \"\"\"\n    ret = Array(len(l), sint(0))  # Initialize an array of secret integers with zeros\n    for i in range(len(l)):\n        for j in range(len(l)):\n            cmp = l[j] < l[i]  # Compare elements\n            ret[i] = ret[i] + cmp.if_else(sint(1), sint(0))  # Increment if l[j] < l[i]\n    return ret\n", "response_1": "def array_rank(l):\n    \"\"\"\n    Return an array with the same size of the original array, \n    each position of which records the number of elements smaller than the element at the same position. \n    \"\"\"\n    n = len(l)\n    ret = Array(n, sint)  # Initialize an array of size n with secret integers\n    for i in range(n):\n        ret[i] = 0  # Initialize each element to 0\n        for j in range(n):\n            comp = l[j] < l[i]  # Comparison result (0 or 1)\n            ret[i] = ret[i] + comp  # Increment if l[j] < l[i]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array. \n    The input index is guaranteed to be legal. \n    \"\"\"\n    ret = Array(len(arr) - 1, sint)\n    @for_range(len(arr) - 1)\n    def _(i):\n        if_else(i < index, \n                lambda: ret[i] = arr[i], \n                lambda: ret[i] = arr[i + 1])\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(arr) - 1, sint)\n    @for_range(len(arr) - 1)\n    def _(i):\n        if_then_else(i < index, lambda: ret[i].update(arr[i]), lambda: ret[i].update(arr[i + 1]))\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "process_by_index", "response_0": "def process_by_index(arr, index, func):\n    \"\"\"\n    Process the element in the input array with given index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array to store the result\n    result = Array(len(arr), arr.value_type)\n    \n    # Iterate over the array and apply the function to the specified index\n    for i in range(len(arr)):\n        if i == index:\n            result[i] = func(arr[i])\n        else:\n            result[i] = arr[i]\n    \n    return result\n", "response_1": "def process_by_index(arr, index, func):\n    \"\"\"\n    Process the element in the input array with given index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = func(arr[index])\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "sum_by_indices", "response_0": "def sum_by_indices(arr, indices):\n    \"\"\"\n    Compute the sum of elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    sum = sfix(0)\n    for index in indices:\n        sum = sum + arr[index]\n    return sum\n", "response_1": "def sum_by_indices(arr, indices):\n    \"\"\"\n    Compute the sum of elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    sum = sfix(0)  # Initialize sum as a secure fixed-point number\n    for index in indices:\n        sum = sum + arr[index]\n    return sum\n", "model_name": "deepseek-v3"}
