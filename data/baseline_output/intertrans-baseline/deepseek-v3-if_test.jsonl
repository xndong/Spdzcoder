{"test_name": "sin_or_cos", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Assuming x is a sfix (secret fixed-point) type\n    # We need to implement or approximate sin and cos functions\n    # Here, we use a simple approximation for demonstration purposes\n\n    # Define sin and cos approximations (Taylor series or other methods)\n    def sin_approx(x):\n        return x - x**3 / 6 + x**5 / 120\n\n    def cos_approx(x):\n        return 1 - x**2 / 2 + x**4 / 24\n\n    # Check if x is nonnegative\n    is_nonnegative = x >= 0\n\n    # Use conditional selection to return sin(x) or cos(x)\n    result = if_else(is_nonnegative, sin_approx(x), cos_approx(x))\n\n    return result\n", "response_1": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    from math import sin, cos\n    from Compiler.types import sfix, sfloat\n    from Compiler.library import if_else\n\n    # Assuming x is of type sfix or sfloat\n    result = if_else(x >= 0, sin(x), cos(x))\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return if_else(input < 0, input, 0)\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return if_else(input < 0, input, 0)\n", "model_name": "deepseek-v3"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    diff = a - b\n    abs_diff = if_else(diff < 0, -diff, diff)\n    return abs_diff <= 1\n", "response_1": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    diff = a - b\n    abs_diff = sgn(diff) * diff\n    return abs_diff <= 1\n", "model_name": "deepseek-v3"}
{"test_name": "hardswish", "response_0": "def hardswish(x):\n    \"\"\"\n    Hardswish function in MP-SPDZ.\n    \"\"\"\n    # Define constants\n    neg_three = -3\n    pos_three = 3\n    six = 6\n\n    # Compute conditions\n    cond1 = x < neg_three\n    cond2 = x > pos_three\n\n    # Compute the result based on conditions\n    result = cond1.if_else(0, cond2.if_else(x, x * (x + pos_three) / six))\n\n    return result\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function in MP-SPDZ.\n    \"\"\"\n    # Define constants\n    three = sfix(3)\n    zero = sfix(0)\n    six = sfix(6)\n    \n    # Compute conditions\n    cond1 = x < -three\n    cond2 = x > three\n    \n    # Compute the result based on conditions\n    result = cond1.if_else(zero, cond2.if_else(x, x * (x + three) / six))\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    result = x\n    result = result.greater_than(6).if_else(6, result)\n    result = result.less_than(-6).if_else(-6, result)\n    return result\n", "response_1": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    result = x\n    result = result * (x <= 6) + 6 * (x > 6)\n    result = result * (x >= -6) + (-6) * (x < -6)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function implemented in MP-SPDZ.\n    \"\"\"\n    ret = sfix(0)\n    if x > sfix(1):\n        ret = x\n    elif x < sfix(-1):\n        ret = x\n    elif x > sfix(0):\n        ret = sfix(1)\n    elif x < sfix(0):\n        ret = sfix(-1)\n    else:\n        ret = sfix(0)\n    return ret\n", "response_1": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function.\n    \"\"\"\n    ret = sint(0)\n    if x > 1:\n        ret = x\n    elif x < -1:\n        ret = x\n    elif x > 0:\n        ret = sint(1)\n    elif x < 0:\n        ret = sint(-1)\n    else:\n        ret = sint(0)\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # Swap a and b if a >= b\n    temp = a\n    a = b\n    b = temp\n    \n    # Swap b and c if b >= c\n    temp = b\n    b = c\n    c = temp\n    \n    # Swap a and b if a >= b\n    temp = a\n    a = b\n    b = temp\n    \n    return b\n", "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # Compare and swap a and b if necessary\n    temp = a\n    a = (a >= b).if_else(b, a)\n    b = (a >= b).if_else(temp, b)\n    \n    # Compare and swap b and c if necessary\n    temp = b\n    b = (b >= c).if_else(c, b)\n    c = (b >= c).if_else(temp, c)\n    \n    # Compare and swap a and b again if necessary\n    temp = a\n    a = (a >= b).if_else(b, a)\n    b = (a >= b).if_else(temp, b)\n    \n    return b\n", "model_name": "deepseek-v3"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler.library import if_else\nfrom Compiler.types import cint\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Assuming x is a cint (secret integer) and ind is a boolean (secret or public)\n    # We need to compute sine and cosine using MP-SPDZ's available functions\n    # For simplicity, we assume that sine and cosine are computed using some approximation\n    # Here, we use placeholder functions for sine and cosine\n    \n    # Placeholder for sine and cosine functions\n    sin_x = x * x  # Replace with actual sine computation\n    cos_x = x + x  # Replace with actual cosine computation\n    \n    # Use if_else to choose between sine and cosine based on the indicator\n    result = if_else(ind, sin_x, cos_x)\n    \n    return result\n", "response_1": "from math import sin, cos\nfrom Compiler.library import if_else\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input.\n    \"\"\"\n    return if_else(ind, sin(x), cos(x))\n", "model_name": "deepseek-v3"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    result = x - 2\n    condition = result >= 0\n    return result * condition + x * (1 - condition)\n", "response_1": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    result = x - 2\n    condition = result >= 0\n    return result * condition + x * (1 - condition)\n", "model_name": "deepseek-v3"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    zero = sfix(0)\n    six = sfix(6)\n    \n    # Compute the conditions\n    cond1 = x < zero\n    cond2 = x > six\n    \n    # Use if_else to handle the conditions\n    result = if_else(cond1, zero, if_else(cond2, six, x))\n    \n    return result\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    zero = sfix(0)\n    six = sfix(6)\n    \n    # Compute the conditions\n    cond1 = x < zero\n    cond2 = x > six\n    \n    # Compute the result based on the conditions\n    result = cond1.if_else(zero, cond2.if_else(six, x))\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "exp_slide", "response_0": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    if x >= 0:\n        return exp(x)\n    else:\n        return x + 1\n", "response_1": "from math import exp\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    if x >= 0:\n        return exp(x)\n    else:\n        return x + 1\n", "model_name": "deepseek-v3"}
{"test_name": "pass_or_not", "response_0": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Determine if the score is greater than or equal to 60\n    passed = score >= 60\n    \n    # If passed, return the original score, else return 59\n    score = (passed * score) + ((1 - passed) * 59)\n    \n    return score, passed\n", "response_1": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Use a secure comparison to check if the score is greater than or equal to 60\n    passed = score >= 60\n    \n    # Use a secure if-else to assign the score value\n    score = if_else(passed, score, 59)\n    \n    return score, passed\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    # Check if a is zero\n    is_a_zero = (a == 0)\n    \n    # Check if b is zero\n    is_b_zero = (b == 0)\n    \n    # If a is zero, check if b is also zero\n    if is_a_zero:\n        if is_b_zero:\n            return 0\n        else:\n            return 1\n    \n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Check the value of the discriminant\n    is_discriminant_positive = (discriminant > 0)\n    is_discriminant_zero = (discriminant == 0)\n    \n    # Determine the number of roots based on the discriminant\n    if is_discriminant_positive:\n        return 2\n    elif is_discriminant_zero:\n        return 1\n    else:\n        return 0\n", "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    # Check if a is zero\n    is_a_zero = a == 0\n    \n    # If a is zero, check if b is zero\n    is_b_zero = b == 0\n    \n    # If a is zero and b is zero, return 0\n    if is_a_zero and is_b_zero:\n        return 0\n    # If a is zero but b is not, return 1\n    elif is_a_zero:\n        return 1\n    \n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # Determine the number of roots based on the discriminant\n    if discriminant > 0:\n        return 2\n    elif discriminant == 0:\n        return 1\n    else:\n        return 0\n", "model_name": "deepseek-v3"}
{"test_name": "elu", "response_0": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    if x > 0:\n        return x\n    else:\n        return exp(x) - 1\n", "response_1": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    from Compiler.library import if_else\n    from Compiler.types import sfix\n\n    # Define the constant e as a fixed-point number\n    e = sfix(math.e)\n\n    # Use if_else to handle the condition\n    return if_else(x > 0, x, e ** x - 1)\n", "model_name": "deepseek-v3"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function in MP-SPDZ\n    \"\"\"\n    return x * (x > 0)\n", "response_1": "from Compiler import types\n\ndef relu(x):\n    \"\"\"\n    ReLU function in MP-SPDZ\n    \"\"\"\n    return types.sint.if_else(x > 0, x, 0)\n", "model_name": "deepseek-v3"}
{"test_name": "leaky_relu", "response_0": "from Compiler.library import sbitint, sbitintvec, if_else\n\ndef leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    x: secret-shared integer\n    alpha: secret-shared integer\n    Returns: secret-shared integer\n    \"\"\"\n    # Check if x > 0\n    is_positive = x > 0\n    \n    # Return x if positive, otherwise x * alpha\n    return if_else(is_positive, x, x * alpha)\n", "response_1": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    # Compare x with 0 to determine if it's positive\n    is_positive = x > 0\n    \n    # If x is positive, return x; otherwise, return x * alpha\n    return is_positive.if_else(x, x * alpha)\n", "model_name": "deepseek-v3"}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    cmp = a >= b\n    return cmp.if_else(a, b)\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a * (a >= b) + b * (b > a)\n", "model_name": "deepseek-v3"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Check if x > 1\n    condition1 = x > 1\n    # Check if x < -1\n    condition2 = x < -1\n    \n    # Compute the results for each condition\n    result1 = x - 1\n    result2 = -x - 1\n    result3 = 0\n    \n    # Use if_else to select the appropriate result based on the conditions\n    return if_else(condition1, result1, if_else(condition2, result2, result3))\n", "response_1": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Compute the conditions\n    cond1 = x > 1\n    cond2 = x < -1\n    \n    # Compute the results for each condition\n    res1 = x - 1\n    res2 = -x - 1\n    res3 = 0\n    \n    # Use the if_else function to select the appropriate result\n    result = if_else(cond1, res1, if_else(cond2, res2, res3))\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "rounded_kinetic_energy", "response_0": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    # Compute kinetic energy: k = m * v^2 / 2\n    k = m * v * v / 2\n    \n    # Get the integer part of k\n    k_int = k.floor()\n    \n    # Determine if the fractional part is less than 0.5\n    fractional_part = k - k_int\n    rounding_condition = fractional_part < 0.5\n    \n    # Return the rounded value\n    return k_int + (1 - rounding_condition)\n", "response_1": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    k = m * v * v / 2\n    k_int = k.floor()\n    remainder = k - k_int\n    if remainder < 0.5:\n        return k_int\n    else:\n        return k_int + 1\n", "model_name": "deepseek-v3"}
{"test_name": "danger_test", "response_0": "# MP-SPDZ program to determine if the situation is dangerous\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy!\n    Given the Dragon Warrior's initial health and the damage he receives,\n    decide whether the situation is dangerous.\n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    is_dangerous = health_left <= 10\n    return is_dangerous\n", "response_1": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    is_dangerous = health_left <= 10\n    return is_dangerous\n", "model_name": "deepseek-v3"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    sum_result = x + y\n    product_result = x * y\n    result = ind.if_else(sum_result, product_result)\n    return result\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs.\n    \"\"\"\n    @if_ (ind == 1)\n    def if_true():\n        return x + y\n\n    @else_\n    def if_false():\n        return x * y\n\n    return if_true() if ind else if_false()\n", "model_name": "deepseek-v3"}
{"test_name": "median", "response_0": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array\n    arr.sort()\n    \n    # Calculate the median\n    ret = sfix(0)\n    if len(arr) % 2 == 1:\n        ret = arr[len(arr) // 2]\n    else:\n        ret = (arr[len(arr) // 2] + arr[len(arr) // 2 - 1]) / 2\n    \n    return ret\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array.\n    Check first whether the array is empty.\n    \"\"\"\n    @if_(len(arr) == 0)\n    def _():\n        crash(\"The length of the array is 0!\")\n\n    # Sort the array\n    arr = sort(arr)\n\n    # Calculate the median\n    n = len(arr)\n    @if_(n % 2 == 1)\n    def _():\n        ret = arr[n // 2]\n    @else_\n    def _():\n        ret = (arr[n // 2] + arr[n // 2 - 1]) / 2\n\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum = a + b\n    is_greater_than_10 = sum > 10\n    result = if_else(is_greater_than_10, 10, sum)\n    return result\n", "response_1": "def add_upto_10(a: sint, b: sint) -> sint:\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_val = a + b\n    is_greater_than_10 = sum_val > 10\n    result = is_greater_than_10.if_else(10, sum_val)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers.\n    The rule is the following:\n    Base fare: 5, which can cover the first 5 miles.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile.\n    \"\"\"\n    base_fare = 5\n    fare = base_fare\n\n    if m <= 5:\n        return fare\n    elif m <= 10:\n        fare += 1.2 * (m - 5)\n        return fare\n    else:\n        fare += 1.2 * (10 - 5)\n        fare += 1.5 * (m - 10)\n        return fare\n", "response_1": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    base_fare = 5\n    if m <= 5:\n        return base_fare\n    elif m <= 10:\n        return base_fare + 1.2 * (m - 5)\n    else:\n        return 11 + 1.5 * (m - 10)\n", "model_name": "deepseek-v3"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x // 1  # Equivalent to math.floor(x) for positive x\n    remainder = x - x_int\n    if remainder < 0.5:\n        return x_int\n    else:\n        return x_int + 1\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.library import *\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x.floor()\n    difference = x - x_int\n    return x_int + (difference >= 0.5)\n", "model_name": "deepseek-v3"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    gpa = sfix(0.0)\n    if score >= 90:\n        gpa = sfix(4.0)\n    elif score >= 85:\n        gpa = sfix(3.6)\n    elif score >= 80:\n        gpa = sfix(3.3)\n    elif score >= 75:\n        gpa = sfix(3.0)\n    elif score >= 70:\n        gpa = sfix(2.6)\n    else:\n        gpa = sfix(2.3)\n    return gpa\n", "response_1": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    gpa = sfix(0.0)\n    if score >= 90:\n        gpa = sfix(4.0)\n    elif score >= 85:\n        gpa = sfix(3.6)\n    elif score >= 80:\n        gpa = sfix(3.3)\n    elif score >= 75:\n        gpa = sfix(3.0)\n    elif score >= 70:\n        gpa = sfix(2.6)\n    else:\n        gpa = sfix(2.3)\n    return gpa\n", "model_name": "deepseek-v3"}
{"test_name": "sign", "response_0": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    neg_one = sint(-1)\n    \n    is_zero = (x == zero)\n    is_positive = (x > zero)\n    \n    result = is_zero.if_else(zero, is_positive.if_else(one, neg_one))\n    \n    return result\n", "response_1": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    minus_one = sint(-1)\n    \n    is_zero = x == zero\n    is_positive = x > zero\n    \n    return if_else(is_zero, zero, if_else(is_positive, one, minus_one))\n", "model_name": "deepseek-v3"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    condition = a <= b\n    result = condition.if_else(a + b, a - b)\n    return result\n", "response_1": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    sum_result = a + b\n    difference_result = a - b\n    condition = a <= b\n    result = if_else(condition, sum_result, difference_result)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ.\n    \"\"\"\n    # Use the if_else construct to implement the CNOT logic\n    return if_else(control_bit, 1 - flip_bit, flip_bit)\n", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MPC operations.\n    \"\"\"\n    # Compute the result using MPC conditional logic\n    result = control_bit * (1 - flip_bit) + (1 - control_bit) * flip_bit\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Compare y with 0 to check if it is negative\n    is_negative = y < 0\n    \n    # If y is negative, return y + 1, otherwise return y\n    result = is_negative * (y + 1) + (1 - is_negative) * y\n    \n    return result\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    return (y < 0).if_else(y + 1, y)\n", "model_name": "deepseek-v3"}
{"test_name": "is_a_parallelogram", "response_0": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    # Check if any two points are the same\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n    \n    # Check the parallelogram conditions\n    condition1 = (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1])\n    \n    return condition1 or condition2 or condition3\n", "response_1": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram.\n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    # Check if any two points are the same\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n    \n    # Check the parallelogram conditions\n    condition1 = (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1])\n    \n    return condition1 or condition2 or condition3\n", "model_name": "deepseek-v3"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    cmp = a <= b\n    return cmp.if_else(a, b)\n", "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    cmp = a <= b\n    result = cmp.if_else(a, b)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "choice_of_the_knight", "response_0": "program choice_of_the_knight:\n    # Define the legal move function\n    def legal(a, b):\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    # Main function to calculate the number of legal moves\n    def main(x, y):\n        counter = 0\n        counter = counter + legal(x + 1, y + 2)\n        counter = counter + legal(x - 1, y + 2)\n        counter = counter + legal(x + 1, y - 2)\n        counter = counter + legal(x - 1, y - 2)\n        counter = counter + legal(x + 2, y + 1)\n        counter = counter + legal(x - 2, y + 1)\n        counter = counter + legal(x + 2, y - 1)\n        counter = counter + legal(x - 2, y - 1)\n        return counter\n", "response_1": "program choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = 0\n\n    def legal(a, b):\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    counter = counter + legal(x + 1, y + 2)\n    counter = counter + legal(x - 1, y + 2)\n    counter = counter + legal(x + 1, y - 2)\n    counter = counter + legal(x - 1, y - 2)\n    counter = counter + legal(x + 2, y + 1)\n    counter = counter + legal(x - 2, y + 1)\n    counter = counter + legal(x + 2, y - 1)\n    counter = counter + legal(x - 2, y - 1)\n\n    return counter\n", "model_name": "deepseek-v3"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    max_value = sum_ab.greater_than(diff_ab).if_else(sum_ab, diff_ab)\n    return max_value\n", "response_1": "def max_sum_different(a: sint, b: sint) -> sint:\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_val = a + b\n    diff_val = a - b\n    max_val = sum_val.if_else(sum_val > diff_val, diff_val)\n    return max_val\n", "model_name": "deepseek-v3"}
