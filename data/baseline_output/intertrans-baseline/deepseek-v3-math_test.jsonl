{"test_name": "next_integer", "response_0": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    # Floor the input value and add 1\n    return t.floor() + 1\n", "response_1": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return t.to_int() + 1\n", "model_name": "deepseek-v3"}
{"test_name": "father_and_son", "response_0": "def father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    result = abs(father_age - son_age * 2)\n    return result\n", "response_1": "def father_and_son(father_age: sint, son_age: sint) -> sint:\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    return abs(father_age - son_age * 2)\n", "model_name": "deepseek-v3"}
{"test_name": "triangle_area", "response_0": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the area of the triangle.\n    \"\"\"\n    area = side * height\n    area = area / 2\n    return area\n", "response_1": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the area of the triangle.\n    The inputs are secret-shared values.\n    \"\"\"\n    area = side * height\n    area = area / 2\n    return area\n", "model_name": "deepseek-v3"}
{"test_name": "sin_plus_cos", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    # Assuming sin_approx and cos_approx are precomputed or approximated functions\n    sin_a = sin_approx(a)\n    cos_a = cos_approx(a)\n    \n    return sin_a + cos_a\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import *\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a) using a Taylor series approximation.\n    \"\"\"\n    # Taylor series approximation for sin(x): x - x^3/6 + x^5/120 - x^7/5040\n    sin_a = a - a**3 / 6 + a**5 / 120 - a**7 / 5040\n    \n    # Taylor series approximation for cos(x): 1 - x^2/2 + x^4/24 - x^6/720\n    cos_a = 1 - a**2 / 2 + a**4 / 24 - a**6 / 720\n    \n    return sin_a + cos_a\n", "model_name": "deepseek-v3"}
{"test_name": "sigmoid", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function using fixed-point arithmetic\n    \"\"\"\n    # Constants for fixed-point arithmetic\n    e = sfix(2.718281828459045)\n    one = sfix(1)\n    zero = sfix(0)\n\n    # Calculate e^(-x)\n    neg_x = -x\n    exp_neg_x = e ** neg_x\n\n    # Calculate 1 + e^(-x)\n    denominator = one + exp_neg_x\n\n    # Calculate 1 / (1 + e^(-x))\n    result = one / denominator\n\n    return result\n", "response_1": "def sigmoid(x):\n    \"\"\"\n    sigmoid function in MP-SPDZ\n    \"\"\"\n    # Constants\n    e = 2.718281828459045\n    one = 1.0\n\n    # Compute e^(-x) using fixed-point arithmetic\n    exp_minus_x = sfix(1) / (sfix(e) ** x)\n\n    # Compute 1 + e^(-x)\n    denominator = sfix(one) + exp_minus_x\n\n    # Compute the sigmoid: 1 / (1 + e^(-x))\n    result = sfix(one) / denominator\n\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "self_exponent", "response_0": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    result = 1\n    for _ in range(k):\n        result = result * k\n    return result\n", "response_1": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    result = 1\n    for _ in range(k):\n        result *= k\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "silu", "response_0": "from Compiler import types\nfrom Compiler import library\n\ndef silu(x):\n    \"\"\"\n    SiLU function in MP-SPDZ\n    \"\"\"\n    # Compute e^(-x) using the approximation 1 / (1 + x) for small x\n    # Note: This is a simple approximation and may not be accurate for all x\n    exp_neg_x = 1 / (1 + x)\n    \n    # Compute the SiLU function: x / (1 + e^(-x))\n    return x / (1 + exp_neg_x)\n", "response_1": "def silu(x):\n    \"\"\"\n    SiLU function in MP-SPDZ\n    \"\"\"\n    e_minus_x = -x\n    e_minus_x.exp()\n    denominator = 1 + e_minus_x\n    return x / denominator\n", "model_name": "deepseek-v3"}
{"test_name": "Gaussian_bracket", "response_0": "from util import *\nfrom Compiler import types\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = types.sint(x).floor()\n    return x - x_int\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = x.floor()\n    return x - x_int\n", "model_name": "deepseek-v3"}
{"test_name": "asin_and_square", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    # Approximate arcsin using a polynomial approximation\n    asin_x = x + (x**3)/6 + (3*x**5)/40 + (5*x**7)/112\n    \n    # Square the result\n    result = asin_x * asin_x\n    \n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    # Assuming x is a fixed-point number\n    asin_x = asin(x)  # Compute arcsin of x\n    result = asin_x * asin_x  # Square the result\n    return result\n\ndef asin(x):\n    \"\"\"\n    Approximate arcsin function using fixed-point arithmetic or lookup table.\n    \"\"\"\n    # This is a placeholder for the actual implementation of asin\n    # In practice, this would be implemented using a polynomial approximation or lookup table\n    return x  # Placeholder, replace with actual implementation\n", "model_name": "deepseek-v3"}
{"test_name": "cylinder_surface", "response_0": "def cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    # Approximate value of pi\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the surface area\n    surface_area = 2 * pi * r * r + 2 * pi * r * h\n    \n    return surface_area\n", "response_1": "from Compiler import floatingpoint\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    # Define the constant pi\n    pi = 3.141592653589793\n    \n    # Calculate the surface area\n    r_squared = floatingpoint.mul(r, r)\n    term1 = floatingpoint.mul(2 * pi, r_squared)\n    term2 = floatingpoint.mul(2 * pi, floatingpoint.mul(r, h))\n    surface_area = floatingpoint.add(term1, term2)\n    \n    return surface_area\n", "model_name": "deepseek-v3"}
{"test_name": "radian_to_degree", "response_0": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    # Define pi as a constant\n    pi = sfix(3.14159265358979323846)\n    \n    # Perform the conversion using fixed-point arithmetic\n    return (r / pi) * sfix(180)\n", "response_1": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    # Define the value of pi (approximated)\n    pi = 3.14159265358979323846\n    # Perform the conversion using fixed-point arithmetic\n    return r * 180 / pi\n", "model_name": "deepseek-v3"}
{"test_name": "square_root", "response_0": "def square_root(a):\n    \"\"\"\n    Compute the square root of a using the Newton-Raphson method.\n    \"\"\"\n    if a == 0:\n        return 0\n    x = a\n    y = (x + 1) / 2\n    while y < x:\n        x = y\n        y = (x + a / x) / 2\n    return x\n", "response_1": "def square_root(a):\n    \"\"\"\n    Return the square root of the input using the Babylonian method.\n    \"\"\"\n    if a == 0:\n        return 0\n    x = a\n    y = (x + 1) // 2\n    while y < x:\n        x = y\n        y = (x + a // x) // 2\n    return x\n", "model_name": "deepseek-v3"}
{"test_name": "cosine_theorem", "response_0": "from util import sqrt, cos\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them,\n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    a_squared = a * a\n    b_squared = b * b\n    two_a_b = 2 * a * b\n    cos_rad = cos(rad)\n    c_squared = a_squared + b_squared - two_a_b * cos_rad\n    c = sqrt(c_squared)\n    return c\n", "response_1": "from Compiler import types, library\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    # Compute the square of a and b\n    a_sq = a * a\n    b_sq = b * b\n\n    # Compute the cosine of the angle using a Taylor series approximation\n    # cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + ...\n    cos_rad = 1 - (rad * rad) / 2 + (rad * rad * rad * rad) / 24 - (rad * rad * rad * rad * rad * rad) / 720\n\n    # Compute the third edge using the cosine theorem\n    third_edge_sq = a_sq + b_sq - 2 * a * b * cos_rad\n\n    # Compute the square root to get the length of the third edge\n    third_edge = library.sqrt(third_edge_sq)\n\n    return third_edge\n", "model_name": "deepseek-v3"}
{"test_name": "lights_states", "response_0": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    return 2 ** num\n", "response_1": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    return 1 << num\n", "model_name": "deepseek-v3"}
{"test_name": "degree_to_radian", "response_0": "def degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    pi = 3.14159265358979323846\n    return (d * pi) / 180\n", "response_1": "def degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    # Approximate value of \u03c0 in MP-SPDZ\n    pi = 3.14159265358979323846\n    # Convert degree to radian\n    return d * pi / 180\n", "model_name": "deepseek-v3"}
{"test_name": "Fah_to_Cel", "response_0": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    # Subtract 32 from Fahrenheit temperature\n    temp = F - 32\n    # Divide by 1.8 using fixed-point arithmetic\n    C = temp * sfix(1) / sfix(1.8)\n    return C\n", "response_1": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    F is a secret-shared value.\n    \"\"\"\n    return (F - sfix(32)) / sfix(1.8)\n", "model_name": "deepseek-v3"}
{"test_name": "elliptic_area", "response_0": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    # MP-SPDZ uses fixed-point arithmetic, so we need to represent pi as a fixed-point number.\n    # Assuming a precision of 16 bits for the fractional part.\n    pi = sfix(3.14159265358979323846)\n    \n    # Calculate the area using the formula pi * a * b\n    area = pi * a * b\n    \n    return area\n", "response_1": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    from Compiler import types\n    from Compiler import floatingpoint\n\n    # Assuming a and b are secret-shared values\n    pi = floatingpoint.PI()\n    area = pi * a * b\n    return area\n", "model_name": "deepseek-v3"}
{"test_name": "floor", "response_0": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Convert the input to a fixed-point number\n    z_fixed = sfix(z)\n    \n    # Truncate the fractional part to get the floor value\n    floor_value = z_fixed.floor()\n    \n    return floor_value\n", "response_1": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Since MP-SPDZ uses integer arithmetic, z is already an integer if it's a fixed-point number.\n    # If z is a floating-point number, we need to convert it to an integer by truncating the decimal part.\n    # Assuming z is a fixed-point number, we can directly return z.\n    return z\n", "model_name": "deepseek-v3"}
{"test_name": "log_and_cube", "response_0": "def log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    # Calculate log2(x) using the change of base formula: log2(x) = ln(x) / ln(2)\n    ln_x = log(x)\n    ln_2 = log(2)\n    log2_x = ln_x / ln_2\n    \n    # Compute the cube of the log2(x)\n    result = log2_x ** 3\n    \n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    # Approximate log2(x) using the method of successive approximation\n    def log2_approx(y):\n        result = cint(0)\n        y = cint(y)\n        while y > 1:\n            y = y / 2\n            result = result + 1\n        return result\n\n    # Compute the log2 of x\n    log_x = log2_approx(x)\n\n    # Compute the cube of the log2 result\n    cube_result = log_x * log_x * log_x\n\n    return cube_result\n", "model_name": "deepseek-v3"}
{"test_name": "floor_and_square", "response_0": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input.\n    Then return the square of the previous outcome.\n    \"\"\"\n    # In MP-SPDZ, we can use the integer division to simulate floor\n    floored = z // 1\n    # Square the floored value\n    squared = floored * floored\n    return squared\n", "response_1": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome.\n    \"\"\"\n    floored = sint(z).to_int()  # Convert to integer, effectively flooring the value\n    return floored * floored  # Square the result\n", "model_name": "deepseek-v3"}
{"test_name": "meters_to_feet", "response_0": "from Compiler import types\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    :param m: secret-shared value representing the length in meters\n    :return: secret-shared value representing the length in feet\n    \"\"\"\n    return m * 3.2808\n", "response_1": "from Compiler import types\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * types.sfix(3.2808)\n", "model_name": "deepseek-v3"}
{"test_name": "sphere_area", "response_0": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    pi = 3.141592653589793\n    return 4 * pi * r * r\n", "response_1": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    # Approximate value of pi\n    pi = 3.141592653589793\n    return 4 * pi * r * r\n", "model_name": "deepseek-v3"}
{"test_name": "coarse_abs", "response_0": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = x.abs()  # Compute the absolute value of x\n    return abs_x.floor()  # Round the absolute value to the nearest integer towards zero\n", "response_1": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = abs(x)\n    return abs_x - (abs_x % 1)\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_chickens", "response_0": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    chickens = heads - (legs - heads * 2) // 2\n    return chickens\n", "response_1": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - (legs - heads * 2) // 2\n", "model_name": "deepseek-v3"}
{"test_name": "interest_calculator", "response_0": "# MP-SPDZ program to calculate interest\ndef interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio, and the number of months,\n    calculate the interest you can get.\n    \"\"\"\n    # Initialize the result with 1 + ratio\n    result = 1 + ratio\n    \n    # Calculate (1 + ratio) ^ months using a loop\n    for _ in range(months - 1):\n        result = result * (1 + ratio)\n    \n    # Subtract 1 and multiply by capital to get the interest\n    interest = (result - 1) * capital\n    \n    return interest\n", "response_1": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get.\n    \"\"\"\n    # Initialize the result as 1 + ratio\n    result = 1 + ratio\n    \n    # Raise (1 + ratio) to the power of months using a loop\n    for _ in range(months - 1):\n        result = result * (1 + ratio)\n    \n    # Calculate the interest\n    interest = (result - 1) * capital\n    \n    return interest\n", "model_name": "deepseek-v3"}
{"test_name": "circle_area", "response_0": "def circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    # MP-SPDZ does not have a built-in pi constant, so we define it manually\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the area using the formula pi * r^2\n    area = pi * r * r\n    \n    return area\n", "response_1": "def circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    # Define the value of pi (\u03c0) as a fixed-point number\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the area using fixed-point arithmetic\n    area = pi * r * r\n    \n    return area\n", "model_name": "deepseek-v3"}
{"test_name": "cube_and_square_root", "response_0": "def cube_and_square_root(x):\n    \"\"\"\n    Take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    # Compute the cube of x\n    cube = x ** 3\n    # Compute the square root of the cube\n    result = sqrt(cube)\n    return result\n", "response_1": "def cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    # Compute the cube of x\n    cube = x * x * x\n    \n    # Compute the square root of the cube\n    result = sqrt(cube)\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x / 1  # Equivalent to floor(x) for positive numbers\n    remainder = x - x_int\n    return x_int + (remainder >= 0.5)\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import print_ln\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x.floor()\n    diff = x - x_int\n    half = sfix(0.5)\n    return x_int.if_else(x_int + sint(1), diff < half)\n\n# Example usage (not part of the code block)\n# x = sfix(3.7)\n# result = round(x)\n# print_ln(\"Rounded value: %s\", result.reveal())\n", "model_name": "deepseek-v3"}
{"test_name": "cryptic_adjustment", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor wants to adjust the pessimistic score of his students mid-term exam.\n    The adjustment formula is 10 * sqrt(10 * sqrt(origin))\n    \"\"\"\n    # Compute the inner square root: sqrt(origin)\n    inner_sqrt = sqrt_fx(origin)\n    \n    # Multiply the inner square root by 10\n    inner_result = 10 * inner_sqrt\n    \n    # Compute the outer square root: sqrt(10 * sqrt(origin))\n    outer_sqrt = sqrt_fx(inner_result)\n    \n    # Multiply the outer square root by 10\n    result = 10 * outer_sqrt\n    \n    return result\n\ndef sqrt_fx(x):\n    \"\"\"\n    Fixed-point square root implementation using the Babylonian method.\n    \"\"\"\n    if x < 0:\n        raise ValueError(\"Cannot compute square root of a negative number.\")\n    \n    # Initial guess\n    guess = x / 2.0\n    \n    # Iterate until convergence\n    for _ in range(20):\n        guess = (guess + x / guess) / 2.0\n    \n    return guess\n", "response_1": "def cryptic_adjustment(origin):\n    \"\"\"\n    The professor want to adjust the pessimistic score of his students mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    sqrt_origin = origin ** 0.5\n    inner_sqrt = 10 * sqrt_origin\n    sqrt_inner_sqrt = inner_sqrt ** 0.5\n    result = 10 * sqrt_inner_sqrt\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "specific_pow", "response_0": "from Compiler import types, instructions, library\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5).\n    \"\"\"\n    # Compute x^2\n    x_squared = x * x\n    \n    # Compute sqrt(x)\n    x_sqrt = library.sqrt(x)\n    \n    # Compute x^(2.5) = x^2 * sqrt(x)\n    result = x_squared * x_sqrt\n    \n    return result\n", "response_1": "from util import *\nfrom fixedpt import *\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    # Convert x to fixed-point representation\n    x_fixed = sfix(x)\n    \n    # Precompute 2.5 in fixed-point representation\n    exponent = sfix(2.5)\n    \n    # Compute x^2.5 using fixed-point arithmetic\n    result = x_fixed ** exponent\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "soft_plus", "response_0": "def soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    e = 2.718281828459045\n    exp_x = e ** x\n    one_plus_exp_x = 1 + exp_x\n    return log(one_plus_exp_x)\n\ndef log(x):\n    \"\"\"\n    Natural logarithm approximation using the Newton-Raphson method\n    \"\"\"\n    if x <= 0:\n        return 0  # Undefined for non-positive numbers\n    n = x - 1\n    for _ in range(10):  # Iterations for better approximation\n        n = n - (exp(n) - x) / exp(n)\n    return n\n\ndef exp(x):\n    \"\"\"\n    Exponential function approximation using Taylor series\n    \"\"\"\n    result = 1\n    term = 1\n    for i in range(1, 10):  # Number of terms in the series\n        term *= x / i\n        result += term\n    return result\n", "response_1": "def soft_plus(x):\n    \"\"\"\n    Softplus function in MP-SPDZ\n    \"\"\"\n    e_x = exp(x)\n    one_plus_e_x = 1 + e_x\n    return log(one_plus_e_x)\n", "model_name": "deepseek-v3"}
{"test_name": "ball_volume", "response_0": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    # Define the value of pi manually\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the volume using fixed-point arithmetic\n    volume = pi * r * r * r * sfix(4) / sfix(3)\n    \n    return volume\n", "response_1": "from Compiler.library import sfix\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return pi * r * r * r * sfix(4) / sfix(3)\n", "model_name": "deepseek-v3"}
{"test_name": "Heron", "response_0": "def Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    area = sqrt(p * (p - a) * (p - b) * (p - c))\n    return area\n", "response_1": "def Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    s_squared = p * (p - a) * (p - b) * (p - c)\n    s = sqrt(s_squared)\n    return s\n\ndef sqrt(x):\n    \"\"\"\n    A simple implementation of the square root function using the Newton-Raphson method.\n    \"\"\"\n    if x < 0:\n        return 0  # Return 0 for negative input (though it should not happen in this context)\n    guess = x / 2\n    for _ in range(10):  # 10 iterations should be enough for a good approximation\n        guess = (guess + x / guess) / 2\n    return guess\n", "model_name": "deepseek-v3"}
{"test_name": "next_perfect_square", "response_0": "def next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    # Calculate the integer square root of x\n    sqrt_x = 0\n    while (sqrt_x + 1) * (sqrt_x + 1) <= x:\n        sqrt_x += 1\n    \n    # Increment by 1 and square to get the next perfect square\n    next_square = (sqrt_x + 1) * (sqrt_x + 1)\n    \n    return next_square\n", "response_1": "def next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x.\n    The input x is guaranteed to be a positive integer.\n    \"\"\"\n    # Find the integer square root of x\n    sqrt_x = 0\n    while (sqrt_x + 1) ** 2 <= x:\n        sqrt_x += 1\n    \n    # Calculate the next perfect square\n    next_square = (sqrt_x + 1) ** 2\n    return next_square\n", "model_name": "deepseek-v3"}
{"test_name": "pi_to_the_x", "response_0": "def pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    # Define the value of pi as a fixed-point number\n    pi = sfix(3.14159265358979323846)\n    \n    # Initialize result as 1.0 (since x^0 = 1)\n    result = sfix(1.0)\n    \n    # Loop to compute pi^x using repeated multiplication\n    for _ in range(x):\n        result = result * pi\n    \n    return result\n", "response_1": "def pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    # Approximate value of pi\n    pi = 3.14159265358979323846\n    \n    # Initialize result as 1\n    result = 1.0\n    \n    # Handle the case when x is 0\n    if x == 0:\n        return 1.0\n    \n    # Compute pi^x using repeated multiplication\n    for _ in range(abs(x)):\n        result = result * pi\n    \n    # If x is negative, take the reciprocal\n    if x < 0:\n        result = 1.0 / result\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "spring_rocket", "response_0": "# MP-SPDZ program to calculate the minimum compression length of a spring\nprogram spring_rocket\n\n# Define the input variables as secret shared values\nsfloat height, m, k\n\n# Define the gravitational constant\ng = sfloat(9.8)\n\n# Calculate the minimum compression length\ncompression_length = sqrt(2 * m * g * height / k)\n\n# Output the result\nprint_ln(\"The minimum compression length is: %s\", compression_length.reveal())\n", "response_1": "from util import if_else\nfrom Compiler import floatingpoint\n\ndef spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = floatingpoint.Sfix(9.8)\n    numerator = 2 * m * g * height\n    denominator = k\n    result = floatingpoint.sqrt(numerator / denominator)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "cone_volume", "response_0": "def cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    # Use the predefined constant for pi in MP-SPDZ\n    pi = sfloat(math.pi)\n    \n    # Compute the volume of the cone\n    volume = pi * r * r * h / 3\n    \n    return volume\n", "response_1": "def cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    # Define pi as a constant\n    pi = 3.14159265358979323846\n    \n    # Compute the volume of the cone\n    volume = pi * r * r * h / 3\n    \n    return volume\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "response_1": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    # Assuming heads and legs are secret-shared values\n    # Calculate the number of rabbits\n    rabbits = (legs - heads * 2) // 2\n    return rabbits\n", "model_name": "deepseek-v3"}
