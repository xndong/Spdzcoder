{"test_name": "array_from_intrinsic_linspace", "response_0": "# Define the start, end, and number of points\nstart = 0\nend = 99\nnum = 10\n\n# Calculate the step size\nstep = (end - start) / (num - 1)\n\n# Initialize an array to store the results\na = Array(num, sfix)\n\n# Generate the linearly spaced values\nfor i in range(num):\n    a[i] = start + i * step\n", "response_1": "start = 0\nend = 99\nnum = 10\n\n# Calculate the step size\nstep = (end - start) // (num - 1)\n\n# Generate the sequence\na = [start + i * step for i in range(num)]\n", "model_name": "deepseek-v3"}
{"test_name": "more_positive", "response_0": "from Compiler.types import Array, sfix, sint\nfrom Compiler.library import print_ln, for_range\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    # Initialize a counter for positive numbers\n    count = sint(0)\n    \n    # Iterate over the array to count positive numbers\n    for i in range(len(arr)):\n        # Check if the element is positive\n        is_positive = arr[i] > sfix(0)\n        # Increment the counter if the element is positive\n        count += is_positive\n    \n    # Return whether the count is greater than zero\n    return count > sint(0)\n\n# Example usage (not part of the MP-SPDZ code)\n# arr = Array(5, sfix)\n# arr.assign([sfix(1), sfix(-2), sfix(3), sfix(-4), sfix(5)])\n# result = more_positive(arr)\n# print_ln(\"More positive numbers: %s\", result.reveal())\n", "response_1": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    # Initialize the count of positive numbers\n    count = sint(0)\n    \n    # Iterate over each element in the array\n    for x in arr:\n        # Check if the element is positive\n        is_positive = x > 0\n        # Increment the count if the element is positive\n        count += is_positive\n    \n    # Return whether the count of positive numbers is greater than half the array length\n    return count > len(arr) / 2\n", "model_name": "deepseek-v3"}
{"test_name": "select", "response_0": "from util import if_else\n\ndef select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    result = Array(len(a), sfloat)\n    for i in range(len(a)):\n        result[i] = if_else(ind[i], a[i], b[i])\n    return result\n", "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    res = Array(len(a), sfloat)\n    for i in range(len(a)):\n        res[i] = if_else(ind[i], a[i], b[i])\n    return res\n", "model_name": "deepseek-v3"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return y * (y > 0)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return y * (y > 0)\n", "model_name": "deepseek-v3"}
{"test_name": "cost_matrix", "response_0": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix in MP-SPDZ.\n    \"\"\"\n    # Determine the shape of the profit matrix\n    matrix_shape = profit_matrix.shape\n    \n    # Find the maximum value in the profit matrix\n    max_value = profit_matrix.max()\n    \n    # Create an offset matrix filled with the maximum value\n    offset_matrix = Array(matrix_shape[0], matrix_shape[1])\n    @for_range(matrix_shape[0])\n    def _(i):\n        @for_range(matrix_shape[1])\n        def _(j):\n            offset_matrix[i][j] = max_value\n    \n    # Compute the cost matrix by subtracting the profit matrix from the offset matrix\n    cost_matrix = Array(matrix_shape[0], matrix_shape[1])\n    @for_range(matrix_shape[0])\n    def _(i):\n        @for_range(matrix_shape[1])\n        def _(j):\n            cost_matrix[i][j] = offset_matrix[i][j] - profit_matrix[i][j]\n    \n    return cost_matrix\n", "response_1": "# Assuming profit_matrix is a 2D array of sfix values\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    # Get the shape of the profit matrix\n    rows = len(profit_matrix)\n    cols = len(profit_matrix[0]) if rows > 0 else 0\n    \n    # Find the maximum value in the profit matrix\n    max_value = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            max_value = max(max_value, profit_matrix[i][j])\n    \n    # Create an offset matrix filled with the maximum value\n    offset_matrix = Array(rows, cols, sfix)\n    for i in range(rows):\n        for j in range(cols):\n            offset_matrix[i][j] = max_value\n    \n    # Compute the cost matrix by subtracting the profit matrix from the offset matrix\n    cost_matrix = Array(rows, cols, sfix)\n    for i in range(rows):\n        for j in range(cols):\n            cost_matrix[i][j] = offset_matrix[i][j] - profit_matrix[i][j]\n    \n    return cost_matrix\n", "model_name": "deepseek-v3"}
{"test_name": "np_zeros", "response_0": "n = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = sint(0)\n", "response_1": "n = 10\na = Array(n, sfix)\na.assign_all(sfix(0))\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index]\n    return array\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a list of lists (2D array)\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    # Create an array of size n with all elements initialized to 0\n    return Array(n, sint(0))\n", "response_1": "def zeros(n):\n    # Create an array of size n initialized with zeros\n    arr = Array(n, sint)\n    for i in range(n):\n        arr[i] = sint(0)\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_slicing_stride", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef array_concate(arrayA, arrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. \n    Collect all the even index elements from the first array and \n    collect all the odd index elements from the second array.\n    \"\"\"\n    # Collect even index elements from arrayA\n    viewA = types.Array(len(arrayA) // 2, arrayA.value_type)\n    for i in range(len(viewA)):\n        viewA[i] = arrayA[2 * i]\n\n    # Collect odd index elements from arrayB\n    viewB = types.Array(len(arrayB) // 2, arrayB.value_type)\n    for i in range(len(viewB)):\n        viewB[i] = arrayB[2 * i + 1]\n\n    # Concatenate viewA and viewB\n    result = types.Array(len(viewA) + len(viewB), arrayA.value_type)\n    for i in range(len(viewA)):\n        result[i] = viewA[i]\n    for i in range(len(viewB)):\n        result[len(viewA) + i] = viewB[i]\n\n    return result\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef array_concate(arrayA, arrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. \n    Collect all the even index elements from the first array and \n    collect all the odd index elements from the second array.\n    \"\"\"\n    # Initialize the result array\n    result = types.Array(len(arrayA) // 2 + len(arrayB) // 2, types.sint)\n\n    # Collect even index elements from arrayA\n    idx = 0\n    for i in range(0, len(arrayA), 2):\n        result[idx] = arrayA[i]\n        idx += 1\n\n    # Collect odd index elements from arrayB\n    for i in range(1, len(arrayB), 2):\n        result[idx] = arrayB[i]\n        idx += 1\n\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "QR_decomposition", "response_0": "# Assuming you have a matrix type and basic linear algebra functions implemented in MP-SPDZ\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    # Initialize Q and R matrices\n    n = len(mat)\n    Q = [[sfix(0) for _ in range(n)] for _ in range(n)]\n    R = [[sfix(0) for _ in range(n)] for _ in range(n)]\n\n    for j in range(n):\n        # Copy the j-th column of mat to v\n        v = [mat[i][j] for i in range(n)]\n        \n        for i in range(j):\n            # Compute the projection of v onto Q[:, i]\n            R[i][j] = sum(Q[k][i] * v[k] for k in range(n))\n            # Subtract the projection from v\n            v = [v[k] - R[i][j] * Q[k][i] for k in range(n)]\n        \n        # Normalize v to get Q[:, j]\n        norm = sqrt(sum(v[k] * v[k] for k in range(n)))\n        for k in range(n):\n            Q[k][j] = v[k] / norm\n        R[j][j] = norm\n\n    return Q\n", "response_1": "from Compiler import types\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix using the Gram-Schmidt process.\n    \"\"\"\n    n = len(mat)\n    Q = types.Matrix(n, n, types.sfix)\n    R = types.Matrix(n, n, types.sfix)\n\n    for j in range(n):\n        v = mat.get_column(j)\n        for i in range(j):\n            R[i][j] = Q.get_column(i).dot_product(v)\n            v = v - Q.get_column(i) * R[i][j]\n        R[j][j] = v.norm()\n        Q.set_column(j, v / R[j][j])\n\n    return Q\n", "model_name": "deepseek-v3"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    min_diff = abs(array[0] - value)\n    min_idx = 0\n    for i in range(1, len(array)):\n        diff = abs(array[i] - value)\n        if diff < min_diff:\n            min_diff = diff\n            min_idx = i\n    return min_idx\n", "response_1": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of the nearest value in an array to the given value.\n    \"\"\"\n    min_diff = None\n    min_index = None\n    \n    for i in range(len(array)):\n        diff = abs(array[i] - value)\n        if min_diff is None or diff < min_diff:\n            min_diff = diff\n            min_index = i\n    \n    return min_index\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_simple_row", "response_0": "from Compiler import types\n\ndef array_simple_concate_rows(arrayA, arrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Get the number of rows and columns in arrayA\n    rowsA = len(arrayA)\n    colsA = len(arrayA[0])\n    \n    # Get the number of rows and columns in arrayB\n    rowsB = len(arrayB)\n    colsB = len(arrayB[0])\n    \n    # Ensure both arrays have the same number of columns\n    if colsA != colsB:\n        raise ValueError(\"Arrays must have the same number of columns\")\n    \n    # Create a new array with the combined number of rows\n    result = types.Array(rowsA + rowsB, colsA, arrayA[0][0].s_type)\n    \n    # Copy rows from arrayA to the result\n    for i in range(rowsA):\n        for j in range(colsA):\n            result[i][j] = arrayA[i][j]\n    \n    # Copy rows from arrayB to the result\n    for i in range(rowsB):\n        for j in range(colsA):\n            result[rowsA + i][j] = arrayB[i][j]\n    \n    return result\n", "response_1": "# MP-SPDZ program to concatenate two 2-D arrays along axis 0\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    Concatenates two 2-D arrays along axis 0.\n    \n    :param ndarrayA: First 2-D array\n    :param ndarrayB: Second 2-D array\n    :return: Concatenated array\n    \"\"\"\n    # Determine the number of rows and columns in the input arrays\n    rows_A = len(ndarrayA)\n    rows_B = len(ndarrayB)\n    cols = len(ndarrayA[0])  # Assuming both arrays have the same number of columns\n    \n    # Initialize the result array with the combined number of rows\n    result = [[sint(0) for _ in range(cols)] for _ in range(rows_A + rows_B)]\n    \n    # Copy elements from ndarrayA to the result array\n    for i in range(rows_A):\n        for j in range(cols):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from ndarrayB to the result array\n    for i in range(rows_B):\n        for j in range(cols):\n            result[rows_A + i][j] = ndarrayB[i][j]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    array = Array(len(ndarray), sfix)  # Assuming the array elements are of type sfix\n    for i in range(len(ndarray)):\n        array[i] = ndarray[i]\n    return array\n", "response_1": "def array_copy(ndarray):\n    # Create a new array with the same size as the input array\n    array = Array(len(ndarray), sfix)\n    \n    # Copy each element from the input array to the new array\n    for i in range(len(ndarray)):\n        array[i] = ndarray[i]\n    \n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "max_pooling", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    \"\"\"\n    # Determine the output dimensions\n    out_shape = (x.shape[0], x.shape[1] // stride, x.shape[2] // stride)\n    out = types.Array(out_shape, types.sint)\n\n    # Iterate over the input dimensions\n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                # Extract the window\n                window = x[b][i:i+stride][j:j+stride]\n                \n                # Compute the maximum value in the window\n                max_val = window[0][0]\n                for wi in range(stride):\n                    for wj in range(stride):\n                        max_val = if_else(window[wi][wj] > max_val, window[wi][wj], max_val)\n                \n                # Store the result in the output array\n                out[b][i // stride][j // stride] = max_val\n\n    return out\n", "response_1": "# Define the max_pooling function in MP-SPDZ\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling operation securely.\n    \"\"\"\n    # Determine the output dimensions\n    out_shape = [x.shape[0], x.shape[1] // stride, x.shape[2] // stride]\n    \n    # Initialize the output array with zeros\n    out = Array(out_shape, sfix)\n    \n    # Iterate over the batches\n    for b in range(x.shape[0]):\n        # Iterate over the height with stride\n        for i in range(0, x.shape[1], stride):\n            # Iterate over the width with stride\n            for j in range(0, x.shape[2], stride):\n                # Extract the window\n                window = x[b, i:i+stride, j:j+stride]\n                \n                # Compute the maximum value in the window securely\n                max_val = sfix.max(window)\n                \n                # Store the result in the output array\n                out[b, i // stride, j // stride] = max_val\n    \n    return out\n", "model_name": "deepseek-v3"}
{"test_name": "array_reshape", "response_0": "# Define the dimensions of the 2D array\nrows = 3\ncols = 5\n\n# Initialize the 2D array\na = Array(rows, Array(cols, sint))\n\n# Fill the array with values from 0 to 14\nfor i in range(rows):\n    for j in range(cols):\n        a[i][j] = sint(i * cols + j)\n", "response_1": "# Define the range and reshape it into a 3x5 matrix\na = [i for i in range(15)]\na = [[a[i * 5 + j] for j in range(5)] for i in range(3)]\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_simple_column", "response_0": "from Compiler import types\n\ndef array_simple_concate_column(arrayA, arrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \n    :param arrayA: A 2-D array of sfix or sint\n    :param arrayB: A 2-D array of sfix or sint\n    :return: A new 2-D array with the concatenated elements\n    \"\"\"\n    # Determine the number of rows and columns in the input arrays\n    rows_A = len(arrayA)\n    cols_A = len(arrayA[0])\n    rows_B = len(arrayB)\n    cols_B = len(arrayB[0])\n    \n    # Ensure both arrays have the same number of rows\n    if rows_A != rows_B:\n        raise ValueError(\"Both arrays must have the same number of rows\")\n    \n    # Create a new array to store the concatenated result\n    result = [[None for _ in range(cols_A + cols_B)] for _ in range(rows_A)]\n    \n    # Copy elements from arrayA and arrayB into the result array\n    for i in range(rows_A):\n        for j in range(cols_A):\n            result[i][j] = arrayA[i][j]\n        for j in range(cols_B):\n            result[i][cols_A + j] = arrayB[i][j]\n    \n    return result\n", "response_1": "from Compiler import types\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Get the number of rows and columns in the input arrays\n    rows_A = len(ndarrayA)\n    cols_A = len(ndarrayA[0]) if rows_A > 0 else 0\n    rows_B = len(ndarrayB)\n    cols_B = len(ndarrayB[0]) if rows_B > 0 else 0\n\n    # Ensure both arrays have the same number of rows\n    if rows_A != rows_B:\n        raise ValueError(\"Input arrays must have the same number of rows\")\n\n    # Create a new array to store the result\n    result = types.Array(rows_A, cols_A + cols_B, types.sint)\n\n    # Copy elements from ndarrayA and ndarrayB into the result array\n    for i in range(rows_A):\n        for j in range(cols_A):\n            result[i][j] = ndarrayA[i][j]\n        for j in range(cols_B):\n            result[i][cols_A + j] = ndarrayB[i][j]\n\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Extract the i-th column from the 2D array\n    column = [row[column_index] for row in ndarray]\n    return column\n", "response_1": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a list of lists (2-D array)\n    # and column_index is the index of the column to be extracted\n    array = [row[column_index] for row in ndarray]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    n = len(array)\n    diag = Array(n, sint)\n    for i in range(n):\n        diag[i] = array[i][i]\n    return diag\n", "response_1": "def diag(array):\n    n = len(array)\n    diag_array = Array(n, sint)\n    \n    for i in range(n):\n        diag_array[i] = array[i][i]\n    \n    return diag_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_special", "response_0": "# Assuming ndarrayA and ndarrayB are 2D arrays in MP-SPDZ\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1. \n    Collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Get the number of rows and columns in the arrays\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n\n    # Initialize empty arrays for even columns of ndarrayA and odd columns of ndarrayB\n    even_cols_A = [[] for _ in range(rows)]\n    odd_cols_B = [[] for _ in range(rows)]\n\n    # Collect even columns from ndarrayA\n    for i in range(rows):\n        for j in range(0, colsA, 2):\n            even_cols_A[i].append(ndarrayA[i][j])\n\n    # Collect odd columns from ndarrayB\n    for i in range(rows):\n        for j in range(1, colsB, 2):\n            odd_cols_B[i].append(ndarrayB[i][j])\n\n    # Concatenate the two arrays along axis 1\n    result = [[] for _ in range(rows)]\n    for i in range(rows):\n        result[i] = even_cols_A[i] + odd_cols_B[i]\n\n    return result\n", "response_1": "# Function to concatenate even columns from the first array and odd columns from the second array\ndef array_special_concate(ndarrayA, ndarrayB):\n    # Get the number of rows and columns in the input arrays\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n    \n    # Initialize the result array\n    result = Array(rows, lambda i: Array(0, sfix))\n    \n    # Collect even columns from the first array\n    for i in range(rows):\n        for j in range(0, colsA, 2):\n            result[i].append(ndarrayA[i][j])\n    \n    # Collect odd columns from the second array\n    for i in range(rows):\n        for j in range(1, colsB, 2):\n            result[i].append(ndarrayB[i][j])\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_arange", "response_0": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-d array similar to numpy.arange\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Calculate the size of the array\n    size = (stop - start) // step\n    if (stop - start) % step != 0:\n        size += 1\n\n    # Initialize the array\n    array = Array(size, sint)\n\n    # Fill the array with values\n    @for_range(size)\n    def _(i):\n        array[i] = start + i * step\n\n    return array\n", "response_1": "from util import if_else\n\ndef arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-D array similar to numpy.arange in MP-SPDZ.\n    \"\"\"\n    stop = if_else(stop is None, start, stop)\n    start = if_else(stop is None, 0, start)\n\n    result = []\n    current = start\n    while current < stop:\n        result.append(current)\n        current += step\n\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_eye_2", "response_0": "m = 3\nn = 5\na = Array(m, Array(n, sgf2n))\n\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sgf2n(1)\n        else:\n            a[i][j] = sgf2n(0)\n", "response_1": "m = 3\nn = 5\na = Array(m, Array(n, sfix))\n\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sfix(1)\n        else:\n            a[i][j] = sfix(0)\n", "model_name": "deepseek-v3"}
{"test_name": "third_smallest", "response_0": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compare arr[i] and arr[j] and swap if necessary\n            smaller = arr[i] < arr[j]\n            temp = arr[i]\n            arr[i] = smaller * arr[i] + (1 - smaller) * arr[j]\n            arr[j] = smaller * arr[j] + (1 - smaller) * temp\n    return arr[2]\n", "response_1": "from Compiler import types\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Sort the array\n    sorted_arr = types.Array(len(arr), types.sint)\n    for i in range(len(arr)):\n        sorted_arr[i] = arr[i]\n    \n    # Bubble sort for simplicity (replace with more efficient sorting if needed)\n    for i in range(len(sorted_arr)):\n        for j in range(len(sorted_arr) - 1):\n            comp = sorted_arr[j] > sorted_arr[j + 1]\n            temp = sorted_arr[j]\n            sorted_arr[j] = comp.if_else(sorted_arr[j + 1], sorted_arr[j])\n            sorted_arr[j + 1] = comp.if_else(temp, sorted_arr[j + 1])\n    \n    # Return the third smallest element\n    return sorted_arr[2]\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array (matrix) in MP-SPDZ\n    array = ndarray[row_index]\n    return array\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a list of lists (2-D array)\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = Array(n, sint)\n\n@for_range(n)\ndef _(i):\n    a[i] = sint(i)\n", "response_1": "n = 10\na = Array(n, sint)\n\nfor i in range(n):\n    a[i] = sint(i)\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "from util import if_else\nfrom Compiler.library import for_range\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from a 2-D array.\n    \"\"\"\n    # Assuming ndarray is a list of lists (2-D array)\n    # and row_index is an integer index\n    \n    # Get the number of columns\n    num_cols = len(ndarray[0])\n    \n    # Initialize the result array\n    result = [0] * num_cols\n    \n    # Iterate over each column to get the i-th row\n    for_range(num_cols)(lambda col: \n        result.__setitem__(col, ndarray[row_index][col])\n    )\n    \n    return result\n", "response_1": "from util import if_else\nfrom Compiler.types import Array, Matrix, sint\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a Matrix and row_index is a sint\n    num_cols = len(ndarray[0])\n    result = Array(num_cols, sint)\n    \n    for j in range(num_cols):\n        result[j] = ndarray[row_index][j]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "array_from_python_structure", "response_0": "# Define the array as a list of secret integers\na_l = [sint(0), sint(10), sint(20), sint(30), sint(40)]\n\n# If you need to use the array in further computations, you can access it as usual\n# For example, accessing the first element:\nfirst_element = a_l[0]\n", "response_1": "# Define the array with length 5\na = Array(5, sint)\n\n# Initialize the array with the values [0, 10, 20, 30, 40]\na[0] = sint(0)\na[1] = sint(10)\na[2] = sint(20)\na[3] = sint(30)\na[4] = sint(40)\n", "model_name": "deepseek-v3"}
{"test_name": "np_reshape", "response_0": "# MP-SPDZ program to reshape an array\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    Reshape a 1D array into a 2D array of size m x n.\n    \"\"\"\n    reshaped_array = Array(m, n, sfix)\n    for i in range(m):\n        for j in range(n):\n            reshaped_array[i][j] = ndarray[i * n + j]\n    return reshaped_array\n", "response_1": "from Compiler import types\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a numpy array.\n    \"\"\"\n    # Assuming ndarray is a flat array of size m * n\n    reshaped_array = types.Array(m, types.Array(n, types.sint))\n    \n    for i in range(m):\n        for j in range(n):\n            reshaped_array[i][j] = ndarray[i * n + j]\n    \n    return reshaped_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ones", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\nn = 10\na = Array(n, sfix)\n@for_range(n)\ndef _(i):\n    a[i] = sfix(1)\n", "response_1": "n = 10\na = Array(n, sint)\n\nfor i in range(n):\n    a[i] = sint(1)\n", "model_name": "deepseek-v3"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    # Assuming y is an array of secret-shared integers\n    for i in range(len(y)):\n        # If y[i] == 1, set it to 0, otherwise keep it as is\n        y[i] = y[i] * (1 - (y[i] == 1))\n    return y\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    @for_range(len(y))\n    def _(i):\n        y[i] = y[i].if_else(0, 1)\n    return y\n", "model_name": "deepseek-v3"}
{"test_name": "np_eye", "response_0": "n = 10\na = Array(n, n, sint)\n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sint(1)\n        else:\n            a[i][j] = sint(0)\n", "response_1": "n = 10\na = Array(n, n, sint)\n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sint(1)\n        else:\n            a[i][j] = sint(0)\n", "model_name": "deepseek-v3"}
{"test_name": "np_diag", "response_0": "a_l = [1, 3, 5, 2, 4, 6]\nn = len(a_l)\na = Matrix(n, n, sint(0))\n\nfor i in range(n):\n    a[i][i] = sint(a_l[i])\n", "response_1": "a_l = [1, 3, 5, 2, 4, 6]\nn = len(a_l)\na = [[0 for _ in range(n)] for _ in range(n)]\n\nfor i in range(n):\n    a[i][i] = a_l[i]\n", "model_name": "deepseek-v3"}
{"test_name": "np_advanced_integer_indexing", "response_0": "# MP-SPDZ program: integer array indexing\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an array from an integer array in MP-SPDZ.\n    \"\"\"\n    # Assuming 'array' is an MP-SPDZ array and 'indices' is a list of integers\n    ret_array = Array(len(indices), sint)  # Create an array to store the result\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]  # Perform the indexing\n    return ret_array\n", "response_1": "# MP-SPDZ function to index an array using an array of indices\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an array using an array of indices.\n    \"\"\"\n    # Initialize an empty array to store the result\n    ret_array = Array(len(indices), 'sint')\n    \n    # Loop through each index and retrieve the corresponding element from the array\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    \n    return ret_array\n", "model_name": "deepseek-v3"}
