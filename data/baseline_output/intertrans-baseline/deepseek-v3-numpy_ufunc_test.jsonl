{"test_name": "cross_entropy_loss", "response_0": "def cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss.\n    \"\"\"\n    from Compiler import types\n    log_y = y.log()\n    product = y * log_y\n    return -product.sum()\n", "response_1": "def cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss in MP-SPDZ.\n    \"\"\"\n    # Initialize the result to 0\n    result = sfix(0)\n    \n    # Iterate over each element in y\n    for i in range(len(y)):\n        # Compute y[i] * log(y[i])\n        log_y = sfix.log(y[i])\n        product = y[i] * log_y\n        \n        # Accumulate the result\n        result -= product\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_square_sqrt", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Calculate the mean of the array\n    mean = sum(array) / len(array)\n    \n    # Calculate the deviation from the mean\n    deviation = array - mean\n    \n    # Square the deviations\n    square = deviation * deviation\n    \n    # Calculate the mean of the squared deviations\n    square_mean = sum(square) / len(square)\n    \n    # Calculate the square root of the mean of squared deviations\n    rmsd = square_mean.sqrt()\n    \n    return rmsd\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Calculate the mean of the array\n    mean = types.sint(sum(array)) / len(array)\n    \n    # Calculate the deviation from the mean\n    deviation = array - mean\n    \n    # Square the deviations\n    square = deviation * deviation\n    \n    # Calculate the mean of the squared deviations\n    square_mean = types.sint(sum(square)) / len(square)\n    \n    # Calculate the square root of the mean of the squared deviations\n    rmsd = types.sint.sqrt(square_mean)\n    \n    return rmsd\n", "model_name": "deepseek-v3"}
{"test_name": "logsumexp", "response_0": "from Compiler import types\nfrom Compiler import library\n\ndef logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp\n    \"\"\"\n    # Compute the maximum value in log_probs\n    _max = library.max(log_probs)\n    \n    # Subtract the maximum value from each element in log_probs\n    ds = log_probs - _max\n    \n    # Compute the sum of the exponentials of the differences\n    exp_sum = library.sum(library.exp(ds))\n    \n    # Return the result of the logsumexp computation\n    return _max + library.log(exp_sum)\n", "response_1": "def logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp in MP-SPDZ\n    \"\"\"\n    # Find the maximum value in log_probs\n    _max = max(log_probs)\n    \n    # Subtract the maximum value from each element in log_probs\n    ds = log_probs - _max\n    \n    # Compute the sum of the exponentials of the differences\n    exp_sum = sum(exp(ds))\n    \n    # Return the logsumexp result\n    return _max + log(exp_sum)\n", "model_name": "deepseek-v3"}
{"test_name": "binary_cross_entropy_loss", "response_0": "from Compiler import types, library\n\ndef binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss.\n    \"\"\"\n    # Avoid log(0) by clipping y_hat\n    y_hat = y_hat.max(0.001)\n    y_hat = y_hat.min(1 - 0.001)\n    \n    # Compute the binary cross-entropy loss\n    loss_part1 = y * y_hat.log2()\n    loss_part2 = (1 - y) * (1 - y_hat).log2()\n    loss = -(loss_part1 + loss_part2).mean()\n    \n    return loss\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss.\n    \"\"\"\n    # Avoid log(0) by clipping y_hat\n    y_hat = y_hat + (y_hat == 0) * 0.001 - (y_hat == 1) * 0.001\n    \n    # Compute the logarithms\n    log_y_hat = log2(y_hat)\n    log_1_minus_y_hat = log2(1 - y_hat)\n    \n    # Compute the loss\n    loss = - (y * log_y_hat + (1 - y) * log_1_minus_y_hat).average()\n    \n    return loss\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_less_equal", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is less than or equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are of the same length and type\n    less_eq = types.Array(len(arrayA), types.sint)\n    \n    for i in range(len(arrayA)):\n        less_eq[i] = arrayA[i] <= arrayB[i]\n    \n    return less_eq\n", "response_1": "def compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is less than or equal to arrayB.\"\"\"\n    less_eq = []\n    for i in range(len(arrayA)):\n        less_eq.append(arrayA[i] <= arrayB[i])\n    return less_eq\n", "model_name": "deepseek-v3"}
{"test_name": "RMS_prop_step", "response_0": "# Define the constants\nalpha = sfix(0.5)\nbeta = sfix(1.0)\n\n# Function to perform RMSprop step\ndef RMS_prop_step(grads, layers):\n    # Initialize the moving average of squared gradients\n    s = [sfix.Array(len(grad)) for grad in grads]\n    \n    # Iterate over the gradients and layers\n    for i in range(len(grads)):\n        grad = grads[i]\n        layer = layers[i]\n        \n        # Update the moving average of squared gradients\n        s[i] = beta * s[i] + (1 - beta) * grad * grad\n        \n        # Update the gradient\n        grad = alpha * (grad / (s[i].sqrt()))\n        \n        # Update the layer\n        layer = layer + grad\n        \n        # Update the layers list\n        layers[i] = layer\n    \n    return layers\n", "response_1": "from Compiler import types\n\ndef RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step.\n    \"\"\"\n    alpha = types.sfix(0.5)\n    beta = types.sfix(1.0)\n    s = [types.sfix.zeros_like(grad) for grad in grads]\n    \n    for i in range(len(grads)):\n        grad = grads[i]\n        layer = layers[i]\n        s[i] = beta * s[i] + (1 - beta) * grad * grad\n        grad = alpha * (grad / (s[i].sqrt()))\n        layer = layer + grad\n        layers[i] = layer\n    \n    return layers\n", "model_name": "deepseek-v3"}
{"test_name": "entropy", "response_0": "from util import if_else\nfrom Compiler.types import sint, cint\nfrom Compiler.library import print_ln, for_range\nfrom Compiler.util import log2\n\ndef entropy(y):\n    \"\"\"\n    Compute the entropy of the given array\n    \"\"\"\n    n = len(y)\n    sum_ = sint(0)\n    \n    # Iterate over unique elements in y\n    unique_elements = list(set(y))\n    for i in unique_elements:\n        # Count the occurrences of the current element\n        count = sint(0)\n        for j in range(n):\n            count += if_else(y[j] == i, sint(1), sint(0))\n        \n        # Calculate the probability and update the sum\n        prob = count / n\n        sum_ += - (prob * log2(prob))\n    \n    return sum_\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef entropy(y):\n    \"\"\"\n    Compute the entropy of the given array\n    \"\"\"\n    n = len(y)\n    sum_ = types.sfix(0)\n    unique_values = set(y)\n    \n    for i in unique_values:\n        v = sum([if_else(y[j] == i, 1, 0) for j in range(n)])\n        p = v / n\n        sum_ += - (p * p.log2())\n    \n    return sum_\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_exp", "response_0": "from Compiler import types\n\ndef compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D array.\"\"\"\n    # Convert the array to fixed-point representation\n    array_fixed = types.sfix.array(len(array))\n    for i in range(len(array)):\n        array_fixed[i] = types.sfix(array[i])\n    \n    # Compute the exponent of each element\n    exp = types.sfix.Array(len(array))\n    for i in range(len(array)):\n        exp[i] = array_fixed[i].exp()\n    \n    # Compute the sum of the exponentiated values\n    summation = types.sfix(0)\n    for i in range(len(exp)):\n        summation += exp[i]\n    \n    # Compute the softmax values\n    softmax = types.sfix.Array(len(array))\n    for i in range(len(exp)):\n        softmax[i] = exp[i] / summation\n    \n    return softmax\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D array.\"\"\"\n    # Compute the exponential of each element in the array\n    exp = array.apply(lambda x: types.sfix.exp(x))\n    \n    # Sum all the exponential values\n    summation = exp.sum()\n    \n    # Compute the softmax values by dividing each exponential by the summation\n    softmax = exp / summation\n    \n    return softmax\n", "model_name": "deepseek-v3"}
{"test_name": "tanh", "response_0": "class Tanh:\n\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        return sfloat.tanh(z)\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        tanh_x = sfloat.tanh(x)\n        return 1 - tanh_x * tanh_x\n", "response_1": "class Tanh:\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        return sfloat.tanh(z)\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        tanh_x = sfloat.tanh(x)\n        return 1 - tanh_x * tanh_x\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_tan", "response_0": "from math import sin, cos\n\ndef compute_tan(array):\n    \"\"\"This function calculates trigonometric tangent, element-wise.\"\"\"\n    tan_res = [sin(x) / cos(x) for x in array]\n    return tan_res\n", "response_1": "from Compiler import types\nfrom Compiler import floatingpoint\n\ndef compute_tan(array):\n    \"\"\"This function calculates the trigonometric tangent, element-wise.\"\"\"\n    tan_res = types.Array(len(array), types.sfix)\n    for i in range(len(array)):\n        x = array[i]\n        # Taylor series approximation for tan(x) around 0\n        tan_x = x + (x**3) / 3 + (2 * x**5) / 15 + (17 * x**7) / 315\n        tan_res[i] = tan_x\n    return tan_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_greater", "response_0": "def compute_greater(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of secret integers\n    greater_res = []\n    for i in range(len(arrayA)):\n        # Compare each element and store the result (1 if true, 0 otherwise)\n        greater_res.append(arrayA[i] > arrayB[i])\n    return greater_res\n", "response_1": "from util import if_else\nfrom Compiler.types import Array, sfix\n\ndef compute_greater(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than arrayB.\"\"\"\n    # Assuming arrayA and arrayB are of the same length and type (e.g., sfix)\n    greater_res = Array(len(arrayA), sfix)\n    for i in range(len(arrayA)):\n        greater_res[i] = if_else(arrayA[i] > arrayB[i], sfix(1), sfix(0))\n    return greater_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_maximum", "response_0": "from Compiler import types\n\ndef compute_maximum(arrayA, arrayB):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    # Assuming arrayA and arrayB are of type Array or similar in MP-SPDZ\n    max_ones = types.Array(arrayA.length, arrayA.value_type)\n    \n    for i in range(arrayA.length):\n        max_ones[i] = (arrayA[i] > arrayB[i]).if_else(arrayA[i], arrayB[i])\n    \n    return max_ones\n", "response_1": "def compute_maximum(arrayA, arrayB, size):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    max_ones = Array(size, sfix)\n    for i in range(size):\n        max_ones[i] = if_else(arrayA[i] > arrayB[i], arrayA[i], arrayB[i])\n    return max_ones\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_log2", "response_0": "def compute_log2(x):\n    \"\"\"This function calculates the base-2 logarithm of x using an iterative method.\"\"\"\n    if x <= 0:\n        raise ValueError(\"Input must be positive\")\n    \n    log2 = 0\n    while x >= 2:\n        x = x / 2\n        log2 += 1\n    return log2\n", "response_1": "def compute_log2(array):\n    \"\"\"This function calculates the base-2 logarithm of x in the input array using secure computation.\"\"\"\n    # Initialize an empty list to store the results\n    log2_array = []\n    \n    # Iterate over each element in the array\n    for x in array:\n        # Initialize the result to 0\n        log2 = 0\n        \n        # While x is greater than 1, divide it by 2 and increment the log2 value\n        while x > 1:\n            x = x / 2\n            log2 = log2 + 1\n        \n        # Append the result to the log2_array\n        log2_array.append(log2)\n    \n    return log2_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_absolute", "response_0": "from util import if_else\nfrom Compiler.types import sfix, sfloat\n\ndef obtain_absolute(array):\n    \"\"\"This function computes the absolute values in an array of secret-shared values.\"\"\"\n    abs_array = [if_else(val < 0, -val, val) for val in array]\n    return abs_array\n", "response_1": "from util import if_else\nfrom Compiler.types import Array, sint, cint\n\ndef obtain_absolute(array):\n    \"\"\"\n    This function computes the absolute values in an MP-SPDZ array.\n    :param array: Input array of type Array of sint or cint\n    :return: Array of the same type with absolute values\n    \"\"\"\n    abs_array = Array(len(array), array.value_type)\n    for i in range(len(array)):\n        abs_array[i] = if_else(array[i] < 0, -array[i], array[i])\n    return abs_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arctan", "response_0": "def compute_arctan(array):\n    \"\"\"This function calculates the trigonometric inverse tangent, element-wise, using a polynomial approximation.\"\"\"\n    arctan_res = Array(len(array))\n    for i in range(len(array)):\n        x = array[i]\n        # Polynomial approximation for arctan(x) in the range [-1, 1]\n        arctan_res[i] = x - (x**3) / 3 + (x**5) / 5 - (x**7) / 7\n    return arctan_res\n", "response_1": "from Compiler import types\n\ndef compute_arctan(array):\n    \"\"\"This function approximates the trigonometric inverse tangent, element-wise.\"\"\"\n    # Polynomial approximation for arctan(x) for x in [-1, 1]\n    def arctan_approx(x):\n        return x - x**3 / 3 + x**5 / 5 - x**7 / 7\n\n    # Apply the approximation element-wise\n    arctan_res = array.apply(arctan_approx)\n    return arctan_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_log", "response_0": "from Compiler import types\nfrom Compiler import library\nfrom Compiler import instructions\n\ndef compute_log(array):\n    \"\"\"This function calculates the natural logarithm for all p in the input array.\"\"\"\n    # Define the precision for the logarithm computation\n    precision = 20  # You can adjust this based on your needs\n    \n    # Initialize the result array\n    nlog = types.Array(len(array), types.sfix)\n    \n    # Compute the logarithm for each element in the array\n    for i in range(len(array)):\n        nlog[i] = library.log(array[i], precision)\n    \n    return nlog\n", "response_1": "from Compiler import types, library\n\ndef compute_log(array):\n    \"\"\"This function calculates the natural logarithm for all p in the input array.\"\"\"\n    # Assuming array is a list of secret-shared values\n    log_array = types.Array(len(array), types.sfix)\n    \n    for i in range(len(array)):\n        # Using the logarithm approximation available in MP-SPDZ\n        log_array[i] = library.log(array[i])\n    \n    return log_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_not_equal", "response_0": "def compute_not_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is not equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of secret-shared values\n    neq = [a != b for a, b in zip(arrayA, arrayB)]\n    return neq\n", "response_1": "def compute_not_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is not equal to arrayB.\"\"\"\n    # Initialize an empty list to store the result\n    neq = []\n\n    # Iterate over the elements of the arrays\n    for i in range(len(arrayA)):\n        # Compare the elements and append the result to the list\n        neq.append(arrayA[i] != arrayB[i])\n\n    return neq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_equal", "response_0": "def compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is equal to arrayB.\"\"\"\n    n = len(arrayA)\n    eq = Array(n, sint)  # Initialize an array to store the equality results\n\n    for i in range(n):\n        eq[i] = arrayA[i] == arrayB[i]  # Perform element-wise equality check\n\n    return eq\n", "response_1": "def compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of the same length\n    eq = []\n    for i in range(len(arrayA)):\n        eq.append(arrayA[i] == arrayB[i])\n    return eq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_true_divide", "response_0": "from Compiler import types\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"true divide between two secret-shared 1-d arrays.\"\"\"\n    # Ensure the arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must have the same length\"\n    \n    # Initialize an array to store the result\n    result = types.Array(len(arrayA), types.sfix)\n    \n    # Perform element-wise division\n    for i in range(len(arrayA)):\n        result[i] = arrayA[i] / arrayB[i]\n    \n    return result\n", "response_1": "def true_divide(arrayA, arrayB):\n    \"\"\"true divide between two MP-SPDZ 1-d arrays.\"\"\"\n    # Assuming arrayA and arrayB are of the same length\n    array = Array(len(arrayA), sfloat)\n    for i in range(len(arrayA)):\n        array[i] = arrayA[i] / arrayB[i]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_greater_equal", "response_0": "from util import if_else\nfrom Compiler.types import sgf2n, Array\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than or equal to arrayB.\"\"\"\n    n = len(arrayA)\n    greater_eq = Array(n, sgf2n)\n    \n    for i in range(n):\n        # Compute the difference between arrayA[i] and arrayB[i]\n        diff = arrayA[i] - arrayB[i]\n        # Check if the difference is non-negative\n        is_non_negative = diff >= 0\n        # Store the result in the greater_eq array\n        greater_eq[i] = if_else(is_non_negative, 1, 0)\n    \n    return greater_eq\n", "response_1": "from util import if_else\nfrom Compiler.types import sint\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is greater than or equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of sint (secret integers)\n    greater_eq = [if_else(a >= b, sint(1), sint(0)) for a, b in zip(arrayA, arrayB)]\n    return greater_eq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_negative", "response_0": "from Compiler import types\n\ndef negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    # Assuming arrayA is a list of sfix or sfloat values in MP-SPDZ\n    array = types.Array(len(arrayA), arrayA[0].__class__)\n    for i in range(len(arrayA)):\n        array[i] = -arrayA[i]\n    return array\n", "response_1": "def negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    # Create an array to store the result\n    result = Array(len(arrayA), sint)\n    \n    # Iterate over the input array and compute the negative of each element\n    for i in range(len(arrayA)):\n        result[i] = -arrayA[i]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_power", "response_0": "def power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    # Initialize an empty array to store the results\n    result = Array(len(arrayA), sint)\n    \n    # Loop through each element in the arrays\n    for i in range(len(arrayA)):\n        x = arrayA[i]\n        y = arrayB[i]\n        # Compute x^y using MP-SPDZ's power operation\n        result[i] = x ** y\n    \n    return result\n", "response_1": "# Import necessary MP-SPDZ libraries\nfrom Compiler import types\n\ndef power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    # Ensure both arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must have the same length\"\n    \n    # Initialize an array to store the result\n    result = types.Array(len(arrayA), types.sint)\n    \n    # Compute the power element-wise\n    for i in range(len(arrayA)):\n        result[i] = arrayA[i] ** arrayB[i]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_exp2", "response_0": "def compute_exp2(array):\n    \"\"\"This function calculates 2^p for all p in the input array.\"\"\"\n    exp = Array(len(array), sint)\n    for i in range(len(array)):\n        exp[i] = 2 ** array[i]\n    return exp\n", "response_1": "def compute_exp2(array):\n    \"\"\"This function calculates 2**p for all p in the input array.\"\"\"\n    exp = []\n    for p in array:\n        exp.append(1 << p)  # Equivalent to 2**p using bitwise shift\n    return exp\n", "model_name": "deepseek-v3"}
{"test_name": "cross_entropy_loss_class", "response_0": "class CrossEntropy:\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss.\n        \"\"\"\n        # Compute the element-wise product of y and log2(y_pred)\n        log_y_pred = log2(y_pred)\n        product = y * log_y_pred\n        \n        # Sum the elements of the product and negate the result\n        cross_entropy = -sum(product)\n        \n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross entropy loss.\n        \"\"\"\n        n = len(y)\n        \n        # Compute the gradient\n        grad = y_pred - y\n        \n        # Normalize the gradient by the number of samples\n        grad = grad / n\n        \n        return grad\n", "response_1": "class CrossEntropy:\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss.\n        \"\"\"\n        # Compute the element-wise product of y and log2(y_pred)\n        log_y_pred = sfloat.log2(y_pred)\n        product = y * log_y_pred\n        \n        # Sum the elements and negate the result\n        cross_entropy = -sfloat.sum(product)\n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross entropy loss\n        \"\"\"\n        n = sfloat(len(y))\n        grad = y_pred - y\n        grad = grad / n\n        return grad\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arccos", "response_0": "# MP-SPDZ program to approximate arccos using a Taylor series approximation\n\n# Function to compute the factorial of a number\ndef factorial(n):\n    res = 1\n    for i in range(1, n + 1):\n        res = res * i\n    return res\n\n# Function to compute the power of a number\ndef power(x, n):\n    res = 1\n    for _ in range(n):\n        res = res * x\n    return res\n\n# Function to approximate arccos using Taylor series\ndef arccos(x):\n    # Ensure x is within the domain of arccos [-1, 1]\n    if x < -1 or x > 1:\n        raise ValueError(\"x must be in the range [-1, 1]\")\n\n    # Taylor series approximation of arccos(x) = pi/2 - (x + (x^3)/6 + (3x^5)/40 + ...)\n    result = sfix(3.141592653589793 / 2)  # pi/2\n    term = x\n    for n in range(1, 10):  # Adjust the number of terms for better accuracy\n        term = term * x * x\n        if n % 2 == 0:\n            continue\n        coeff = sfix(1) / factorial(2 * n + 1)\n        result = result - coeff * term\n    return result\n\n# Function to compute arccos element-wise for an array\ndef compute_arccos(array):\n    arccos_res = []\n    for x in array:\n        arccos_res.append(arccos(x))\n    return arccos_res\n", "response_1": "from Compiler import types\n\ndef compute_arccos(array):\n    \"\"\"This function calculates the trigonometric inverse cosine, element-wise.\"\"\"\n    # Polynomial approximation of arccos(x) for x in [-1, 1]\n    # arccos(x) \u2248 \u03c0/2 - x - x^3/6 - x^5/40 - x^7/112 - x^9/288\n    pi_over_2 = types.sfix(3.14159265358979323846 / 2)\n    arccos_res = pi_over_2 - array - (array ** 3) / 6 - (array ** 5) / 40 - (array ** 7) / 112 - (array ** 9) / 288\n    return arccos_res\n", "model_name": "deepseek-v3"}
{"test_name": "r2_score", "response_0": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score.\n    \"\"\"\n    # Calculate the mean of y_test\n    mean_y_test = sum(y_test) / len(y_test)\n    \n    # Calculate the total sum of squares\n    total_sum_squares = sum((y_test - mean_y_test) ** 2)\n    \n    # Calculate the residual sum of squares\n    residual_sum_squares = sum((y_test - y_hat) ** 2)\n    \n    # Compute the R2 score\n    r2 = 1 - residual_sum_squares / total_sum_squares\n    \n    return r2\n", "response_1": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score.\n    \"\"\"\n    # Compute the mean of y_test\n    mean_y_test = sum(y_test) / len(y_test)\n    \n    # Compute the total sum of squares\n    total_sum_squares = sum((y_test - mean_y_test) ** 2)\n    \n    # Compute the residual sum of squares\n    residual_sum_squares = sum((y_test - y_hat) ** 2)\n    \n    # Compute and return the r2 score\n    return 1 - residual_sum_squares / total_sum_squares\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arcsin", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef compute_arcsin(array):\n    \"\"\"This function calculates the trigonometric inverse sine, element-wise.\"\"\"\n    # Define a polynomial approximation for arcsin\n    def arcsin_approx(x):\n        # Coefficients for the polynomial approximation of arcsin\n        a0 = 0.0\n        a1 = 1.0\n        a3 = 0.16666666666666666\n        a5 = 0.075\n        a7 = 0.044642857142857144\n        \n        # Polynomial approximation: arcsin(x) \u2248 a1*x + a3*x^3 + a5*x^5 + a7*x^7\n        x2 = x * x\n        x3 = x * x2\n        x5 = x3 * x2\n        x7 = x5 * x2\n        return a1 * x + a3 * x3 + a5 * x5 + a7 * x7\n    \n    # Apply the approximation to each element in the array\n    arcsin_res = array.get_type().Array(len(array))\n    for i in range(len(array)):\n        x = array[i]\n        arcsin_res[i] = if_else(x < 0, -arcsin_approx(-x), arcsin_approx(x))\n    \n    return arcsin_res\n", "response_1": "from fixedpt import *\n\ndef compute_arcsin(array):\n    \"\"\"This function calculates trigonometric inverse sine, element-wise.\"\"\"\n    arcsin_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        arcsin_res[i] = sfix.asin(array[i])\n    return arcsin_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_true_divide2", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"Secure element-wise division between two secret-shared 1D arrays.\"\"\"\n    res = Array(len(arrayA), sfloat)\n    for i in range(len(arrayA)):\n        res[i] = arrayA[i] / arrayB[i]\n    return res\n", "response_1": "from Compiler.types import Array, sfix\nfrom Compiler.library import for_range\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"True divide between two arrays in MP-SPDZ.\"\"\"\n    # Assuming arrayA and arrayB are of the same length and type sfix\n    n = len(arrayA)\n    res = Array(n, sfix)\n    \n    @for_range(n)\n    def _(i):\n        res[i] = arrayA[i] / arrayB[i]\n    \n    return res\n", "model_name": "deepseek-v3"}
{"test_name": "square_error_loss", "response_0": "def square_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    diff = y_pred - y\n    squared_diff = diff * diff\n    sum_squared_diff = sum(squared_diff)\n    return 0.5 * sum_squared_diff\n", "response_1": "def squre_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    # Compute the difference between y_pred and y\n    diff = y_pred - y\n    \n    # Compute the squared norm of the difference\n    squared_norm = diff * diff\n    \n    # Sum the squared differences (assuming y and y_pred are vectors)\n    sum_squared_diff = sum(squared_norm)\n    \n    # Multiply by 0.5 to get the final loss\n    loss = 0.5 * sum_squared_diff\n    \n    return loss\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_less", "response_0": "def compute_less(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e., whether arrayA is less than arrayB.\n    Both arrayA and arrayB are lists of secret-shared integers.\n    The result is a list of secret-shared bits where 1 indicates True (arrayA[i] < arrayB[i]) and 0 indicates False.\n    \"\"\"\n    less_res = []\n    for a, b in zip(arrayA, arrayB):\n        # Compute the difference (b - a) and check if it is positive\n        diff = b - a\n        # The result is 1 if diff > 0, otherwise 0\n        less_res.append(diff > 0)\n    return less_res\n", "response_1": "from Compiler import types\n\ndef compute_less(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is less than arrayB.\n    Both arrayA and arrayB are assumed to be arrays of secret-shared integers or fixed-point numbers.\n    \"\"\"\n    # Ensure that the arrays are of the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must be of the same length\"\n    \n    # Initialize an empty array to store the result\n    less_res = types.Array(len(arrayA), types.sint)\n    \n    # Perform element-wise comparison\n    for i in range(len(arrayA)):\n        less_res[i] = arrayA[i] < arrayB[i]\n    \n    return less_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_cos", "response_0": "def compute_cosine(array):\n    \"\"\"This function calculates the trigonometric cosine, element-wise, using a Taylor series approximation.\"\"\"\n    # Taylor series approximation for cosine: cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + ...\n    cos_res = []\n    for x in array:\n        x_squared = x * x\n        x_fourth = x_squared * x_squared\n        x_sixth = x_fourth * x_squared\n        cos_x = 1 - x_squared / 2 + x_fourth / 24 - x_sixth / 720\n        cos_res.append(cos_x)\n    return cos_res\n", "response_1": "# Taylor series approximation for cosine function\ndef taylor_cos(x, terms=10):\n    \"\"\"Approximate cosine using Taylor series expansion.\"\"\"\n    result = 1  # First term of the series\n    sign = -1\n    power = 2\n    factorial = 2\n    for i in range(1, terms):\n        result += sign * (x ** power) / factorial\n        sign *= -1\n        power += 2\n        factorial *= (power - 1) * power\n    return result\n\ndef compute_cosine(array):\n    \"\"\"Calculate trigonometric cosine, element-wise, using Taylor series approximation.\"\"\"\n    cos_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        cos_res[i] = taylor_cos(array[i])\n    return cos_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_sin", "response_0": "# Define a function to compute the factorial of a number\ndef factorial(n):\n    res = 1\n    for i in range(1, n + 1):\n        res *= i\n    return res\n\n# Define a function to compute the sine of a number using Taylor series expansion\ndef sin(x, terms=5):\n    result = 0\n    for n in range(terms):\n        term = ((-1) ** n) * (x ** (2 * n + 1)) / factorial(2 * n + 1)\n        result += term\n    return result\n\n# Define a function to compute the sine of each element in an array\ndef compute_sine(array):\n    sin_res = Array(len(array), sint)\n    for i in range(len(array)):\n        sin_res[i] = sin(array[i])\n    return sin_res\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef taylor_sin(x, terms=5):\n    \"\"\"Approximate sine using Taylor series expansion.\"\"\"\n    result = x\n    sign = -1\n    power = x\n    factorial = 1\n    for i in range(1, terms):\n        power = power * x * x\n        factorial = factorial * (2 * i) * (2 * i + 1)\n        term = power / factorial\n        result = result + sign * term\n        sign = sign * -1\n    return result\n\ndef compute_sine(array):\n    \"\"\"Calculate trigonometric sine, element-wise.\"\"\"\n    sin_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        sin_res[i] = taylor_sin(array[i])\n    return sin_res\n", "model_name": "deepseek-v3"}
{"test_name": "update_weights", "response_0": "def update_weights(m, A, X, Y):\n    \"\"\"\n    Update the weights and return the difference.\n    \"\"\"\n    # Compute the dot product of X and (A - Y)\n    diff = A - Y\n    dot_product = X.dot(diff)\n    \n    # Compute the weight update\n    dw = dot_product * (1 / m)\n    \n    return dw\n", "response_1": "def update_weights(m, A, X, Y):\n    \"\"\"\n    Update the weights and return the difference.\n    \"\"\"\n    # Compute the dot product of X and (A - Y)\n    diff = A - Y\n    dot_product = X * diff\n\n    # Compute the average by dividing by m\n    dw = dot_product / m\n\n    return dw\n", "model_name": "deepseek-v3"}
{"test_name": "toy_layer", "response_0": "from Compiler.library import sfix, sfix_matrix, sfix_vector, sfix_array\n\ndef sigmoid(x):\n    return 1 / (1 + sfix.exp(-x))\n\ndef toy_layer(input_data, weights, biases):\n    # Assuming input_data, weights, and biases are sfix_matrix or sfix_vector types\n    layer1_input = sfix_matrix.dot(input_data, weights[0]) + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    layer2_input = sfix_matrix.dot(layer1_output, weights[1]) + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    return layer2_output\n", "response_1": "from Compiler import types as sfix\nfrom Compiler import library as lib\nfrom Compiler import util\n\ndef sigmoid(x):\n    return sfix.sigmoid(x)\n\ndef toy_layer(input_data, weights, biases):\n    # First layer\n    layer1_input = lib.dot(input_data, weights[0]) + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    \n    # Second layer\n    layer2_input = lib.dot(layer1_output, weights[1]) + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    \n    return layer2_output\n", "model_name": "deepseek-v3"}
