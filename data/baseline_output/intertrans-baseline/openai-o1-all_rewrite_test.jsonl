{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    length = len(arr)\n    # Create a new array of the same length\n    new_array = [sint(0) for _ in range(length)]\n\n    # Copy elements before the given index\n    for i in range(index):\n        new_array[i] = arr[i]\n\n    # Shift elements after the given index forward by one\n    for i in range(index, length - 1):\n        new_array[i] = arr[i + 1]\n\n    # Place the moved element at the end\n    new_array[length - 1] = arr[index]\n\n    return new_array\n", "response_1": "def move_to_end(arr, index):\n    n = len(arr)\n    new_arr = Array(n, sint)\n    # Copy elements before the index\n    for i in range(index):\n        new_arr[i] = arr[i]\n    # Copy elements after the index\n    for i in range(index, n - 1):\n        new_arr[i] = arr[i + 1]\n    # Place the element at the given index at the end\n    new_arr[n - 1] = arr[index]\n    return new_arr\n", "model_name": "azure-openai-o1"}
{"test_name": "second_largest", "response_0": "# Utility function for \"OR\" of two secret bits.\ndef s_or(x, y):\n    # x and y are sbit or sint in {0,1}.\n    return x + y - x * y\n\ndef second_largest(arr):\n    # Assume arr is a list of secret shared integers (sint).\n    \n    # The idea is to keep track of two indices in arr[0] and arr[1].\n    # By the end, arr[0] and arr[1] will hold the two largest elements,\n    # and we return the smaller of these two.\n    \n    # Start loop from 2 to len(arr).\n    n = len(arr)\n    for i in range(2, n):\n        # c0 = (arr[i] > arr[0])\n        c0 = (arr[i] > arr[0])\n        # c1 = (arr[i] > arr[1])\n        c1 = (arr[i] > arr[1])\n        # c = c0 OR c1\n        c = s_or(c0, c1)\n\n        # idx = 0 if arr[0] < arr[1], else 1\n        tmp = (arr[0] < arr[1])  # tmp is 1 if arr[0] < arr[1], else 0\n        idx = 1 - tmp            # if tmp=1 => idx=0, else idx=1\n\n        # Obvious branching: arr[idx] = arr[i] if c is 1\n        # Data-oblivious updates:\n        arr[0] = c * (1 - idx) * arr[i] + (1 - c * (1 - idx)) * arr[0]\n        arr[1] = c * idx       * arr[i] + (1 - c * idx)       * arr[1]\n\n    # Finally, return the smaller of arr[0] and arr[1],\n    # which is the second largest number.\n    final_cmp = (arr[0] < arr[1])\n    return final_cmp * arr[0] + (1 - final_cmp) * arr[1]\n", "response_1": "# MP-SPDZ code translation of the given Python function\n\n# This function finds the second largest element in a secure array.\n# Note that direct indexing by a secret bit (e.g., arr[idx]) is not supported\n# in MP-SPDZ the same way as in Python, so we implement conditional replacement\n# via secret-shared booleans (cond, c, etc.). Here, we assume 'arr' is\n# a list of secure types (e.g., sfix or sint), and 'n' is the length of the list.\n\ndef second_largest(arr, n):\n    # Process elements from index 2 to n-1\n    for i in range(2, n):\n        # Secure bits indicating if arr[i] is greater than arr[0] or arr[1]\n        c1 = arr[i] > arr[0]\n        c2 = arr[i] > arr[1]\n\n        # Combine the bits for an \"or\"-like condition\n        cond = c1 + c2 - c1 * c2  # This yields 1 if either c1 or c2 is 1, else 0\n\n        # Determine which index is smaller (arr[0] < arr[1])?\n        c = arr[0] < arr[1]\n\n        # If cond == 1, replace the smaller of the two with arr[i]\n        # (When cond == 0, these assignments do nothing.)\n        arr[0] = arr[0] * (1 - cond * c) + arr[i] * (cond * c)\n        arr[1] = arr[1] * (1 - cond * (1 - c)) + arr[i] * (cond * (1 - c))\n\n    # Finally, return the smaller of arr[0] and arr[1], since that is\n    # the second largest, per the original Python logic.\n    c3 = arr[0] < arr[1]\n    return arr[0] * c3 + arr[1] * (1 - c3)\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_true", "response_0": "from Compiler.types import sbool\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the secret-shared boolean array (arr) contains a True\n    by performing a logical OR over all entries.\n    \"\"\"\n    ret = sbool(0)\n    for b in arr:\n        ret = ret | b\n    return ret\n", "response_1": "def exists_true(arr):\n    ret = s_bool(0)\n    for x in arr:\n        ret = ret | x\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_indicator", "response_0": "# Declare the predicator function you intend to use.\n# It should take a secure type (e.g., sint) and return a secure 0/1 result.\n# For example, a predicator that checks if an element is greater than 0:\ndef predicator(x):\n    return x > 0\n\n# Translated \"array_indicator\" function.\n# It expects:\n#  - arr: an Array of secure values\n#  - predicator: a function mapping each secure value to a secure boolean/int result\ndef array_indicator(arr, predicator):\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "# array_indicator.mpc\n\n# In MP-SPDZ, \"predicator\" cannot be passed directly as a Python function.\n# One approach is to define the \"predicator\" logic inline or as an MPC macro/function\n# that returns a secure type. Below, we illustrate a generic translation of the\n# Python code snippet into MP-SPDZ style. Adapt as needed for your specific logic\n# and types (e.g., sfix, sint, etc.).\n\ndef array_indicator(arr, predicator):\n    n = len(arr)\n    ret = [None] * n\n    for i in range(n):\n        # predicator should be a function or inline logic that takes a secure value\n        # and returns a secure result. For example:\n        #   ret[i] = (arr[i] > sfix(0))\n        # if the predicator is \"greater than zero\".\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    sum_prod = sint(0)\n    for x, y in zip(vec1, vec2):\n        sum_prod += x * y\n    return sum_prod\n", "response_1": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    # Initialize a secret-shared integer summation\n    result = sint(0)\n    # Iterate over each pair of elements, multiply, and accumulate\n    for i in range(len(vec1)):\n        result += vec1[i] * vec2[i]\n    # Return the final secret-shared result\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift_2", "response_0": "from Compiler.types import sint, Array\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array by 1 index.\n    For example, [a0, a1, a2] will be shifted to [a1, a2, a0].\n    \"\"\"\n    n = len(a)\n    shifted = Array(n, sint)\n    for i in range(n):\n        shifted[i] = a[(i - 1 + n) % n]\n    return shifted\n", "response_1": "def array_shift(a):\n    n = len(a)\n    # Create a new array of secret integers with the same length\n    shifted = [sint(0) for _ in range(n)]\n    \n    # Assign each element from the position (i-1) modulo n\n    for i in range(n):\n        shifted[i] = a[(i - 1) % n]\n    \n    return shifted\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_than_scalar", "response_0": "# mp-spdz code for array_greater_than_scalar\n# This implementation assumes arr is a list of sint (secret integers) \n# and bound is also a sint. The comparison \">\" between sint values yields an sbit.\ndef array_greater_than_scalar(arr, bound):\n    ret = []\n    for i in range(len(arr)):\n        ret.append(arr[i] > bound)\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array of secret-shared integers (arr) and a secret-shared (or clear) integer (bound),\n    return a list of secret bits indicating which elements are greater than the bound.\n    \"\"\"\n    ret = []\n    for x in arr:\n        # The '>' operator in MP-SPDZ on secret/shared integers returns a secret bit\n        ret.append(x > bound)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises_2", "response_0": "# In MP-SPDZ, we use secure data types (sint, sfix, etc.) instead of regular Python integers.\n# Below is an example translation of the Python function into MP-SPDZ style code.\n\nn = regint.get_input_from(0)          # Securely read the array length\narr = [sfix.get_input_from(0) for _ in range(n)]  # Securely read array elements\n\ndef count_rises(array):\n    # Prepare a list to store the comparison results (1 if array[i] < array[i+1], else 0)\n    flag = [sint(0) for _ in range(n - 1)]\n    for i in range(n - 1):\n        flag[i] = array[i] < array[i + 1]\n\n    # Sum up the results\n    count = sint(0)\n    for i in range(n - 1):\n        count += flag[i]\n\n    return count\n\n# Call the secure function and reveal the result\nresult = count_rises(arr)\nprint_ln(\"Count of rises: %s\", result.reveal())\n", "response_1": "# You can use sfix or sint depending on your array element types.\n# In this example, we assume they are sfix.\n# This function returns the number of times an element is\n# followed by a larger value in a secure manner.\n\nfrom Compiler.types import sfix\n\ndef count_rises(arr):\n    n = len(arr)\n    count = sfix(0)\n    for i in range(n - 1):\n        count += (arr[i] < arr[i+1])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    n = len(arr)\n    for i in range(n):\n        # If index i is even, decrement by 1; if odd, increment by 1\n        if i % 2 == 0:\n            arr[i] = arr[i] - 1\n        else:\n            arr[i] = arr[i] + 1\n    return arr\n", "response_1": "`\ndef choppy_plus_minus(arr):\n    n = len(arr)\n    result = Array(n, sint)\n    for i in range(n):\n        idx = regint(i)\n        cond = idx % 2\n        result[i] = arr[i] + (2 * cond - 1)\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef how_many_roots(a: sint, b: sint, c: sint):\n    d = b * b - 4 * a * c\n    cond_pos = d > 0\n    cond_zero = d == 0\n    two_roots = 2 * cond_pos\n    one_root_by_discriminant = cond_zero\n    ret2 = two_roots + one_root_by_discriminant\n    ret1 = if_else(b == 0, 0, 1)\n    return if_else(a == 0, ret1, ret2)\n", "response_1": "from Compiler.types import sfix\n\ndef how_many_roots(a, b, c):\n    # a, b, c are sfix values\n    eq0_a = a.equal(0)\n    eq0_b = b.equal(0)\n    disc = b * b - 4 * a * c\n    eq0_disc = disc.equal(0)\n    gt0_disc = disc > 0\n\n    # If a == 0, then return 0 if b == 0 else 1\n    ret_val_if_a_eq0 = eq0_b.if_else(0, 1)\n    # Otherwise return 2 if disc > 0, 1 if disc == 0, else 0\n    ret_val_if_a_neq0 = gt0_disc.if_else(2, eq0_disc.if_else(1, 0))\n\n    return eq0_a.if_else(ret_val_if_a_eq0, ret_val_if_a_neq0)\n\ndef main():\n    # Reading coefficients a, b, c as inputs from player 0\n    a = sfix.get_input_from(0)\n    b = sfix.get_input_from(0)\n    c = sfix.get_input_from(0)\n    result = how_many_roots(a, b, c)\n    result.print_ln('%s\\n')\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied", "response_0": "# MP-SPDZ translation of the count_satisfied function:\n# Counts how many elements in a secret-shared array 'arr' \n# are less than a secret-shared 'threshold'.\n\ndef count_satisfied(arr, threshold):\n    # Step 1: Initialize accumulation with secret integer 0\n    summation = sint(0)\n    \n    # Step 2: Iterate over the array\n    for x in arr:\n        # Step 3: Compare each element with threshold, resulting in a secret bit\n        flag = (x < threshold)\n        # Step 4: Accumulate the secret bit\n        summation += flag\n    \n    # Step 5: Return the final secret sum\n    return summation\n", "response_1": "from Compiler.types import sint, sbit, cfix\nfrom Compiler.library import for_range\n\n# A simple predicator function returning 1 if e > 0 else 0.\ndef predicator(e):\n    # Compare e with 0, yielding a secret bit\n    comparison_bit = e > cfix(0)\n    # Convert that secret bit to a secret integer for arithmetic\n    return comparison_bit.if_else(sint(1), sint(0))\n\n# MP-SPDZ-style translation of the Python \"count_satisfied\" function.\ndef count_satisfied(arr):\n    s = sint(0)\n    # Loop over each secret-shared value in arr\n    for e in arr:\n        s += predicator(e)\n    return s\n\ndef main():\n    pass\n", "model_name": "azure-openai-o1"}
{"test_name": "traverse_and_sum", "response_0": "# Securely compute the sum of element-wise products of two arrays in MP-SPDZ\n# Differences from Python:\n#  - Use secure data types (sint).\n#  - No native Python lists with comprehensions, we must use loops instead.\n\nfrom Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef traverse_and_sum(arr1, arr2, length):\n    result = sint(0)\n    for i in range(length):\n        result += arr1[i] * arr2[i]\n    return result\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    length = len(arr1)\n    total_sum = sfix(0)\n    for i in range(length):\n        total_sum += arr1[i] * arr2[i]\n    return total_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "array_round", "response_0": "from Compiler.types import sfix\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer (approximate).\n    \"\"\"\n    n = len(arr)\n    ret = [sfix(0) for _ in range(n)]\n    for i in range(n):\n        # vround() returns an sfix rounded to the nearest integer\n        ret[i] = arr[i].vround()\n    return ret\n", "response_1": "# This MP-SPDZ program rounds each element of a secret-shared array to the nearest integer\n# using a simple \"round half up\" rule (not Python's default \"round half to even\" rule).\n\nfrom Compiler.types import sfix, sint\n\ndef array_round(n):\n    # 'n' is the length of the input array.\n    # The input array is assumed to be read or assigned into an sfix.Array(n) named 'arr' beforehand.\n    # This function returns a sint.Array(n) with each element holding the nearest integer.\n    arr = sfix.Array(n)\n    ret = sint.Array(n)\n    for i in range(n):\n        val = arr[i] + sfix(0.5)\n        floored = val.floor()  # floor returns sfix with the integer part\n        ret[i] = floored.to_sint()\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr, n):\n    # arr and brr: secret-shared numeric arrays of length n\n    # ret: secret-shared integer array of length n\n    ret = sint.Array(n)\n    for i in range(n):\n        comparison_bit = arr[i] < brr[i]\n        # If arr[i] < brr[i], output 0; otherwise 1\n        ret[i] = comparison_bit.if_else(sint(0), sint(1))\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i]>=brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(arr)\n    # Use a secret integer array for storing the comparison results\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # Convert the boolean (or sbit) comparison result into a secret integer 1 or 0\n        ret[i] = (arr[i] >= brr[i]).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint, Array\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        # Convert the comparison result (sbit) to sint\n        ret[i] = sint(arr[i] < 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # Compare arr[i] with 0, generating a secret bit indicating negativity\n        negative_bit = (arr[i] < 0)\n        # Convert the secret bit to a secret integer 1 or 0\n        ret[i] = negative_bit.if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b, n, m):\n    \"\"\"\n    a, b: arrays of secure (or clear) types in MP-SPDZ\n    n, m: their respective lengths, provided as compile-time constants or clear integer values\n    Returns an array (ret) whose length is max(n, m) in MP-SPDZ,\n    where ret[i] = a[i] - b[i] if 0 <= i < min(n,m), \n    and the rest of ret is derived from padding rules consistent with the Python version.\n    \"\"\"\n    # Create the return array with length up to max(n, m).\n    # In actual MP-SPDZ usage, n and m must be known at compile time (or clear).\n    ret_len = n if n > m else m\n    ret = Array(ret_len, a[0].type)  # Using the same type as a[0], which can be sint, sfix, etc.\n\n    # Compute the elementwise subtraction for the overlapping part.\n    length_of_zip = n if n < m else m\n    @for_range(length_of_zip)\n    def _(i):\n        ret[i] = a[i] - b[i]\n\n    # Fill the difference from whichever array is longer.\n    # If a is longer, its extra elements go as-is. If b is longer, its extra elements go as negative.\n    if n < m:\n        @for_range_opt(n, m)  # from n to m-1\n        def _(i):\n            ret[i] = -b[i]\n    elif n > m:\n        @for_range_opt(m, n)  # from m to n-1\n        def _(i):\n            ret[i] = a[i]\n    # If lengths are equal, there is no padding.\n\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    la = len(a)\n    lb = len(b)\n    ret = []\n    \n    # Subtract over the overlapping range\n    for i in range(min(la, lb)):\n        ret.append(a[i] - b[i])\n    \n    # If 'a' is longer, append the remaining elements from 'a'\n    if la > lb:\n        for i in range(lb, la):\n            ret.append(a[i])\n    \n    # If 'b' is longer, append the negation of the remaining elements of 'b'\n    elif lb > la:\n        for i in range(la, lb):\n            ret.append(-b[i])\n    \n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_process(arr):\n    \"\"\"\n    MP-SPDZ version of array_process.\n    This function takes an array of secure integers and applies\n    a fixed operation to each element (e.g., add 1 here).\n    Modify this body to change the operation as needed.\n    \"\"\"\n    n = len(arr)\n    res = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # Replace 'arr[i] + 1' with the desired operation\n        res[i] = arr[i] + 1\n    return res\n", "response_1": "# In MP-SPDZ, there is no direct way to pass a function as an argument\n# the way Python does. Below is a conceptual translation that shows\n# how you might structure \"array_process\" to iterate over an array and\n# apply a transformation. You need to manually inline or macro-expand\n# the intended \"func\" within the loop.\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    Note: 'func' cannot be passed around like in Python. You must\n    replace or inline its logic directly here or via a macro.\n    \"\"\"\n    n = len(arr)\n    out = sfix.Array(n)\n    @for_range(n)\n    def _(i):\n        # Replace 'func' call with your own logic or macro:\n        out[i] = func(arr[i])  # Not straightforwardly supported in MP-SPDZ\n    return out\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift", "response_0": "from Compiler.types import sfix\n\ndef array_shift(a):\n    n = len(a)\n    # Create a new array to hold the shifted values\n    shifted_array = sfix.Array(n)\n    # The first element is the last element of the original array\n    shifted_array[0] = a[n - 1]\n    # Each subsequent element moves over by one position\n    for i in range(1, n):\n        shifted_array[i] = a[i - 1]\n    return shifted_array\n", "response_1": "from Compiler.types import sint\n\ndef array_shift(a):\n    n = len(a)\n    temp = a[n - 1]\n    for i in range(n - 1, 0, -1):\n        a[i] = a[i - 1]\n    a[0] = temp\n    return a\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_select", "response_0": "# In MP-SPDZ, we typically work with secure types (e.g., sfix).\n# Below is a direct translation of the Python code into MP-SPDZ style.\n\nfrom Compiler.types import sfix\n\ndef compare_and_select(a, b):\n    n = len(a)\n    ret_array = [None] * n\n    for i in range(n):\n        # (a[i] > b[i]) generates a secure boolean, used to select between a[i] and b[i].\n        ret_array[i] = (a[i] > b[i]).if_else(a[i], b[i])\n    return ret_array\n", "response_1": "from Compiler.types import sfix\n\ndef compare_and_select(a, b):\n    n = len(a)\n    ret_array = [sfix(0) for _ in range(n)]\n    for i in range(n):\n        cond = a[i] > b[i]\n        ret_array[i] = cond.if_else(a[i], b[i])\n    return ret_array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract", "response_0": "# In MP-SPDZ, array lengths are typically known at compile time. \n# We assume 'a' and 'b' are python lists of secure data (e.g., sfix or sint).\n# This function returns a new array (of secure data) containing elementwise a[i] - b[i],\n# automatically padding the shorter list with zeros.\n# No usage example is included in this code block.\n\ndef array_subtract(a, b):\n    import math\n    from Compiler.types import sfix  # or replace with sint/int depending on your use-case\n\n    n = len(a)\n    m = len(b)\n    length = max(n, m)\n    result = sfix.Array(length)\n\n    for i in range(length):\n        val_a = a[i] if i < n else sfix(0)\n        val_b = b[i] if i < m else sfix(0)\n        result[i] = val_a - val_b\n\n    return result\n", "response_1": "def array_subtract(a, b):\n    # a and b are arrays of secure type, e.g. sfix in MP-SPDZ\n    len_a = len(a)\n    len_b = len(b)\n    ret_len = max(len_a, len_b)\n\n    ret = sfix.Array(ret_len)\n\n    if len_a < len_b:\n        a_pad = sfix.Array(ret_len)\n        for i in range(ret_len):\n            if i < len_a:\n                a_pad[i] = a[i]\n            else:\n                a_pad[i] = sfix(0)\n        for i in range(ret_len):\n            ret[i] = a_pad[i] - b[i]\n    else:\n        b_pad = sfix.Array(ret_len)\n        for i in range(ret_len):\n            if i < len_b:\n                b_pad[i] = b[i]\n            else:\n                b_pad[i] = sfix(0)\n        for i in range(ret_len):\n            ret[i] = a[i] - b_pad[i]\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    n = len(c)\n    # Create a new array with double the length of the input array\n    d = Array(2 * n, c[0].type)\n    # Copy elements from the original array twice\n    for i in range(n):\n        d[i] = c[i]\n        d[i + n] = c[i]\n    return d\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    n = len(c)\n    c_repeated = Array(2 * n, c[0].reg_type)\n    for i in range(n):\n        c_repeated[i] = c[i]\n    for i in range(n):\n        c_repeated[n + i] = c[i]\n    return c_repeated\n", "model_name": "azure-openai-o1"}
{"test_name": "zeros", "response_0": "def zeros(num):\n    # Return the all-zero array with length num.\n    zero_array = Array(num, sfix)\n    for i in range(num):\n        zero_array[i] = sfix(0)\n    return zero_array\n", "response_1": "from Compiler.types import sint, Array\n\ndef zeros(num):\n    arr = Array(num, sint)\n    for i in range(num):\n        arr[i] = sint(0)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    \"\"\"\n    For the given secret-shared array (arr), clip each element to [lower_bound, upper_bound].\n    \"\"\"\n    n = len(arr)\n    clipped = Array(n, sfix)\n    for i in for_range(n):\n        above_upper = arr[i] >= upper_bound\n        below_lower = arr[i] <= lower_bound\n        clipped[i] = above_upper * upper_bound + \\\n                     (1 - above_upper) * (\n                         below_lower * lower_bound + (1 - below_lower) * arr[i]\n                     )\n    return clipped\n", "response_1": "from Compiler.types import sfix\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    clipped_arr = []\n    for x in arr:\n        # Check if x >= upper_bound\n        cond_upper = (x - upper_bound).ge0()\n        # Check if x > lower_bound\n        cond_lower = (x - lower_bound).gt0()\n        # If x >= upper_bound, choose upper_bound \n        # else if x > lower_bound, choose x \n        # else choose lower_bound\n        clipped_value = cond_upper.if_else(\n            upper_bound,\n            cond_lower.if_else(x, lower_bound)\n        )\n        clipped_arr.append(clipped_value)\n    return clipped_arr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicator):\n    from Compiler.types import sint\n    count = sint(0)\n    for element in arr:\n        count = count + predicator(element)\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator, length):\n    \"\"\"\n    Count the number of elements in arr that satisfy the predicator.\n    Each element of arr and the result must be of a secure type (e.g. sint).\n    \"\"\"\n    count = sint(0)\n    for i in range(length):\n        count += predicator(arr[i])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    n = len(arr)\n    count = s_int(0)\n    for i in range(n):\n        # This loop replicates creating an array filled with arr[i] and comparing each element to arr[j],\n        # where j goes from i to the end, just as cmparr[i:] does in the original Python code.\n        for j in range(i, n):\n            count += (arr[i] > arr[j])\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    # Count the number of reverse order pairs in the array of sint.\n    length = len(arr)\n    count = sint(0)\n    for i in range(length):\n        for j in range(i+1, length):\n            count += (arr[i] > arr[j])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_inc", "response_0": "def array_inc(arr, size):\n    # Increment all elements in the input array by 1\n    for i in range(size):\n        arr[i] = arr[i] + 1\n    return arr\n", "response_1": "def array_inc(arr, n):\n    # Increments all elements of arr by 1.\n    # The parameter 'n' is the length of the array.\n    for i in range(n):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    # arr is a list of secure integers (e.g., sint)\n    count = sint(0)\n    brr = arr[1:]\n    for x, y in zip(arr, brr):\n        count += (x < y)\n    return count\n", "response_1": "def count_rises(arr):\n    n = len(arr)\n    count = sint(0)\n    for i in range(n - 1):\n        count += (arr[i] < arr[i + 1])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_2", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\n# Define a specific function to apply. MP-SPDZ does not support \n# passing arbitrary user-defined functions as parameters.\ndef example_func(x):\n    # Example transformation\n    return x + 42\n\ndef array_process(arr):\n    \"\"\"\n    Process all elements in the input array using a fixed function\n    (here, 'example_func') in an MP-SPDZ program.\n    \"\"\"\n    n = len(arr)\n    # Create a new list (or Array) to store results\n    processed_arr = [sint(0) for _ in range(n)]\n    \n    for i in range(n):\n        # Apply the fixed function to each element\n        processed_arr[i] = example_func(arr[i])\n    \n    return processed_arr\n", "model_name": "azure-openai-o1"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    s = sfix(0)\n    for x in vec:\n        s += x * x\n    return s.sqrt()\n", "response_1": "def two_norm(vec):\n    # Square each element\n    squares = [x * x for x in vec]\n    \n    # Sum the squares\n    total = sfix(0)\n    for sq in squares:\n        total += sq\n    \n    # Compute the square root of the total\n    return total.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "totally_dominate", "response_0": "def array_min(a):\n    # Computes the minimum of a secret shared array 'a' element-wise\n    m = a[0]\n    for i in range(1, len(a)):\n        diff = a[i] - m\n        m = m + diff * (a[i] < m)\n    return m\n\ndef array_max(a):\n    # Computes the maximum of a secret shared array 'a' element-wise\n    m = a[0]\n    for i in range(1, len(a)):\n        diff = a[i] - m\n        m = m + diff * (a[i] > m)\n    return m\n\ndef totally_dominate(a, b):\n    # Check if every element in 'a' is no smaller than every element in 'b'\n    amin = array_min(a)\n    bmax = array_max(b)\n    return amin >= bmax\n", "response_1": "def totally_dominate(a, b):\n    # Compute min(a)\n    val_amin = a[0]\n    for i in range(1, len(a)):\n        c = a[i] < val_amin\n        val_amin = c.if_else(a[i], val_amin)\n\n    # Compute max(b)\n    val_bmax = b[0]\n    for i in range(1, len(b)):\n        c = b[i] > val_bmax\n        val_bmax = c.if_else(b[i], val_bmax)\n\n    # Compare min(a) and max(b)\n    return val_amin.greater_equal(val_bmax)\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product_2", "response_0": "# To compute the inner product of two secure arrays in MP-SPDZ, \n# you can define a function similar to the following:\n\ndef inner_product(vec1, vec2):\n    n = len(vec1)\n    summation = sfix(0)  # or sint(0) if using integer shares\n    for i in range(n):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "response_1": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    result = sint(0)\n    for i in range(len(vec1)):\n        result += vec1[i] * vec2[i]\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "get_subarr_by_indices", "response_0": "from Compiler.types import sint, regint, Array\n\ndef get_subarr_by_indices(a, indices):\n    # a is assumed to be an Array of sint values\n    # indices is assumed to be a list (Array) of regint values\n    ret = Array(len(indices), sint)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    ret_len = len(indices)\n    # Create a new array of the appropriate size\n    ret = Array(ret_len, sfix)\n    # Populate ret by picking elements from 'a' using 'indices'\n    for i in range(ret_len):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint, sbit\nfrom Compiler.library import print_ln\n\ndef main():\n    # Input the size of the array (provided by party 0)\n    n = sint.get_input_from(0)\n    # Input array elements (provided by party 0)\n    arr = [sint.get_input_from(0) for _ in range(n)]\n    \n    # Initialize a secure bit to 0\n    result = sbit(0)\n    \n    # Check for existence of 5 or 7 in the array\n    for item in arr:\n        is_5 = (item == 5)\n        is_7 = (item == 7)\n        result = result.bit_or(is_5.bit_or(is_7))\n    \n    # Reveal and print the result\n    print_ln('Exists 5 or 7? => %s', result.reveal())\n", "response_1": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    # arr is a list of secret integers (sint)\n    s = sint(0)\n    for x in arr:\n        eq_5 = (x == 5)\n        eq_7 = (x == 7)\n        s = s + eq_5 + eq_7\n    return (s > 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "remove_by_index", "response_0": "# This MP-SPDZ program removes the element from arr at the given (public) index\n# and returns a new array without that element.\n\ndef remove_by_index(arr, index):\n    n = len(arr)\n    # Create a new array of length n-1 with the same type as the elements in arr\n    ret = Array(n - 1, type(arr[0]))\n    # Copy all elements before the index\n    for i in range(index):\n        ret[i] = arr[i]\n    # Copy all elements after the index\n    for i in range(index, n - 1):\n        ret[i] = arr[i + 1]\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    n = len(arr)\n    ret = Array(n - 1, arr[0].type)\n    # Copy elements up to index\n    for i in range(index):\n        ret[i] = arr[i]\n    # Copy elements after index\n    for i in range(index, n - 1):\n        ret[i] = arr[i + 1]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "average", "response_0": "from Compiler.types import sfix\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summation = sfix(0)\n    for val in arr:\n        summation += val\n\n    length = len(arr)\n    ret = summation / sfix(length)\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array in MP-SPDZ.\n    \"\"\"\n    summation = sfix(0)\n    for item in arr:\n        summation += item\n    length = len(arr)\n    ret = summation / length\n    return ret\n", "model_name": "azure-openai-o1"}
