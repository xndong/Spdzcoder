{"test_name": "indicate_positive", "response_0": "def indicate_positive(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        positive_bit = arr[i] > 0  # yields a secret bit\n        ret[i] = positive_bit.if_else(sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.types import sint, sbit, Array\n\ndef indicate_positive(arr):\n    ret = Array(len(arr), sbit)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > sint(0)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_xor", "response_0": "def array_xor(a, b):\n    n = len(a)\n    ret = [sgf2n(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "response_1": "def array_xor(a, b):\n    n = len(a)\n    # Create an array of secure integers (sint) with the same length as a\n    ret = [sint(0) for _ in range(n)]\n    # Perform the elementwise XOR operation\n    for i in range(n):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "interlaced_placement", "response_0": "from Compiler.types import sint, Array\n\ndef interlaced_placement(a, b):\n    n = len(a)\n    ret = Array(2*n, sint)\n    for i in range(2*n):\n        if i % 2 == 1:\n            ret[i] = b[(i-1)//2]\n        else:\n            ret[i] = a[i//2]\n    return ret\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef interlaced_placement(a, b):\n    n = len(a)\n    ret = Array(2 * n, sint)\n    @for_range(2 * n)\n    def _loop(i):\n        if i % 2 == 0:\n            ret[i] = a[i // 2]\n        else:\n            ret[i] = b[(i - 1) // 2]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_and", "response_0": "from Compiler.types import sint\n\ndef array_and(a, b):\n    n = len(a)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "def array_and(a, b):\n    \"\"\"\n    Compute the elementwise AND of the two input vectors in MP-SPDZ.\n    \"\"\"\n    n = len(a)\n    ret = [None]*n\n    for i in range(n):\n        # Using bitwise AND for secret booleans/integers\n        ret[i] = a[i] & b[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_indicator", "response_0": "# array_indicator.mpc\n\nfrom Compiler.types import sint\n\ndef array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set \n    to be the value of the predicator evaluated on that element.\n    \"\"\"\n    ret = [sint(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    # Initialize the result array with secure integers (or appropriate MP-SPDZ type)\n    ret = [sint(0) for _ in range(len(arr))]\n\n    # Iterate over each element and apply the secure predicator\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n\n    # Return the resulting array of secure booleans/indicators\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.types import sint\nfrom Compiler.library import Array\n\ndef array_greater_than_scalar(arr, bound):\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "from Compiler.types import sfix, sbit, Array\n\ndef array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = Array(n, sbit)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_no_greater_than_scalar", "response_0": "def array_no_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = [None] * n\n    for i in range(n):\n        ret[i] = arr[i] <= bound\n    return ret\n", "response_1": "# array_no_greater_than_scalar.mpc\n\nfrom Compiler.types import sfix\nfrom Compiler.types import sbool\n\n# Example setting: fixed array size\nn = 5\n\n# Secret-shared input: arr\narr = [sfix.get_input_from(0) for _ in range(n)]\n\n# Secret-shared input: bound\nbound = sfix.get_input_from(0)\n\n# Prepare the result array\nret = [sbool() for _ in range(n)]\n\n# Populate ret with the comparisons\nfor i in range(n):\n    # The comparison <= returns a secret bit\n    ret[i] = arr[i] <= bound\n\n# Reveal and print for demonstration here (output handling can be changed as needed)\nfor i in range(n):\n    ret[i].reveal().print_reg()\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    n = len(a)\n    # Create array for reversed segment\n    b = sintArray(n)\n    # Reverse copy\n    for i in range(n):\n        b[i] = a[n - 1 - i]\n    # Create array for concatenation\n    c = sintArray(2 * n)\n    for i in range(n):\n        c[i] = a[i]\n    for i in range(n):\n        c[n + i] = b[i]\n    return c\n", "response_1": "def reverse_and_concat(a):\n    n = len(a)\n    b = Array(n, sint)\n    for i in range(n):\n        b[i] = a[n - 1 - i]\n    c = Array(2 * n, sint)\n    for i in range(n):\n        c[i] = a[i]\n    for i in range(n):\n        c[n + i] = b[i]\n    return c\n", "model_name": "azure-openai-o1"}
{"test_name": "array_round", "response_0": "from Compiler.types import sfix\n\ndef array_round(arr):\n    n = len(arr)\n    ret = [sfix(0) for _ in range(n)]\n    for i in range(n):\n        # Obtain the integer part (for non-negative inputs, Trunc() will act like floor).\n        int_part = arr[i].Trunc()\n\n        # Compare the fractional part with 0.5 and use if_else for secure branching.\n        ret[i] = (arr[i] - int_part < 0.5).if_else(int_part, int_part + 1)\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef array_round(arr):\n    # arr is a list of sfix values\n    n = len(arr)\n    ret = [sfix(0) for _ in range(n)]\n    for i in range(n):\n        int_part = arr[i].Trunc()      # floor of the sfix value\n        ret[i] = int_part + (arr[i] - int_part >= sfix(0.5))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    # This function returns an array of secure bits (sbit) indicating\n    # whether arr[i] >= brr[i] for each index i.\n    n = len(arr)\n    ret = [None] * n\n    for i in range(n):\n        ret[i] = (arr[i] >= brr[i])\n    return ret\n", "response_1": "from Compiler.types import sint, sbit, Array\n\ndef array_greater_eq(arr, brr):\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        cmp_bit = arr[i] >= brr[i]          # Secure comparison returns sbit\n        ret[i] = cmp_bit.if_else(sint(1), sint(0))  # Convert sbit to sint (0/1)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse", "response_0": "def reverse(arr):\n    # arr is an array of s_int type elements.\n    n = len(arr)\n    ret = [s_int(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef reverse(arr):\n    \"\"\"\n    Reverse the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint, Array\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given secret-shared array, return a secret-shared array of the same size.\n    Each element is 1 (secret-shared) if the corresponding input element is negative,\n    otherwise 0 (secret-shared).\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] < 0\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = arr[i] < 0\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "max_sub_sequence", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\ndef max_sub_sequence(arr):\n    partial_max = Array(len(arr), sfix)\n    suffix_max = Array(len(arr), sfix)\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n\n    for i in range(1, len(arr)):\n        cond1 = suffix_max[i - 1] >= 0\n        suffix_max[i] = cond1.if_else(suffix_max[i - 1] + arr[i], arr[i])\n        cond2 = partial_max[i - 1] >= suffix_max[i]\n        partial_max[i] = cond2.if_else(partial_max[i - 1], suffix_max[i])\n\n    return partial_max[len(arr) - 1]\n", "response_1": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\ndef max_sub_sequence(arr):\n    # arr is an Array of sfix\n    n = len(arr)\n    suffix_max = Array(n, sfix)\n    partial_max = Array(n, sfix)\n    \n    suffix_max[0] = arr[0]\n    partial_max[0] = arr[0]\n    \n    @for_range(1, n)\n    def loop(i):\n        # suffix_max[i] = (suffix_max[i-1]>=0) ? suffix_max[i-1] + arr[i] : arr[i]\n        suffix_max[i] = sfix.if_else(suffix_max[i-1] >= 0, suffix_max[i-1] + arr[i], arr[i])\n        # partial_max[i] = (partial_max[i-1]>=suffix_max[i]) ? partial_max[i-1] : suffix_max[i]\n        partial_max[i] = sfix.if_else(partial_max[i-1] >= suffix_max[i], partial_max[i-1], suffix_max[i])\n    \n    return partial_max[n - 1]\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_select", "response_0": "# In MP-SPDZ, we typically import the secure types we need. \n# For element-wise comparison and selection between two secret integer arrays, \n# we can do the following:\n\nfrom Compiler.types import sint\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise, \n    and save the larger value into the returned array. \n    a and b are arrays of secure integers (sint).\n    \"\"\"\n    n = len(a)\n    ret_array = [sint(0) for _ in range(n)]\n    for i in range(n):\n        cond = (a[i] > b[i])       # Comparison returns a secret bit\n        ret_array[i] = cond.if_else(a[i], b[i])  # Select a[i] if cond else b[i]\n    return ret_array\n", "response_1": "def compare_and_select(a, b):\n    n = len(a)\n    ret_array = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # Compare a[i] and b[i] in a secure manner\n        c = a[i] > b[i]\n        # If c is 1, choose a[i]; otherwise b[i]\n        ret_array[i] = c.if_else(a[i], b[i])\n    return ret_array\n", "model_name": "azure-openai-o1"}
{"test_name": "count_element_frequency", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef count_element_frequency(l):\n    n = len(l)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            match_bit = (l[i] == l[j])  # returns an sbit\n            ret[i] = ret[i] + if_else(match_bit, sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef count_element_frequency(n, l):\n    \"\"\"\n    Return an array with the same size of the original array,\n    each position of which records the number of occurrences of the element at the same position.\n    \"\"\"\n    ret = [sint(0) for _ in range(n)]\n    @for_range(n)\n    def _(i):\n        @for_range(n)\n        def _(j):\n            cond = (l[j] == l[i])\n            ret[i] = ret[i] + cond\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_or", "response_0": "def array_or(a, b):\n    n = len(a)\n    ret = [sbit(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i].bit_or(b[i])\n    return ret\n", "response_1": "def array_or(a, b):\n    n = len(a)\n    ret = [s_int(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i] + b[i] - a[i] * b[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "stock_predicator", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import if_else\n\ndef stock_predicator(days):\n    \"\"\"\n    Translated function for secure computation:\n    Finds the maximum profit by choosing an earlier buy day\n    and a later sell day among the given prices.\n    Returns 0 if no positive profit is possible.\n    \"\"\"\n    length = len(days)\n    lowest = Array(length, sint)\n    partial_max = Array(length, sint)\n\n    # Initialization\n    lowest[0] = days[0]\n    partial_max[0] = sint(0)\n\n    # Dynamic programming approach with secure conditionals\n    for i in range(1, length):\n        # Maintain the minimum price seen so far\n        cond_lowest = (lowest[i-1] <= days[i])\n        lowest[i] = if_else(cond_lowest, lowest[i-1], days[i])\n\n        # Update the max profit if selling now is better than previous max\n        cond_profit = (partial_max[i-1] >= (days[i] - lowest[i-1]))\n        partial_max[i] = if_else(cond_profit, partial_max[i-1], days[i] - lowest[i-1])\n\n    return partial_max[length-1]\n", "response_1": "from Compiler.types import sint, sbit, comparison, Array, if_else\nfrom Compiler.library import print_ln\n\ndef stock_predicator_spdz(days):\n    n = len(days)\n    # Initialize arrays to store intermediate results\n    lowest = Array(n, sint)\n    partial_max = Array(n, sint)\n    \n    # Set initial values\n    lowest[0] = days[0]\n    partial_max[0] = sint(0)\n    \n    # Main dynamic programming loop\n    for i in range(1, n):\n        cond_lowest = (lowest[i - 1] <= days[i])\n        lowest[i] = if_else(cond_lowest, lowest[i - 1], days[i])\n        \n        diff = days[i] - lowest[i - 1]\n        cond_partial = (partial_max[i - 1] >= diff)\n        partial_max[i] = if_else(cond_partial, partial_max[i - 1], diff)\n    \n    # Return the final result (most profitable difference or zero if none positive)\n    return partial_max[n - 1]\n\n# Example of revealing the result after calling the function:\n# result = stock_predicator_spdz(days)\n# print_ln(\"Maximum Profit: %s\", result.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "len5_inc_array", "response_0": "def len5_inc_array(init):\n    # Create an array of 5 secure integers\n    ret = Array(5, sint)\n    # Assign each element to init + i\n    for i in range(5):\n        ret[i] = init + i\n    return ret\n", "response_1": "from Compiler.types import Array, sint\n\ndef len5_inc_array(init):\n    \"\"\"\n    Return an increase-by-one array with given initial element and length 5.\n    \"\"\"\n    ret = Array(5, sint)\n    for i in range(5):\n        ret[i] = init + i\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "cut_first_five", "response_0": "from Compiler.types import sint\nfrom Compiler.library import Array, for_range, if_else\n\ndef cut_first_five(arr):\n    ret = Array(5, sint)\n    @for_range(5)\n    def _(i):\n        ret[i] = if_else(i < len(arr), arr[i], sint(0))\n    return ret\n", "response_1": "def cut_first_five(arr):\n    n = 5\n    ret = Array(n, s_int)\n    # Initialize ret with zero shares\n    @for_range(n)\n    def _(i):\n        ret[i] = s_int(0)\n\n    # Copy up to 5 elements from arr\n    limit = min(n, len(arr))\n    @for_range(limit)\n    def _(i):\n        ret[i] = arr[i]\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "max_pooling_1d", "response_0": "from Compiler.types import sfix, sint\n\ndef max_pooling_1d(vec, step):\n    # step is expected to be a compile-time known integer (otherwise convert to int/sint carefully)\n    ret_length = len(vec) // step\n    ret = [sfix(0) for _ in range(ret_length)]\n    for i in range(ret_length):\n        current_max = vec[i * step]\n        for j in range(step):\n            cond = vec[i * step + j] > current_max\n            current_max = cond.if_else(vec[i * step + j], current_max)\n        ret[i] = current_max\n    return ret\n", "response_1": "from Compiler.types import sfix, Array\n\ndef max_pooling_1d(vec: Array, step: int):\n    ret_length = len(vec) // step\n    ret = Array(ret_length, sfix)\n    for i in range(ret_length):\n        max_val = vec[i * step]\n        for j in range(step):\n            cond = vec[i * step + j] > max_val\n            max_val = cond.if_else(vec[i * step + j], max_val)\n        ret[i] = max_val\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater", "response_0": "from Compiler.types import sint, Array\n\ndef array_greater(arr, brr):\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = (arr[i] > brr[i]).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef array_greater(arr, brr, n):\n    ret = [sint(0) for _ in range(n)]\n    @for_range(n)\n    def _(i):\n        ret[i] = arr[i] > brr[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "dumb_concat", "response_0": "def dumb_concat(arr, brr):\n    length = len(arr) + len(brr)\n    ret = Array(length, sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i]\n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n    return ret\n", "response_1": "def dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    arr_len = len(arr)\n    brr_len = len(brr)\n    ret_len = arr_len + brr_len\n    ret = Array(ret_len, sint)\n    for i in range(arr_len):\n        ret[i] = arr[i]\n    for j in range(brr_len):\n        ret[arr_len + j] = brr[j]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "indicator_if_else", "response_0": "def indicator_if_else(a, b, ind):\n    \"\"\"\n    Return an array c with the same length of a and b.\n    The element of c is set to be the corresponding element of a if the indicator is 1,\n    and is set to be the corresponding element of b if the indicator is 0.\n    \"\"\"\n    n = len(ind)\n    c = [sfix(0) for _ in range(n)]\n    for i in range(n):\n        c[i] = ind[i] * a[i] + (sfix(1) - ind[i]) * b[i]\n    return c\n", "response_1": "def indicator_if_else(a, b, ind):\n    c = [None]*len(ind)\n    for i in range(len(ind)):\n        c[i] = ind[i].if_else(a[i], b[i])\n    return c\n", "model_name": "azure-openai-o1"}
{"test_name": "elementwise_multiplication", "response_0": "from Compiler.types import sint\n\ndef elementwise_multiplication(a, b):\n    \"\"\"\n    Compute the elementwise multiplication of the two input vectors.\n    \"\"\"\n    n = len(a)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "def elementwise_multiplication(a, b):\n    from Compiler.types import sint\n    n = len(a)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    # 'a' is assumed to be an Array from MP-SPDZ (e.g., Array(sint) or similar).\n    # 'indices' is assumed to hold public integer values.\n    n = len(indices)\n    ret = Array(n, a[0].value_type)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef get_subarr_by_indices(a, indices):\n    n = len(indices)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "inc_array", "response_0": "def inc_array(num):\n    # num is a cleartext integer\n    arr = Array(num, cint)\n    for i in range(num):\n        arr[i] = i + 1\n    return arr\n", "response_1": "from Compiler.types import regint, Array\n\ndef inc_array(num):\n    \"\"\"\n    Return an array with length num and elements 1 to num.\n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    arr = Array(num, regint)\n    for i in range(num):\n        arr[i] = i + 1\n    return arr\n\nnum = regint.get_input_from(0)\nresult = inc_array(num)\nresult.output()\n", "model_name": "azure-openai-o1"}
{"test_name": "cut_last_five", "response_0": "def cut_last_five(arr):\n    n = len(arr)\n    # Initialize result array of length 5 with secure 0\n    ret = [sint(0) for _ in range(5)]\n    \n    # Copy the last min(5, n) elements from arr into ret in reverse order\n    limit = min(n, 5)\n    for i in range(limit):\n        ret[4 - i] = arr[n - 1 - i]\n    \n    return ret\n", "response_1": "from Compiler.types import sfix, Array\n\ndef cut_last_five(arr):\n    ret = Array(5, sfix)\n    for i in range(5):\n        ret[i] = sfix(0)\n    n = len(arr)\n    limit = 5 if n >= 5 else n\n    for i in range(limit):\n        ret[4 - i] = arr[n - 1 - i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "average_pooling_1d", "response_0": "from Compiler.types import sfix, Array\n\ndef average_pooling_1d(vec, step):\n    ret_length = len(vec) // step\n    ret = Array(ret_length, sfix)\n    for i in range(ret_length):\n        avg = sfix(0)\n        for j in range(step):\n            avg = avg + vec[i * step + j] / sfix(step)\n        ret[i] = avg\n    return ret\n", "response_1": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\ndef average_pooling_1d(vec, step):\n    n = len(vec)\n    ret_length = n // step\n    ret = Array(ret_length, sfix)\n\n    @for_range(ret_length)\n    def _(i):\n        current_avg = sfix(0)\n        @for_range(step)\n        def __(j):\n            nonlocal current_avg\n            current_avg += vec[i * step + j] / sfix(step)\n        ret[i] = current_avg\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_relu", "response_0": "from Compiler.types import sfix, Array\n\ndef array_relu(arr):\n    \"\"\"\n    Apply ReLU function elementwisely to the input array.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sfix)\n    for i in range(n):\n        # Compare with zero and use conditional selection in MP-SPDZ\n        ret[i] = (arr[i] >= sfix(0)).if_else(arr[i], sfix(0))\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef array_relu(arr):\n    \"\"\"\n    Apply ReLU function elementwise to the input array of sfix.\n    \"\"\"\n    ret = [sfix(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        cond = arr[i] >= sfix(0)\n        ret[i] = cond.if_else(arr[i], sfix(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "move_to_end", "response_0": "def move_to_end(arr, length, index):\n    \"\"\"\n    Moves the element at a clear integer 'index' in the array 'arr' to the end.\n    'arr' can be an Array of secure type (e.g., sfix, sbitint, sint, etc.).\n    'length' is the clear integer size of 'arr'.\n    \"\"\"\n    temp = arr[index]\n    for i in range(index + 1, length):\n        arr[i - 1] = arr[i]\n    arr[length - 1] = temp\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef move_to_end(arr, index):\n    temp = arr[index]\n    @for_range(len(arr) - (index + 1))\n    def _(i):\n        arr[index + i] = arr[index + i + 1]\n    arr[len(arr) - 1] = temp\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "set_to_zero", "response_0": "from Compiler.types import sint, regint\n\ndef set_to_zero(arr, index):\n    # Assuming 'arr' is an array of 'sint' and 'index' is a public integer (regint)\n    arr[index] = sint(0)\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef set_to_zero(arr, index):\n    # Assuming arr is an array of sints and index is a compile-time integer\n    arr[index] = sint(0)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "last_partial_sum", "response_0": "def last_partial_sum(arr, n):\n    # arr is a list/array of secret shared integers (sint).\n    # n is a compile-time public integer.\n    ret = sint(0)\n    @for_range(n)\n    def _(i):\n        ret += arr[len(arr) - n + i]\n    return ret\n", "response_1": "from Compiler.types import s_int\n\ndef last_partial_sum(arr, n):\n    # arr is assumed to be an array of s_int\n    # n is assumed to be a public integer (e.g., regint) so that it can be used in range()\n    ret = s_int(0)\n    for i in range(len(arr) - n, len(arr)):\n        ret = ret + arr[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "permute_by_indices", "response_0": "from Compiler.types import sint, Array\n\ndef permute_by_indices(a, indices):\n    n = len(a)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "from Compiler.types import Array\n\ndef permute_by_indices(a, indices):\n    n = len(a)\n    ret = Array(n, a[0].get_type())\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "get_rank", "response_0": "from Compiler.types import sint\n\ndef get_rank(arr, index):\n    rank = sint(0)\n    for i in range(len(arr)):\n        rank += (arr[i] < arr[index])\n    return rank\n", "response_1": "from Compiler.types import sint\n\ndef get_rank(arr, index):\n    rank = sint(0)\n    for item in arr:\n        rank = rank + (item < arr[index])\n    return rank\n", "model_name": "azure-openai-o1"}
{"test_name": "interchange_by_indices", "response_0": "def interchange_by_indices(arr: list[sint], index1: cint, index2: cint) -> list[sint]:\n    \"\"\"\n    Interchange the two secret-shared integer elements in the array 'arr'\n    with given plaintext indices 'index1' and 'index2'.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef interchange_by_indices(arr, index1, index2):\n    # Swap arr[index1] and arr[index2]\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "increase_by", "response_0": "from Compiler.types import sint\n\ndef increase_by(arr, index, k):\n    # 'arr' is assumed to be a list of 'sint', 'index' and 'k' are 'sint' or 'cint'\n    arr[index] = arr[index] + k\n    return arr\n", "response_1": "def increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k using MP-SPDZ sints.\n    \"\"\"\n    arr[index] = arr[index] + k\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "retrieve_by_index", "response_0": "def retrieve_by_index(arr, index):\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    return arr[index]\n", "response_1": "def retrieve_by_index(arr, index):\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    return arr[index]\n", "model_name": "azure-openai-o1"}
{"test_name": "scale_by", "response_0": "def scale_by(arr, index, k):\n    arr[index] = arr[index] * k\n    return arr\n", "response_1": "def scale_by(arr, index, k):\n    # In MP-SPDZ, arr should be declared with a secure type, for example:\n    # arr = Array(<size>, sfix) or Array(<size>, sint), depending on precision needs.\n    # The following assigns arr[index] = arr[index] * k securely:\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "take_opposite_to", "response_0": "def take_opposite_to(arr, index):\n    # This function assumes 'arr' is a list of secret values (sint) or clear values,\n    # and 'index' is a clear integer (cint) in MP-SPDZ.\n    arr[index] = -arr[index]\n    return arr\n", "response_1": "def take_opposite_to(arr, index):\n    # arr is typically a list/array of secret shared values (e.g. sint).\n    # index is typically a public integer (regint) indicating which element to negate.\n    arr[index] = -arr[index]\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_rank", "response_0": "n = sint.get_input_from(0)\nl = Array(n, sint)\nfor i in range(n):\n    l[i] = sint.get_input_from(0)\n\nret = Array(n, sint)\nfor i in range(n):\n    ret[i] = sint(0)\n    for j in range(n):\n        # (l[j] < l[i]) produces an sbit, so we convert it to a secure integer (1 or 0).\n        c = (l[j] < l[i])\n        ret[i] = ret[i] + c.if_else(sint(1), sint(0))\n\nfor i in range(n):\n    ret[i].print_ln()\n", "response_1": "def array_rank(l):\n    n = len(l)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            is_smaller = (l[j] < l[i])\n            ret[i] = ret[i] + is_smaller\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "remove_by_index", "response_0": "from Compiler.types import sint, Array\n\ndef remove_by_index(arr, index):\n    # Create result array of the same secure type as arr with size len(arr)-1\n    ret = Array(len(arr) - 1, type(arr[0]))\n    for i in range(len(arr) - 1):\n        if i < index:\n            ret[i] = arr[i]\n        else:\n            ret[i] = arr[i + 1]\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    n = len(arr)\n    # Create a new array with one fewer elements, using the same type as arr\n    ret = Array(n-1, arr[0].type)\n    # Copy elements, skipping the one at 'index'\n    for i in range(n-1):\n        if i < index:\n            ret[i] = arr[i]\n        else:\n            ret[i] = arr[i+1]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "process_by_index", "response_0": "# MP-SPDZ code for processing an element in the array by index\n\n# Step 1: Define the operation we want to apply.\n# In this example, we simply square the value.\ndef func(x):\n    return x * x\n\n# Step 2: Implement the process_by_index function.\n# 'arr' can be a list of secret or clear values.\n# 'idx' must be a clear integer (regint) for direct indexing.\ndef process_by_index(arr, idx):\n    arr[idx] = func(arr[idx])\n    return arr\n", "response_1": "def process_by_index(arr, index, func):\n    # arr: array of secure or clear values\n    # index: clear integer index\n    # func: a function that applies some operation to arr[index]\n    arr[index] = func(arr[index])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_by_indices", "response_0": "def sum_by_indices(arr, indices):\n    # Assuming arr is a public or secret shared array (e.g. sfix array),\n    # and indices is a public list of integers.\n    # Example types might be [sfix] for arr and list<int> for indices.\n    total = sfix(0)\n    for i in range(len(indices)):\n        total += arr[indices[i]]\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_by_indices(arr, indices):\n    s = sint(0)\n    for idx in indices:\n        s = s + arr[idx]\n    return s\n", "model_name": "azure-openai-o1"}
