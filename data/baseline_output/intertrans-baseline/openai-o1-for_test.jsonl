{"test_name": "multiply_first_five", "response_0": "# This MP-SPDZ program multiplies the first five elements in a secret-shared array.\n# If the array length is less than five, it multiplies all elements.\n\nn = regint.get_input_from(0)                # Public/regint input for array length\narray = [sint.get_input_from(0) for _ in range(n)]  # Secret-shared array inputs\n\nprod = sint(1)\nlimit = 5\nuse_n_if_less_than_five = n < 5\nlimit = use_n_if_less_than_five.if_else(n, limit)\n\nfor i in range(limit):\n    prod *= array[i]\n\nprod.print_reveal()\n", "response_1": "from Compiler.types import sfix\n\ndef multiply_first_five(array):\n    prod = sfix(1)\n    for i in range(len(array)):\n        prod *= array[i]\n        if i >= 4:\n            break\n    return prod\n", "model_name": "azure-openai-o1"}
{"test_name": "second_largest", "response_0": "# This MP-SPDZ program securely computes the second largest value in an array of secret-shared integers.\n# Below is a direct translation of the given Python function to MP-SPDZ syntax and semantics.\n\n# Define the array length\nn = 5\n\n# Secret-shared input array (party 0 provides all inputs for demonstration; adjust as needed)\narr = [sint.get_input_from(0) for _ in range(n)]\n\n# Compare the first two elements securely to initialize \"largest\" and \"second\"\nc_init = arr[0] >= arr[1]\nlargest = c_init.if_else(arr[0], arr[1])\nsecond = c_init.if_else(arr[1], arr[0])\n\n# Loop through the rest of the elements\nfor i in range(2, n):\n    # Securely compare arr[i] with 'largest'\n    c = arr[i] >= largest\n    \n    # Temporarily hold old largest to correctly update second\n    old_largest = largest\n    \n    # Update largest using secure comparison\n    largest = c.if_else(arr[i], largest)\n    \n    # If arr[i] was bigger than old largest, then old largest becomes second\n    second = c.if_else(old_largest, second)\n    \n    # If arr[i] wasn't bigger than largest, compare arr[i] with second\n    c2 = arr[i] >= second\n    second = c2.if_else(arr[i], second)\n\n# Reveal the second largest value (for demonstration, remove or adjust as needed)\nprint_ln(\"Second largest: %s\", second.reveal())\n", "response_1": "# second_largest.mpc\n\n# Secure function to find the second largest element in the array\n# Note:\n#  1) 'arr[i] >= largest' generates a secure bit indicating which branch to take.\n#  2) cond.if_else(x, y) chooses x if cond is 1, otherwise y.\n\ndef second_largest(arr):\n    # Initialize largest and second based on the first two elements\n    init_cond = arr[0] >= arr[1]\n    largest = init_cond.if_else(arr[0], arr[1])\n    second = init_cond.if_else(arr[1], arr[0])\n\n    # Iterate through the rest of the array\n    for i in range(2, len(arr)):\n        # Check if arr[i] is larger than the current largest\n        cond1 = arr[i] >= largest\n        new_largest_if_cond1 = cond1.if_else(arr[i], largest)\n        new_second_if_cond1 = cond1.if_else(largest, second)\n\n        # Check if arr[i] is larger than the current second\n        cond2 = arr[i] >= second\n        new_second_if_cond2 = cond2.if_else(arr[i], second)\n\n        # Update largest and second\n        largest = new_largest_if_cond1\n        second = cond1.if_else(new_second_if_cond1, new_second_if_cond2)\n\n    # Return the second largest element\n    return second\n", "model_name": "azure-openai-o1"}
{"test_name": "partial_sum", "response_0": "def partial_sum(arr, n):\n    partial = sfix(0)\n    for i in range(n):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array in MP-SPDZ.\n    \"\"\"\n    # Initialize the partial sum as a secure integer\n    partial = sint(0)\n\n    # Accumulate and store the running partial sums in-place\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n\n    # Return the modified array\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "max_adjacent_product", "response_0": "# This MP-SPDZ program reads an array of secret-shared integers from player 0,\n# then computes and reveals the maximum product of adjacent elements.\n\nn = sint.get_input_from(0)\narr = [sint.get_input_from(0) for _ in range(n)]\n\ncur = arr[0] * arr[1]\nfor i in range(1, n):\n    product = arr[i - 1] * arr[i]\n    bigger = product > cur\n    cur = bigger.if_else(product, cur)\n\noutput = cur.reveal()\nprint_ln(\"%s\", output)\n", "response_1": "def max_adjacent_product(arr):\n    # arr is an array of secret-shared sints\n    length = len(arr)\n    cur = arr[0] * arr[1]\n    for i in range(1, length - 1):\n        product = arr[i] * arr[i + 1]\n        bigger = product > cur\n        cur = bigger * product + (1 - bigger) * cur\n    return cur\n", "model_name": "azure-openai-o1"}
{"test_name": "argmax", "response_0": "from Compiler.types import sint\n\ndef argmax(a):\n    # a is a list of sint\n    index = sint(0)\n    current = a[0]\n    for i in range(1, len(a)):\n        # Securely compare a[i] >= current\n        comp = (a[i] >= current)\n        # Secure \"if-else\": choose i if the comparison is true, otherwise keep index\n        index = comp.if_else(sint(i), index)\n        # Update current similarly\n        current = comp.if_else(a[i], current)\n    return index\n", "response_1": "def argmax(a):\n    n = len(a)\n    current = a[0]\n    index = sint(0)\n    for i in range(1, n):\n        is_greater = a[i] > current\n        index = index.if_else(is_greater, i, index)\n        current = current.if_else(is_greater, a[i], current)\n    return index\n", "model_name": "azure-openai-o1"}
{"test_name": "count_distinct", "response_0": "def count_distinct(arr):\n    counter = sint(0)\n    for i in range(len(arr)):\n        unique = sint(1)\n        for j in range(i):\n            eq = (arr[i] == arr[j])\n            unique = unique * (1 - eq)\n        counter = counter + unique\n    return counter\n", "response_1": "def count_distinct(arr):\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            eq = (arr[j] == arr[i])\n            unique = unique * (sint(1) - eq)\n        counter = counter + unique\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_true", "response_0": "from Compiler.types import sbit\n\ndef exists_true(arr):\n    # Initialize the return value as a secret boolean set to False\n    ret = sbit(0)\n    # Combine each element of the array with the current result using bitwise OR\n    for item in arr:\n        ret |= item\n    return ret\n", "response_1": "def exists_true(arr):\n    # arr is a list/array of s_bit elements\n    ret = s_bit(0)\n    for item in arr:\n        # OR operation in MP-SPDZ for secret bits: a OR b = a + b - a*b\n        ret = ret + item - ret * item\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "range", "response_0": "from Compiler.types import sint\nfrom Compiler.library import *\n\ndef spdz_range(arr):\n    # arr is a list of secret integers (sint)\n    max_value = arr[0]\n    min_value = arr[0]\n    for i in range(1, len(arr)):\n        item = arr[i]\n        is_item_larger = max_value >= item\n        max_value = is_item_larger * max_value + (1 - is_item_larger) * item\n\n        is_item_smaller = min_value <= item\n        min_value = is_item_smaller * min_value + (1 - is_item_smaller) * item\n\n    return max_value - min_value\n", "response_1": "def range(arr):\n    # Determine the initial secret-shared max and min from the first element\n    max_value = arr[0]\n    min_value = arr[0]\n    \n    # Iterate through the array to update max_value and min_value using secure comparisons\n    for item in arr[1:]:\n        cond_max = item >= max_value\n        max_value = sfix.if_else(cond_max, item, max_value)\n        \n        cond_min = item <= min_value\n        min_value = sfix.if_else(cond_min, item, min_value)\n    \n    # Return the difference between max_value and min_value\n    return max_value - min_value\n", "model_name": "azure-openai-o1"}
{"test_name": "count_larger_than_5", "response_0": "def count_larger_than_5(arr):\n    # Initialize a secret integer counter.\n    counter = sint(0)\n\n    # Loop through each secret integer in arr.\n    for item in arr:\n        # Compare item with 5 in a secret way, yielding a secret bit.\n        condition = item.gtb(cint(5))\n        \n        # Add the secret bit to the counter.\n        counter = counter + condition\n    \n    # Return the total count as a secret integer.\n    return counter\n", "response_1": "# Declare a function that counts elements in 'arr' that are larger than 5\ndef count_larger_than_5(arr, n):\n    counter = sint(0)\n    for i in range(n):\n        cond = (arr[i] > 5)\n        counter = counter + cond\n    return counter\n\n# Read input size from party 0's input\nn = sint.get_input_from(0)\n\n# Create an array of secure integers of length 'n'\narr = Array(n, sint)\n\n# Read array elements from party 0's input\nfor i in range(n):\n    arr[i] = sint.get_input_from(0)\n\n# Call function and reveal the result\nresult = count_larger_than_5(arr, n)\nprint_ln(\"Number of elements larger than 5: %s\", result.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr):\n    max_val = sint(0)\n    sum_val = sint(0)\n    for item in arr:\n        abs_item = (item >= 0).if_else(item, -item)\n        larger = abs_item > max_val\n        max_val = larger.if_else(abs_item, max_val)\n        sum_val += abs_item\n    return (max_val * 2) > sum_val\n", "response_1": "from Compiler.types import sint\n\ndef exists_dominator(arr):\n    max_val = sint(0)\n    sum_val = sint(0)\n    for item in arr:\n        abs_val = item.if_else(item < 0, -item, item)\n        bigger = abs_val > max_val\n        max_val = bigger.if_else(abs_val, max_val)\n        sum_val += abs_val\n    return (2 * max_val) > sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "greedy_picker", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef greedy_picker(items, captivity):\n    num = sint(0)\n    for i in range(len(items)):\n        cond = items[i].less_equal(captivity)\n        captivity = captivity - (cond * items[i])\n        num = num + cond\n    return num\n\ndef main():\n    n = sint.get_input_from(0)\n    items = Array(n, sint)\n    for i in range(n):\n        items[i] = sint.get_input_from(0)\n    cap = sint.get_input_from(0)\n    result = greedy_picker(items, cap)\n    result.print_ln(\"%s\", result)\n", "response_1": "# MP-SPDZ code translation of the greedy_picker function\n\n# We'll assume that 'items' is a list/array of secure integer types (s_int or sint),\n# and 'captivity' is also a secure integer.\n# MP-SPDZ uses bitwise operations to handle conditionals securely.\n# The key difference here is that checking 'item <= captivity' produces a secure bit\n# (which we refer to below as 'e'), and that bit is used to selectively update 'captivity'\n# and our count 'num'.\n\ndef greedy_picker(items, captivity):\n    num = s_int(0)\n    for i in range(len(items)):\n        e = items[i] <= captivity     # e is a secure bit (0/1) indicating if items[i] <= captivity\n        captivity = captivity - items[i] * e\n        num = num + e\n    return num\n", "model_name": "azure-openai-o1"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s, l):\n    # s is assumed to be a secure integer (sint)\n    # l is assumed to be a list/array of secure integers (sint array)\n    for i in srange(len(l)):\n        s = s + l[i]\n    return s\n", "response_1": "def scalar_add_array(s, l):\n    # In MP-SPDZ, s and each element in l are typically secret-shared integers (sint).\n    # We iterate through the list and add each element to s.\n    for i in range(len(l)):\n        s = s + l[i]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "is_equidistant_seq", "response_0": "from Compiler.types import sfix, sbit\n\ndef is_equidistant_seq(arr):\n    \"\"\"\n    This function checks whether the secret-shared list 'arr' \n    is an equidistant sequence. It returns an sbit(1) if True, \n    or sbit(0) otherwise.\n    \"\"\"\n    n = len(arr)\n    eq = sbit(1)\n    # If array length is 0 or 1, consider it equidistant\n    if n <= 1:\n        return eq\n\n    # Initialize the stored difference from first two elements\n    d = arr[1] - arr[0]\n\n    # Check the difference with the rest of the elements\n    for i in range(2, n):\n        diff = arr[i] - arr[i - 1]\n        eq = eq & (diff == d)\n    return eq\n", "response_1": "def is_equidistant_seq(arr, n):\n    # Return whether or not the array is an equidistant sequence.\n    # If the array has length 1 or 0, return True.\n    if n <= 1:\n        return sbit(1)\n    d = sint(0)\n    res = sbit(1)\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if i > 0:\n            eq = (diff == d)\n            res = res & eq\n        d = diff\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product", "response_0": "from Compiler.types import sfix\n\ndef inner_product(vec1, vec2):\n    sum_value = sfix(0)\n    for i in range(len(vec1)):\n        sum_value += vec1[i] * vec2[i]\n    return sum_value\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays in MP-SPDZ.\n    \"\"\"\n    s = sfix(0)\n    for i in range(len(vec1)):\n        s = s + vec1[i] * vec2[i]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "more_distinct_nonnegative", "response_0": "# MP-SPDZ code translating the Python function:\n# more_distinct_nonnegative(arr)\n# into secure computation form.\n\nfrom Compiler.types import sint, sbit\nfrom Compiler.library import print_ln\n\ndef main():\n    # Read the size of the input array from player 0\n    n = sint.get_input_from(0)\n    \n    # Read the array from player 0\n    arr = [sint.get_input_from(0) for _ in range(n)]\n    \n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    \n    # Count the distinct nonnegative vs. distinct negative elements\n    for i in range(n):\n        unique = sbit(1)\n        for j in range(i):\n            eq = arr[j].equal(arr[i])\n            unique = unique & ~eq\n        \n        is_nonnegative = arr[i].geq(0)\n        nonnegative_counter += (unique & is_nonnegative).cast_sint()\n        negative_counter += (unique & ~is_nonnegative).cast_sint()\n    \n    # Compare and reveal the final result\n    result = nonnegative_counter.greater_than(negative_counter)\n    print_ln(\"%s\", result.reveal())\n", "response_1": "from Compiler.types import sint\n\ndef more_distinct_nonnegative(arr):\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    n = len(arr)\n    \n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            eq = arr[i] == arr[j]\n            unique = unique * (1 - eq)\n        \n        is_nonnegative = arr[i] >= 0\n        nonnegative_counter = nonnegative_counter + (unique * is_nonnegative)\n        negative_counter = negative_counter + (unique * (1 - is_nonnegative))\n    \n    return nonnegative_counter > negative_counter\n", "model_name": "azure-openai-o1"}
{"test_name": "flip_positives", "response_0": "# This MP-SPDZ code implements the same logic as the Python flip_positives function:\n# Flip each positive element in a secret-shared array to its negative counterpart.\n\n# We assume 'sint' as the secret integer type and that the array has already been\n# securely input into \"array\". The length n of the array is known.\n\ndef flip_positives(array):\n    n = len(array)\n    for i in range(n):\n        cond = array[i] > 0\n        array[i] = cond.if_else(-array[i], array[i])\n    return array\n", "response_1": "# flip_positives.mpc\n\nimport sys\nfrom Compiler.types import sfix\n\ndef flip_positives(arr):\n    for i in range(len(arr)):\n        condition = arr[i].gt(0)\n        arr[i] = condition.if_else(-arr[i], arr[i])\n    return arr\n\ndef main():\n    n = int(sys.argv[1])\n    array = [sfix.get_input_from(0) for _ in range(n)]\n    array = flip_positives(array)\n    for i in range(n):\n        array[i].print_reveal()\n        print_ln(\"\")\n", "model_name": "azure-openai-o1"}
{"test_name": "divide_and_plus", "response_0": "# Step 1: Import the necessary modules\nfrom Compiler.types import sfix\n\n# Step 2: Define the function\ndef divide_and_plus(x):\n    # Step 3: Perform the loop\n    for i in range(4):\n        x = x / sfix(2)\n        x = x + sfix(1)\n    return x\n\n# Step 4: Implement the main program\ndef main():\n    input_x = sfix.get_input_from(0)\n    result = divide_and_plus(input_x)\n    result.print_ln(\"Final result: %s\")\n", "response_1": "# MP-SPDZ code for divide_and_plus function\n# Note: Here we assume x is an sfix value.\n\ndef divide_and_plus(x):\n    for i in range(4):\n        x = x / sfix(2)\n        x = x + sfix(1)\n    return x\n", "model_name": "azure-openai-o1"}
{"test_name": "array_log2", "response_0": "def array_log2(arr):\n    # Take logarithm with base two for all elements in the input array.\n    # Assumes elements are secret fixed-point numbers (sfix) or similar type supporting .log2().\n    for i in range(len(arr)):\n        arr[i] = arr[i].log2()\n    return arr\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef array_log2(arr):\n    # Approximation of ln(2)\n    ln2 = 0.6931471805599453\n    # Convert 1/ln(2) to a cfix constant\n    inv_ln2 = cfix(1.0 / ln2)\n    for i in range(len(arr)):\n        arr[i] = arr[i].log() * inv_ln2\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_to_ten", "response_0": "from Compiler.types import sint\n\ndef sum_to_ten(array):\n    s = sint(0)\n    n = len(array)\n    for i in range(n):\n        cond = s < 10\n        s = s + array[i] * cond\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_to_ten(array):\n    # Compute partial sum until sum >= 10 using secure shares\n    s = sint(0)\n    continue_bit = sint(1)\n    for i in range(len(array)):\n        s = s + array[i] * continue_bit\n        condition_reached = s >= 10\n        continue_bit = continue_bit * (1 - condition_reached)\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    For elements with an even index, decrement the element by 1.\n    For elements with an odd index, increment the element by 1.\n    \"\"\"\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            arr[i] = arr[i] - 1\n        else:\n            arr[i] = arr[i] + 1\n    return arr\n", "response_1": "def choppy_plus_minus(secret_arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(secret_arr)\n    for i in range(n):\n        if i % 2 == 1:\n            secret_arr[i] = secret_arr[i] + 1\n        else:\n            secret_arr[i] = secret_arr[i] - 1\n    return secret_arr\n", "model_name": "azure-openai-o1"}
{"test_name": "min_element", "response_0": "from Compiler.types import sint\n\ndef min_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a[1:]:\n        is_smaller = item < current\n        current = is_smaller.if_else(item, current)\n    return current\n", "response_1": "from Compiler.types import sint\n\ndef min_element(a):\n    \"\"\"\n    Return the minimum value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a[1:]:\n        cond = current <= item\n        current = cond.if_else(current, item)\n    return current\n", "model_name": "azure-openai-o1"}
{"test_name": "soft_max", "response_0": "from Compiler.types import sfix, exp\n\ndef soft_max(arr):\n    sum_exp = sfix(0)\n    for x in arr:\n        sum_exp += exp(x)\n    res = []\n    for x in arr:\n        res.append(exp(x) / sum_exp)\n    return res\n", "response_1": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef soft_max(arr):\n    # Compute exponentials of each element\n    exps = [mpc_math.exp(x) for x in arr]\n    # Sum the exponentials\n    denom = sfix(0)\n    for e in exps:\n        denom += e\n    # Compute element-wise normalization by the sum\n    return [e / denom for e in exps]\n", "model_name": "azure-openai-o1"}
{"test_name": "count_reverse_pair_with_break", "response_0": "n = int(input())\narr = [cint(input()) for _ in range(n)]\ncount = cint(0)\n\nfor i in range(1, n):\n    if arr[i] > 10:\n        break\n    for j in range(i):\n        if arr[j] > arr[i]:\n            count = count + 1\n\nprint_ln(\"%s\", count.reveal())\n", "response_1": "# This MP-SPDZ program reads an integer n (array length) from player 0,\n# then reads n integers from player 0 into a secure array arr.\n# It counts the number of \"reverse pairs\" until it encounters an element > 10\n# (simulating a 'break' by maintaining an 'active' flag).\n\nfrom Compiler.types import sint\nfrom Compiler.types import Array\n\nn = sint.get_input_from(0)\narr = Array(n, sint)\nfor i in range(n):\n    arr[i] = sint.get_input_from(0)\n\ncount = sint(0)\nactive = sint(1)   # Flag to indicate if we continue counting\n\nfor i in range(1, n):\n    cond = arr[i] <= 10\n    tmp_count = sint(0)\n    for j in range(i):\n        tmp_count += arr[j].gt(arr[i])\n    count += active * tmp_count\n    active = active * cond  # If current element > 10, active becomes 0 thereafter\n\ncount.print_ln(\"%s\", count)\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_unique", "response_0": "from Compiler.types import sint, sbit\n\ndef sum_unique(arr):\n    n = len(arr)\n    total_sum = sint(0)\n    for i in range(n):\n        unique = sbit(1)\n        for j in range(n):\n            eq_ij = arr[i].equal(arr[j])\n            # Only consider checks when j != i (clear condition)\n            if j != i:\n                # If there's any match, multiply unique by 0\n                unique = unique * (1 - eq_ij)\n        # Add the element to the sum only if unique == 1\n        total_sum = total_sum + arr[i] * unique\n    return total_sum\n", "response_1": "def sum_unique(arr):\n    n = len(arr)\n    # Use a secret-fixed-point or secret-integer type for the accumulation\n    sum_val = sfix(0)\n    for i in range(n):\n        # Use an sbit (secret bit) to indicate uniqueness\n        unique = sbit(1)\n        for j in range(n):\n            # Compare arr[i] and arr[j] in secret\n            eq = arr[i].equal(arr[j])  # returns an sbit\n            # Multiply by the public condition (i != j) converted to sbit\n            eq_j = eq & sbit(i != j)\n            # If eq_j is 1, the current element is no longer unique\n            unique = unique & ~eq_j\n        # Conditionally add arr[i] if unique is 1\n        sum_val = sum_val + arr[i] * sfix(unique)\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "check_sum", "response_0": "from Compiler.types import sint\n\ndef check_sum(array, target):\n    total = sint(0)\n    for num in array:\n        total = total + num\n    return total == target\n", "response_1": "def check_sum(array, target):\n    s = sint(0)\n    for num in array:\n        s = s + num\n    return s == target\n", "model_name": "azure-openai-o1"}
{"test_name": "prod", "response_0": "# In MP-SPDZ, we can multiply together all elements in an array of secret shared integers (sint)\ndef prod(array):\n    result = sint(1)\n    for num in array:\n        result = result * num\n    return result\n", "response_1": "def prod(array):\n    product = sint(1)\n    for num in array:\n        product = product * num\n    return product\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_till_negative", "response_0": "from Compiler.types import sint\n\ndef sum_till_negative(array):\n    s = sint(0)\n    for i in range(len(array)):\n        # Reveal the comparison with 0 to decide whether to break\n        if (array[i] < 0).reveal():\n            break\n        s += array[i]\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_till_negative(array):\n    s = sint(0)\n    ok = sint(1)\n    for x in array:\n        is_neg = x < 0\n        s += x * ok\n        ok *= (1 - is_neg)\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    s = s_int(0)\n    for i in range(len(arr)):\n        # predicator(arr[i]) is expected to return an s_bit\n        # which can be added to 's' (an s_int)\n        s += predicator(arr[i])\n    return s\n", "response_1": "# We assume:\n#   1) arr is a list of secret-shared integer values (e.g. of type sint).\n#   2) predicator is a function (to be defined separately) that outputs\n#      a secret integer or bit when given an element from arr.\n\ndef count_satisfied(arr):\n    count = sint(0)\n    for i in range(len(arr)):\n        # predicator(arr[i]) should yield an MP-SPDZ secret (e.g. a sint or sbit).\n        count = count + predicator(arr[i])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "standard_deviation", "response_0": "def standard_deviation(arr):\n    # arr is assumed to be a list of secure fixed-point values, e.g. sfix\n    # Import or define necessary MP-SPDZ types/functions before using\n    length = len(arr)\n    average = sfix(0)\n    for x in arr:\n        average += x\n    average = average / sfix(length)\n\n    variance = sfix(0)\n    for x in arr:\n        diff = x - average\n        variance += diff * diff\n    variance = variance / sfix(length)\n\n    return variance.sqrt()\n", "response_1": "# MP-SPDZ code snippet to compute the standard deviation of an array of secret-shared values\n\n# Declare the length of the array (public or secret). For demonstration, assume this is public:\nn = 4  # Example length\n\n# Create an array of secret-shared fixed-point values (sfix)\narr = [sfix.get_input_from(0) for _ in range(n)]  # Reads n secret values from party 0\n\n# Compute the average\naverage = sfix(0)\nfor i in range(n):\n    average += arr[i]\naverage = average / n\n\n# Compute the variance\nvariance = sfix(0)\nfor i in range(n):\n    diff = arr[i] - average\n    variance += diff * diff\nvariance = variance / n\n\n# Compute the standard deviation\nstdev = variance.sqrt()\n\n# Reveal the standard deviation (for debugging or final output)\nstdev_output = stdev.reveal()\nprint_ln(\"Standard deviation: %s\", stdev_output)\n", "model_name": "azure-openai-o1"}
{"test_name": "dominate", "response_0": "def dominate(a, b):\n    # Assume a and b are lists of secure types (e.g., sfix, sint)\n    n = len(a)\n    ret = 1  # Will hold 1 if dominant, else 0\n    for i in range(n):\n        # 'a[i] >= b[i]' yields a secure bit (0 or 1) in MP-SPDZ\n        # Multiplying accumulates the result across all checks\n        ret = ret * (a[i] >= b[i])\n    return ret\n", "response_1": "def dominate(a, b):\n    # Initialize return value as 1 in s_bit type for secure boolean\n    ret = s_bit(1)\n    # Loop through the length of the arrays\n    for i in range(len(a)):\n        # Compare each pair of elements and update ret\n        ret &= (a[i] >= b[i])\n    # Return the final secure boolean\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "rescale", "response_0": "from Compiler.types import sfix\n\ndef sabs(x):\n    return (x < 0).if_else(-x, x)\n\ndef smax(a, b):\n    return (a > b).if_else(a, b)\n\ndef rescale(brr):\n    max_abs = sfix(0)\n    for item in brr:\n        abs_item = sabs(item)\n        max_abs = smax(max_abs, abs_item)\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "response_1": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    # 'brr' is assumed to be a list/array of secure fixed-point (sfix) values\n    # in MP-SPDZ.\n    max_abs = sfix(0)\n    n = len(brr)\n\n    # Find the maximum absolute value in 'brr'\n    for i in range(n):\n        val = brr[i].abs()\n        cond = val > max_abs\n        max_abs = cond.if_else(val, max_abs)\n\n    # Divide each element by the maximum absolute value\n    for i in range(n):\n        brr[i] = brr[i] / max_abs\n\n    return brr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_minus7", "response_0": "def array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7 in MP-SPDZ.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_minus7(arr):\n    # Subtract 7 from each sint element in the array\n    for i in range(len(arr)):\n        arr[i] = arr[i] - sint(7)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sfix\n\ndef traverse_and_sum(arr1, arr2):\n    # Initialize a secure summation variable\n    s = sfix(0)\n    # Traverse arrays securely\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            s = s + arr1[i] * arr2[j]\n    return s\n", "response_1": "def traverse_and_sum(arr1, arr2, len_arr1, len_arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    total_sum = sfix(0)\n    for i in range(len_arr1):\n        for j in range(len_arr2):\n            total_sum += arr1[i] * arr2[j]\n    return total_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler.types import sint\n\ndef smax(x, y):\n    cond = x >= y\n    return cond.if_else(x, y)\n\ndef longest_nondec_subseq(a):\n    n = len(a)\n    max_length = sint(0)\n    cur_length = sint(0)\n    for i in range(n):\n        if i == 0:\n            # compile-time check\n            cur_length = sint(1)\n        else:\n            ge = a[i] >= a[i-1]\n            # runtime secure conditional\n            cur_length = ge.if_else(cur_length + sint(1), sint(1))\n        max_length = smax(max_length, cur_length)\n    return max_length\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef smax(x, y):\n    return if_else(x >= y, x, y)\n\nn = sint.get_input_from(0)\na = [sint.get_input_from(0) for _ in range(n)]\n\nmax_length = sint(0)\ncur_length = sint(0)\n\nfor i in range(n):\n    if i == 0:\n        cur_length = 1\n    else:\n        # c is 1 if non-decreasing at this step, otherwise 0\n        c = a[i] >= a[i - 1]\n        old_cur_length = cur_length\n        old_max_length = max_length\n        # If c==1 => cur_length+1 else => 1 \n        cur_length = c * (old_cur_length + 1) + (1 - c) * 1\n        # Update max_length only if non-decreasing condition fails\n        max_length = smax(old_max_length, old_cur_length * (1 - c))\n\n# Final update\nmax_length = smax(max_length, cur_length)\n\nprint_ln(\"%s\", max_length.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_but_skip_biggest", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef sum_but_skip_biggest(arr, length):\n    s = sint(0)\n    biggest = arr[0]\n    for i in range(1, length):\n        cond = arr[i] >= biggest\n        # Update biggest if the current element is larger\n        biggest = if_else(cond, arr[i], biggest)\n        # If current element is not bigger, add it\n        s = s + if_else(cond, sint(0), arr[i])\n    return s\n", "response_1": "def sum_but_skip_biggest(array):\n    # Declare secure integer variables in MP-SPDZ\n    sum_val = sint(0)\n    biggest = array[0]\n    n = len(array)\n    # The loop computes sum by skipping whenever encountering a new biggest element\n    for i in range(n):\n        cond = array[i] >= biggest\n        biggest = cond * array[i] + (1 - cond) * biggest\n        sum_val += (1 - cond) * array[i]\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "second_test", "response_0": "from Compiler.types import sint\n\ndef second_test(arr):\n    count = sint(0)\n    for i in range(1, len(arr)):\n        count = count + (arr[0] < arr[i])\n    return (count == 1).reveal()\n", "response_1": "def second_test(arr):\n    from Compiler.types import sint\n    count = sint(0)\n    for i in range(1, len(arr)):\n        count = count + (arr[0] < arr[i])\n    return count == 1\n", "model_name": "azure-openai-o1"}
{"test_name": "Manhattan_distance", "response_0": "def Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two secret-shared vectors.\n    \"\"\"\n    s = sfix(0)\n    for i in range(len(a)):\n        diff = a[i] - b[i]\n        s = s + diff.abs()\n    return s\n", "response_1": "def Manhattan_distance(a, b):\n    # a, b should be lists/arrays of secure types (e.g., sfix or sint).\n    # Initialize the return value with a secure type.\n    ret = sfix(0)\n    \n    # Compute the sum of absolute differences between each element.\n    for i in range(len(a)):\n        diff = a[i] - b[i]\n        ret += diff.abs()\n    \n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "deal_with_only_positive", "response_0": "from Compiler.types import sint\n\ndef deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sint(1)\n    result_sum = sint(0)\n    for i in range(len(array)):\n        cond = array[i] > 0\n        result_sum = result_sum + cond * sign * array[i]\n        sign = sign * (1 - 2 * cond)\n    return result_sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef deal_with_only_positive(array):\n    sign = sint(1)\n    partial_sum = sint(0)\n    @for_range(len(array))\n    def loop(i):\n        skip = array[i].less_equal(0)\n        partial_sum.write(partial_sum.read() + (1 - skip) * sign.read() * array[i])\n        sign.write(sign.read() * (skip + (1 - skip)*-1))\n    return partial_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import sint, cint, if_else\n\ndef compare_and_return(arr, brr):\n    length = len(arr)\n    # Initialize return value as -1 and a flag to track if we've found a match\n    ret = cint(-1)\n    flag = cint(0)\n\n    for i in range(length):\n        # Compare current elements\n        eq = (arr[i] == brr[i])\n        # Update ret and flag only if there's a match and it's the first match encountered\n        condition = eq * (flag == 0)\n        ret = if_else(condition, cint(i), ret)\n        flag = if_else(condition, cint(1), flag)\n    \n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef compare_and_return(arr, brr):\n    # We assume arr[i] and brr[i] are secret values of type sint\n    # This function returns the first index i for which arr[i] == brr[i]\n    # or -1 if there is no such index.\n    found = sint(0)\n    ret = sint(-1)\n    for i in range(len(arr)):\n        i_sint = sint(i)\n        eq_sint = (arr[i] == brr[i])  # This is a secret comparison\n        update = (1 - found) * eq_sint  # We only update if we haven't found a match yet\n        # Update ret to i if update == 1, otherwise keep the old ret\n        ret = ret + update * (i_sint - ret)\n        # Once we have found a match, 'found' remains 1\n        found = found + update\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_odd_positive", "response_0": "# In MP-SPDZ, we typically define a function to receive our input\n# as secure integers (sint) and then compute the desired result.\n# Below is a translation of the Python function into MP-SPDZ code:\n\ndef sum_odd_positive(arr):\n    # arr is a list of secure integers (sint).\n    # We will compute the sum of all the odd (mod 2 == 1) positive (>) numbers.\n    \n    s = sint(0)\n    for x in arr:\n        # (x % 2) checks if x is odd.\n        # (x > 0) checks if x is positive.\n        # Multiplying them yields 1 if both conditions are true, else 0.\n        # Then multiply by x to add x only when it is positive odd.\n        s = s + x * ((x % 2) * (x > 0))\n    return s\n", "response_1": "from Compiler.types import s_int\n\ndef sum_odd_positive(arr):\n    result = s_int(0)\n    for item in arr:\n        condition = (item % 2 == 1) * (item > 0)\n        result += item * condition\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "two_sum", "response_0": "from Compiler.types import sint, sbool\n\ndef two_sum(arr, target):\n    # arr is an array of sint\n    # target is a single sint\n    n = len(arr)\n    found = sbool(0)\n    for i in range(n):\n        for j in range(n):\n            found = found | (arr[i] + arr[j] == target)\n    return found\n", "response_1": "from Compiler.types import sint, sbit\n\ndef two_sum(arr, target):\n    \"\"\"\n    Return whether the input array (list of sints) contains two elements (can be the same) \n    whose sum equals the target (also a sint). \n    The return value is a sbit indicating the result (1 for True, 0 for False).\n    \"\"\"\n    n = len(arr)\n    found = sbit(0)\n    for i in range(n):\n        for j in range(n):\n            match = (arr[i] + arr[j] - target).is_zero()\n            found = found | match\n    return found\n", "model_name": "azure-openai-o1"}
{"test_name": "seq_search", "response_0": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target.\n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements.\n\n    MP-SPDZ translation notes:\n    - \"equal\" is used to compare two secret/shared integers.\n    - \"if_else\" applies a conditional assignment based on a secret bit.\n    - Accumulate the result in a secret variable \"res\" initialized to -1.\n    - Overwrite \"res\" upon equality, preserving it otherwise.\n    \"\"\"\n    from Compiler.types import sint\n    \n    res = sint(-1)\n    for i in range(len(arr)):\n        eq = arr[i].equal(target)\n        res = eq.if_else(sint(i), res)\n    return res\n", "response_1": "# seq_search.mpc\n\n# This function takes an array of secret-shared integers (arr) and a secret-shared target (target).\n# It returns an sint representing the index where target is found, or -1 if not found.\n\ndef seq_search(arr, target):\n    index = sint(-1)  # Default index is -1 (target not found)\n    for i in range(len(arr)):\n        found = (arr[i] == target)\n        # If found is 1 (True), index is set to i; otherwise it remains unchanged\n        index = found.if_else(sint(i), index)\n    return index\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_array", "response_0": "from Compiler.types import sint\n\ndef choppy_array(arr):\n    n = len(arr)\n    result = sint(1)  # Will be 1 (True) unless a violation occurs\n\n    for i in range(n):\n        if i % 2 == 1:\n            # i odd => arr[i] should be the largest among the remaining\n            for j in range(n - i):\n                violation = (arr[i + j] > arr[i])  # sbool\n                # If violation is True => pick 0, else 1\n                result *= violation.if_else(sint(0), sint(1))\n        else:\n            # i even => arr[i] should be the smallest among the remaining\n            for j in range(n - i):\n                violation = (arr[i + j] < arr[i])  # sbool\n                # If violation is True => pick 0, else 1\n                result *= violation.if_else(sint(0), sint(1))\n\n    # Compare against 1 to return an sbool (True/False in secure form)\n    return (result == sint(1))\n", "response_1": "def choppy_array(arr):\n    # arr is a list of secret-shared integers (e.g., sints).\n    length = len(arr)\n    choppy = sint(1)             # Start by assuming \"choppy\"\n    for i in range(length):\n        i_is_odd = i % 2         # This remains a normal Python boolean\n        for j in range(length - i):\n            # Compare arr[i+j] with arr[i], forming a secret boolean\n            cond = arr[i + j].gt(arr[i]) if i_is_odd else arr[i + j].lt(arr[i])\n            # If the condition is true (cond == 1), then multiply by 0 => choppy = 0\n            choppy = choppy * (1 - cond)\n    # choppy will be 1 if never failing, or 0 if any fail occurred\n    return choppy\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    Note:\n        In MP-SPDZ, passing a function reference like `func` is not fully\n        supported in the low-level runtime. However, in its Python front-end,\n        you may still write a function in this style, understanding that\n        MP-SPDZ will inline or interpret such calls statically.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "# array_process.mpc\n\n# Example secure function (placeholder). You would implement\n# the actual secure operation you want here.\ndef secure_transform(x):\n    # For instance, returning x + 1 or x * x in secure form:\n    return x + 1\n\ndef array_process(arr):\n    \"\"\"\n    Process all elements in the secure array 'arr' using a secure transform.\n    This replicates the loop behavior of the Python version, but necessarily\n    replaces the passed-in 'func' with a fixed secure function.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = secure_transform(arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "normalize", "response_0": "from Compiler.types import sfix\n\ndef normalize(vec):\n    sum_sq = sfix(0)\n    for item in vec:\n        sum_sq += item * item\n    base = sum_sq.sqrt()\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "response_1": "from Compiler.types import sfix\n\ndef normalize(vec):\n    acc = sfix(0)\n    # Accumulate the sum of squares\n    for item in vec:\n        acc += item * item\n\n    # Compute the secure square root\n    base = acc.sqrt()\n\n    # Normalize each element\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n\n    return vec\n", "model_name": "azure-openai-o1"}
{"test_name": "impatient_merchant", "response_0": "from Compiler.types import sint, Array\n\ndef main():\n    # Read the number of days\n    n = sint.get_input_from(0)\n\n    # Read the prices for each day\n    days = Array(n, sint)\n    for i in range(n):\n        days[i] = sint.get_input_from(0)\n\n    # Initialize the logic variables\n    can_buy = sint(1)\n    net = sint(0)\n    orig_price = sint(0)\n\n    # Iterate through all days\n    for i in range(n):\n        # Condition: if we are in a \"buy\" phase\n        cond_buy = can_buy\n        # Condition: if we are in a \"sell\" phase and today's price is greater than original cost\n        cond_sell = (sint(1) - can_buy) * (days[i] > orig_price)\n\n        # Update net based on buying condition\n        net = net - cond_buy * days[i]\n\n        # Update net based on selling condition\n        net = net + cond_sell * days[i]\n\n        # Update the original price if we buy\n        orig_price = cond_buy.if_else(days[i], orig_price)\n\n        # Transition states: set can_buy to 0 if we buy, then to 1 if we sell\n        can_buy = cond_buy.if_else(sint(0), can_buy)\n        can_buy = cond_sell.if_else(sint(1), can_buy)\n\n    # Output the final net profit\n    net.print_reg()\n", "response_1": "from Compiler.types import sint, regint\nfrom Compiler.library import for_range\n\ndef main():\n    # Read the length of the days list as a public input (from party 0).\n    n = regint.get_input_from(0)\n\n    # Read each day's price as a secret input (from party 0).\n    days = []\n    for i in range(n):\n        days.append(sint.get_input_from(0))\n\n    can_buy = sint(1)\n    net = sint(0)\n    orig_price = sint(0)\n\n    # Iterate over all days\n    @for_range(n)\n    def _(i):\n        # cond_1 is True (1) if can_buy is 1, else 0\n        cond_1 = can_buy\n        # cond_2 is True (1) if we cannot buy (can_buy==0) and current day price > orig_price\n        cond_2 = (sint(1) - can_buy) * (days[i] > orig_price)\n\n        next_net = net - days[i] * cond_1 + days[i] * cond_2\n        next_orig_price = orig_price * (sint(1) - cond_1) + days[i] * cond_1\n        next_can_buy = can_buy - cond_1 + cond_2\n\n        # Update state\n        net = next_net\n        orig_price = next_orig_price\n        can_buy = next_can_buy\n\n    # Reveal the final net value\n    # (Remove or modify this reveal as necessary depending on your protocol and requirements)\n    print_ln(\"%s\", net.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift", "response_0": "# In MP-SPDZ, we often work with secure data types like sint. \n# This function assumes that 'a' is a list of such secure data types (e.g. sint).\n# It shifts the array 'a' by 1 position and returns the shifted array.\ndef array_shift(a):\n    temp = a[len(a) - 1]\n    for i in range(len(a) - 1):\n        a[len(a) - 1 - i] = a[len(a) - 2 - i]\n    a[0] = temp\n    return a\n", "response_1": "def array_shift(a):\n    # Shift the array one index to the left.\n    # For example, [0,1,2] will be shifted to [1,2,0]\n    n = len(a)\n    temp = a[n - 1]\n    for i in range(n - 1):\n        a[n - i - 1] = a[n - i - 2]\n    a[0] = temp\n    return a\n", "model_name": "azure-openai-o1"}
{"test_name": "array_double", "response_0": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array (of secret integers).\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    n = len(arr)\n    for i in for_range(n):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "stop_at_zero", "response_0": "def stop_at_zero(array):\n    done = sint(0)\n    for i in range(len(array)):\n        eq_zero = (array[i] == 0)\n        not_zero = 1 - eq_zero\n        # Increment only if we haven't 'stopped' yet and current element is non-zero\n        inc = (1 - done) * not_zero\n        array[i] = array[i] + inc\n        # Once we see a zero, set 'done' so subsequent iterations skip increments\n        done = done + (1 - done) * eq_zero\n    return array\n", "response_1": "def stop_at_zero(a):\n    n = len(a)\n    stop = sint(0)             # Flag indicating if we've encountered zero\n    for i in range(n):\n        eq = a[i].equal(0)     # Compare a[i] with 0 securely\n        # Update stop to 1 if we find zero (logical OR for bits: stop = stop OR eq)\n        stop = stop + eq - stop * eq\n        # Add 1 to a[i] only if we have not encountered zero yet\n        a[i] = a[i] + (1 - stop)\n    return a\n", "model_name": "azure-openai-o1"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n    # In MP-SPDZ, using \"~\" on an sbit or sbool type inverts the bit.\n    for i in range(len(arr)):\n        arr[i] = ~arr[i]\n    return arr\n", "response_1": "from Compiler.types import sbit\n\ndef array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = ~arr[i]\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_then_clip", "response_0": "def array_process_then_clip(arr, func):\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = (arr[i] > sfix(10)).if_else(sfix(10), arr[i])\n        arr[i] = (arr[i] < sfix(-10)).if_else(sfix(-10), arr[i])\n    return arr\n", "response_1": "from Compiler.types import sfix\n\ndef array_process_then_clip(arr, size, func):\n    \"\"\"\n    Securely process all elements in 'arr' using 'func', \n    then clip each outcome into the range [-10,10].\n    \"\"\"\n    for i in range(size):\n        val = func(arr[i])\n        # Clip upper bound\n        clipped_val = (val > 10).if_else(sfix(10), val)\n        # Clip lower bound\n        arr[i] = (clipped_val < -10).if_else(sfix(-10), clipped_val)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "add_and_count_positive", "response_0": "from Compiler.types import sint\n\ndef add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given array (list of sints), and count\n    the number of positive numbers in the updated array.\n    Return both the updated array and the count as sints.\n    \"\"\"\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        count += array[i].gtz()  # .gtz() returns a secret bit indicating if array[i] > 0\n    return array, count\n", "response_1": "def add_and_count_positive(array, k):\n    n = len(array)\n    count = s_int(0)\n    for i in range(n):\n        array[i] = array[i] + k\n        count = count + array[i].gt(0)\n    return array, count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    from Compiler.types import sfix\n\n    len_a = len(a)\n    len_b = len(b)\n    ret_len = len_a if len_a > len_b else len_b\n    ret = sfix.Array(ret_len)\n\n    # Initialize all elements to 0\n    for i in range(ret_len):\n        ret[i] = sfix(0)\n\n    if len_a > len_b:\n        # Subtract for overlapping range\n        for i in range(len_b):\n            ret[i] = a[i] - b[i]\n        # Copy remaining elements from the first array\n        for i in range(len_a - len_b):\n            ret[len_b + i] = a[len_b + i]\n    else:\n        # Subtract for overlapping range\n        for i in range(len_a):\n            ret[i] = a[i] - b[i]\n        # Pad with negatives of the second array\n        for i in range(len_b - len_a):\n            ret[len_a + i] = sfix(0) - b[len_a + i]\n\n    return ret\n", "response_1": "# MP-SPDZ code implementing the array_subtract function\n\ndef array_subtract(a, b):\n    # Determine lengths of the inputs\n    la = len(a)\n    lb = len(b)\n\n    # Determine the size of the result\n    ret_len = max(la, lb)\n\n    # Initialize the result array with 0\n    ret = [type(a[0])(0) for _ in range(ret_len)]\n\n    # If length of a is greater than b\n    if la > lb:\n        # Subtract elementwise where both a and b have values\n        for i in range(lb):\n            ret[i] = a[i] - b[i]\n        # Copy the remaining elements of a\n        for i in range(la - lb):\n            ret[lb + i] = a[lb + i]\n    else:\n        # Subtract elementwise where both a and b have values\n        for i in range(la):\n            ret[i] = a[i] - b[i]\n        # Copy the remaining negative b elements\n        for i in range(lb - la):\n            ret[la + i] = -b[la + i]\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "lower_bound", "response_0": "from Compiler.types import sint, MemValue\n\ndef lower_bound(arr, x):\n    ret = MemValue(sint(-1))\n    distance = MemValue(sint(0))\n    found = MemValue(sint(0))\n    n = len(arr)\n\n    for i in range(n):\n        cond = (arr[i] <= x)                             # secret bit\n        fc = (found.read() == 0)                         # 1 if not found yet, otherwise 0\n        diff = x - arr[i]                                # x - arr[i]\n        dc = (diff < distance.read())                    # 1 if this candidate is better (closer)\n        or_val = fc + dc - fc * dc                       # logical OR for secrets: fc OR dc\n        update_condition = cond * or_val                 # update if arr[i] <= x AND (found=0 OR diff<distance)\n\n        ret.write(update_condition * i + (1 - update_condition) * ret.read())\n        distance.write(update_condition * diff + (1 - update_condition) * distance.read())\n        found.write(update_condition * 1 + (1 - update_condition) * found.read())\n\n    return ret.read()\n", "response_1": "def lower_bound(arr, x):\n    # arr: array of secure values (e.g., sfix or sint)\n    # x: secure value (e.g., sfix or sint)\n    # Returns: index as a secure integer (sint)\n\n    from types import sint, sfix, sbit  # Assuming these types are available\n\n    ret = sint(-1)          # Stores final result\n    distance = sfix(0)      # Stores closest distance found so far\n    found = sbit(0)         # Flag indicating whether we have found any valid element\n\n    for i in range(len(arr)):\n        c1 = (arr[i] <= x)  # sbit condition for arr[i] <= x\n        new_distance = x - arr[i]\n\n        # If 'found' is not set yet, we allow an update; otherwise, we compare distances\n        c2 = found.not_().if_else(sbit(1), new_distance < distance)  \n\n        # We update if both conditions are met\n        c = c1 & c2\n\n        # Update ret, distance, found based on c\n        ret = c.if_else(i, ret)\n        distance = c.if_else(new_distance, distance)\n        found = found | c1  # Once we see an element <= x, we set found to 1\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "argmin", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef argmin(a):\n    \"\"\"\n    Return the index of the minimum value of an array 'a',\n    where elements of 'a' are secure integers (sint).\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = sint(0)\n    for i in range(n):\n        cond = (current <= a[i])\n        index = if_else(cond, index, sint(i))\n        current = if_else(cond, current, a[i])\n    return index\n", "response_1": "def argmin(a):\n    n = len(a)\n    index = sint(0)\n    current = a[0]\n    for i in range(1, n):\n        cond = (current <= a[i])\n        index = index * cond + sint(i) * (1 - cond)\n        current = current * cond + a[i] * (1 - cond)\n    return index\n", "model_name": "azure-openai-o1"}
{"test_name": "independent_robbery", "response_0": "# Independent Robbery in MP-SPDZ\n\n# Define a helper function for secure max comparison.\n# Here, 'a >= b' produces a secure bit that is used in if_else().\ndef sfix_max(a, b):\n    cond = a >= b\n    return cond.if_else(a, b)\n\n# Read the number of houses as a secret integer.\nn = sint.get_input_from_all()\n\n# Read all house amounts as secret fixed-point values.\nhouses = Array(n, sfix)\nfor i in range(n):\n    houses[i] = sfix.get_input_from_all()\n\n# Create a dp array of secret fixed-point values.\ndp = Array(n, sfix)\n\n# Initialize dp[0] and dp[1] with the first two houses.\ndp[0] = houses[0]\ndp[1] = sfix_max(houses[1], dp[0])\n\n# Fill the dp array with the maximum profit at each step.\nfor i in range(2, n):\n    dp[i] = sfix_max(dp[i-2] + houses[i], dp[i-1])\n\n# Reveal the final result and print it.\ndp[n-1].reveal().print_ln()\n", "response_1": "# MP-SPDZ code translating the given Python \"independent_robbery\" logic \n# (noting that the Python version's dp[1] assignment looks unintended, but here it is replicated faithfully).\n\nfrom Compiler.types import s_int, Array\nfrom Compiler.library import if_else\n\ndef independent_robbery(houses):\n    n = len(houses)\n    dp = Array(n, s_int)\n    for i in range(n):\n        dp[i] = s_int(0)\n    # dp[0] = houses[0]\n    dp[0] = houses[0]\n    # dp[1] = dp[1] if dp[1]>=dp[0] else dp[0]\n    dp[1] = if_else(dp[1] >= dp[0], dp[1], dp[0])\n    # for i in range(2, len(houses)):\n    #     if dp[i-2]+houses[i] >= dp[i-1]:\n    #         dp[i] = dp[i-2]+houses[i]\n    #     else:\n    #         dp[i] = dp[i-1]\n    for i in range(2, n):\n        dp[i] = if_else(dp[i-2] + houses[i] >= dp[i-1],\n                        dp[i-2] + houses[i],\n                        dp[i-1])\n    return dp[n-1]\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_odd_and_odd", "response_0": "# sum_odd_and_odd.mpc\nfrom Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_odd_and_odd(arr):\n    n = len(arr)\n    s = sint(0)\n    @for_range(n)\n    def loop_i(i):\n        # Only proceed if i is odd\n        if i % 2 == 1:\n            @for_range(i)\n            def loop_j(j):\n                # Only add arr[j] if j is odd\n                if j % 2 == 1:\n                    s += arr[j]\n    return s\n", "response_1": "def sum_odd_and_odd(arr):\n    # In MP-SPDZ, arr should be a list of secure integers (e.g., sint).\n    s = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            s += arr[j]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "is_monotonous", "response_0": "def is_monotonous(arr):\n    d = sint(0)\n    monot = sint(1)\n    for i in range(len(arr) - 1):\n        new_diff = arr[i + 1] - arr[i]\n        if i > 0:\n            violation = (new_diff * d).less_equal(0)\n            monot = monot * (sint(1) - violation)\n        d = new_diff\n    return monot\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\nfrom Compiler import comparison\n\ndef is_monotonous(arr):\n    n = len(arr)\n    d = sfix(0)      \n    is_mono = sint(1)\n\n    @for_range(n - 1)\n    def loop_body(i):\n        nonlocal d, is_mono\n        diff = arr[i + 1] - arr[i]\n        # Check condition for strict monotonic violation:\n        # (i > 0) and (diff * d <= 0)\n        cond = comparison.leq(diff * d, sfix(0)) * (1 if i > 0 else 0)\n        is_mono = is_mono * (1 - cond)\n        d = diff\n\n    return is_mono\n", "model_name": "azure-openai-o1"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    # arr is assumed to be a list of secret-shared integers (sint).\n    count = sint(0)\n    neg_sum = sint(0)\n    for item in arr:\n        count += (item > 0)       # MP-SPDZ comparison returns a bit (sbit), automatically usable here.\n        neg_sum += item * (item < 0)\n    return count, neg_sum\n", "response_1": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    count = sint(0)\n    neg_sum = sint(0)\n    \n    for item in arr:\n        is_positive = item > 0\n        is_negative = item < 0\n        count = count + is_positive\n        neg_sum = neg_sum + (is_negative * item)\n    \n    return (count, neg_sum)\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_even", "response_0": "def sum_even(arr):\n    # Initialize a secure variable for the sum\n    reg_sum = sint(0)\n    \n    # Iterate through each element in the array\n    for x in arr:\n        # Compute x % 2 in secure domain\n        mod2 = x % 2\n        \n        # Compute a secure indicator that is 1 if x is even, 0 otherwise\n        is_even = 1 - mod2\n        \n        # Add x to the running sum if x is even\n        reg_sum = reg_sum + x * is_even\n    \n    # Return the secure sum of even numbers\n    return reg_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_even(arr):\n    total = sint(0)\n    for x in arr:\n        is_even = 1 - (x % 2)\n        total += is_even * x\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    # Initialize sum as a secret-shared fixed-point zero\n    s = sfix(0)\n    # Accumulate absolute values\n    for item in vec:\n        # Use MP-SPDZ conditional to get absolute value\n        s += (item < 0).if_else(-item, item)\n    return s\n", "response_1": "def one_norm(vec):\n    # vec is assumed to be a list of secure data types (e.g., sfix)\n    s = sfix(0)\n    for item in vec:\n        s = s + item.abs()\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "array_floor", "response_0": "from Compiler.types import sfix, sint\n\ndef array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    n = len(arr)\n    result = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # Convert from sfix to secret integer, effectively performing a floor operation\n        result[i] = arr[i].to_sint()\n    return result\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range, comparison, TruncPr\nfrom Compiler.types import Array\n\ndef array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    This translates Python's math.floor (which rounds down, \n    handling negative values by moving to the next integer \n    more negative than or equal to the original) into MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sfix)\n    for i in for_range(n):\n        # integer_part is the truncated integer (towards zero)\n        integer_part = TruncPr(arr[i].v, sfix.k, sfix.f)\n        # Determine the sign\n        is_negative = comparison.LTZ(arr[i].v)\n        # Fractional part\n        fractional_bits = arr[i].v - (integer_part << sfix.f)\n        has_fractional = comparison.NZ(fractional_bits)\n        # If negative and has fractional part, subtract 1\n        floor_val = integer_part - (is_negative * has_fractional)\n        ret[i] = sfix(floor_val, arr[i].f, arr[i].k)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "three_five", "response_0": "def three_five(arr):\n    # Initialize two secure boolean indicators\n    has3 = sint(0)\n    has5 = sint(0)\n\n    # Check each element in arr\n    for item in arr:\n        # Logical OR for secure bits: has3 = has3 OR (item == 3)\n        has3 = has3 + (1 - has3) * (item == 3)\n        # Logical OR for secure bits: has5 = has5 OR (item == 5)\n        has5 = has5 + (1 - has5) * (item == 5)\n\n    # Return True if both 3 and 5 are present or neither is present\n    return (has3 * has5) + ((1 - has3) * (1 - has5))\n", "response_1": "from Compiler.types import sint, regint\n\n# Read the length of the array (secret or clear input as needed).\nn = regint.get_input_from(0)\n\n# Read the array elements from party 0.\narr = [sint.get_input_from(0) for _ in range(n)]\n\n# Initialize has3 and has5 to 0 (boolean as 0/1 in sint).\nhas3 = sint(0)\nhas5 = sint(0)\n\n# Iterate over array to find whether 3 or 5 is present.\nfor item in arr:\n    cond3 = item.equal(3)\n    has3 = has3 + cond3 - has3 * cond3  # Boolean OR for has3\n\n    cond5 = item.equal(5)\n    has5 = has5 + cond5 - has5 * cond5  # Boolean OR for has5\n\n# Compute the final condition: (has3 AND has5) OR (NOT has3 AND NOT has5)\nres = (has3 * has5) + ((sint(1) - has3) * (sint(1) - has5))\n\n# Output the result (1 for True, 0 for False).\nres.print_plaintext()\n", "model_name": "azure-openai-o1"}
{"test_name": "num_above_average", "response_0": "# num_above_average in MP-SPDZ\n\ndef num_above_average(arr):\n    # Initialize sum and count as secure integers\n    s = sint(0)\n    c = sint(0)\n\n    # Compute the sum of all elements\n    for i in range(len(arr)):\n        s = s + arr[i]\n\n    # Compute average\n    avg = s / len(arr)\n\n    # Count how many elements are >= average\n    for i in range(len(arr)):\n        c = c + (arr[i] >= avg)\n\n    # Return the count\n    return c\n", "response_1": "# MP-SPDZ translation of the Python function num_above_average(arr)\n# This program reads the size of the array 'n' from player 0,\n# then reads 'n' secret-shared values of type sfix from player 0,\n# computes how many are >= the average, and outputs the count as a public value.\n\ndef main():\n    n = sint.get_input_from(0)           # number of elements in the array\n    arr = [sfix.get_input_from(0) for _ in range(n)]\n    \n    total_sum = sfix(0)\n    for i in range(n):\n        total_sum = total_sum + arr[i]\n    \n    avg = total_sum / n\n    \n    count = sfix(0)\n    for i in range(n):\n        # The comparison (>=) creates an sbit/sint, which we can add to sfix\n        count = count + (arr[i] >= avg)\n    \n    # Reveal and output the result of the count\n    print_ln('%s', count.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound=1, lower_bound=-1):\n    # In MP-SPDZ, we can leverage secure comparisons and conditional assignments.\n    # For each element, compare it with the lower and upper bounds securely,\n    # and assign the clipped value.\n    for i in range(len(arr)):\n        arr[i] = (arr[i] < lower_bound).if_else(lower_bound, arr[i])\n        arr[i] = (arr[i] > upper_bound).if_else(upper_bound, arr[i])\n    return arr\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef clip(arr, upper_bound, lower_bound):\n    for i in range(len(arr)):\n        arr[i] = if_else(arr[i] < lower_bound, lower_bound, arr[i])\n        arr[i] = if_else(arr[i] > upper_bound, upper_bound, arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "# MP-SPDZ code translating the Python function:\n# def sum_with_certain_element_skipped(array):\n#     sum = 0\n#     for i in range(len(array)):\n#         if 5 <= sum + array[i] <= 10:\n#             continue\n#         sum += array[i]\n#     return sum\n\nfrom Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef sum_with_certain_element_skipped(arr):\n    partial_sum = sint(0)\n    for i in range(len(arr)):\n        candidate = partial_sum + arr[i]\n        skip_condition = (candidate >= 5) * (candidate <= 10)\n        partial_sum = partial_sum + if_else(skip_condition, sint(0), arr[i])\n    return partial_sum\n", "response_1": "# MP-SPDZ translation of the Python function sum_with_certain_element_skipped(array)\n# The array should contain secure integers (sint).\n# All elements that would cause the partial sum to be in the interval [5, 10] are skipped.\n\ndef sum_with_certain_element_skipped(array):\n    s = sint(0)\n    for i in range(len(array)):\n        new_sum = s + array[i]\n        c1 = new_sum.greater_equal(sint(5))\n        c2 = new_sum.less_equal(sint(10))\n        skip = c1 * c2\n        s = s + array[i] * (sint(1) - skip)\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.library import *\ndef main():\n    # Read the number of elements in the array (public input)\n    n = regint.get_input_from(0)\n    \n    # Initialize partial sums as secret integers\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    \n    # Read array elements and compute odd and even sums in a data-dependent way\n    for i in range(n):\n        item = sint.get_input_from(0)\n        c = item & 1     # Extract the least significant bit\n        odd_sum += item * c\n        even_sum += item * (1 - c)\n    \n    # Reveal and print the results\n    print_ln(\"Odd sum: %s, Even sum: %s\", odd_sum.reveal(), even_sum.reveal())\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr_length, arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for i in range(arr_length):\n        condition = arr[i] % 2\n        odd_sum = odd_sum + arr[i] * condition\n        even_sum = even_sum + arr[i] * (1 - condition)\n    return odd_sum, even_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "distance", "response_0": "def distance(vec1, vec2):\n    # Accumulate squared differences\n    s = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        s += diff * diff\n\n    # Return the square root of the accumulated sum\n    return s.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two secure vectors.\n    \"\"\"\n    dist_sum = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        dist_sum += diff * diff\n    return dist_sum.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "num_occurrence", "response_0": "// MP-SPDZ translation of the Python function:\n// num_occurrence(arr, target)\n//\n// This function returns the number of occurrences of 'target' in 'arr'.\n// Both arr and target are assumed to be secret integer types (s_int), \n// although they could also be clear integer types if desired.\n\ndef num_occurrence(arr, target):\n    # Initialize the count to 0 as a secret integer\n    count = s_int(0)\n    \n    # Loop over each element in the secret array 'arr'\n    for i in range(len(arr)):\n        # Compare arr[i] with target securely\n        is_equal = (arr[i] == target)\n        \n        # Update count by adding the result of the comparison\n        count = count + is_equal\n    \n    # Return the final count\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef num_occurrence(sarr, starget):\n    \"\"\"\n    Return the number of occurrences of starget in the secure array sarr.\n    \"\"\"\n    s_count = sint(0)\n    for item in sarr:\n        s_count += (item == starget)\n    return s_count\n", "model_name": "azure-openai-o1"}
{"test_name": "palindrome", "response_0": "from Compiler.types import sbit\n\ndef palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    # sbit(1) represents True in MP-SPDZ for bitwise logical operations\n    flag = sbit(1)\n    for i in range(n):\n        flag = flag & (arr[i] == arr[n - 1 - i])\n    return flag\n", "response_1": "/// Check whether the array (secret-shared) is a palindrome\ndef palindrome(arr):\n    # flag is initially 1 (True in secret-shared form)\n    flag = s_int(1)\n    n = len(arr)\n    # Loop over half of the array or full length depending on your preference\n    # Here we demonstrate the full-length loop, which is logically valid.\n    for i in range(n):\n        flag = flag * (arr[i] == arr[n - 1 - i])\n    return flag\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    # MP-SPDZ translation to count the number of reverse order pairs \n    # in a secret-shared array \"arr\".\n    num = sint(0)\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            num += (arr[i] > arr[j])\n    return num\n", "response_1": "def reverse_order_pair(arr_len, arr):\n    num = sint(0)\n    for i in range(arr_len):\n        for j in range(i+1, arr_len):\n            num += arr[i] > arr[j]\n    return num\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_of_cubes", "response_0": "from Compiler.types import sint\n\ndef sum_of_cubes(arr):\n    ret = sint(0)\n    for item in arr:\n        ret = ret + item * item * item\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_cubes(arr):\n    ret = sint(0)\n    for item in arr:\n        ret += item * item * item\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "max_element", "response_0": "def max_element(a):\n    current = a[0]\n    for i in range(1, len(a)):\n        bigger = current >= a[i]\n        current = bigger.if_else(current, a[i])\n    return current\n", "response_1": "def max_element(a):\n    # a is assumed to be a list of secret-shared values (e.g., sints or sfix).\n    # We compute the maximum by iteratively comparing elements in a.\n    r = a[0]\n    for i in range(1, len(a)):\n        cond = a[i] >= r\n        r = cond.if_else(a[i], r)\n    return r\n", "model_name": "azure-openai-o1"}
{"test_name": "array_if_else", "response_0": "from Compiler.types import sfix, sbit, if_else\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    for i in range(len(arr)):\n        condition = predicator(arr[i])  # should return an sbit (or cbit) indicating True/False\n        arr[i] = if_else(condition, if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef predicator(x):\n    # Replace with your own predicate logic here\n    return x > sfix(0)\n\ndef if_func(x):\n    # Replace with custom \"if\" transformation logic here\n    return x + sfix(1)\n\ndef else_func(x):\n    # Replace with custom \"else\" transformation logic here\n    return x - sfix(1)\n\ndef array_if_else(arr, length):\n    \"\"\"\n    For each element in the input array:\n      if predicator(element) is True, apply if_func,\n      otherwise apply else_func.\n    \"\"\"\n    for i in range(length):\n        condition = predicator(arr[i])\n        arr[i] = if_else(condition, if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "inf_norm", "response_0": "def inf_norm(vec):\n    max_val = sfix(0)\n    for item in vec:\n        abs_item = item.abs()\n        cond = max_val >= abs_item\n        max_val = cond * max_val + (1 - cond) * abs_item\n    return max_val\n", "response_1": "from Compiler.types import sfix\n\ndef inf_norm(vec):\n    # Return the infinite-norm of the vector.\n    max_val = sfix(0)\n    for item in vec:\n        current_abs = item.abs()\n        max_val = (max_val >= current_abs).if_else(max_val, current_abs)\n    return max_val\n", "model_name": "azure-openai-o1"}
{"test_name": "array_inc", "response_0": "from Compiler.types import sint, Array\n\ndef array_inc(arr):\n    \"\"\"\n    Securely increment all elements in the input array by 1 in MP-SPDZ\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "response_1": "def array_inc(arr):\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array of secure integers.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n    for i in range(n - 1):\n        count += (arr[i] < arr[i + 1])\n    return count\n", "response_1": "def count_rises(arr):\n    # arr is assumed to be an array/list of secure integer shares (sint).\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        count += arr[i] < arr[i + 1]\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "skip_at_zero", "response_0": "def skip_at_zero(array):\n    from Compiler.types import sint\n    n = len(array)\n    for i in range(n):\n        cond = array[i].equal(0)\n        array[i] = array[i] + (1 - cond)\n    return array\n", "response_1": "def skip_at_zero(array, n):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    @for i in range(n):\n        cond = (array[i] == 0)\n        @if cond:\n            # do nothing\n        @else:\n            array[i] = array[i] + 1\n        @endif\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_intersect", "response_0": "def array_intersect(p, q):\n    n = len(p)\n    m = len(q)\n    # Initialize the result to 0 (no common elements found yet)\n    result = s_int(0)\n    # Double loop to check every element of p against every element of q\n    for i in range(n):\n        for j in range(m):\n            # Check if p[i] equals q[j], which returns a secret 0/1\n            is_equal = p[i].equal(q[j])\n            # Update result to be the logical OR of any previous match and this equality\n            result = result + is_equal - result * is_equal\n    return result\n", "response_1": "def array_intersect(p, q, len_p, len_q):\n    # Returns an sbit indicating if there is any common element.\n    has_intersect = sbit(0)\n    for i in range(len_p):\n        for j in range(len_q):\n            eq_ij = p[i].equal(q[j])\n            has_intersect = has_intersect.or_(eq_ij)\n    return has_intersect\n", "model_name": "azure-openai-o1"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    sum_val = sfix(0)\n    for item in vec:\n        sum_val += item * item\n    return sum_val.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector in MP-SPDZ.\n    \"\"\"\n    sum_val = sfix(0)\n    for item in vec:\n        sum_val += item * item\n    return sum_val.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_between", "response_0": "from Compiler.types import sfix\n\ndef sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l, u].\n    \"\"\"\n    sum_val = sfix(0)\n    for item in arr:\n        cond_low = item >= l\n        cond_high = item <= u\n        cond = cond_low * cond_high\n        sum_val = sum_val + cond * item\n    return sum_val\n", "response_1": "from Compiler.types import sint\n\ndef sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    total_sum = sint(0)\n    for item in arr:\n        cond_in_range = (item.greater_equal(l)) * (item.less_equal(u))\n        total_sum = total_sum + cond_in_range * item\n    return total_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "largest_gap", "response_0": "from Compiler.types import sint\n\ndef largest_gap(arr):\n    n = len(arr)\n    cur = sint(0)\n    for i in range(n - 1):\n        diff = (arr[i + 1] - arr[i]).abs()\n        cond = diff > cur\n        cur = cond.if_else(diff, cur)\n    return cur\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import sabs, if_else\n\ndef largest_gap(arr):\n    # arr is a list of secret integers (\"sint\")\n    # The length of arr is guaranteed to be at least 2.\n    cur = sint(0)\n    for i in range(len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        diff = sabs(diff)\n        bigger = diff > cur\n        cur = if_else(bigger, diff, cur)\n    return cur\n", "model_name": "azure-openai-o1"}
{"test_name": "totally_dominate", "response_0": "def smin(arr):\n    m = arr[0]\n    for i in range(1, len(arr)):\n        m = (arr[i] < m).if_else(arr[i], m)\n    return m\n\ndef smax(arr):\n    m = arr[0]\n    for i in range(1, len(arr)):\n        m = (arr[i] > m).if_else(arr[i], m)\n    return m\n\ndef totally_dominate(a, b):\n    a_min = smin(a)\n    b_max = smax(b)\n    return a_min >= b_max\n", "response_1": "def totally_dominate(a, b):\n    a_min = a[0]\n    for i in range(1, len(a)):\n        a_min = (a[i] < a_min).if_else(a[i], a_min)\n    b_max = b[0]\n    for i in range(1, len(b)):\n        b_max = (b_max < b[i]).if_else(b[i], b_max)\n    return a_min >= b_max\n", "model_name": "azure-openai-o1"}
{"test_name": "element_count", "response_0": "def element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array in MP-SPDZ.\n    \"\"\"\n    from Compiler.types import sint\n    \n    ret = sint(0)\n    for item in arr:\n        cond = (item == target)\n        ret = ret + cond\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    # Initialize the return value as a secret integer with zero\n    ret = sint(0)\n    \n    # Loop over the array to count occurrences\n    for i in range(len(arr)):\n        # Compare each element with the target\n        eq = (arr[i] == target)\n        # Increment ret by 1 if they are equal\n        ret = ret + eq\n    \n    # Return the count of occurrences\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "is_subarray", "response_0": "from Compiler.types import sint, sbit\n\ndef is_subarray(c, d):\n    c_len = len(c)\n    d_len = len(d)\n    subarray_found = sbit(0)\n    for i in range(d_len):\n        if c_len <= (d_len - i):\n            flag = sbit(1)\n            for j in range(c_len):\n                eq = c[j].equal(d[i + j])\n                flag = flag & eq\n            subarray_found = subarray_found | flag\n    return subarray_found\n", "response_1": "from Compiler.types import sbit\n\ndef is_subarray(c, d):\n    \"\"\"\n    Return whether the first array c is a continuous subarray of the second array d.\n    c and d are lists of secret-shared values (sint).\n    The function returns an sbit indicating True or False in secret-shared form.\n    \"\"\"\n    len_c = len(c)\n    len_d = len(d)\n    result = sbit(0)\n\n    for i in range(len_d):\n        # Check if there's enough space in d to contain c starting at position i\n        if i <= len_d - len_c:\n            sub_check = sbit(1)\n            for j in range(len_c):\n                sub_check &= (d[i + j] == c[j])\n            result |= sub_check\n\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(s_arr):\n    # Initialize a secret bit indicating the existence of 5 or 7\n    sbit_exists = sbit(0)\n    \n    # Iterate over all secret-shared items in the array\n    for item in s_arr:\n        # Compare each item with 5 and 7 (returns a secret bit)\n        eq5 = (item == 5)\n        eq7 = (item == 7)\n        # Update the existence bit by OR-ing previous state with current comparisons\n        sbit_exists = sbit_exists | eq5 | eq7\n\n    # Return the secret bit (1 if 5 or 7 exists, 0 otherwise)\n    return sbit_exists\n", "response_1": "from Compiler.types import sbit\n\ndef exists_5_or_7(arr):\n    found = sbit(0)\n    for item in arr:\n        eq5 = (item == 5)\n        eq7 = (item == 7)\n        found = found | eq5 | eq7\n    return found\n", "model_name": "azure-openai-o1"}
{"test_name": "variance", "response_0": "from Compiler.types import sfix\n\ndef variance(arr):\n    n = sfix(len(arr))\n    average = sfix(0)\n    variance_res = sfix(0)\n    \n    # First pass: compute average\n    for item in arr:\n        average += item / n\n\n    # Second pass: compute variance\n    for item in arr:\n        difference = item - average\n        variance_res += (difference * difference) / n\n\n    return variance_res\n", "response_1": "# In MP-SPDZ, we typically use secure data types such as sfix for fractional/private values.\n# Here, 'arr' is assumed to be a list of sfix elements.\n\ndef variance(arr):\n    n = len(arr)\n    average = sfix(0)\n    for i in range(n):\n        average += arr[i]\n    average /= n\n    \n    var = sfix(0)\n    for i in range(n):\n        diff = arr[i] - average\n        var += diff * diff\n    var /= n\n    \n    return var\n", "model_name": "azure-openai-o1"}
{"test_name": "is_ascending", "response_0": "# MP-SPDZ translation of is_ascending function.\n# This function returns a secure 0/1 (sint) indicating\n# if the input array is in strictly ascending order.\n# It returns 1 if true, 0 if false.\n\nfrom Compiler.types import sint\n\ndef is_ascending(arr):\n    n = len(arr)\n    if n == 1:\n        return sint(1)\n    result = sint(1)\n    for i in range(n - 1):\n        condition = arr[i] < arr[i + 1]\n        result = result * condition\n    return result\n", "response_1": "# is_ascending.mpc\n\ndef is_ascending(arr):\n    # This function checks whether \"arr\" is in strictly ascending order.\n    # If \"arr\" has length 1, it returns sbit(1) (which behaves like True).\n    n = len(arr)\n    result = sbit(1)       # initially assume True\n    for i in range(n - 1):\n        # Update \"result\" by AND-ing with the condition arr[i] < arr[i+1].\n        result = result & (arr[i] < arr[i+1])\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "xor_all", "response_0": "# MP-SPDZ translation of the given Python xor_all function.\n# This function takes an array of secret-shared bits (sbit) and returns their XOR.\n\nfrom Compiler.types import sbit\n\ndef xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n", "response_1": "def xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "upper_bound", "response_0": "from Compiler.types import s_int, s_bit\n\ndef upper_bound(arr, x):\n    \"\"\"\n    Return the index (as s_int) of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = s_int(-1)\n    distance = s_int(0)\n    found = s_bit(0)\n    for i in range(len(arr)):\n        cond1 = arr[i] > x\n        cond_not_found = s_bit(1) - found\n        cond_dist = (arr[i] - x) < distance\n        cond2 = cond_not_found | cond_dist\n        cond = cond1 & cond2\n\n        ret = cond.if_else(s_int(i), ret)\n        distance = cond.if_else(arr[i] - x, distance)\n        found = cond.if_else(s_bit(1), found)\n    return ret\n", "response_1": "def upper_bound(arr, x, n):\n    # arr: array of sints\n    # x: a sint\n    # n: a public integer denoting the length of arr\n    # returns: a sint representing the index of the smallest element bigger than x,\n    #          or -1 if no such element exists\n\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n\n    for i in range(n):\n        cond1 = arr[i] > x               # True if arr[i] > x\n        new_dist = arr[i] - x\n        cond2 = new_dist < distance\n        # cond is True if cond1 and (not found or new_dist < distance)\n        cond = cond1 * ((1 - found) + found * cond2)\n\n        # Update ret, distance, and found based on cond\n        ret = ret * (1 - cond) + sint(i) * cond\n        distance = distance * (1 - cond) + new_dist * cond\n        found = found * (1 - cond) + 1 * cond\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_then_sum", "response_0": "# array_process_then_sum.mpc\n\n# Translation of the original Python function to MP-SPDZ.\n# Since MP-SPDZ does not support passing a function as an argument in the same way,\n# you would define a specific \"func(x)\" function separately and use it here.\n\ndef array_process_then_sum(arr):\n    \"\"\"\n    Process all elements in the input array with a fixed function, \n    then sum up the processed elements. \n    'arr' should be a list of MP-SPDZ secure types such as sfix or sint.\n    \"\"\"\n    total_sum = sfix(0)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])  # 'func' must be defined elsewhere as needed\n        total_sum += arr[i]\n    return total_sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    total_sum = sint(0)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        total_sum = total_sum + arr[i]\n    return total_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "average", "response_0": "def average(arr):\n    sum_val = sfix(0)\n    length = len(arr)\n    for i in range(length):\n        sum_val = sum_val + arr[i]\n    ret = sum_val / sfix(length)\n    return ret\n", "response_1": "def average(arr):\n    # Initialize a secure fixed-point sum value\n    s = sfix(0)  \n    length = len(arr)\n    \n    # Accumulate the sum\n    for i in range(length):\n        s = s + arr[i]\n    \n    # Compute the average as secure fixed-point division\n    return s / sfix(length)\n", "model_name": "azure-openai-o1"}
{"test_name": "array_filter", "response_0": "from Compiler.types import sfix, sbit, if_else\n\ndef array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array,\n    if the predicator returns True, preserve the element,\n    otherwise set it to 0.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = if_else(predicator(arr[i]), arr[i], sfix(0))\n    return arr\n", "response_1": "def array_filter(arr, predicator):\n    n = len(arr)\n    for i in range(n):\n        c = predicator(arr[i])   # c should be a secure bit (e.g., sbit)\n        arr[i] = arr[i] * c      # Elements become zero if predicator returns 0\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_up", "response_0": "from Compiler.types import sint\n\ndef sum_up(array):\n    \"\"\"\n    The sum_up function in MP-SPDZ\n    \"\"\"\n    total = sint(0)\n    for num in array:\n        total = total + num\n    return total\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_up(array):\n    total = sint(0)\n    @for_range(len(array))\n    def _(i):\n        total.iadd(array[i])\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_to_zero", "response_0": "# MP-SPDZ code\n# Translate the negative_to_zero function from Python to MP-SPDZ\n# so that negative elements in 'array' become zero.\n\ndef negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(len(array)):\n        cond = array[i] >= sfix(0)\n        array[i] = cond.if_else(array[i], sfix(0))\n    return array\n", "response_1": "def negative_to_zero(arr):\n    n = len(arr)\n    for i in range(n):\n        is_nonnegative = arr[i] >= sint(0)\n        arr[i] = is_nonnegative.if_else(arr[i], sint(0))\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_only_positive_to_ten", "response_0": "# sum_only_positive_to_ten.mpc\n\n# Import necessary MP-SPDZ types\nfrom Compiler.types import sint\n\ndef sum_only_positive_to_ten(array_sint):\n    limit = sint(10)\n    total_sum = sint(0)\n    active = sint(1)               # Used to stop accumulation once total_sum >= limit\n\n    # Loop over each secret array element\n    for i in range(len(array_sint)):\n        is_positive = array_sint[i] > 0\n        can_add = (total_sum < limit) * active\n        to_add = array_sint[i] * is_positive * can_add\n        total_sum = total_sum + to_add\n        active = active * (total_sum < limit)\n    \n    return total_sum\n", "response_1": "from Compiler.types import sint, sbit\n\ndef sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements\n    until the sum becomes no smaller than 10 in MP-SPDZ.\n    \"\"\"\n    n = len(array)\n    sum_val = sint(0)\n    done = sbit(0)\n\n    for i in range(n):\n        is_positive = array[i] > sint(0)\n        not_done = (done == sbit(0))\n        add_this = is_positive & not_done\n        sum_val = sum_val + add_this.if_else(array[i], sint(0))\n        done = done | (sum_val >= sint(10))\n\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "bubble_sort", "response_0": "# Initialize data\nn = 4\narr = Array(n, sint)\n\n# Read inputs from party 0\nfor i in range(n):\n    arr[i] = sint.get_input_from(0)\n\n# Bubble sort\nfor i in range(n - 1):\n    for j in range(n - 1 - i):\n        cond = arr[j] >= arr[j + 1]\n        bigger = cond.if_else(arr[j], arr[j + 1])\n        smaller = cond.if_else(arr[j + 1], arr[j])\n        arr[j] = smaller\n        arr[j + 1] = bigger\n\n# Reveal the sorted result\nfor i in range(n):\n    arr[i].print_reveal()\n", "response_1": "def bubble_sort(arr):\n    # Bubble sort using secure comparisons/swaps.\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-1-i):\n            cond = (arr[j] >= arr[j+1])\n            swap_left = cond * arr[j+1] + (1 - cond) * arr[j]\n            swap_right = cond * arr[j] + (1 - cond) * arr[j+1]\n            arr[j] = swap_left\n            arr[j+1] = swap_right\n    return arr\n", "model_name": "azure-openai-o1"}
