{"test_name": "sin_or_cos", "response_0": "from Compiler.types import sfix\n\ndef sin_or_cos(x):\n    zero = sfix(0)\n    return (x >= zero).if_else(x.sin(), x.cos())\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else, sin, cos\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # 'x' is interpreted as an sfix secure type. The if_else\n    # function is used for secure conditional selection.\n    return if_else(x >= 0, sin(x), cos(x))\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_relu", "response_0": "from Compiler.types import sfix\n\ndef negative_relu(x):\n    # In MP-SPDZ, comparison (x < 0) yields a secret boolean.\n    # Use conditional selection to return x if x < 0, else return sfix(0).\n    return (x < 0).if_else(x, sfix(0))\n", "response_1": "from Compiler.types import sfix\n\ndef negative_relu(x):\n    # Negative ReLU: return x if x < 0 else 0\n    return (x < sfix(0)) * x\n", "model_name": "azure-openai-o1"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    return (a - b).abs() <= sfix(1)\n", "response_1": "# In MP-SPDZ, you typically work with secret shared variables (e.g., sfix),\n# and you cannot use Python's built-in abs directly. Instead, you implement\n# a conditional-based absolute value. Then you check whether that is <= 1.\n# This snippet shows how you might implement is_close using MP-SPDZ syntax.\n\nfrom Compiler.types import sfix\n\ndef abs_sfix(x):\n    is_negative = x < 0\n    return is_negative.if_else(-x, x)\n\ndef is_close(a, b):\n    # a and b are secret-shared sfix values\n    diff = a - b\n    diff_abs = abs_sfix(diff)\n    return diff_abs <= 1\n", "model_name": "azure-openai-o1"}
{"test_name": "hardswish", "response_0": "from Compiler.types import sfix\n\ndef hardswish(x):\n    zero = sfix(0)\n    three = sfix(3)\n    cond_neg3 = (x < -three)\n    cond_pos3 = (x > three)\n    return cond_neg3.if_else(\n        zero,\n        cond_pos3.if_else(\n            x,\n            x * (x + three) / sfix(6)\n        )\n    )\n", "response_1": "def hardswish(x):\n    # Here 'x' is assumed to be an sfix or sint in MP-SPDZ\n    mul_term = x * (x + 3)\n    scaled_mul = mul_term / 6\n    below_neg_three = x < -3\n    above_pos_three = x > 3\n    temp_val = below_neg_three.if_else(0, scaled_mul)\n    return above_pos_three.if_else(x, temp_val)\n", "model_name": "azure-openai-o1"}
{"test_name": "clip_at_6", "response_0": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    tmp = (x > sfix(6)).if_else(sfix(6), x)\n    result = (tmp < sfix(-6)).if_else(sfix(-6), tmp)\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef clip_at_6(x):\n    upper_bound = sfix(6)\n    lower_bound = sfix(-6)\n    \n    cond_upper = x > upper_bound\n    cond_lower = x < lower_bound\n    \n    tmp = if_else(cond_upper, upper_bound, x)\n    return if_else(cond_lower, lower_bound, tmp)\n", "model_name": "azure-openai-o1"}
{"test_name": "piecewise_function", "response_0": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    ret = sfix(0)\n    if x > sfix(1):\n        ret = x\n    elif x < sfix(-1):\n        ret = x\n    elif x > sfix(0):\n        ret = sfix(1)\n    elif x < sfix(0):\n        ret = sfix(-1)\n    else:\n        ret = sfix(0)\n    return ret\n", "response_1": "# MP-SPDZ translation of the piecewise_function\n\n# Import the required MP-SPDZ library\nfrom Compiler.types import sfix, sint\n\ndef piecewise_function(x):\n    # Initialize return value\n    ret = sfix(0)\n\n    # First condition: x > 1\n    c1 = x > sfix(1)\n    ret = c1.if_else(x, ret)\n\n    # Second condition: x < -1\n    c2 = x < sfix(-1)\n    # Only true if the first condition is false\n    c2_mask = c2 * (sint(1) - c1)\n    ret = c2_mask.if_else(x, ret)\n\n    # Third condition: x > 0 (excluding the first two)\n    c3 = x > sfix(0)\n    c1_or_c2 = (c1 + c2) > sint(0)\n    c3_mask = c3 * (sint(1) - c1_or_c2)\n    ret = c3_mask.if_else(sfix(1), ret)\n\n    # Fourth condition: x < 0 (excluding the first three)\n    c4 = x < sfix(0)\n    c1_c2_c3 = (c1_or_c2 + c3) > sint(0)\n    c4_mask = c4 * (sint(1) - c1_c2_c3)\n    ret = c4_mask.if_else(sfix(-1), ret)\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "middle", "response_0": "from Compiler.types import sint\n\ndef middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    cond = (a >= b)\n    temp = cond.if_else(a, b)\n    a = cond.if_else(b, a)\n    b = temp\n\n    cond = (b >= c)\n    temp = cond.if_else(b, c)\n    b = cond.if_else(c, b)\n    c = temp\n\n    cond = (a >= b)\n    temp = cond.if_else(a, b)\n    a = cond.if_else(b, a)\n    b = temp\n\n    return b\n", "response_1": "def middle(a, b, c):\n    cond1 = a.gte(b)\n    new_a = cond1 * b + (1 - cond1) * a\n    new_b = cond1 * a + (1 - cond1) * b\n    a = new_a\n    b = new_b\n\n    cond2 = b.gte(c)\n    new_b = cond2 * c + (1 - cond2) * b\n    new_c = cond2 * b + (1 - cond2) * c\n    b = new_b\n    c = new_c\n\n    cond3 = a.gte(b)\n    new_a = cond3 * b + (1 - cond3) * a\n    new_b = cond3 * a + (1 - cond3) * b\n    a = new_a\n    b = new_b\n\n    return b\n", "model_name": "azure-openai-o1"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler.types import sfix, sbool\nfrom Compiler.library import sin, cos\n\ndef indicated_sin_or_cos(x: sfix, ind: sbool):\n    return ind.if_else(sin(x), cos(x))\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.library import sin, cos\n\ndef indicated_sin_or_cos(x, ind):\n    # x is assumed to be an sfix or sfloat variable\n    # ind is assumed to be a sint acting as a boolean (0 or 1)\n    return sin(x) * ind + cos(x) * (1 - ind)\n", "model_name": "azure-openai-o1"}
{"test_name": "minus2_if_else", "response_0": "from Compiler.types import sint\n\ndef minus2_if_else(x: sint):\n    tmp = x - 2\n    cond = tmp >= 0\n    return cond.if_else(tmp, x)\n", "response_1": "from Compiler.types import sfix, if_else\n\ndef minus2_if_else(x):\n    cond = x >= sfix(2)\n    return if_else(cond, x - 2, x)\n", "model_name": "azure-openai-o1"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    from Compiler.types import sfix, if_else\n\n    zero = sfix(0)\n    six = sfix(6)\n\n    return if_else(x < zero, zero, if_else(x > six, six, x))\n", "response_1": "def relu6(x):\n    zero = sfix(0)\n    six = sfix(6)\n    c0 = x < zero\n    r0 = c0.if_else(zero, x)\n    c6 = r0 > six\n    r1 = c6.if_else(six, r0)\n    return r1\n", "model_name": "azure-openai-o1"}
{"test_name": "exp_slide", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef exp_slide(x):\n    # x is an sfix (secure fixed-point type)\n    cond = x >= sfix(0)\n    return if_else(cond, x.exp(), x + sfix(1))\n", "response_1": "from Compiler.types import sfix\n\ndef exp_slide(x):\n    # If x >= 0, return e^x, otherwise x + 1\n    cond = x >= sfix(0)\n    return cond.if_else(x.exp(), x + sfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "pass_or_not", "response_0": "from Compiler.types import sfix, sbit, sint\n\ndef pass_or_not(score):\n    passed = (score >= sfix(60))\n    final_score = passed.if_else(score, sfix(59))\n    bool_passed = passed.if_else(sint(1), sint(0))\n    return final_score, bool_passed\n", "response_1": "from Compiler.types import sint, sbit\nfrom Compiler.library import if_else\n\ndef pass_or_not(score: sint):\n    cond = (score >= 60)\n    ret_score = if_else(cond, score, sint(59))\n    ret_passed = cond\n    return ret_score, ret_passed\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_roots", "response_0": "# how_many_roots.mpc\n\n# This program securely computes the number of roots of a quadratic function\n# ax^2 + bx + c = 0 using MP-SPDZ. The inputs a, b, and c are secret-shared\n# integers provided by party 0, and the result is revealed.\n\ndef how_many_roots(a, b, c):\n    eq_a = (a == 0)\n    eq_b = (b == 0)\n    disc = b * b - 4 * a * c\n    gt_disc = (disc > 0)\n    eq_disc = (disc == 0)\n\n    # When a == 0:\n    #   if b == 0 => 0\n    #   else => 1\n    roots_when_a0 = eq_b.if_else(sint(0), sint(1))\n\n    # When a != 0:\n    #   if b*b - 4*a*c > 0 => 2\n    #   elif b*b - 4*a*c == 0 => 1\n    #   else => 0\n    roots_when_a_not_0 = gt_disc.if_else(sint(2),\n                                         eq_disc.if_else(sint(1),\n                                                         sint(0)))\n\n    # Combine both cases\n    return eq_a.if_else(roots_when_a0, roots_when_a_not_0)\n\ndef main():\n    a = sint.get_input_from(0)\n    b = sint.get_input_from(0)\n    c = sint.get_input_from(0)\n    res = how_many_roots(a, b, c)\n    print_ln(\"Number of roots: %s\", [res.reveal()])\n", "response_1": "def how_many_roots(a, b, c):\n    # a, b, c are secret integers (sint).\n    cond_a_zero = (a == 0)\n    cond_b_zero = (b == 0)\n    disc = b * b - 4 * a * c\n    cond_disc_gt_0 = (disc > 0)\n    cond_disc_eq_0 = (disc == 0)\n\n    # When a == 0:\n    #   if b == 0 => result is 0\n    #   else => result is 1\n    part_if_b_zero = cond_b_zero.if_else(0, 1)\n\n    # When a != 0: \n    #   if disc > 0 => 2 \n    #   else if disc == 0 => 1\n    #   else => 0\n    part_disc_result = cond_disc_gt_0.if_else(2, cond_disc_eq_0.if_else(1, 0))\n\n    # Combine both results:\n    final = cond_a_zero.if_else(part_if_b_zero, part_disc_result)\n    return final\n", "model_name": "azure-openai-o1"}
{"test_name": "elu", "response_0": "from Compiler.types import sfix\n\ndef elu(x):\n    zero = sfix(0)\n    return (x > zero).if_else(x, x.exp() - 1)\n", "response_1": "def elu(x):\n    from Compiler.library import if_else, exp\n    return if_else(x > 0, x, exp(x) - 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "relu", "response_0": "def relu(x):\n    cond = x > sfix(0)\n    return cond.if_else(x, sfix(0))\n", "response_1": "from Compiler.types import sfix\n\ndef relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return x * (x > sfix(0))\n", "model_name": "azure-openai-o1"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    Secure Leaky ReLU function with a leak factor alpha in MP-SPDZ.\n    \"\"\"\n    one = sfix(1)\n    is_positive = x > sfix(0)\n    return is_positive * x + (one - is_positive) * (x * alpha)\n", "response_1": "def leaky_relu(x, alpha):\n    # In MP-SPDZ, we use secure comparisons rather than standard Python comparisons.\n    # Here, 'cond' will be a secure bit indicating if 'x' is >= 0.\n    cond = x.greater_equal(sfix(0))\n    # We then compute x if 'cond' is true, otherwise x * alpha.\n    return (x * cond) + (x * alpha * (1 - cond))\n", "model_name": "azure-openai-o1"}
{"test_name": "max", "response_0": "from Compiler.types import sfix\n\ndef max(a: sfix, b: sfix) -> sfix:\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    condition = (a >= b)\n    return condition.if_else(a, b)\n", "response_1": "from Compiler.types import sfix\n\ndef smax(a: sfix, b: sfix) -> sfix:\n    \"\"\"\n    Return the maximum value of the two secure inputs a and b.\n    \"\"\"\n    # In MP-SPDZ, we replace the standard Python 'if' with 'if_else',\n    # which uses secure comparison results (a >= b) to determine the return value.\n    return (a >= b).if_else(a, b)\n", "model_name": "azure-openai-o1"}
{"test_name": "bowl_shape", "response_0": "from Compiler.types import sfix\n\ndef bowl_shape(x):\n    cond1 = x > sfix(1)\n    cond2 = x < sfix(-1)\n    return cond1.if_else(x - sfix(1), cond2.if_else(-x - sfix(1), sfix(0)))\n", "response_1": "from Compiler.types import sfix\n\ndef bowl_shape(x):\n    # Create boolean-like masks for each condition\n    cond_gt_1 = (x > sfix(1))\n    cond_lt_neg_1 = (x < sfix(-1))\n\n    # Compute the corresponding values for each branch\n    val_if_gt_1 = x - sfix(1)\n    val_if_lt_neg_1 = -x - sfix(1)\n    val_else = sfix(0)\n\n    # Combine results using secure multiplications with boolean-like masks\n    return cond_gt_1 * val_if_gt_1 + cond_lt_neg_1 * val_if_lt_neg_1 + (1 - cond_gt_1 - cond_lt_neg_1) * val_else\n", "model_name": "azure-openai-o1"}
{"test_name": "rounded_kinetic_energy", "response_0": "from Compiler.types import sfix\n\ndef rounded_kinetic_energy(m, v):\n    # Compute the kinetic energy in sfix\n    k = m * v * v * sfix(0.5)\n    \n    # Floor of k\n    k_int = k.floor()\n    \n    # Fractional part\n    fraction = k - sfix(k_int)\n    \n    # Compare fraction with 0.5\n    cond = fraction < sfix(0.5)\n    \n    # If fraction < 0.5 => return k_int, else => k_int + 1\n    return cond.if_else(k_int, k_int + 1)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef rounded_kinetic_energy(m, v):\n    # m and v are secret fixed-point values (sfix)\n    k = m * (v * v) / sfix(2)\n    k_int = k.floor()\n    diff = k - k_int\n    cond = diff < sfix(0.5)\n    return if_else(cond, k_int, k_int + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "danger_test", "response_0": "# danger_test.mpc\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy!\n    Given the Dragon Warrior's initial health and the damage he receives,\n    decide whether the situation is dangerous.\n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    # 'origin' and 'damage' are assumed to be secret integers (sint).\n    return (origin - damage) <= 10\n", "response_1": "from Compiler.types import sint, cint\n\ndef danger_test(origin, damage):\n    return (origin - damage) <= cint(10)\n\norigin = sint.get_input_from(0)\ndamage = sint.get_input_from(0)\n\ndanger = danger_test(origin, damage)\ndanger.print_reg_plain()\n", "model_name": "azure-openai-o1"}
{"test_name": "indicated_sum_or_multiply", "response_0": "from Compiler.types import sint, sbit\n\ndef indicated_sum_or_multiply(x: sint, y: sint, ind: sbit) -> sint:\n    return (x + y)*ind + (x*y)*(1 - ind)\n", "response_1": "from Compiler.types import sint, sbool\nfrom Compiler.library import if_else\n\ndef indicated_sum_or_multiply(x: sint, y: sint, ind: sbool):\n    # If 'ind' is True (1), return x + y, otherwise return x * y\n    return if_else(ind, x + y, x * y)\n", "model_name": "azure-openai-o1"}
{"test_name": "median", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - 1 - i):\n            cond = arr[j] > arr[j + 1]\n            tmp = arr[j]\n            arr[j]     = if_else(cond, arr[j + 1], arr[j])\n            arr[j + 1] = if_else(cond, tmp,         arr[j + 1])\n\ndef median(arr):\n    # In MP-SPDZ we do not raise exceptions, but you could manually handle\n    # the case of zero length if desired\n    n = len(arr)\n    bubble_sort(arr)\n    half = n // 2\n    is_odd = (n % 2)\n    ret_odd = arr[half]\n    ret_even = (arr[half] + arr[half - 1]) / sfix(2)\n    return if_else(is_odd, ret_odd, ret_even)\n", "response_1": "from Compiler.types import sfix\nfrom sorting import mergesort\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array in MP-SPDZ.\n    This function expects arr to be an array (list) of sfix values.\n    \"\"\"\n    n = len(arr)\n    # For secure computation, we generally avoid raising exceptions.\n    # If n == 0, no sensible median can be computed.\n\n    sorted_arr = mergesort(arr)  # Sort array using MP-SPDZ's mergesort\n    if n == 0:\n        # No output if array is empty (could alternatively reveal an error message)\n        return sfix(0)\n\n    # If array length is odd\n    # (n % 2) will be 1 if n is odd, 0 if even\n    if (n % 2) == 1:\n        return sorted_arr[n // 2]\n    else:\n        return (sorted_arr[n // 2] + sorted_arr[(n // 2) - 1]) / sfix(2)\n", "model_name": "azure-openai-o1"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    sum_val = a + b\n    clip = sum_val > 10\n    return sum_val * (1 - clip) + 10 * clip\n", "response_1": "from Compiler.types import sint, cint\n\ndef add_upto_10(a: sint, b: sint) -> sint:\n    sum_val = a + b\n    cond = sum_val > cint(10)\n    return cond.if_else(cint(10), sum_val)\n", "model_name": "azure-openai-o1"}
{"test_name": "taxi_fare", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef main():\n    # Step 2: Read the secure input 'm'\n    m = sfix.get_input_from(0)\n    \n    # Step 3: Define constants\n    base_fare = sfix(5)\n    \n    # Step 4: Compute partial fare values\n    cost_05 = base_fare\n    cost_510 = base_fare + sfix(1.2) * (m - sfix(5))\n    cost_10plus = sfix(11) + sfix(1.5) * (m - sfix(10))\n    \n    # Conditional logic for the three fare segments\n    tmp = if_else(m <= sfix(5), cost_05, cost_510)\n    fare = if_else(m <= sfix(10), tmp, cost_10plus)\n    \n    # Step 5: Store result in memory location 0\n    fare.store_in_mem(0)\n", "response_1": "# taxi_fare.mpc\n\ndef main():\n    from Compiler.types import sfix\n    from Compiler.library import if_else\n\n    # Secure input for the number of miles (secret shared)\n    m = sfix.get_input_from(0)\n\n    # Define piecewise conditions\n    c1 = m.less_equal(sfix(5))                  # m <= 5\n    c2 = (m.greater_equal(sfix(5))) * (m.less_equal(sfix(10)))  # 5 <= m <= 10\n    c3 = 1 - c1 - c2                            # m > 10\n\n    # Define fare calculations for each interval\n    fare_part1 = sfix(5)                                           # Flat fare if m <= 5\n    fare_part2 = sfix(5) + sfix(1.2) * (m - sfix(5))                # 5 + 1.2*(m-5) for 5 <= m <= 10\n    fare_part3 = sfix(11) + sfix(1.5) * (m - sfix(10))              # 11 + 1.5*(m-10) for m > 10\n\n    # Combine results according to conditions\n    # One approach is chained if_else. Another is summation with conditional coefficients:\n    fare_c1 = if_else(c1, fare_part1, sfix(0))\n    fare_c2 = if_else(c2, fare_part2, sfix(0))\n    fare_c3 = if_else(c3, fare_part3, sfix(0))\n    fare = fare_c1 + fare_c2 + fare_c3\n\n    # Output result\n    fare.print_plaintext()\n", "model_name": "azure-openai-o1"}
{"test_name": "round", "response_0": "from Compiler.types import sfix\n\ndef round_sfix(x):\n    x_int = x.trunc()\n    difference = x - x_int\n    return x_int + (difference >= sfix(0.5))\n", "response_1": "def round(x):\n    x_int = x.trunc()\n    diff = x - x_int\n    cond = diff < 0.5\n    return cond.if_else(x_int, x_int + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    # Initialize GPA to the lowest tier\n    gpa = sfix(2.3)\n    \n    # Check each threshold in ascending order\n    gpa = if_else(score >= 70, sfix(2.6), gpa)\n    gpa = if_else(score >= 75, sfix(3.0), gpa)\n    gpa = if_else(score >= 80, sfix(3.3), gpa)\n    gpa = if_else(score >= 85, sfix(3.6), gpa)\n    gpa = if_else(score >= 90, sfix(4.0), gpa)\n    \n    return gpa\n\ndef main():\n    # Example of reading a secret or public input depends on your setting\n    score = sfix.get_input_from(0)  # Replace 0 with the appropriate player ID if needed\n    result = gpa_calculator(score)\n    result.print_plain()\n", "response_1": "# MP-SPDZ code translating the Python gpa_calculator function:\n\n# Input the secure score (e.g., from party 0)\nscore = sfix.get_input_from(0)\n\n# Define threshold checks\nis_greater_or_equal_90 = score.greater_equal(90)\nis_greater_or_equal_85 = score.greater_equal(85)\nis_greater_or_equal_80 = score.greater_equal(80)\nis_greater_or_equal_75 = score.greater_equal(75)\nis_greater_or_equal_70 = score.greater_equal(70)\n\n# Define all possible GPA values as sfix\ngpa_4  = sfix(4.0)\ngpa_36 = sfix(3.6)\ngpa_33 = sfix(3.3)\ngpa_30 = sfix(3.0)\ngpa_26 = sfix(2.6)\ngpa_23 = sfix(2.3)\n\n# Start with the lowest GPA\ngpa = gpa_23\n\n# Update GPA based on score thresholds\ngpa = is_greater_or_equal_70.if_else(gpa_26, gpa)\ngpa = is_greater_or_equal_75.if_else(gpa_30, gpa)\ngpa = is_greater_or_equal_80.if_else(gpa_33, gpa)\ngpa = is_greater_or_equal_85.if_else(gpa_36, gpa)\ngpa = is_greater_or_equal_90.if_else(gpa_4,  gpa)\n\n# Reveal or print the result\ngpa.print_plain()\n", "model_name": "azure-openai-o1"}
{"test_name": "sign", "response_0": "from Compiler.types import sint\n\ndef sign(x: sint) -> sint:\n    return (x > 0) - (x < 0)\n", "response_1": "def sign(x):\n    # This function returns:\n    #  1 if x > 0\n    #  0 if x == 0\n    # -1 if x < 0\n    bpos = x > 0\n    bneg = x < 0\n    return sint(bpos) - sint(bneg)\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    # a and b are secret-shared variables (e.g., sint, sfix, or sfloat).\n    c = a <= b\n    return (c * (a + b)) + ((1 - c) * (a - b))\n", "response_1": "# sum_or_difference.mpc\n\nfrom Compiler.types import sfix\n\ndef sum_or_difference(a, b):\n    # c indicates whether a is less than or equal to b\n    c = (a <= b)\n    # If c is 1, return a+b, else return a-b\n    return c * (a + b) + (1 - c) * (a - b)\n", "model_name": "azure-openai-o1"}
{"test_name": "CNOT", "response_0": "from Compiler.types import sint\n\ndef CNOT(control_bit: sint, flip_bit: sint) -> sint:\n    # (not flip_bit) if control_bit else flip_bit\n    # Replace \"not\" with 1 - flip_bit for secure integer bits:\n    return control_bit * (1 - flip_bit) + (1 - control_bit) * flip_bit\n", "response_1": "# Declare or read secure bits from players (as needed in your MP-SPDZ execution context)\nfrom Compiler.types import sbit\n\ndef CNOT(control_bit, flip_bit):\n    # The CNOT logic from the Python version is equivalent to an XOR in MP-SPDZ\n    return control_bit ^ flip_bit\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_plus1", "response_0": "# negative_plus1.mpc\n\ndef negative_plus1(y):\n    bit_neg = (y < 0)\n    return y + bit_neg.if_else(1, 0)\n", "response_1": "from Compiler.types import sfix\n\ndef negative_plus1(y):\n    # is_negative will be a secure bit (0 or 1)\n    is_negative = (y < 0)\n    # Use if_else to select between y+1 and y based on is_negative\n    return is_negative.if_else(y + 1, y)\n\ndef main():\n    # Securely read y from player 0\n    y = sfix.get_input_from(0)\n    # Compute and print the result\n    result = negative_plus1(y)\n    result.print_plaintext()\n", "model_name": "azure-openai-o1"}
{"test_name": "is_a_parallelogram", "response_0": "# Secure inputs for the four points a, b, c, d\na0 = sint.get_input_from(0)\na1 = sint.get_input_from(0)\nb0 = sint.get_input_from(0)\nb1 = sint.get_input_from(0)\nc0 = sint.get_input_from(0)\nc1 = sint.get_input_from(0)\nd0 = sint.get_input_from(0)\nd1 = sint.get_input_from(0)\n\n# Define a function to check if two points (x0, x1) and (y0, y1) are the same\ndef same(x0, x1, y0, y1):\n    return (x0 == y0) * (x1 == y1)\n\n# Compute whether any two points are the same (which invalidates the parallelogram)\nsameAB = same(a0, a1, b0, b1)\nsameAC = same(a0, a1, c0, c1)\nsameAD = same(a0, a1, d0, d1)\nsameBC = same(b0, b1, c0, c1)\nsameBD = same(b0, b1, d0, d1)\nsameCD = same(c0, c1, d0, d1)\nisSame = (sameAB + sameAC + sameAD + sameBC + sameBD + sameCD) > 0\n\n# Check three possible parallelogram conditions\ncond1 = ((a0 + b0) == (c0 + d0)) * ((a1 + b1) == (c1 + d1))\ncond2 = ((a0 + c0) == (b0 + d0)) * ((a1 + c1) == (b1 + d1))\ncond3 = ((a0 + d0) == (b0 + c0)) * ((a1 + d1) == (b1 + c1))\nisPara = (cond1 + cond2 + cond3) > 0\n\n# If points aren\u2019t duplicated, and one of the parallelogram conditions is satisfied, result is 1; else 0\nres = (1 - isSame) * isPara\n\n# Reveal the final result\nprint_ln('%s', res)\n", "response_1": "def is_a_parallelogram(a0, a1, b0, b1, c0, c1, d0, d1):\n    \"\"\"\n    Given the coordinates of four vertices in secure integer form, \n    return a secure bit indicating whether they can form a parallelogram (1 for True, 0 for False).\n    \"\"\"\n    def same(x0, x1, y0, y1):\n        return (x0 == y0) & (x1 == y1)\n\n    any_same = same(a0, a1, b0, b1) \\\n               | same(a0, a1, c0, c1) \\\n               | same(a0, a1, d0, d1) \\\n               | same(b0, b1, c0, c1) \\\n               | same(b0, b1, d0, d1) \\\n               | same(c0, c1, d0, d1)\n\n    cond1 = ((a0 + b0) == (c0 + d0)) & ((a1 + b1) == (c1 + d1))\n    cond2 = ((a0 + c0) == (b0 + d0)) & ((a1 + c1) == (b1 + d1))\n    cond3 = ((a0 + d0) == (b0 + c0)) & ((a1 + d1) == (b1 + c1))\n\n    parallelogram_condition = cond1 | cond2 | cond3\n\n    return (1 - any_same) & parallelogram_condition\n", "model_name": "azure-openai-o1"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs, using MP-SPDZ secure comparison.\n    \"\"\"\n    c = a <= b\n    return c * a + (1 - c) * b\n", "response_1": "def smin(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return (a <= b).if_else(a, b)\n", "model_name": "azure-openai-o1"}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x, y):\n    n = 8\n    def legal(a, b):\n        return ((a >= 0) & (a < n) & (b >= 0) & (b < n))\n    counter = sint(0)\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n    return counter\n", "response_1": "from Compiler.types import sint, sbit\n\ndef choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board.\n    Here is a knight on position (x,y) of an empty chess board.\n    You should return how many positions on the chess board the knight can reach.\n    \"\"\"\n    zero = sint(0)\n    seven = sint(7)\n\n    def legal(a, b):\n        # Each comparison returns an sbit, so we convert to sint.\n        cond1 = (a.gte(zero)).to_sint()\n        cond2 = ((seven - a).gte(zero)).to_sint()\n        cond3 = (b.gte(zero)).to_sint()\n        cond4 = ((seven - b).gte(zero)).to_sint()\n        return cond1 * cond2 * cond3 * cond4\n\n    counter = sint(0)\n    counter = counter + legal(x + 1, y + 2)\n    counter = counter + legal(x - 1, y + 2)\n    counter = counter + legal(x + 1, y - 2)\n    counter = counter + legal(x - 1, y - 2)\n    counter = counter + legal(x + 2, y + 1)\n    counter = counter + legal(x - 2, y + 1)\n    counter = counter + legal(x + 2, y - 1)\n    counter = counter + legal(x - 2, y - 1)\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "max_sum_difference", "response_0": "# In MP-SPDZ, we use secure types and a conditional selection\n# utility function to replicate the Python \"if\" behavior.\n# This function returns the maximum value between a+b and a-b.\n# a and b should be secure integers (sint) in MP-SPDZ.\n\nfrom Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef max_sum_different(a: sint, b: sint) -> sint:\n    sum_val = a + b\n    diff_val = a - b\n    return if_else(sum_val > diff_val, sum_val, diff_val)\n", "response_1": "from Compiler.types import sfix\n\ndef max_sum_different(a, b):\n    sum_ = a + b\n    diff_ = a - b\n    cond = sum_ > diff_\n    return cond.if_else(sum_, diff_)\n\ndef main():\n    a = sfix.get_input_from(0)\n    b = sfix.get_input_from(0)\n    result = max_sum_different(a, b)\n    result.print_reveal()\n", "model_name": "azure-openai-o1"}
