{"test_name": "next_integer", "response_0": "from Compiler.types import sfix\n\ndef floor_sfix(x):\n    truncated = x.trunc()\n    is_negative = (x < sfix(0))\n    has_fraction = (x != truncated)\n    return truncated - (is_negative * has_fraction)\n\ndef next_integer(t):\n    return floor_sfix(t) + sfix(1)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import TruncPr\n\ndef floor_sfix(x):\n    int_part = x.trunc()           # Truncate towards zero\n    is_neg = x < sfix(0)           # Check if x is negative\n    is_not_int = x != int_part     # Check if x has a fractional part\n    return int_part - (is_neg * is_not_int)\n\ndef next_integer(t):\n    return floor_sfix(t) + 1\n", "model_name": "azure-openai-o1"}
{"test_name": "father_and_son", "response_0": "# Given the age of father and son (as secure MP-SPDZ types), \n# returns the absolute difference between father's age and twice son's age.\ndef father_and_son(father_age, son_age):\n    return (father_age - son_age * 2).abs()\n", "response_1": "# MP-SPDZ translation of the Python function:\n# Given the age of father and son, return the number of years \n# between the father's age being twice the son's age.\n\nfrom Compiler.types import sint\n\ndef father_and_son(father_age: sint, son_age: sint) -> sint:\n    diff = father_age - 2 * son_age\n    sign = diff < 0\n    return diff * (1 - 2 * sign)\n", "model_name": "azure-openai-o1"}
{"test_name": "triangle_area", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef triangle_area(side, height):\n    # Returns side * height / 2 in a secure manner\n    return side * height * sfix(0.5)\n\ndef main():\n    side = sfix.get_input_from(0)\n    height = sfix.get_input_from(0)\n    area = triangle_area(side, height)\n    print_ln(\"Triangle area: %s\", area.reveal())\n", "response_1": "from Compiler.types import sfix\n\ndef triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height,\n    compute the area of the triangle in secure fixed-point arithmetic.\n    \"\"\"\n    return side * height / sfix(2)\n", "model_name": "azure-openai-o1"}
{"test_name": "sin_plus_cos", "response_0": "from Compiler.types import sfix\n\ndef sin_approx(a):\n    x2 = a * a\n    x3 = x2 * a\n    x5 = x3 * x2\n    # Polynomial approximation of sin(x): x - x^3/6 + x^5/120\n    return a - x3 / sfix(6) + x5 / sfix(120)\n\ndef cos_approx(a):\n    x2 = a * a\n    x4 = x2 * x2\n    x6 = x2 * x4\n    # Polynomial approximation of cos(x): 1 - x^2/2 + x^4/24 - x^6/720\n    return sfix(1) - x2 / sfix(2) + x4 / sfix(24) - x6 / sfix(720)\n\ndef sin_plus_cos(a):\n    # Return sin(a) + cos(a) using polynomial approximations\n    return sin_approx(a) + cos_approx(a)\n\ndef main():\n    a = sfix.get_input_from(0)\n    result = sin_plus_cos(a)\n    result.print_plaintext()\n", "response_1": "from Compiler.library import sin_fx, cos_fx\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a).\n    Here, 'a' is expected to be a secret shared value (e.g., 'sfix').\n    \"\"\"\n    return sin_fx(a) + cos_fx(a)\n", "model_name": "azure-openai-o1"}
{"test_name": "sigmoid", "response_0": "from Compiler.types import sfix\n\n# The sigmoid function in MP-SPDZ\ndef sigmoid(x):\n    # Instead of math.pow(math.e, -x), we use the .exp() method on -x\n    return sfix(1) / (sfix(1) + (-x).exp())\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef sigmoid(x):\n    return sfix(1) / (sfix(1) + exp(x.neg()))\n", "model_name": "azure-openai-o1"}
{"test_name": "self_exponent", "response_0": "from Compiler.types import sint\n\ndef self_exponent(k):\n    # Return k^k in MP-SPDZ. Remove import math, as it's not needed here.\n    return k ** k\n", "response_1": "def self_exponent(k):\n    return k**k\n", "model_name": "azure-openai-o1"}
{"test_name": "silu", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef silu(x):\n    # x is expected to be an sfix value\n    return x / (sfix(1) + exp(-x))\n", "response_1": "# 1. Import MP-SPDZ libraries\nfrom Compiler.types import sfix\nfrom Compiler.library import exp\n\n# 2. Define the SiLU function\ndef silu(x):\n    return x / (1 + exp(-x))\n\n# 3. Main program\ndef main():\n    # Read secure input (e.g., from player 0)\n    x = sfix.get_input_from(0)\n    \n    # Compute the SiLU function\n    y = silu(x)\n    \n    # Store or output the result (e.g., for player 0)\n    y.store_in_mem(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "Gaussian_bracket", "response_0": "from Compiler.types import sfix\n\ndef Gaussian_bracket(x):\n    # x is assumed to be of type sfix.\n    # Extract the integer part through shifting right by the fractional precision.\n    x_int = x.v >> x.f      # This is a sint holding the floor of x if x >= 0.\n    x_int_sfix = sfix(x_int)  # Convert the integer part back to sfix.\n    return x - x_int_sfix     # The fractional part of x.\n", "response_1": "# gaussian_bracket.mpc\n# MP-SPDZ code translation for the Gaussian_bracket function.\n\nfrom Compiler.types import sfix\nfrom Compiler.library import TruncPr, comparison\n\ndef sfix_floor(x):\n    \"\"\"\n    Return floor(x) for secret fixed-point x.\n    \"\"\"\n    # Truncation toward zero\n    t = sfix(TruncPr(x, sfix.f, sfix.k, False))\n    # Fractional part\n    frac = x - t\n    # Indicates if x < 0\n    sign = comparison.LTZ(x)\n    # Indicates if the fractional part is non-zero\n    not_integer = comparison.NZ(frac)\n    # Correct for negative x\n    correction = sign * not_integer\n    return t - correction\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return x - floor(x) for secret fixed-point x.\n    \"\"\"\n    x_int = sfix_floor(x)\n    return x - x_int\n", "model_name": "azure-openai-o1"}
{"test_name": "asin_and_square", "response_0": "# arcsin_and_square.mpc\n\n# In MP-SPDZ, there is no built-in arcsin function. We use a Taylor-series\n# based polynomial approximation for arcsin(x) near 0:\n#    arcsin(x) \u2248 x + x^3/6 + 3x^5/40 + 5x^7/112\n# This approximation is reasonably accurate for |x| << 1. \n# Then we compute the square of the result.\n\nfrom Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef arcsin_approx(x):\n    term1 = x\n    term2 = (x**3) / 6\n    term3 = (3 * (x**5)) / 40\n    term4 = (5 * (x**7)) / 112\n    return term1 + term2 + term3 + term4\n\ndef main():\n    # Secret-shared input from party 0\n    x = sfix.get_input_from(0)\n    \n    # Approximate arcsin\n    arcsin_x = arcsin_approx(x)\n    \n    # Compute the square\n    result = arcsin_x * arcsin_x\n    \n    # Reveal the result for output\n    print_ln(\"arcsin(x)^2: %s\", result.reveal())\n", "response_1": "from Compiler.library import sqrt, atan, sfix\n\ndef asin_and_square(x):\n    \"\"\"\n    Approximate arcsin(x) = atan( x / sqrt(1 - x*x) ), then return its square.\n    \"\"\"\n    y = atan( x / sqrt(sfix(1) - x*x) )\n    return y * y\n", "model_name": "azure-openai-o1"}
{"test_name": "cylinder_surface", "response_0": "from Compiler.types import sfix\n\ndef cylinder_surface(r, h):\n    pi = sfix(3.141592653589793)\n    return sfix(2) * pi * (r * r) + sfix(2) * pi * r * h\n", "response_1": "# cylinder_surface.mpc\n\n# This MP-SPDZ program computes the surface area of a cylinder using secret shared inputs.\n# It replicates the functionality of the Python function:\n#     2 * math.pi * r**2 + 2 * math.pi * r * h\n# but uses sfix as the secret-shared floating-point type.\n\nfrom Compiler.types import sfix\n\ndef cylinder_surface(r, h):\n    # Define an approximate value for pi\n    pi = sfix(3.141592653589793)\n    \n    # Compute surface area using MP-SPDZ syntax\n    r_squared = r * r\n    term1 = sfix(2) * pi * r_squared\n    term2 = sfix(2) * pi * r * h\n    \n    return term1 + term2\n", "model_name": "azure-openai-o1"}
{"test_name": "radian_to_degree", "response_0": "from Compiler.types import sfix\n\nPI = 3.141592653589793\n\ndef radian_to_degree(r):\n    return r * sfix(180) / sfix(PI)\n\ndef main():\n    r = sfix.get_input_from(0)\n    result = radian_to_degree(r)\n    print_ln(\"%s\", result)\n", "response_1": "from Compiler.types import sfix, cfix\n\nPI = cfix(3.141592653589793)\n\ndef radian_to_degree(r):\n    return r / PI * cfix(180)\n", "model_name": "azure-openai-o1"}
{"test_name": "square_root", "response_0": "def square_root(a):\n    \"\"\"\n    Return the square root of the input.\n    \"\"\"\n    return a.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef square_root(a):\n    # a should be an sfix (secure fractional type)\n    return a.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "cosine_theorem", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt, cos\n\ndef cosine_theorem(a: sfix, b: sfix, rad: sfix) -> sfix:\n    \"\"\"\n    Given the two edges a, b and the angle rad between them,\n    use cosine theorem to compute the length of the third edge in a secure manner.\n    \"\"\"\n    c = a*a + b*b - 2*a*b*cos(rad)\n    return sqrt(c)\n", "response_1": "from Compiler.types import sfix\n\n# A small polynomial approximation for cosine around 0\ndef cos_approx(x):\n    # cos(x) \u2248 1 - x^2/2 + x^4/24\n    x2 = x * x\n    x4 = x2 * x2\n    return 1 - x2/2 + x4/24\n\ndef cosine_theorem(a, b, rad):\n    # Apply the cosine theorem: c = sqrt(a^2 + b^2 - 2ab cos(rad))\n    return (a*a + b*b - 2*a*b*cos_approx(rad)).sqrt()\n\n# Inputs a, b, rad as secret-shared sfix values (e.g. from party 0)\na = sfix.get_input_from(0)\nb = sfix.get_input_from(0)\nrad = sfix.get_input_from(0)\n\n# Compute the length of the third edge\nresult = cosine_theorem(a, b, rad)\n\n# Reveal the result\nresult.print_plain()\n", "model_name": "azure-openai-o1"}
{"test_name": "lights_states", "response_0": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    # In MP-SPDZ, use 'cint(2) ** num' for 2^num if 'num' is a public integer.\n    return cint(2) ** num\n", "response_1": "# MP-SPDZ code translating lights_states function\n# Reads a secure integer num from party 0, computes 2^num, and outputs the result to party 0\n\nnum = sint.get_input_from(0)\nresult = pow(cint(2), num)\nresult.reveal_to(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "degree_to_radian", "response_0": "from Compiler.types import sfix\n\n# Approximation of \u03c0 for MP-SPDZ\nPI = sfix(3.141592653589793)\n\ndef degree_to_radian(d):\n    # Converting degree to radian\n    return (d / sfix(180)) * PI\n", "response_1": "from Compiler.types import sfix\n\nPI = sfix(3.141592653589793)\n\ndef degree_to_radian(d):\n    # Converting degree to radian\n    return d * PI / 180\n", "model_name": "azure-openai-o1"}
{"test_name": "Fah_to_Cel", "response_0": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature (F) to Celsius temperature.\n    \"\"\"\n    return (F - sfix(32)) / sfix(1.8)\n", "response_1": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - sfix(32)) / sfix(1.8)\n", "model_name": "azure-openai-o1"}
{"test_name": "elliptic_area", "response_0": "from Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    # Define \u03c0 as a secure fixed-point constant\n    pi = sfix(3.141592653589793)\n    # Calculate and return area = \u03c0 * a * b\n    return pi * a * b\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef elliptic_area(a, b):\n    # Approximate \u03c0 as a constant\n    pi_approx = sfix(3.141592653589793)\n    return pi_approx * a * b\n\n# Read inputs from player 0\na = sfix.get_input_from(0)\nb = sfix.get_input_from(0)\n\n# Compute and reveal the result\narea_result = elliptic_area(a, b)\nprint_ln('Elliptic area: %s', area_result.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "floor", "response_0": "def floor(z):\n    from Compiler.types import sfix\n    # z is expected to be sfix.\n    truncated = z.trunc()                           # Remove fractional bits\n    fraction_is_zero = (z == truncated)             # Compare z and truncated\n    negative = (z < 0)\n    fraction_nonzero = fraction_is_zero.if_else(0, 1)\n    return truncated - sfix(negative * fraction_nonzero)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import Trunc, if_else\n\ndef floor_sfix(z):\n    # First, truncate towards zero.\n    truncated_value = Trunc(z, 0, False)\n    \n    # Check whether z is negative.\n    is_negative = z < 0\n    \n    # Check whether z is already an integer.\n    is_integer = z == truncated_value\n    \n    # Adjust only if negative and not already an integer.\n    adjust = if_else(is_negative * (1 - is_integer), 1, 0)\n    \n    # Subtract 1 if negative non-integer, else do nothing.\n    return truncated_value - adjust\n", "model_name": "azure-openai-o1"}
{"test_name": "log_and_cube", "response_0": "from Compiler.types import sfix\n\ndef log_and_cube(x):\n    # x is expected to be an sfix (secret floating-point) in MP-SPDZ\n    # We compute base-2 logarithm and then cube the result\n    log_val = x.log2()\n    return log_val * log_val * log_val\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import log2_fx\n\ndef log_and_cube(x):\n    # x is expected to be an sfix value in MP-SPDZ.\n    # We use the built-in log2_fx function to compute the approximate base-2 log,\n    # then multiply the result by itself three times to get the cube.\n    y = log2_fx(x)\n    return y * y * y\n", "model_name": "azure-openai-o1"}
{"test_name": "floor_and_square", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef floor_sfix(x):\n    # Truncate x to its integer part.\n    # Then subtract 1 if x is negative and has a non-zero fractional part.\n    t = x.Trunc()\n    # Check if x is negative and differs from its truncated version:\n    needs_sub = (x < 0) * (x != t)\n    return t - needs_sub\n\ndef floor_and_square(z):\n    # First compute floor(z) using the custom floor for sfix.\n    fz = floor_sfix(z)\n    # Return floor(z)\u00b2.\n    return fz * fz\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef floor_sfix(x):\n    \"\"\"\n    Compute floor(x) for a secret-fixed-point number x.\n    \"\"\"\n    frac_part = x.v & ((1 << sfix.f) - 1)\n    int_part = x.v >> sfix.f\n    negative = (x.v < 0)\n    has_fraction = (frac_part != 0)\n    correction = if_else(negative * has_fraction, 1, 0)\n    return sfix(int_part - correction, k=x.k, f=x.f)\n\ndef floor_and_square(z):\n    \"\"\"\n    Calculate the floor of z and then return its square.\n    \"\"\"\n    floored_z = floor_sfix(z)\n    return floored_z * floored_z\n", "model_name": "azure-openai-o1"}
{"test_name": "meters_to_feet", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef meters_to_feet(m):\n    return m * sfix(3.2808)\n\nm = sfix.get_input_from(0)\nresult = meters_to_feet(m)\nprint_ln(\"%s\", result)\n", "response_1": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * sfix(3.2808)\n", "model_name": "azure-openai-o1"}
{"test_name": "sphere_area", "response_0": "from Compiler.types import sfix\n\ndef sphere_area(r):\n    pi = sfix(3.141592653589793)\n    return sfix(4) * pi * r * r\n", "response_1": "def sphere_area(r):\n    # MP-SPDZ does not support external libraries like math; we define pi ourselves.\n    # Use an appropriate secure data type, e.g., sfix for fixed-point arithmetic.\n    pi = sfix(3.141592653589793)\n    return sfix(4) * pi * r * r\n", "model_name": "azure-openai-o1"}
{"test_name": "coarse_abs", "response_0": "# Translation of the Python function coarse_abs(x) = floor(abs(x))\n# into an MP-SPDZ function using secret-shared fixed-point values.\n\nfrom Compiler.types import sfix\n\ndef coarse_abs(x: sfix):\n    # x is a secret-shared fixed-point number\n    # 1) Take absolute value\n    # 2) Extract integer part (floor for positive values)\n    return x.abs().int_part()\n", "response_1": "from Compiler.types import sfix\n\ndef coarse_abs(x):\n    # x is an sfix\n    # Return the absolute value of x, and truncate any fractional part\n    return x.abs().int_part()\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_chickens", "response_0": "from Compiler.types import sint\nfrom Compiler.library import sdivsi\n\n# Read two secure integers (heads, legs) from player 0\nheads = sint.get_input_from(0)\nlegs = sint.get_input_from(0)\n\n# Perform the calculation how_many_chickens(heads, legs):\n# chickens = heads - ((legs - 2*heads) // 2)\ntemp = legs - (heads * 2)\nhalf_temp = sdivsi(temp, 2)\nchickens = heads - half_temp\n\n# Output the result\nchickens.print_ln(\"%s\", chickens)\n", "response_1": "def how_many_chickens(heads, legs):\n    # heads and legs are secret/shared integers (sint)\n    return heads - ((legs - heads * 2) >> 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "interest_calculator", "response_0": "def interest_calculator(capital, ratio, months):\n    return ((sfix(1) + ratio).pow(months) - sfix(1)) * capital\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\ndef main():\n    # Read inputs as secret-shared or private values as needed\n    capital = sfix.get_input_from(0)\n    ratio = sfix.get_input_from(0)\n    months = sint.get_input_from(0)  # Assuming months is an integer\n\n    # Compute (1 + ratio) ^ months by repeated multiplication\n    one_plus_ratio = sfix(1) + ratio\n    power_value = sfix(1)\n    # For a private 'months', this loop reveals 'months' to all parties\n    # If you want to keep 'months' secret, consider other techniques\n    for i in range(months.reveal()):\n        power_value = power_value * one_plus_ratio\n\n    # Calculate interest: ( (1 + ratio)^months - 1 ) * capital\n    interest = (power_value - sfix(1)) * capital\n\n    # Reveal the result\n    print_ln(\"Calculated interest: %s\", interest.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "circle_area", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\n# Approximate value for \u03c0\npi = sfix(3.141592653589793)\n\n# Securely read the radius from party 0\nr = sfix.get_input_from(0)\n\n# Compute the area\narea = pi * (r * r)\n\n# Output the result\nprint_ln(\"%s\", area.reveal())\n", "response_1": "def circle_area(r):\n    # r should be a secure fixed-point type (e.g. sfix) in MP-SPDZ\n    pi = sfix(3.141592653589793)\n    return pi * r * r\n", "model_name": "azure-openai-o1"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler.types import sfix\n\ndef cube_and_square_root(x):\n    # x is expected to be an sfix for secure computations\n    # compute x^3\n    cubic_value = x * x * x\n    # return the square root of the cubic value\n    return cubic_value.sqrt()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import print_ln, sqrt\n\nx = sfix.get_input_from(0)\ncubed_value = x * x * x\nresult = sqrt(cubed_value)\n\nprint_ln(\"cube_and_square_root: %s\", result.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "round", "response_0": "from Compiler.types import sfix\n\ndef mpc_round(x):\n    x_int = x.floor()\n    cond = (x - x_int) < sfix(0.5)\n    return sfix.if_else(cond, x_int, x_int + sfix(1))\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import floor\n\ndef round_sfix(x):\n    x_int = floor(x)\n    fractional_part = x - x_int\n    condition = fractional_part < sfix(0.5)\n    return condition.if_else(x_int, x_int + sfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "cryptic_adjustment", "response_0": "from Compiler.types import sfix\n\ndef cryptic_adjustment(origin):\n    return sfix(10) * (sfix(10) * origin.sqrt()).sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef cryptic_adjustment(origin):\n    tmp_sqrt_1 = origin.sqrt()\n    tmp_mult_10 = sfix(10) * tmp_sqrt_1\n    tmp_sqrt_2 = tmp_mult_10.sqrt()\n    return sfix(10) * tmp_sqrt_2\n", "model_name": "azure-openai-o1"}
{"test_name": "specific_pow", "response_0": "def specific_pow(x):\n    \"\"\"\n    Return x^(2.5) in MP-SPDZ. \n    (Here, x should be a secure fixed-point type, \n    and x.sqrt() provides the square root of x.)\n    \"\"\"\n    return x * x * x.sqrt()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt_fx\n\ndef specific_pow(x):\n    # Computes x^(2.5) using x^2 * sqrt(x)\n    return x * x * sqrt_fx(x)\n", "model_name": "azure-openai-o1"}
{"test_name": "soft_plus", "response_0": "from Compiler.types import sfix\n\ndef soft_plus(x):\n    return sfix.log(1 + sfix.exp(x))\n", "response_1": "from Compiler.types import sfix\n\ndef soft_plus(x):\n    # Computes log( 1 + e^x ) using MP-SPDZ\n    return sfix.log(sfix(1) + sfix.exp(x))\n", "model_name": "azure-openai-o1"}
{"test_name": "ball_volume", "response_0": "from Compiler.types import sfix\n\ndef ball_volume(r):\n    # Return the volume of the ball with given radius\n    pi = sfix(3.141592653589793)\n    return (sfix(4) / sfix(3)) * pi * (r * r * r)\n", "response_1": "from Compiler.types import sfix\n\n# Approximate the mathematical constant \u03c0\npi = sfix(3.141592653589793)\n\ndef ball_volume(r):\n    # Compute r cubed\n    r_cubed = r * r * r\n    # Return (4/3)\u03c0r\u00b3\n    return (sfix(4) * pi * r_cubed) / sfix(3)\n", "model_name": "azure-openai-o1"}
{"test_name": "Heron", "response_0": "# In MP-SPDZ, we assume `a`, `b`, and `c` are sfix (secure fixed-point) variables.\n# This function computes the triangle area using Heron's formula.\n\ndef Heron(a, b, c):\n    p = (a + b + c) / sfix(2)\n    return (p * (p - a) * (p - b) * (p - c)).sqrt()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef main():\n    a = sfix.get_input_from(0)\n    b = sfix.get_input_from(0)\n    c = sfix.get_input_from(0)\n\n    p = (a + b + c) / 2\n    area = sqrt(p * (p - a) * (p - b) * (p - c))\n    area.print_plain()\n", "model_name": "azure-openai-o1"}
{"test_name": "next_perfect_square", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import sqrt_fx, TruncPr\n\ndef next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x.\n    The input x is guaranteed to be a positive integer.\n    \"\"\"\n    x_sfix = sfix(x)\n    approximate_root = sqrt_fx(x_sfix)\n    floor_root = TruncPr(approximate_root, 0, approximate_root.k, approximate_root.f)\n    return (floor_root + 1) * (floor_root + 1)\n", "response_1": "from Compiler.types import sint, sfix\n\ndef next_perfect_square(x):\n    # x is a positive integer (sint)\n    # Convert x to sfix for applying sqrt()\n    xf = sfix(x)\n    # Compute the square root as sfix, then truncate to get floor value\n    c_floor = xf.sqrt().trunc()\n    # Increment by 1 and square again\n    return (c_floor + 1) * (c_floor + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "pi_to_the_x", "response_0": "def pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x in MP-SPDZ using fixed-point operations.\n    \"\"\"\n    from Compiler.types import sfix, cfix\n    from Compiler.library import log_fx, exp_fx\n    \n    cfix_pi = cfix(3.141592653589793)  # cfix constant for pi\n    # Compute pi^x = exp(x * log(pi))\n    return exp_fx(x * log_fx(cfix_pi))\n", "response_1": "# pi_to_the_x.mpc\n\n# This MP-SPDZ program defines a function that, given a secret input x,\n# computes pi^x using an approximate value of pi.\n\nfrom Compiler.types import sfix\n\ndef pi_to_the_x(x):\n    # Approximate value of pi as a public sfix constant.\n    pi_approx = sfix(3.141592653589793)\n    # Return pi^x.\n    return pi_approx ** x\n", "model_name": "azure-openai-o1"}
{"test_name": "spring_rocket", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef main():\n    height = sfix.get_input_from(0)\n    mass = sfix.get_input_from(0)\n    stiffness = sfix.get_input_from(0)\n    g = sfix(9.8)\n    result = sqrt(sfix(2) * mass * g * height / stiffness)\n    result.print_reveal()\n", "response_1": "from Compiler.types import sfix\n\ndef spring_rocket(height, m, k):\n    g = sfix(9.8)\n    return (2 * m * g * height / k).sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "cone_volume", "response_0": "from Compiler.types import sfix\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return pi * r * r * h / sfix(3)\n", "response_1": "from Compiler.types import sfix\n\ndef cone_volume(r, h):\n    pi = sfix(3.141592653589793)\n    return (pi * r * r * h) / sfix(3)\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2).div(2)\n", "response_1": "from Compiler.types import sint\n\ndef how_many_rabbits(heads: sint, legs: sint) -> sint:\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem in MP-SPDZ.\n    \"\"\"\n    return (legs - heads * 2).div(2)\n", "model_name": "azure-openai-o1"}
