{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler.types import sfix, Array\n\ndef main():\n    start = sfix(0)\n    end = sfix(99)\n    num = 10\n    step = (end - start) / (num - 1)\n    a = Array(num, sfix)\n    for i in range(num):\n        a[i] = start + sfix(i) * step\n", "response_1": "from Compiler.types import sfix, Array\n\nstart = sfix(0)\nend = sfix(99)\nnum = 10\n\na = Array(num, sfix)\nstep = (end - start) / sfix(num - 1)\n\nfor i in range(num):\n    a[i] = start + step * sfix(i)\n", "model_name": "azure-openai-o1"}
{"test_name": "more_positive", "response_0": "from Compiler.types import sint\n\ndef more_positive(arr):\n    # Initialize a secret integer sum\n    s = sint(0)\n    # Accumulate the sign of each element in arr\n    for x in arr:\n        # 1 when x>0, 0 otherwise\n        is_pos = x > 0\n        # 1 when x<0, 0 otherwise\n        is_neg = x < 0\n        # sign(x) = is_pos - is_neg\n        s += (is_pos - is_neg)\n    # Return an sbit indicating whether the sum of signs is greater than 0\n    return s > 0\n", "response_1": "from Compiler.types import sint\nfrom Compiler.types import sfix\n\ndef more_positive(arr):\n    # We'll compute the difference between the number of positive and negative elements.\n    # 'sum_sign' accumulates (#pos - #neg).\n    sum_sign = sint(0)\n    for x in arr:\n        # pos and neg are secret bits indicating x>0 and x<0 respectively\n        pos = x > 0\n        neg = x < 0\n        \n        # Convert secret bits to secret integers\n        pos_int = pos.if_else(sint(1), sint(0))\n        neg_int = neg.if_else(sint(1), sint(0))\n        \n        # Add to the running sum of signs\n        sum_sign += pos_int - neg_int\n    \n    # Compare sum_sign to 0. This returns a secret bit indicating if #pos > #neg\n    return sum_sign > 0\n", "model_name": "azure-openai-o1"}
{"test_name": "select", "response_0": "# In MP-SPDZ, we typically work with secure data types (e.g., sfix) instead of standard Python floats.\n# We also use secure boolean types (sbit or sfix assumed to be 0/1) for conditions.\n# Below is a straightforward element-wise selection, following the semantics of \"np.where(ind, a, b)\".\n# Each position i will be taken from a[i] if ind[i] is 1, otherwise from b[i].\n\ndef select(ind, a, b):\n    n = len(ind)\n    res = [sfix() for _ in range(n)]\n    for i in range(n):\n        # 'ind[i]' is treated as a secure boolean (0 or 1).\n        # 'if_else' chooses 'a[i]' if 'ind[i]' is 1, otherwise 'b[i]'.\n        res[i] = ind[i].if_else(a[i], b[i])\n    return res\n", "response_1": "from Compiler.types import sfix\n\ndef select(ind, a, b):\n    n = len(ind)\n    res = sfix.Array(n)\n    for i in range(n):\n        res[i] = ind[i]*a[i] + (1 - ind[i])*b[i]\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_relu", "response_0": "# MP-SPDZ implementation of ReLU function\n\nfrom Compiler.types import sfix\n\ndef relu(x):\n    # x is a secret-shared fixed-point value\n    # compare x with 0, returning a 'secret-bit' type\n    mask = (x > 0)\n    # multiply x by the mask to zero out negative values\n    return mask * x\n", "response_1": "# In MP-SPDZ, we can replace np.clip(y, 0, np.inf) with a direct max(0, y) operation.\n# For secret-shared data types such as sfix, the comparison operator (>) will yield 1 if y > 0 and 0 otherwise.\n# Multiplying y by (y > 0) thus zeroes out all negative values and keeps non-negative values as is.\n\ndef relu(y):\n    return y * (y > 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "cost_matrix", "response_0": "# MP-SPDZ code translating the Python code for cost_matrix\n# Note: This example assumes profit_matrix is a 2D list of sfix values.\n\ndef cost_matrix(profit_matrix):\n    rows = len(profit_matrix)\n    cols = len(profit_matrix[0])\n\n    # Find the maximum element in profit_matrix\n    max_val = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            cond = profit_matrix[i][j] > max_val\n            max_val = max_val.if_else(cond, profit_matrix[i][j], max_val)\n\n    # Build offset_matrix using max_val\n    offset_matrix = []\n    for i in range(rows):\n        row_offset = []\n        for j in range(cols):\n            row_offset.append(max_val)\n        offset_matrix.append(row_offset)\n\n    # Compute cost_matrix = offset_matrix - profit_matrix\n    cost_matrix_result = []\n    for i in range(rows):\n        row_cost = []\n        for j in range(cols):\n            row_cost.append(offset_matrix[i][j] - profit_matrix[i][j])\n        cost_matrix_result.append(row_cost)\n\n    return cost_matrix_result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import Matrix\n\ndef cost_matrix(profit_matrix, rows, cols):\n    # Find the maximum value in the profit_matrix\n    curr_max = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            cond = profit_matrix[i][j] > curr_max\n            curr_max = cond.if_else(profit_matrix[i][j], curr_max)\n\n    # Build an offset matrix using the maximum value\n    offset_matrix = Matrix(sfix, rows, cols)\n    for i in range(rows):\n        for j in range(cols):\n            offset_matrix[i][j] = curr_max\n\n    # Compute the cost matrix\n    cost_m = Matrix(sfix, rows, cols)\n    for i in range(rows):\n        for j in range(cols):\n            cost_m[i][j] = offset_matrix[i][j] - profit_matrix[i][j]\n\n    return cost_m\n", "model_name": "azure-openai-o1"}
{"test_name": "np_zeros", "response_0": "from Compiler.types import sint\n\nn = 10\na = sint.Array(n)\na.assign_all(0)\n", "response_1": "n = 10\na = sfix.Array(n)\na.assign_all(sfix(0))\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "# MP-SPDZ code: array_dimensional_indexing for extracting the i-th row from a 2-D secure array\n\ndef array_dimensional_indexing(ndarray, row_index, rows, cols):\n    \"\"\"\n    Translated version of the Python function to index the i-th row from a 2-D secure array.\n    - ndarray: sfix.Matrix(rows, cols)\n    - row_index: secure integer (sint) specifying which row to index\n    - rows, cols: integer constants for matrix dimensions\n    \"\"\"\n    row = sfix.Array(cols)\n    @for_range(cols)\n    def _(j):\n        row[j] = ndarray[row_index][j]\n    return row\n", "response_1": "# Secretariat for setting dimensions\nN = 4\nM = 5\n\n# Secret-shared input for row index\nrow_index = sint.get_input_from(0)\n\n# Reading a 2D secret-shared array\nmatrix_2d = Matrix(N, M, sfix)\nfor i in range(N):\n    for j in range(M):\n        matrix_2d[i][j] = sfix.get_input_from(0)\n\n# Selecting the row corresponding to row_index\nselected_row = Array(M, sfix)\nfor j in range(M):\n    selected_row[j] = matrix_2d[row_index][j]\n\n# Reveal or further process selected_row as needed\nfor j in range(M):\n    selected_row[j].reveal_to(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    from Compiler.types import sfix, Array\n    from Compiler.library import for_range\n    arr = sfix.Array(n)\n    @for_range(n)\n    def _(i):\n        arr[i] = sfix(0)\n    return arr\n", "response_1": "def zeros(n):\n    arr = sfix.Array(n)\n    for i in range(n):\n        arr[i] = sfix(0)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_slicing_stride", "response_0": "# This MP-SPDZ program replicates array_concate(ndarrayA, ndarrayB) by \n# collecting all even-index elements from A and odd-index elements from B, \n# then concatenating them.\n\n# Define lengths for demonstration, replace them with actual lengths as needed.\nnA = 5\nnB = 6\n\n# Read arrays as secure fixed-point arrays from player 0\nA = sfixArray(nA, input_from=0)\nB = sfixArray(nB, input_from=0)\n\n# Calculate the lengths of the slices\nA_even_len = (nA + 1) // 2\nB_odd_len = nB // 2\n\n# Allocate intermediate slicing arrays\nviewA = sfixArray(A_even_len)\nviewB = sfixArray(B_odd_len)\n\n# Fill viewA with elements at even indices of A\nfor i in range(A_even_len):\n    viewA[i] = A[2 * i]\n\n# Fill viewB with elements at odd indices of B\nfor i in range(B_odd_len):\n    viewB[i] = B[2 * i + 1]\n\n# Concatenate the two views\nconc_len = A_even_len + B_odd_len\nconc = sfixArray(conc_len)\n\nfor i in range(A_even_len):\n    conc[i] = viewA[i]\nfor i in range(B_odd_len):\n    conc[A_even_len + i] = viewB[i]\n\n# Output each element in the final concatenated array\nfor i in range(conc_len):\n    print_ln(\"%s\", conc[i].reveal())\n", "response_1": "from Compiler.types import sint, Array, MemValue\nfrom Compiler.library import for_range\n\ndef array_concate(A, B, n, m):\n    # Number of even indices in [0...n-1]\n    sizeA = (n + 1) // 2\n    # Number of odd indices in [0...m-1]\n    sizeB = m // 2\n    # Prepare result array\n    result_size = sizeA + sizeB\n    C = Array(result_size, sint)\n\n    c_index = MemValue(sint(0))\n\n    # Fill from A's even indices\n    @for_range(sizeA)\n    def loopA(i):\n        even_index = 2 * i\n        C[c_index] = A[even_index]\n        c_index.write(c_index + 1)\n\n    # Fill from B's odd indices\n    @for_range(sizeB)\n    def loopB(i):\n        odd_index = 2 * i + 1\n        C[c_index] = B[odd_index]\n        c_index.write(c_index + 1)\n\n    return C\n\n# Read lengths\nn = sint.get_input_from(0)\nm = sint.get_input_from(0)\n\n# Read first array\nA = Array(n, sint)\nA.input_from(0)\n\n# Read second array\nB = Array(m, sint)\nB.input_from(0)\n\n# Concatenate\nC = array_concate(A, B, n, m)\n\n# Reveal and print output\nfor i in range(len(C)):\n    C[i].reveal().print_ln()\n", "model_name": "azure-openai-o1"}
{"test_name": "QR_decomposition", "response_0": "# This MP-SPDZ program computes the Q matrix of the QR decomposition \n# using the classical Gram-Schmidt process. \n# The input matrix \"mat\" is read as secret-shared values.\n\n# Use sfix for secret-shared fixed-point representation\n# (You could also use sfloat if preferred.)\n\nfrom Compiler.types import sfix\nfrom Compiler.library import for_range, for_range_multithread\nfrom Compiler.library import print_ln\nfrom Compiler.matrix import Matrix, vector\n\ndef QR_decomposition(mat):\n    # mat is an MxN matrix of sfix\n    M = len(mat)\n    N = len(mat[0])\n\n    # Allocate Q and R\n    Q = Matrix(sfix, M, N)\n    R = Matrix(sfix, N, N)\n\n    # Temporary vector for Gram-Schmidt\n    v_j = vector(sfix, M)\n\n    # Classical Gram-Schmidt\n    for j in range(N):\n        # Copy column j of mat into v_j\n        for i in range(M):\n            v_j[i] = mat[i][j]\n        # Orthogonalize v_j w.r.t. all previously computed columns of Q\n        for k in range(j):\n            # R[k][j] = Q[:,k]^T * mat[:,j]\n            temp_sum = sfix(0)\n            for i in range(M):\n                temp_sum = temp_sum + Q[i][k] * mat[i][j]\n            R[k][j] = temp_sum\n            # v_j = v_j - R[k][j]*Q[:,k]\n            for i in range(M):\n                v_j[i] = v_j[i] - R[k][j] * Q[i][k]\n\n        # R[j][j] = norm of v_j\n        norm_val = sfix(0)\n        for i in range(M):\n            norm_val = norm_val + v_j[i] * v_j[i]\n        # Use sqrt from library or an appropriate fixed-point approximation if available\n        # Here we do a naive square root using pow, which may need an approximation\n        R[j][j] = norm_val.pow(0.5)\n\n        # Q[:,j] = v_j / R[j][j]\n        for i in range(M):\n            Q[i][j] = v_j[i] / R[j][j]\n\n    return Q\n\ndef main():\n    # Example dimensions (modify for your scenario)\n    M = 3\n    N = 3\n\n    # Read input matrix mat in secret-shared form\n    mat = Matrix(sfix, M, N)\n    for i in range(M):\n        for j in range(N):\n            mat[i][j] = sfix.get_input_from(0)\n\n    # Compute Q\n    Q_result = QR_decomposition(mat)\n\n    # Output Q_result\n    for i in range(M):\n        for j in range(N):\n            print_ln(\"Q[%s][%s] = %s\", i, j, Q_result[i][j].reveal())\n", "response_1": "# QR_decomposition.mpc\n\n# This program computes the Q matrix of the QR-decomposition using a \n# simple Gram-Schmidt process in MP-SPDZ. \n# Note that it is assumed that 'mat' is an n-by-m matrix of secret-shared sfix values.\n\nfrom Compiler.types import sfix, Matrix\n\ndef QR_decomposition_Q(mat: Matrix) -> Matrix:\n    n = len(mat)        # Number of rows\n    m = len(mat[0])     # Number of columns\n\n    # Initialize Q as an n-by-m matrix of zeros\n    Q = Matrix(n, m, sfix(0))\n\n    # Classical Gram-Schmidt\n    for i in range(m):\n        # v is initially the i-th column of mat\n        v = [mat[row][i] for row in range(n)]\n\n        # Subtract the projections onto the previous columns of Q\n        for j in range(i):\n            dot_q_m = sfix(0)\n            for row in range(n):\n                dot_q_m += Q[row][j] * mat[row][i]\n            for row in range(n):\n                v[row] = v[row] - dot_q_m * Q[row][j]\n\n        # Compute the norm of v\n        norm_v_sq = sfix(0)\n        for row in range(n):\n            norm_v_sq += v[row] * v[row]\n\n        # Secure square root\n        norm_v = norm_v_sq.sqrt()\n\n        # Normalize and store in Q\n        for row in range(n):\n            Q[row][i] = v[row] / norm_v\n\n    return Q\n", "model_name": "azure-openai-o1"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of the nearest value in a secure array to the given secure value.\n    Both 'array' and 'value' should be MP-SPDZ secure types (e.g., sfix).\n    \"\"\"\n    from Compiler.library import if_else\n    from Compiler.types import sfix, sint\n\n    # Initialize minimum difference to a large number and index to 0\n    min_diff = sfix(999999999)\n    min_idx = sint(0)\n\n    # Assume 'array' is a list/tuple of secure values\n    for i, x in enumerate(array):\n        diff = x - value\n        # Compute absolute difference\n        is_neg = diff < sfix(0)\n        diff_abs = if_else(is_neg, -diff, diff)\n        # Compare to update minimum difference\n        is_smaller = diff_abs < min_diff\n        min_diff = if_else(is_smaller, diff_abs, min_diff)\n        min_idx = if_else(is_smaller, sint(i), min_idx)\n\n    return min_idx\n", "response_1": "# MP-SPDZ code translating the Python function \"find_nearest_index\"\n# that returns the index of the nearest value in a secret integer array \n# to a secret integer value.\n\ndef find_nearest_index(array, value):\n    n = len(array)\n    # Initialize min_distance to a large secret integer\n    # and min_index to zero.\n    min_distance = sint(2147483647)\n    min_index = sint(0)\n\n    for i in range(n):\n        tmp = array[i] - value\n        # Compute absolute value of tmp in MP-SPDZ\n        dist = (tmp < 0).if_else(-tmp, tmp)\n        # Check if the new distance is smaller\n        is_less = dist < min_distance\n        # Update minimum distance and index accordingly\n        min_distance = is_less.if_else(dist, min_distance)\n        min_index = is_less.if_else(sint(i), min_index)\n\n    return min_index\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_simple_row", "response_0": "# In MP-SPDZ, you typically work with secret-shared data types instead of regular NumPy arrays.\n# Below is an example function that conceptually replicates np.concatenate along axis 0.\n\n# Assume ndarrayA and ndarrayB are 2-D secret-shared arrays (e.g., sfix, sint).\n# Let M denote the number of rows in ndarrayA, K the number of rows in ndarrayB,\n# and N the number of columns for both.\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB, M, K, N):\n    # Create a new 2-D array with (M + K) rows and N columns\n    res = sfix.Array(M + K, N)\n    # Copy rows from the first array\n    for i in range(M):\n        for j in range(N):\n            res[i][j] = ndarrayA[i][j]\n    # Append rows from the second array\n    for i in range(K):\n        for j in range(N):\n            res[M + i][j] = ndarrayB[i][j]\n    return res\n", "response_1": "from Compiler.types import sfix\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D secret-shared arrays along axis 0.\n    \"\"\"\n    rowsA = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    rowsB = len(ndarrayB)\n    result = [[sfix(0) for _ in range(colsA)] for _ in range(rowsA + rowsB)]\n    \n    for i in range(rowsA):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n    \n    for i in range(rowsB):\n        for j in range(colsA):\n            result[rowsA + i][j] = ndarrayB[i][j]\n    \n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "np_copy", "response_0": "from Compiler.types import Array\n\ndef array_copy(ndarray):\n    n = len(ndarray)\n    elem_type = type(ndarray[0])\n    copy_array = Array(n, elem_type)\n    for i in range(n):\n        copy_array[i] = ndarray[i]\n    return copy_array\n", "response_1": "def array_copy(src_array):\n    n = len(src_array)\n    copied_array = Array(n, sfix)  # or 'sint' / 'sfloat' depending on your needs\n    for i in range(n):\n        copied_array[i] = src_array[i]\n    return copied_array\n", "model_name": "azure-openai-o1"}
{"test_name": "max_pooling", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else, for_range\n\ndef max_pooling(x, stride, n_batch, n_height, n_width):\n    \"\"\"\n    x        : 3D secret-shared input array of dimensions [n_batch, n_height, n_width]\n    stride   : public integer stride\n    n_batch  : public integer, number of batches\n    n_height : public integer, height dimension\n    n_width  : public integer, width dimension\n\n    Returns a 3D secret-shared array \"out\" of dimensions \n      [n_batch, n_height // stride, n_width // stride], \n    where each element is the maximum value of the stride-by-stride block in x.\n    \"\"\"\n    out_height = n_height // stride\n    out_width = n_width // stride\n\n    # Create output array\n    out = sfix.Array([n_batch, out_height, out_width])\n\n    # Perform max pooling\n    @for_range(n_batch)\n    def loop_b(b):\n        @for_range(0, n_height, stride)\n        def loop_i(i):\n            @for_range(0, n_width, stride)\n            def loop_j(j):\n                temp = x[b][i][j]\n                # Evaluate over stride-by-stride region\n                @for_range(stride)\n                def loop_i2(i2):\n                    @for_range(stride)\n                    def loop_j2(j2):\n                        cond = x[b][i + i2][j + j2] > temp\n                        temp_assign = if_else(cond, x[b][i + i2][j + j2], temp)\n                        temp.write(temp_assign)\n                out[b][i // stride][j // stride] = temp\n\n    return out\n", "response_1": "# MP-SPDZ program for max pooling\n# Note: No usage examples included in this code block.\n\n# Example static shapes (replace with your own setup).\nnB = 2        # Batch size\nnH = 6        # Input height\nnW = 6        # Input width\nstride = 2    # Pooling stride\n\n# Define input array (B x H x W).\nx = Array(nB, Array(nH, Array(nW, sfix)))\n\n# Read input values for x from party 0.\nfor b in range(nB):\n    for i in range(nH):\n        for j in range(nW):\n            x[b][i][j] = sfix.get_input_from(0)\n\n# Compute output shape after pooling.\noutH = nH // stride\noutW = nW // stride\n\n# Define output array.\nout = Array(nB, Array(outH, Array(outW, sfix)))\n\n# Perform max pooling.\nfor b in range(nB):\n    for i in range(0, nH, stride):\n        for j in range(0, nW, stride):\n            cur_max = x[b][i][j]\n            for p in range(stride):\n                for q in range(stride):\n                    tmp = x[b][i + p][j + q]\n                    bigger = tmp > cur_max\n                    cur_max = bigger.if_else(tmp, cur_max)\n            out[b][i // stride][j // stride] = cur_max\n\n# Store the result. \n# (Adapt the storing or printing of results to your own need.)\nfor b in range(nB):\n    for i in range(outH):\n        for j in range(outW):\n            out[b][i][j].store_in_mem()\n", "model_name": "azure-openai-o1"}
{"test_name": "array_reshape", "response_0": "from Compiler.types import sint, Matrix\n\nn = 3\nm = 5\n\n# Create a 3\u00d75 matrix 'a'\na = Matrix(n, m, sint)\n\nval = 0\nfor i in range(n):\n    for j in range(m):\n        a[i][j] = sint(val)\n        val += 1\n", "response_1": "// Define a 2D array of secret integers (sint) with 3 rows and 5 columns\nsint a[3][5];\n\n// Fill the array with values 0..14\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 5; j++) {\n        a[i][j] = i * 5 + j;\n    }\n}\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_simple_column", "response_0": "# In MP-SPDZ, one can implement a function that concatenates two matrices along axis 1 (columns) like this:\n# (Here, we assume both input matrices have the same number of rows. \n# The type sfix is used as an example for secret-shared fixed-point data.)\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    nA = len(ndarrayA)\n    mA = len(ndarrayA[0])\n    nB = len(ndarrayB)\n    mB = len(ndarrayB[0])\n\n    # Initialize the result matrix with nA rows and (mA + mB) columns\n    result = Matrix(sfix, nA, mA + mB)\n\n    # Copy values from the first matrix\n    for i in range(nA):\n        for j in range(mA):\n            result[i][j] = ndarrayA[i][j]\n\n    # Copy values from the second matrix\n    for i in range(nA):\n        for j in range(mB):\n            result[i][mA + j] = ndarrayB[i][j]\n\n    # Return the concatenated result\n    return result\n", "response_1": "# In MP-SPDZ, you typically work with secret-shared data types instead of NumPy arrays.\n# The following function shows how to combine two 2D secret-shared arrays along axis 1.\n\ndef array_simple_concate_column(A, B):\n    # Determine dimensions\n    R = len(A)\n    C1 = len(A[0])\n    C2 = len(B[0])\n\n    # Create a new 2D array (Matrix) for the result with dimensions (R, C1 + C2)\n    # using secret-shared fixed-point type sfix\n    res = Matrix(R, C1 + C2, sfix)\n\n    # Copy values from A\n    for i in range(R):\n        for j in range(C1):\n            res[i][j] = A[i][j]\n\n    # Copy values from B, placing them after A's columns\n    for i in range(R):\n        for j in range(C2):\n            res[i][C1 + j] = B[i][j]\n\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "# array_dimensional_indexing.mpc\n\n# This MP-SPDZ program demonstrates how to extract the i-th column from a 2-D array.\n# It defines a function that takes an MP-SPDZ matrix (e.g., of type sfix), a column index,\n# and the number of rows n, then returns a new 1-D array corresponding to the selected column.\n\nfrom Compiler.types import sfix\n\ndef array_dimensional_indexing(ndarray, column_index, n):\n    result_column = sfix.Array(n)\n    for i in range(n):\n        result_column[i] = ndarray[i][column_index]\n    return result_column\n", "response_1": "def array_dimensional_indexing(matrix, n, m, column_index):\n    \"\"\"\n    Returns the i-th column from a 2-D array (matrix) as an array of length n.\n    \"\"\"\n    from Compiler.types import sfix\n    column_array = sfix.Array(n)\n    for i in range(n):\n        column_array[i] = matrix[i][column_index]\n    return column_array\n", "model_name": "azure-openai-o1"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    # Determine the dimensions of the 2D array\n    rows = len(array)\n    cols = len(array[0])\n\n    # Find the smaller dimension for the diagonal length\n    size = min(rows, cols)\n\n    # Allocate a list for the diagonal\n    diagonal_result = [sfix(0) for _ in range(size)]\n\n    # Extract the diagonal\n    for i in range(size):\n        diagonal_result[i] = array[i][i]\n\n    # Return the diagonal as a list\n    return diagonal_result\n", "response_1": "def diag(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    size = rows if rows < cols else cols\n    diagonal = [matrix[0][0].__class__.get_type(0) for _ in range(size)]\n    for i in range(size):\n        diagonal[i] = matrix[i][i]\n    return diagonal\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_special", "response_0": "from Compiler.types import sfix\n\ndef array_special_concate(rows, colsA, A, colsB, B):\n    # Number of even columns in the first array\n    num_even_colsA = (colsA + 1) // 2\n    # Number of odd columns in the second array\n    num_odd_colsB = colsB // 2\n    # Total columns in the result\n    res_cols = num_even_colsA + num_odd_colsB\n\n    # Initialize the result array\n    res = [[sfix(0) for _ in range(res_cols)] for _ in range(rows)]\n\n    for i in range(rows):\n        c2 = 0\n        # Collect even columns from the first array\n        for j in range(0, colsA, 2):\n            res[i][c2] = A[i][j]\n            c2 += 1\n        # Collect odd columns from the second array\n        for j in range(1, colsB, 2):\n            res[i][c2] = B[i][j]\n            c2 += 1\n\n    return res\n", "response_1": "# array_special_concate.mpc\n# MP-SPDZ translation of the Python code that concatenates every other row from two 2D arrays.\n\nfrom Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef array_special_concate(A, B, rowsA, colsA, rowsB, colsB):\n    \"\"\"\n    A and B are 2D secure arrays of shape (rows, cols) in MP-SPDZ (e.g., sfix elements).\n    This function replicates:\n      viewA = ndarrayA[ ::2 ]       # Every other row\n      viewB = ndarrayB[1::2]        # Every other row, starting from row index = 1\n      result = np.concatenate((viewA, viewB), axis=1)\n    and returns the result as a new 2D secure array.\n    \"\"\"\n\n    # Create \"viewA\": rows 0, 2, 4, ... from A\n    nA = (rowsA + 1) // 2  # number of rows in viewA\n    viewA = [[sfix(0) for _ in range(colsA)] for _ in range(nA)]\n    for i in range(nA):\n        row_index = 2*i\n        for j in range(colsA):\n            viewA[i][j] = A[row_index][j]\n\n    # Create \"viewB\": rows 1, 3, 5, ... from B\n    nB = rowsB // 2        # number of rows in viewB\n    viewB = [[sfix(0) for _ in range(colsB)] for _ in range(nB)]\n    for i in range(nB):\n        row_index = 1 + 2*i\n        for j in range(colsB):\n            viewB[i][j] = B[row_index][j]\n\n    # Horizontally concatenate viewA and viewB\n    # (Assuming nA == nB so they have the same number of rows)\n    out_cols = colsA + colsB\n    out = [[sfix(0) for _ in range(out_cols)] for _ in range(nA)]\n    for i in range(nA):\n        for j in range(colsA):\n            out[i][j] = viewA[i][j]\n        for j in range(colsB):\n            out[i][colsA + j] = viewB[i][j]\n\n    return out\n", "model_name": "azure-openai-o1"}
{"test_name": "np_arange", "response_0": "# MP-SPDZ code replicating Python's arange logic with public (clear) integer arrays\n# This function returns an array of cint representing values from start to stop (exclusive)\n# incremented by step. If only one argument is provided, it is interpreted as 'stop' with 'start'\n# defaulted to 0. All parameters must be public (cint).\n\ndef arange_cint(start, stop=None, step=1):\n    # Emulate \"if stop is None: stop = start; start = 0\"\n    if stop is None:\n        stop = start\n        start = 0\n    \n    # Compute the length (using integer division)\n    length = (stop - start + step - 1) // step\n    \n    # Allocate a public array\n    arr = Array(length, cint)\n    \n    # Fill the array\n    for i in range(length):\n        arr[i] = start + i * step\n    \n    return arr\n", "response_1": "from Compiler.types import cint, Array\nfrom Compiler.library import for_range\n\ndef mpc_arange(start, stop, step):\n    # Compute the length as an integer division\n    length = (stop - start) // step\n\n    # Create an array of the required length\n    arr = Array(length, cint)\n\n    @for_range(length)\n    def _(i):\n        arr[i] = start + (step * i)\n\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "np_eye_2", "response_0": "from Compiler.types import sint\n\nm = 3\nn = 5\n\n# Initialize a 2D array of secure integers\na = [[sint(0) for _ in range(n)] for _ in range(m)]\n\n# Fill the diagonal with 1\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sint(1)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import for_range, Matrix\n\nm = 3\nn = 5\n\na = Matrix(sfix, m, n)\n\n@for_range(m)\ndef _(i):\n    @for_range(n)\n    def __(j):\n        a[i][j] = sfix(1) if i == j else sfix(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "third_smallest", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest secret-shared element in the array\n    by performing a simple bubble sort.\n    \"\"\"\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            condition = arr[j] < arr[i]\n            arr_i = if_else(condition, arr[j], arr[i])\n            arr_j = if_else(condition, arr[i], arr[j])\n            arr[i] = arr_i\n            arr[j] = arr_j\n    return arr[2]\n", "response_1": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i - 1):\n            # Compare and swap secret-shared values\n            cond = arr[j] > arr[j+1]\n            bigger = cond.if_else(arr[j], arr[j+1])\n            smaller = cond.if_else(arr[j+1], arr[j])\n            arr[j] = smaller\n            arr[j+1] = bigger\n\ndef third_smallest(arr):\n    bubble_sort(arr)\n    return arr[2]\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "# file: array_dimensional_indexing.mpc\n\n# We assume 'ndarray' is a 2-D list of sfix elements (e.g., ndarray[row][col]).\n# We also assume 'row_index' is a clear integer (regint). \n# If 'row_index' is secret, the indexing would need more advanced techniques.\n\ndef array_dimensional_indexing(ndarray, row_index):\n    row_length = len(ndarray[0])  # assuming non-empty 2-D structure\n    result_row = [sfix(0) for _ in range(row_length)]\n    \n    @for_range(row_length)\n    def _(j):\n        result_row[j] = ndarray[row_index][j]\n    \n    return result_row\n", "response_1": "# MP-SPDZ translation of the Python program for indexing the i-th row from a 2-D array.\n\n# Assume 'matrix' is a 2-D Matrix of secure type (e.g., sfix) and 'row_index' is an sint.\n\ndef array_dimensional_indexing(matrix, row_index):\n    row_size = matrix.sizes[1]\n    result = Array(row_size, matrix.value_type)\n    for j in range(row_size):\n        result[j] = matrix[row_index][j]\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_from_intrinsic_arange", "response_0": "# Define n as a public integer\nn = 10\n\n# Define an array a of secret integers (length n)\na = Array(n, sint)\n\n# Initialize array a to values 0 through n-1\nfor i in range(n):\n    a[i] = sint(i)\n", "response_1": "from Compiler.types import sint, Array\n\nn = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = sint(i)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index, num_cols):\n    \"\"\"\n    MP-SPDZ function to index row_index-th row\n    from a 2-D secret-shared array.\n    ndarray: sfix.Matrix representing the 2-D array\n    row_index: sint (secret) or int (public) selecting the row\n    num_cols: number of columns in the array\n    \"\"\"\n    \n    row_data = sfix.Array(num_cols)\n    for j in range(num_cols):\n        row_data[j] = ndarray[row_index][j]\n    return row_data\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    # Assume 'ndarray' is a list of lists of type sfix (2-D secure array)\n    # and 'row_index' is a public integer (regint).\n    ncols = len(ndarray[0])\n    sfix_array = sfix.Array(ncols)\n    for i in range(ncols):\n        sfix_array[i] = ndarray[row_index][i]\n    return sfix_array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler.types import Array, cint\nfrom Compiler.library import for_range\n\ndef main():\n    a_l = [0, 10, 20, 30, 40]\n    a = Array(len(a_l), cint)\n    for i in range(len(a_l)):\n        a[i] = a_l[i]\n", "response_1": "from Compiler.types import Array, sint\n\n# Create a 1-dim secret integer array of length 5\na = Array(5, sint, [0, 10, 20, 30, 40])\n", "model_name": "azure-openai-o1"}
{"test_name": "np_reshape", "response_0": "from Compiler.types import sfix, Matrix\n\ndef array_reshape(in_array, m, n):\n    # Create a new matrix of secure fixed-point numbers with dimensions m x n\n    reshaped = Matrix(m, n, sfix)\n    \n    # Fill the new matrix in row-major order\n    for i in range(m):\n        for j in range(n):\n            reshaped[i][j] = in_array[i * n + j]\n    \n    # Return the reshaped matrix\n    return reshaped\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import Matrix\n\ndef array_reshape(ndarray, m, n):\n    # Create a 2D matrix of shape (m, n)\n    reshaped = Matrix(m, n, sfix)\n    # Copy elements from the input 1D array to the new 2D matrix\n    for i in range(m):\n        for j in range(n):\n            reshaped[i][j] = ndarray[i * n + j]\n    return reshaped\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ones", "response_0": "from Compiler.types import sfix, Array\n\nn = 10\na = Array(n, sfix)\n\nfor i in range(n):\n    a[i] = sfix(1)\n", "response_1": "from Compiler.types import sint, Array\n\nn = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = 1\n", "model_name": "azure-openai-o1"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    # This function sets elements equal to 1 in the secure array 'y' to 0 in MP-SPDZ.\n    # 'y' is assumed to be a list of secure types such as sints.\n    n = len(y)\n    for i in range(n):\n        is_one = (y[i] == 1)\n        y[i] = is_one.if_else(0, y[i])\n    return y\n", "response_1": "def set_one_to_zero(y):\n    n = len(y)\n    for i in range(n):\n        cond = (y[i] == 1)\n        y[i] = cond.if_else(0, y[i])\n    return y\n", "model_name": "azure-openai-o1"}
{"test_name": "np_eye", "response_0": "n = 10\na = Matrix(sint, n, n, 0)\nfor i in range(n):\n    a[i][i] = 1\n", "response_1": "from Compiler.types import sfix, Matrix\n\nn = 10\na = Matrix(sfix, n, n)\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sfix(1)\n        else:\n            a[i][j] = sfix(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_diag", "response_0": "# This MP-SPDZ code snippet demonstrates how to translate the Python code\n#   a_l = [1,3,5,2,4,6]\n#   a = np.diag(a_l)\n# into an equivalent MP-SPDZ program that creates a diagonal matrix.\n\nn = 6\n# Define a_l as an array of secure integer shares\na_l = [sint(1), sint(3), sint(5), sint(2), sint(4), sint(6)]\n\n# Create an n x n matrix of secure integer shares\nDmat = Matrix(sint, n, n)\n\n# Assign diagonal entries from a_l and zero elsewhere\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            Dmat[i][j] = a_l[i]\n        else:\n            Dmat[i][j] = sint(0)\n", "response_1": "a_l = [sint(1), sint(3), sint(5), sint(2), sint(4), sint(6)]\na = Matrix(sint, 6, 6)\nfor i in range(6):\n    for j in range(6):\n        a[i][j] = sint(0)\nfor i in range(6):\n    a[i][i] = a_l[i]\n", "model_name": "azure-openai-o1"}
{"test_name": "np_advanced_integer_indexing", "response_0": "# integer_array_indexing.mpc\n\n# Step 1: Set up the sizes for the array and indices (replace with actual values or input reading).\n# In MP-SPDZ, you typically either hardcode these or read them from inputs.\nn = 5\nm = 3\n\n# Step 2: Define the public array (e.g., a plain integer array stored in cints).\n# In practice, these values could come from public input instructions such as:\n#   array = [cint.get_input_from(0) for _ in range(n)]\narray = [cint(10), cint(20), cint(30), cint(40), cint(50)]\n\n# Step 3: Define the public list of indices (again, possibly read from input).\n# \"indices\" must be valid array indices in Python sense (0 to n-1).\n# Example: [1,3,0] meaning array[1], array[3], array[0].\nindices = [cint(1), cint(3), cint(0)]\n\n# Step 4: Create a result array by picking elements from \"array\" using the provided \"indices\".\nret_array = []\nfor i in range(m):\n    idx = indices[i]\n    # MP-SPDZ allows direct indexing into a Python list using a *public* integer\n    ret_array.append(array[idx])\n\n# ret_array now contains the subset of array in the order of \"indices\".\n# You could continue with further secure computations or print the results if desired.\nfor elem in ret_array:\n    elem.print_ln()\n", "response_1": "from Compiler.types import sint, cint, Array\n\n# We assume 'n' is the length of the base array and 'm' is the number of indices.\n\nn = 5\nm = 3\n\n# Declare the secret array for 'array' with length n.\nsecret_array = Array(n, sint)\nfor i in range(n):\n    secret_array[i] = sint.get_input_from(0)  # Reading from party 0, for example\n\n# Declare the plaintext array for 'indices' with length m.\nindices = Array(m, cint)\nfor i in range(m):\n    indices[i] = cint.get_input_from(0)  # Reading from party 0, for example\n\n# Prepare an output array to store results.\nret_array = Array(m, sint)\n\n# Perform integer-based indexing.\n# For each index i in [0..m), copy secret_array[ indices[i] ] into ret_array[i].\nfor i in range(m):\n    ret_array[i] = secret_array[ indices[i] ]\n\n# ret_array now contains all the elements selected by 'indices' from 'secret_array'.\n# You can reveal or further process 'ret_array' as needed.\n", "model_name": "azure-openai-o1"}
