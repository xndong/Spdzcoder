{"test_name": "multiply_first_five", "response_0": "from mpyc.runtime import mpc\nfrom mpyc.sectypes import SecureFixedPoint\nfrom mpyc.array import Array\n\ndef multiply_first_five(array, length):\n    secnum = SecureFixedPoint()\n    prod = mpc.const(1, secnum)\n    for i in range(5):\n        if i < length:\n            elem = mpc.const(array[i], secnum)\n            prod = mpc.mul(prod, elem)\n        else:\n            prod = mpc.mul(prod, mpc.const(1, secnum))\n    return prod\n", "response_1": "define multiply_first_five(array):\n    var prod = 1;\n    var n = array.length;\n    var limit = n < 5 ? n : 5;\n    for (var i = 0; i < limit; i++) {\n        prod = prod * array[i];\n    }\n    return prod;\n", "model_name": "qwen-qwq"}
{"test_name": "second_largest", "response_0": "", "response_1": "from mpyc.runtime import mpc\n\nasync def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    # Convert array to secure numbers\n    arr = mpc.SecInt()(arr)\n    \n    # Initialize largest and second\n    if await mpc.eq(arr[0], arr[1]):\n        largest = arr[0]\n        second = arr[1]\n    elif await mpc.gte(arr[0], arr[1]):\n        largest = arr[0]\n        second = arr[1]\n    else:\n        largest = arr[1]\n        second = arr[0]\n    \n    # Iterate through the array\n    for num in arr[2:]:\n        if await mpc.gte(num, largest):\n            second = largest\n            largest = num\n        else:\n            if await mpc.gte(num, second):\n                second = num\n    \n    # Output the second largest element\n    return await mpc.output(second)\n", "model_name": "qwen-qwq"}
{"test_name": "partial_sum", "response_0": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array. \n    \"\"\"\n    if len(arr) == 0:\n        return arr\n    partial = arr[0].zero()\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "function partial_sum(arr: Array[Int, 10]):\n    let partial = Int(0)\n    for i in 0 to 9:\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "max_adjacent_product", "response_0": "function max_adjacent_product(arr: array[Int]): Int is\n\n    // Return the max product of adjacent elements in the array.\n    // The input array is guaranteed to have length at least 2.\n\n    cur = mul(arr.get(0), arr.get(1))\n    for i in 0..(len(arr)-2):\n        product = mul(arr.get(i), arr.get(i+1))\n        if gt(product, cur):\n            cur = product\n    return cur\n\nend function\n", "response_1": "def max_adjacent_product(arr):\n    n = len(arr)\n    assert n >= 2, \"Array must have at least two elements\"\n\n    # Initialize cur to the product of the first two elements\n    cur = arr[0] * arr[1]\n\n    # Iterate through the array\n    for i in range(n - 1):\n        product = arr[i] * arr[i + 1]\n        # Compare and update cur if the new product is greater\n        cur = sifgt(product, cur, cur, product)\n\n    # Reconstruct the result to get the actual value\n    return reconstruct(cur)\n", "model_name": "qwen-qwq"}
{"test_name": "argmax", "response_0": "from spdz import argmax\n\ndef argmax(a):\n    return argmax(a)\n", "response_1": "from program import Program\nfrom sctypes import MC, SC\nfrom comparison import gt\nfrom arithmetic import if_else\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max value of an array.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = 0\n    for i in range(1, n):\n        is_greater = gt(a[i], current)\n        current = if_else(is_greater, a[i], current)\n        index = if_else(is_greater, i, index)\n    return index\n", "model_name": "qwen-qwq"}
{"test_name": "count_distinct", "response_0": "def count_distinct(n, *args):\n    # Input array elements\n    arr = [InpInt(_sec=int(args[i])) for i in range(n)]\n    \n    # Initialize counter\n    counter = 0\n    \n    for i in range(n):\n        unique = 1  # Assume unique initially\n        for j in range(i):\n            # Check if arr[j] == arr[i]\n            if arr[j] == arr[i]:\n                unique = 0  # Not unique\n                break  # No need to check further\n        if unique:\n            counter += 1\n    \n    # Output the result\n    PrintInt(counter, \"Unique count: \")\n\n# Example usage:\n# count_distinct(5, 1, 2, 3, 2, 1)\n", "response_1": "def count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    n = len(arr)\n    counter = sfix(0)  # Initialize secret-shared counter\n\n    for i in range(n):\n        unique = l1bit(1)  # Assume unique initially (1 means True)\n        for j in range(i):\n            # Compare arr[j] and arr[i] securely\n            eq = arr[j].eq(arr[i])\n            # If any previous element is equal, set unique to False (0)\n            unique = unique & eq\n        # If unique is still True (1), increment the counter\n        counter = counter + unique\n    return counter\n", "model_name": "qwen-qwq"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    # Sum all elements of the array\n    total = arr.sum()\n    \n    # Check if the sum is greater than zero\n    result = total > 0\n    \n    return result\n", "response_1": "def exists_true(arr):\n    sum_val = 0\n    for item in arr:\n        sum_val += item\n    return sum_val > 0\n", "model_name": "qwen-qwq"}
{"test_name": "range", "response_0": "def range(arr):\n    n = len(arr)\n    max_value = arr[0]\n    min_value = arr[0]\n    for i in range(1, n):\n        max_value = secure_max(max_value, arr[i])\n        min_value = secure_min(min_value, arr[i])\n    return max_value - min_value\n\ndef secure_max(a, b):\n    # Assuming greater_than is a secure comparison function in MP-SPDZ\n    cond = greater_than(a, b)\n    return cond * a + (1 - cond) * b\n\ndef secure_min(a, b):\n    # Assuming less_than is a secure comparison function in MP-SPDZ\n    cond = less_than(a, b)\n    return cond * a + (1 - cond) * b\n", "response_1": "from mpspdz import if_else\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0  # or handle as appropriate\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr[1:]:\n        max_value = if_else(max_value >= item, max_value, item)\n        min_value = if_else(min_value <= item, min_value, item)\n    return max_value - min_value\n", "model_name": "qwen-qwq"}
{"test_name": "count_larger_than_5", "response_0": "proc count_larger_than_5(arr):\n    five = Constant(5)\n    diff = arr - five\n    indicators = IFGTZ(diff)\n    counter = sum(indicators)\n    return counter\n", "response_1": "def count_larger_than_5(arr):\n    # Initialize the counter to zero\n    counter = 0\n    # Iterate over each element in the array\n    for item in arr:\n        # Perform a secure comparison to check if item > 5\n        # In MP-SPDZ, comparison of secret shared values needs to be done securely\n        is_larger = item > 5\n        # Convert the boolean result to an integer (1 if True, 0 otherwise)\n        # Assuming MP-SPDZ has a function to convert boolean to integer securely\n        int_is_larger = to_int(is_larger)\n        # Add the result to the counter\n        counter = counter + int_is_larger\n    # Return the final count\n    return counter\n", "model_name": "qwen-qwq"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr):\n    n = len(arr)\n    max = 0\n    sum = 0\n    for i in range(n):\n        abs_item = s abs(arr[i])\n        max = s_if(s_gt(abs_item, max), abs_item, max)\n        sum = sum + abs_item\n    return s_gt(2 * max, sum)\n", "response_1": "def exists_dominator(arr):\n    # Find the maximum absolute value in the array\n    max_abs = 0\n    for item in arr:\n        abs_item = abs(item)\n        if abs_item > max_abs:\n            max_abs = abs_item\n\n    # Compute the sum of absolute values of all elements\n    sum_abs = 0\n    for item in arr:\n        sum_abs += abs(item)\n\n    # Check if twice the maximum absolute value is greater than the sum\n    result = 2 * max_abs > sum_abs\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "greedy_picker", "response_0": "def greedy_picker(items, captivity):\n    num = 0\n    for item in items:\n        if item <= captivity:\n            captivity = captivity - item\n            num = num + 1\n    return num\n", "response_1": "from mp_spdz import Int, Bit, less_or_equal\n\n# Define the maximum number of items\nN = 10  # Set this to the maximum number of items expected\n\ndef greedy_picker(items: Array(Int), captivity: Int) -> Int:\n    num = Int(0)\n    for i in range(N):\n        b = less_or_equal(items[i], captivity)\n        captivity = captivity - (items[i] * b)\n        num = num + b\n    return num\n", "model_name": "qwen-qwq"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n", "response_1": "from mp_spdz import secure_sum, SecureInteger\n\ndef scalar_add_array(s, l):\n    s = SecureInteger(s, bitlength=32)\n    if l:\n        l = [SecureInteger(item, bitlength=32) for item in l]\n        sum_l = secure_sum(l)\n    else:\n        sum_l = SecureInteger(0, bitlength=32)\n    result = s + sum_l\n    return result.reveal()\n", "model_name": "qwen-qwq"}
{"test_name": "is_equidistant_seq", "response_0": "def is_equidistant_seq(arr):\n\n    n = len(arr)\n\n    if n <= 1:\n\n        return 1\n\n    else:\n\n        d0 = arr[1] - arr[0]\n\n        sum_diffs = Int(0)\n\n        for i in range(n-1):\n\n            di = arr[i+1] - arr[i]\n\n            diff = di - d0\n\n            sum_diffs += diff * diff\n\n        return eqz(sum_diffs)\n\n", "response_1": "from program.utils import Input, Eq, All\n\narr = Input(sender=0, value=[1, 2, 3, 4, 5])\n\nn = len(arr)\n\nif n <= 1:\n\n    return 1  # True\n\ndiffs = [arr[i+1] - arr[i] for i in range(n-1)]\n\nequivalences = [Eq(d, diffs[0]) for d in diffs]\n\nis_equidistant = All(equivalences)\n\nreturn is_equidistant\n\n", "model_name": "qwen-qwq"}
{"test_name": "inner_product", "response_0": "from protocols import Dot\n\ndef inner_product(vec1, vec2):\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    return Dot(vec1, vec2)\n", "response_1": "def inner_product(vec1, vec2):\n    return dot_product(vec1, vec2)\n", "model_name": "qwen-qwq"}
{"test_name": "more_distinct_nonnegative", "response_0": "# Assuming arr is a secret shared array\n\nnonnegative_counter = 0S\n\nnegative_counter = 0S\n\nfor i in 0 to len(arr) - 1:\n\nunique = True\n\nfor j in 0 to i - 1:\n\ndiff = arr[j] - arr[i]\n\nis_zero = eqz(diff)\n\nunique = unique and not is_zero\n\nif unique:\n\nif ge(arr[i], 0):\n\nnonnegative_counter += 1\n\nelse:\n\nnegative_counter += 1\n\nresult = gt(nonnegative_counter, negative_counter)\n\nreveal(result)\n\n", "response_1": "def main():\n    # Assuming 'size' is a public parameter indicating the length of the array\n    size = get_input_size()  # Function to retrieve the size, needs to be defined based on MP-SPDZ setup\n\n    # Load secret-shared input array\n    arr = load_secret_input('arr', size)\n\n    # Initialize counters for non-negative and negative unique elements\n    nonnegative_counter = SecureInt(0)\n    negative_counter = SecureInt(0)\n\n    # Iterate through each element in the array\n    for i in range(size):\n        unique = SecureBool(True)\n        # Check uniqueness by comparing with previous elements\n        for j in range(i):\n            equal = eq(arr[j], arr[i])\n            unique = and_(unique, not_(equal))\n        # If unique, classify and count\n        if unique:\n            nonnegative = ge(arr[i], SecureInt(0))\n            nonnegative_counter = if_else(nonnegative, add(nonnegative_counter, 1), nonnegative_counter)\n            negative = not_(nonnegative)\n            negative_counter = if_else(negative, add(negative_counter, 1), negative_counter)\n\n    # Compare the counters\n    result = gt(nonnegative_counter, negative_counter)\n\n    # Reconstruct the result to output\n    output = reconstruct(result)\n    print(output)\n", "model_name": "qwen-qwq"}
{"test_name": "flip_positives", "response_0": "def flip_positives(array):\n    n = len(array)\n    for i in range(n):\n        if array[i] > 0:\n            array[i] = -array[i]\n    return array\n", "response_1": "from mp_spdz import Program, sint, Array, sbit\n\ndef flip_positives(array):\n    n = len(array)\n    result = Array(sint, n)\n    for i in range(n):\n        x = array[i]\n        is_positive = x > 0  # is_positive is sbit\n        is_positive_sint = sint(is_positive)\n        flipped = x - 2 * x * is_positive_sint\n        result[i] = flipped\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "divide_and_plus", "response_0": "def divide_and_plus(x):\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n", "response_1": "def divide_and_plus(x):\n    for i in range(4):\n        x = (x / 2) + 1\n    return x\n", "model_name": "qwen-qwq"}
{"test_name": "array_log2", "response_0": "def array_log2(arr):\n    import mp_math\n    return mp_math.log2(arr)\n", "response_1": "def array_log2(arr):\n    from spdz import MPC, Double\n    import math\n\n    # Assuming arr is a list of Double (secret-shared values)\n    result = []\n    ln2 = math.log(2)  # Precompute log(2)\n\n    for elem in arr:\n        # Assuming MPC.log is the natural logarithm function for Double type\n        log_elem = MPC.log(elem)\n        # Convert natural log to log base 2\n        log2_elem = log_elem / Double(ln2)\n        result.append(log2_elem)\n\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "sum_to_ten", "response_0": "def sum_to_ten(array):\n    sum = sint(0)\n    done = sint(0)\n    for elem in array:\n        sum += elem * (sint(1) - done)\n        new_done = done.or_op(sum.gte(sint(10)))\n        done = new_done\n    return sum\n", "response_1": "sum = 0\n\nfor i in range(len(array)):\n\nsum += array[i]\n\nif sum >= 10:\n\nbreak\n\nreturn sum\n\n", "model_name": "qwen-qwq"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    result = [sfix(0) for _ in range(len(arr))]  # Initialize result list with zeros\n    for i in range(len(arr)):\n        if i % 2:\n            result[i] = arr[i] + 1\n        else:\n            result[i] = arr[i] - 1\n    return result\n", "response_1": "from mpyc.runtime import mpc\nfrom mpyc.sectypes import SecureFixedPoint\n\nasync def choppy_plus_minus(arr):\n    secfld = type(arr[0])  # Assuming arr elements are of the same secure type\n    adjustment = mpc.Array(len(arr), secfld)\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            adjustment[i] = secfld(-1)\n        else:\n            adjustment[i] = secfld(1)\n    result = mpc.vector_add(arr, adjustment)\n    return result\n\nasync def main():\n    await mpc.start()\n    secfld = mpc.SecFXp()\n    arr = await mpc.input([secfld(2), secfld(3), secfld(4), secfld(5)])\n    result = await choppy_plus_minus(arr)\n    print(await mpc.output(result))\n    await mpc.shutdown()\n\nif __name__ == '__main__':\n    mpc.run(main())\n", "model_name": "qwen-qwq"}
{"test_name": "min_element", "response_0": "define min_element_manual(a):\n    n = len(a)\n    current = a[0]\n    for i in range(1, n):\n        item = a[i]\n        current = IfLessEqual(current, item, current, item)\n    return current\n", "response_1": "function min_element(a):\n    n = length(a)\n    current = a[0]\n    for i in 1 to n-1:\n        item = a[i]\n        current = if le(current, item) then current else item\n    return current\n", "model_name": "qwen-qwq"}
{"test_name": "soft_max", "response_0": "from mpspdz import exp, NewArray, Range\n\nfunction soft_max(arr):\n\n    denominator = 0\n\n    for item in arr:\n\n        denominator += exp(item)\n\n    brr = NewArray(len(arr))\n\n    for i in Range(len(arr)):\n\n        brr[i] = exp(arr[i]) / denominator\n\n    return brr\n\n", "response_1": "from mp_spdz import Math, sum, inv\n\ndef soft_max(arr):\n    \"\"\"\n    Compute the softmax of the input array arr.\n    \n    Parameters:\n    arr (list of shares): The input array.\n    \n    Returns:\n    list of shares: The softmax of the input array.\n    \"\"\"\n    # Compute the exponential of each element in the array\n    exp_arr = [Math.exp(x) for x in arr]\n    \n    # Sum of all exponentials\n    sum_exp = sum(exp_arr)\n    \n    # Inverse of the sum of exponentials\n    inv_sum_exp = inv(sum_exp)\n    \n    # Compute the softmax for each element\n    softmax_arr = [exp_x * inv_sum_exp for exp_x in exp_arr]\n    \n    return softmax_arr\n", "model_name": "qwen-qwq"}
{"test_name": "count_reverse_pair_with_break", "response_0": "def count_reverse_pair_with_break(arr):\n    n = len(arr)\n    \n    # Step 1: Compute is_valid_i[i]\n    is_valid_i = [0] * n\n    is_valid_i[0] = LessThan(arr[0], 11)\n    for i in range(1, n):\n        is_valid_i[i] = is_valid_i[i-1] * LessThan(arr[i], 11)\n    \n    # Step 2: Count reverse pairs\n    count = 0\n    for i in range(1, n):\n        for j in range(0, i):\n            count += is_valid_i[i] * GreaterThan(arr[j], arr[i])\n    \n    return count\n", "response_1": "def count_reverse_pair_with_break(arr):\n    n = len(arr)\n    count = sint(0)\n    mask = sint(1)\n    for i in range(1, n):\n        is_gt_10 = arr[i] > sint(10)\n        mask = mask * (sint(1) - is_gt_10)\n        for j in range(i):\n            count += mask * (arr[j] > arr[i])\n    return count\n", "model_name": "qwen-qwq"}
{"test_name": "sum_unique", "response_0": "def sum_unique(arr):\n    n = len(arr)\n    sum = MPZ(0)  # Assuming MPZ is used for integer types in MP-SPDZ\n    for i in range(n):\n        unique_i = Bit(1)  # Assume Bit is the type for secret shared bits\n        for j in range(n):\n            if j != i:\n                eq_ji = eq(arr[j], arr[i])  # Equality check\n                unique_i = land(unique_i, lnot(eq_ji))  # logical AND and NOT\n        sum = sum + arr[i] * unique_i  # Summing unique elements\n    return sum\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "check_sum", "response_0": "", "response_1": "def check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value.\n    \"\"\"\n    sum = 0\n    for num in array:\n        sum += num\n    return sum == target\n", "model_name": "qwen-qwq"}
{"test_name": "prod", "response_0": "define prod(array: array[Share]):\n    return arrays.mul_all(array);\n", "response_1": "from mspmpdz import Array, sfix, reduce\n\ndef prod(array: Array[sfix]) -> sfix:\n    return reduce(lambda x, y: x * y, array, sfix(1))\n", "model_name": "qwen-qwq"}
{"test_name": "sum_till_negative", "response_0": "from Program import Program\nfrom Arrays import Array\nfrom Comparisons import lt\nfrom Types import Int\n\ndef sum_till_negative(array):\n    sum = Int(0)\n    mask = Int(1)\n    for i in range(len(array)):\n        is_negative = lt(array[i], Int(0))\n        mask = mask * (Int(1) - is_negative)\n        sum += array[i] * mask\n    return sum\n", "response_1": "def sum_till_negative(array_length):\n    array = Input(\"array\", [TypeMod.p for _ in range(array_length)])\n    sum = 0\n    flag = 1  # Start with flag set to true (1)\n    for i in range(array_length):\n        is_negative = secure_less_than(array[i], 0)\n        new_flag = secure_and(flag, secure_not(is_negative))\n        sum += array[i] * new_flag\n        flag = new_flag\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    sum = 0\n    for i in range(len(arr)):\n        condition = secure_compare(predicator(arr[i]), 1)\n        sum = sum + secure_if(condition, 1, 0)\n    return sum\n", "response_1": "def count_satisfied(arr, predicator):\n    sum = sint(0)\n    for i in range(len(arr)):\n        sum = sum + predicator(arr[i])\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "standard_deviation", "response_0": "", "response_1": "from program_library import *\n\nclass Protocol:\n\n    def __init__(self, arr):\n        self.arr = arr\n        self.n = len(arr)\n\n    def standard_deviation(self):\n        sum_arr = SecureFixedPoint(0)\n        sum_squares = SecureFixedPoint(0)\n        for item in self.arr:\n            sum_arr += item\n            sum_squares += item * item\n        average = sum_arr.div_int(self.n)\n        variance = sum_squares.div_int(self.n) - average * average\n        std_dev = variance.sqrt()\n        std_dev_reconstructed = reconstruct(std_dev)\n        return std_dev_reconstructed\n", "model_name": "qwen-qwq"}
{"test_name": "dominate", "response_0": "from mp_spdz.bitops import allbit\nfrom mp_spdz.array import Array\n\ndef dominate(a: Array, b: Array) -> bit:\n    return allbit(a >= b)\n", "response_1": "def dominate(a, b):\n    comparisons = ge(a, b)\n    result = all(comparisons)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    # Compute the absolute values of the array elements\n    abs_brr = [sabs(x) for x in brr]\n    \n    # Find the maximum absolute value\n    max_abs = smax(abs_brr)\n    \n    # Rescale each element by dividing by the max absolute value\n    scaled_brr = [sdiv(x, max_abs) for x in brr]\n    \n    return scaled_brr\n", "response_1": "function rescale(brr: Array[SecretFix]) -> Array[SecretFix]:\n    # Initialize max_abs with the absolute value of the first element\n    max_abs = abs(brr[0])\n\n    # Iterate through the array to find the maximum absolute value\n    for i in 1 to len(brr)-1:\n        abs_val = abs(brr[i])\n        if abs_val > max_abs:\n            max_abs = abs_val\n\n    # Rescale the array\n    rescaled_brr = Array[SecretFix](len(brr))\n    for i in 0 to len(brr)-1:\n        rescaled_brr[i] = brr[i] / max_abs\n\n    return rescaled_brr\n", "model_name": "qwen-qwq"}
{"test_name": "array_minus7", "response_0": "", "response_1": "def array_minus7(arr):\n    # Subtract all elements in the input array by 7.\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Compute the sum of products of all pairs from arr1 and arr2 using MP-SPDZ.\n    This is optimized to compute sum(arr1) * sum(arr2).\n    \"\"\"\n    # Compute sum of arr1\n    sum_arr1 = SecureFixedPoint(0)\n    for elem in arr1:\n        sum_arr1 += elem\n    \n    # Compute sum of arr2\n    sum_arr2 = SecureFixedPoint(0)\n    for elem in arr2:\n        sum_arr2 += elem\n    \n    # Compute the product of the sums\n    result = sum_arr1 * sum_arr2\n    \n    return result\n", "response_1": "def traverse_and_sum():\n    # Load inputs\n    arr1 = MPSharedArray.load_from_party(0, \"arr1\")\n    arr2 = MPSharedArray.load_from_party(1, \"arr2\")\n\n    # Compute sum of products\n    sum = MPSharedInt.sum_of_products(arr1, arr2)\n\n    # Output the result\n    result = sum.reconstruct()\n    print(\"Sum:\", result)\n", "model_name": "qwen-qwq"}
{"test_name": "longest_nondec_subseq", "response_0": "from mp_spdz import Int, Array, secure_compare_ge, secure_max\n\ndef longest_nondec_subseq(a):\n    n = len(a)\n    max_length = Int(0)\n    cur_length = Int(1)\n    for i in range(1, n):\n        is_nondec = secure_compare_ge(a[i], a[i-1])\n        update_max = secure_max(max_length, cur_length)\n        max_length = is_nondec * max_length + (1 - is_nondec) * update_max\n        cur_length = is_nondec * (cur_length + 1) + (1 - is_nondec) * 1\n    max_length = secure_max(max_length, cur_length)\n    return max_length.reveal()\n", "response_1": "def longest_nondec_subseq(a):\n\nn = len(a)\n\nmax_length = Number(0)\n\ncur_length = Number(0)\n\nfor i in range(n):\n\nif i == 0:\n\ncur_length = Number(1)\n\nelse:\n\nis_nondec = ge(a[i], a[i-1])\n\nnew_cur_length = is_nondec * (cur_length + 1) + (1 - is_nondec) * 1\n\nnew_max_length = max_length * is_nondec + max(max_length, cur_length) * (1 - is_nondec)\n\ncur_length = new_cur_length\n\nmax_length = new_max_length\n\nmax_length = max(max_length, cur_length)\n\nreturn max_length\n\n", "model_name": "qwen-qwq"}
{"test_name": "sum_but_skip_biggest", "response_0": "def sum_but_skip_biggest(array):\n    sum = 0L\n    biggest = array[0]\n    for i in range(len(array)):\n        element = array[i]\n        condition = greater_or_equal(element, biggest)\n        new_biggest = cif(condition, element, biggest)\n        sum = cif(condition, sum, sum + element)\n        biggest = new_biggest\n    return sum\n", "response_1": "function sum_but_skip_biggest(array):\n    sum = 0\n    biggest = array[0]\n    for i in 0..len(array)-1:\n        if array[i] >= biggest:\n            biggest = array[i]\n            continue\n        sum += array[i]\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "second_test", "response_0": "from mpyc.runtime import mpc\nfrom mpyc.sectypes import SecureInteger\nfrom mpyc.array import Array\n\ndef second_test(arr: Array[SecureInteger]) -> int:\n    first = arr[0]\n    cmp = mpc.lt(first, arr[1:])\n    count = mpc.sum(cmp)\n    result = mpc.eq(count, 1)\n    opened_result = mpc.open(result)\n    return opened_result\n", "response_1": "proc second_test(arr):\n    # Get the first element\n    first = arr[0]\n\n    # Initialize counter\n    count = 0\n\n    # Loop through the array starting from the second element\n    for i in 1 to len(arr)-1:\n        # Compare and increment count if arr[i] > first\n        if arr[i] > first:\n            count = count + 1\n\n    # Check if count is exactly 1\n    if count == 1:\n        return 1\n    else:\n        return 0\n", "model_name": "qwen-qwq"}
{"test_name": "Manhattan_distance", "response_0": "from mp_spdz import *\n\ndef Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    ret = 0\n    for i in range(len(a)):\n        diff = a[i] - b[i]\n        abs_diff = sabs(diff)\n        ret = sadd(ret, abs_diff)\n    return ret\n", "response_1": "def secure_abs(x):\n    \"\"\"\n    Compute the absolute value of a shared value x in a secure manner.\n    \"\"\"\n    # Assume MP-SPDZ has a secure comparison function that returns a shared bit\n    is_positive = x >= 0\n    abs_x = x * is_positive + (-x) * (1 - is_positive)\n    return abs_x\n\ndef Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance between two vectors a and b.\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Vectors must be of the same length\")\n    \n    ret = 0\n    for i in range(len(a)):\n        diff = a[i] - b[i]\n        abs_diff = secure_abs(diff)\n        ret += abs_diff\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "deal_with_only_positive", "response_0": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = 1\n    sum = 0\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        sum = sum + sign * array[i]\n        sign = (-1) * sign\n    return sum\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "compare_and_return", "response_0": "function compare_and_return(arr, brr):\n    ret = -1\n    for i in 0..len(arr)-1:\n        if arr[i] == brr[i]:\n            ret = i\n            break\n    return ret\n", "response_1": "def compare_and_return(arr, brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    ret = -1\n    for i in range(len(arr)):\n        if arr[i] == brr[i]:\n            ret = i\n            break\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "sum_odd_positive", "response_0": "def sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = 0.s\n    for item in arr:\n        is_odd = item % 2.s\n        is_positive = item > 0.s\n        condition = is_odd * is_positive\n        sum = sum + (item * condition)\n    return sum\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "two_sum", "response_0": "def two_sum():\n    # Read the array length from input\n    arr_len = get_input_from(0, sfix)\n    \n    # Read the array elements\n    arr = []\n    for _ in range(arr_len):\n        arr.append(get_input_from(0, sfix))\n    \n    # Read the target value\n    target = get_input_from(0, sfix)\n    \n    # Initialize a variable to track if any pair sums to target\n    found = fix(0)\n    \n    # Iterate through all pairs of elements\n    for i in range(arr_len):\n        for j in range(arr_len):\n            # Compute the sum of arr[i] and arr[j]\n            sum_ij = arr[i] + arr[j]\n            \n            # Check if the sum equals the target\n            is_equal = sum_ij == target\n            found = found | is_equal  # logical OR to track if any pair matches\n            \n            # Early exit if a match is found\n            if found:\n                break\n        if found:\n            break\n    \n    # Output the result\n    if found:\n        print(\"True\")\n    else:\n        print(\"False\")\n\ntwo_sum()\n", "response_1": "def two_sum(arr, target):\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            sum_ij = arr[i] + arr[j]\n            equality = sum_ij == target\n            result = result + equality\n    return result > 0\n", "model_name": "qwen-qwq"}
{"test_name": "seq_search", "response_0": "def seq_search(arr, target):\n    n = len(arr)\n    matches = [sint(arr[i] == target) for i in range(n)]\n    match_indices = [sint(i) * matches[i] for i in range(n)]\n    found_index = sum(match_indices)\n    found = sum(matches)\n    result = found_index * (found == 1) + (-1) * (found != 1)\n    return result\n", "response_1": "def seq_search(arr, target):\n    n = len(arr)\n    found_index = -1\n    found = False\n    for i in range(n):\n        match = arr[i] == target\n        found = found or match\n        found_index = if_then_else(match, i, found_index)\n    return if_then_else(found, found_index, -1)\n", "model_name": "qwen-qwq"}
{"test_name": "choppy_array", "response_0": "def choppy_array(arr):\n    n = len(arr)\n    result = True\n    for i in range(n):\n        if i % 2 == 0:\n            # Check if arr[i] is the smallest of the remaining elements\n            for j in range(i + 1, n):\n                result = result AND (arr[i] <= arr[j])\n        else:\n            # Check if arr[i] is the largest of the remaining elements\n            for j in range(i + 1, n):\n                result = result AND (arr[i] >= arr[j])\n        if not result:\n            return False\n    return result\n", "response_1": "def choppy_array(arr):\n    sorted_arr = sort(arr)\n    min_index = Int(0)\n    max_index = Int(len(arr)) - 1\n    is_choppy = SecInt(1)\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            expected = sorted_arr[min_index]\n            min_index += 1\n        else:\n            expected = sorted_arr[max_index]\n            max_index -= 1\n        is_equal = eq(arr[i], expected)\n        is_choppy = is_choppy * is_equal\n    return is_choppy\n", "model_name": "qwen-qwq"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    from mpyc.runtime import mpc  # Import the MP-SPDZ runtime\n\n    n = len(arr)\n    for i in range(n):\n        arr[i] = mpc.run(func(arr[i]))\n    return arr\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "normalize", "response_0": "from programmpc import *\n\ndef normalize(vec):\n    sum_squares = SecFrac(0)\n    for item in vec:\n        sum_squares += item * item\n    base = sqrt(sum_squares)\n    reciprocal = SecFrac(1) / base\n    for i in range(len(vec)):\n        vec[i] *= reciprocal\n    return vec\n", "response_1": "def normalize(vec):\n    \"\"\"\n    Normalize the vector using MP-SPDZ.\n    \"\"\"\n    # Compute the sum of squares\n    sum_squares = sum(sq(x) for x in vec)\n    \n    # Compute the square root of the sum of squares\n    norm = sqrt(sum_squares)\n    \n    # Avoid division by zero, though norm should be zero only if vec is all zeros\n    # Assuming vec is not all zeros, proceed with division\n    normalized_vec = [div(x, norm) for x in vec]\n    \n    return normalized_vec\n", "model_name": "qwen-qwq"}
{"test_name": "impatient_merchant", "response_0": "from mp_spdz import *\n\ndef main():\n    days = get_input(0, \"days\")\n    \n    can_buy = 1  # Start with can_buy = True\n    net = 0\n    orig_price = 0\n    \n    for i in range(len(days)):\n        price = days[i]\n        \n        buy_condition = can_buy\n        sell_condition = GT(price, orig_price) * (1 - can_buy)\n        \n        net = net - buy_condition * price + sell_condition * price\n        \n        orig_price = IF(buy_condition, price, orig_price)\n        \n        can_buy = can_buy - buy_condition + sell_condition\n    \n    reveal(net)\n", "response_1": "def impatient_merchant(days):\n    can_buy = sbit(1)  # True\n    net = sint(0)\n    orig_price = sint(0)\n    for price in days:\n        buy_condition = can_buy\n        sell_condition = can_buy.not_() & price.greater_than(orig_price)\n        \n        # Buy updates\n        net = buy_condition.if_else(net - price, net)\n        orig_price = buy_condition.if_else(price, orig_price)\n        can_buy = buy_condition.if_else(sbit(0), can_buy)\n        \n        # Sell updates\n        net = sell_condition.if_else(net + price, net)\n        can_buy = sell_condition.if_else(sbit(1), can_buy)\n    \n    return net\n", "model_name": "qwen-qwq"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    n = len(a)\n    result = MPArith.Array(n, MPArith.SecInt())\n    for i in range(1, n):\n        result[i] = a[i-1]\n    result[0] = a[n-1]\n    return result\n", "response_1": "def array_shift(a):\n    n = a.size\n    if n <= 1:\n        return a  # No shift needed for arrays with 0 or 1 element\n\n    temp = MP.array_load(a, 0)\n    for i in range(n - 1):\n        MP.array_store(a, i, MP.array_load(a, i + 1))\n    MP.array_store(a, n - 1, temp)\n    return a\n", "model_name": "qwen-qwq"}
{"test_name": "array_double", "response_0": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in Range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "stop_at_zero", "response_0": "def stop_at_zero(array):\n    n = len(array)\n    stop = False\n    for i in Range(0, n):\n        is_zero = (array[i] == 0)\n        stop = stop OR is_zero\n        if not stop:\n            array[i] += 1\n    return array\n", "response_1": "def stop_at_zero(array):\n    mask = mpc.neq(array, 0)\n    array = array + (mask * 1)\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n\n\"\"\"\n\nTake the opposite of all elements in the input array.\n\n\"\"\"\n\nreturn [snot(x) for x in arr]\n\n", "response_1": "def array_not(arr):\n    from mpspdz import NOT, map\n    return map(NOT, arr)\n", "model_name": "qwen-qwq"}
{"test_name": "array_process_then_clip", "response_0": "from mp_spdz import *\n\n# Define the processing function\ndef double(x):\n    return 2 * x\n\n# Define the clipping function\ndef clip(x):\n    cond_gt = sgt(x, 10)\n    x = cif(cond_gt, 10, x)\n    cond_lt = slt(x, -10)\n    x = cif(cond_lt, -10, x)\n    return x\n\n# Define the array processing function\ndef array_process_then_clip(arr, func):\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = clip(arr[i])\n    return arr\n\n# Main function to set up the computation\ndef main():\n    # Securely input the array from parties\n    arr = Input([party1, party2, party3], type=SecureFixedPoint, size=5)\n    \n    # Process the array\n    arr_processed = array_process_then_clip(arr, double)\n    \n    # Reconstruct the results to output\n    arr_reconstructed = Reconstruct(arr_processed)\n    print(arr_reconstructed)\n", "response_1": "def array_process_then_clip(arr, func):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = func(arr[i])\n        if arr[i] > 10:\n            arr[i] = 10\n        elif arr[i] < -10:\n            arr[i] = -10\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "add_and_count_positive", "response_0": "from mpspdz import secure_gt, SharedInt\n\ndef prot_add_and_count_positive():\n    array = get_input_from_parties('array')\n    k = get_shared_value('k')\n    modified_array = array + k\n    is_positive = secure_gt(modified_array, 0)\n    count = sum(is_positive)\n    return modified_array, count\n", "response_1": "def add_and_count_positive(array, k):\n    n = len(array)\n    res = MPArithmeticSharedArray(n)\n    pos = MPBooleanSharedArray(n)\n    count = 0\n\n    for i in range(n):\n        res[i] = array[i] + k\n        pos[i] = res[i] > 0\n        count += pos[i].reconstruct()\n\n    return res, count\n", "model_name": "qwen-qwq"}
{"test_name": "array_subtract", "response_0": "def array_subtract_padded(a, b):\n    return [a_i - b_i for a_i, b_i in zip(a, b)]\n", "response_1": "function array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    n = a.size()\n    m = b.size()\n    \n    if n == 0:\n        if m == 0:\n            return SecretArray(0)\n        else:\n            ret = SecretArray(m)\n            for i in 0 to m-1:\n                ret[i] = -b[i]\n            return ret\n    else:\n        if m == 0:\n            ret = SecretArray(n)\n            for i in 0 to n-1:\n                ret[i] = a[i]\n            return ret\n        else:\n            if n > m:\n                ret = SecretArray(n)\n                for i in 0 to m-1:\n                    ret[i] = a[i] - b[i]\n                for i in m to n-1:\n                    ret[i] = a[i]\n                return ret\n            else:\n                ret = SecretArray(m)\n                for i in 0 to n-1:\n                    ret[i] = a[i] - b[i]\n                for i in n to m-1:\n                    ret[i] = -b[i]\n                return ret\n", "model_name": "qwen-qwq"}
{"test_name": "lower_bound", "response_0": "def lower_bound(arr, x):\n    n = len(arr)\n    # Assuming arr[i] and x are within 0 to 100, set large_value to 101\n    large_value = 101  \n    distances = sint.Array(n)\n    for i in range(n):\n        gt = arr[i].bitwise_gt(x)\n        distances[i] = x - arr[i] + large_value * gt\n    min_value, min_index = distances.min()\n    lt_bit = min_value.bitwise_lt(large_value)\n    result = sint.cond(lt_bit, min_index, -1)\n    return result\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "argmin", "response_0": "def argmin(party, a):\n    n = len(a)\n    if n == 0:\n        raise ValueError(\"Array is empty\")\n    \n    current = a[0]\n    index = Public(0)\n    \n    for i in range(1, n):\n        comp = current.le(a[i])\n        index = if_else(comp, index, Public(i))\n        current = if_else(comp, current, a[i])\n    \n    party.send(index, 0)\n", "response_1": "function argmin(a: Array(Int)) -> Int:\n    n: Int = a.length\n    current: Int = a[0]\n    index: Int = 0\n    for i in 1..(n - 1):\n        condition: Bool = lt(a[i], current)\n        conditional_assign(current, a[i], condition)\n        conditional_assign(index, i, condition)\n    return index\n", "model_name": "qwen-qwq"}
{"test_name": "independent_robbery", "response_0": "def independent_robbery(houses):\n\n    n = len(houses)\n\n    prev_prev = sint(0)\n\n    prev = houses[0]\n\n    for i in range(1, n):\n\n        option1 = prev_prev + houses[i]\n\n        option2 = prev\n\n        cmp = option1.gte(option2)\n\n        current = option1 * cmp + option2 * (1 - cmp)\n\n        prev_prev, prev = prev, current\n\n    return prev.reconstruct()\n\n", "response_1": "function independent_robbery(houses: array[In], length: In):\n    // Initialize dp array with secure integers\n    dp = array[SecureInteger](length)\n    \n    // Base cases\n    dp[0] = houses[0]\n    dp[1] = max(houses[0], houses[1])\n    \n    // Iterate from the third house to the last house\n    for i from 2 to length - 1:\n        val1 = dp[i - 2] + houses[i]\n        val2 = dp[i - 1]\n        dp[i] = max(val1, val2)\n    endfor\n    \n    // Return the result\n    return dp[length - 1]\nendfunction\n", "model_name": "qwen-qwq"}
{"test_name": "sum_odd_and_odd", "response_0": "define sum_odd_and_odd(arr):\n    var sum = 0\n    for i in 0 to ArrayLength(arr)-1 do\n        if i % 2 != 0 then\n            for j in 0 to i-1 do\n                if j % 2 != 0 then\n                    sum = sum + arr[j]\n    return sum\n", "response_1": "proc sum_odd_and_odd(arr[], len)\n\n    Private i, j;\n\n    In sum = 0;\n\n    for(i = 0; i < len; i = i + 1) {\n\n        if (i % 2) != 0 {\n\n            for(j = 0; j < i; j = j + 1) {\n\n                if (j % 2) != 0 {\n\n                    sum += arr[j];\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return sum;\n\n", "model_name": "qwen-qwq"}
{"test_name": "is_monotonous", "response_0": "", "response_1": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    d = 0\n    for i in range(len(arr)-1):\n        if i > 0 and (arr[i+1]-arr[i])*d <= 0:\n            return False\n        d = arr[i+1]-arr[i]\n    return True\n\ndef main():\n    # Read the array from a file\n    with open('input.txt', 'r') as f:\n        arr = [int(x) for x in f.read().split()]\n\n    # Check if the array is strictly monotonous\n    result = is_monotonous(arr)\n\n    # Output the result\n    if result:\n        print(\"1\")\n    else:\n        print(\"0\")\n\nif __name__ == \"__main__\":\n    main()\n", "model_name": "qwen-qwq"}
{"test_name": "positive_count_negative_sum", "response_0": "from mpyc.runtime import mpc\n\nasync def positive_count_negative_sum():\n    # Read the array as a secret input from all parties\n    arr = await mpc.input_from(ALL, length=SIZE)\n    \n    # Determine which elements are positive\n    is_positive = await mpc.greater_than(arr, 0)\n    # Sum the number of positive elements\n    count = await mpc.sum(is_positive)\n    \n    # Determine which elements are negative\n    is_negative = await mpc.less_than(arr, 0)\n    # Mask the array to include only negative elements\n    negative_elements = [a if neg else 0 for a, neg in zip(arr, is_negative)]\n    # Sum the negative elements\n    sum_negative = await mpc.sum(negative_elements)\n    \n    return count, sum_negative\n", "response_1": "def positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = 0\n    summ = 0  # 'sum' is a reserved keyword, so using 'summ' instead\n\n    for item in arr:\n        if item > 0:\n            count = count + 1\n        if item < 0:\n            summ = summ + item\n\n    return count, summ\n", "model_name": "qwen-qwq"}
{"test_name": "sum_even", "response_0": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = 0\n    for item in arr:\n        if eq(mod2(item), 0):\n            sum += item\n    return sum\n", "response_1": "from mp_spdz import *\n\ndef sum_even(arr, n):\n    sum = Int(0)\n    for i in range(n):\n        item = arr[i]\n        is_even = eq(item % Int(2), Int(0))\n        sum += item * is_even\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    return sum(abs(vec))\n", "response_1": "def one_norm(vec):\n    abs_vec = [abs(item) for item in vec]\n    return sum(abs_vec)\n", "model_name": "qwen-qwq"}
{"test_name": "array_floor", "response_0": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    \"\"\"\n    return [x.floor() for x in arr]\n", "response_1": "from mp_spdz import Array, floor\n\ndef array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    \"\"\"\n    # Assuming arr is an Array of secret-shared values\n    ret = Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = floor(arr[i])\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "three_five", "response_0": "def three_five(arr):\n    # Initialize has3 and has5 to 0 (False)\n    has3 = 0\n    has5 = 0\n\n    # Iterate through each item in the array\n    for item in arr:\n        # Check if item is 3 and update has3\n        temp3 = secure_compare(item, 3)\n        has3 = has3 + temp3 - has3 * temp3\n\n        # Check if item is 5 and update has5\n        temp5 = secure_compare(item, 5)\n        has5 = has5 + temp5 - has5 * temp5\n\n    # Check if has3 is equal to has5\n    result = secure_compare(has3, has5)\n\n    # Return the result\n    return result\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "num_above_average", "response_0": "from mp_spdz import secure_ge\n\ndef num_above_average(arr):\n    n = len(arr)\n    \n    # Step 1: Compute the sum of the array elements\n    sum_arr = sum(arr)\n    \n    # Step 2: Compute the average\n    avg = sum_arr / n\n    \n    # Step 3: Count elements >= avg\n    count = 0\n    for item in arr:\n        # Secure comparison: item >= avg\n        is_above = secure_ge(item, avg)\n        count += is_above\n    \n    return count\n", "response_1": "from mp_spdz import *\n\ndef num_above_average(arr):\n    n = len(arr)\n    sum_arr = sum(arr)\n    reciprocal_n = reciprocal(n)\n    avg = sum_arr * reciprocal_n\n    count = 0\n    for item in arr:\n        gt = item >= avg\n        count += gt\n    return count\n", "model_name": "qwen-qwq"}
{"test_name": "clip", "response_0": "from mpc import Array, Int, min, max\n\ndef clip_arr(arr, upper_bound=1, lower_bound=-1):\n    for i in range(len(arr)):\n        arr[i] = min(max(arr[i], lower_bound), upper_bound)\n    return arr\n", "response_1": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    import sys\n    sys.path.append('path_to_mp_spdz_lib')  # Adjust path as necessary\n\n    from mp_spdz import minimum, maximum\n\n    # Ensure arr, upper_bound, and lower_bound are of compatible secret-shared types\n\n    # Clip the array\n    clipped_arr = maximum(minimum(arr, upper_bound), lower_bound)\n\n    return clipped_arr\n\n# Example usage (this part would be adapted based on MP-SPDZ's input/output methods)\nif __name__ == \"__main__\":\n    # Assuming arr, upper_bound, lower_bound are read or received beforehand\n    # For demonstration, placeholders are used\n    arr = ...  # Read or receive secret-shared array\n    upper_bound = ...  # Read or receive secret-shared upper bound\n    lower_bound = ...  # Read or receive secret-shared lower bound\n\n    clipped_arr = clip(arr, upper_bound, lower_bound)\n\n    # Write or send the clipped array\n    # For demonstration, placeholder for writing or sending the result\n", "model_name": "qwen-qwq"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "party_id, num_parties, my_num = welcome()\n\n# Define the length of the array\narray_len = ...  # some predefined value\n\n# Create a secret shared array\narray = make_array(array_len, Int)\n\n# Receive shares of array elements from parties\nfor i in range(array_len):\n    array[i] = input(\"array_element_\" + str(i), Int)\n\npartial_sum = 0\n\nfor i in range(array_len):\n    temp_sum = partial_sum + array[i]\n    bit1 = secure_compare(temp_sum, 5, \">=\")\n    bit2 = secure_compare(temp_sum, 10, \"<=\")\n    bit = bit1 & bit2\n    partial_sum = partial_sum + array[i] * (1 - bit)\n\n# Output the result\noutput(partial_sum, \"partial_sum\")\n", "response_1": "# Read the array from input\narray = MPyIntVector.read_from_file(\"input.txt\", 4)\n\n# Initialize sum to 0\nsum = MPyInt(0)\n\n# Process each element in the array\nfor i in range(4):\n    potential_sum = sum + array[i]\n    condition = (5 <= potential_sum) & (potential_sum <= 10)\n    sum += IF(condition, MPyInt(0), array[i])\n\n# Output the result\nOutput(sum, \"sum\")\n", "model_name": "qwen-qwq"}
{"test_name": "sum_of_odd_and_even", "response_0": "from secint import SecureInt\n\ndef sum_of_odd_and_even_sec(arr):\n    odd_sum = SecureInt(0)\n    even_sum = SecureInt(0)\n    for item in arr:\n        remainder = item.mod(SecureInt(2))\n        odd_sum += item * remainder\n        even_sum += item * (SecureInt(1) - remainder)\n    return odd_sum, even_sum\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "distance", "response_0": "function distance(vec1, vec2):\n    sum = 0.0;\n    for i in 0 .. len(vec1)-1:\n        diff = vec1[i] - vec2[i];\n        sum = sum + (diff * diff);\n    return sqrt(sum);\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "num_occurrence", "response_0": "function num_occurrence(Int[] arr, Int target):\n    Int count = 0\n    for i in 0 to length(arr) - 1:\n        Int item = arr[i]\n        Int diff = item - target\n        Int eq_result = eqZ(diff)\n        count = count + eq_result\n    return count\n", "response_1": "def num_occurrence(arr, target):\n\nreturn sum(secure_compare_eq(item, target) for item in arr)\n\n", "model_name": "qwen-qwq"}
{"test_name": "palindrome", "response_0": "def palindrome(arr):\n    from mp_spdz import eq, and_, Bool, Int\n\n    n = len(arr)\n    flag = Bool(True)\n    for i in range(n):\n        # Compare arr[i] and arr[n - 1 - i]\n        comparison = eq(arr[i], arr[n - 1 - i])\n        # Update flag with logical AND\n        flag = and_(flag, comparison)\n    return flag\n", "response_1": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    n = len(arr)\n    flag = 1  # Initialize flag to True (1)\n    for i in range(n // 2):\n        # Check if elements at positions i and n-1-i are equal\n        eq = arr[i] == arr[n - 1 - i]\n        # Update flag: flag = flag AND eq\n        flag = flag * eq\n    return flag\n", "model_name": "qwen-qwq"}
{"test_name": "reverse_order_pair", "response_0": "# Define the secure comparison macro, assuming it's provided by MP-SPDZ\nmacro secure_compare(a, b, comp):\n    # Implementation provided by MP-SPDZ framework\n    pass\n\n# Assuming n is known and not secret\nn = len(arr)\n\n# Define the array of secret-shared values\narr = Array(n, Integer(32))  # Assuming 32-bit integers\n\n# Initialize sum\nnum = 0\n\n# Iterate over all unique pairs (i, j) with i < j\nfor i in range(n):\n    for j in range(i+1, n):\n        # Perform secure comparison\n        cmp_result = secure_compare(arr[i], arr[j], \"gt\")\n        # Add to sum\n        num += cmp_result\n\n# num now holds the secret-shared count of reverse order pairs\n# To reconstruct the result, use Reconstruct(num)\nresult = Reconstruct(num)\n", "response_1": "def reverse_order_pair(length):\n    # Create an array of secret shared integers\n    arr = Array.create(length, sint)\n    \n    # Input array elements securely\n    for i in range(length):\n        arr[i] = sint.input_(description=\"arr[{}]\".format(i))\n    \n    # Initialize count of reverse order pairs\n    num = sint(0)\n    \n    # Iterate over all unique pairs (i, j) where i < j\n    for i in range(length):\n        for j in range(i+1, length):\n            # Compare arr[i] and arr[j]\n            diff = arr[i] > arr[j]\n            # Add the comparison result to the count\n            num += sint(diff)\n    \n    # Reveal the final count\n    result = num.reveal()\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "sum_of_cubes", "response_0": "def sum_of_cubes(n: Size, arr: Array[SignedInt(32), n]) -> Reconstructed[SignedInt(64)]:\n    ret = SignedInt(64)(0)\n    for i in Range(n):\n        item = arr[i]\n        cube = item * item * item  # Compute cube\n        ret = ret + cube           # Accumulate sum\n    return ret\n", "response_1": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array.\n    \"\"\"\n    # Initialize ret to zero as a shared value\n    ret = 0\n    for item in arr:\n        # Compute cube of item securely\n        cube = item * item * item\n        # Add cube to ret\n        ret = ret + cube\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "max_element", "response_0": "def max_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a:\n        # Perform secure comparison\n        cmp = secure_compare_ge(current, item)\n        # Select the maximum value based on the comparison\n        current = select(cmp, current, item)\n    return current\n", "response_1": "from msp.spdz import *\n\ndef max_element(a):\n    current = a[0]\n    for item in a:\n        condition = greater_than(current, item)\n        current = if_else(condition, current, item)\n    return current\n", "model_name": "qwen-qwq"}
{"test_name": "array_if_else", "response_0": "", "response_1": "def array_if_else(arr, predicator, if_func, else_func):\n    from mpspdz import if_else\n\n    # Compute conditions using the predicate\n    conditions = [predicator(x) for x in arr]\n\n    # Compute results for both branches\n    if_results = [if_func(x) for x in arr]\n    else_results = [else_func(x) for x in arr]\n\n    # Select results based on conditions\n    arr = [if_else(c, i, e) for c, i, e in zip(conditions, if_results, else_results)]\n\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "inf_norm", "response_0": "def inf_norm(vec):\n    n = len(vec)\n    if n == 0:\n        return sfix(0)\n    sum = sfix(0)\n    for i in range(n):\n        abs_item = sabs(vec[i])\n        sum = smax(sum, abs_item)\n    return sum\n", "response_1": "from mpyc.sectypes import SecureFixedPoint\nfrom mpyc.runtime import mpc\n\ndef inf_norm(vec):\n    abs_vec = [item.abs() for item in vec]\n    return mpc.max(abs_vec)\n", "model_name": "qwen-qwq"}
{"test_name": "array_inc", "response_0": "# Define constants\nparties = 2\nN = 5  # Example array size\n\n# Define secure integer type\nsint = SecureInteger(32)  # Assuming 32-bit integers\n\n# Define the function\nfunction (sint[N]) array_inc(sint[N] arr):\n    for i in 0 to N-1:\n        arr[i] = arr[i] + 1\n    return arr\n\n# Main protocol\nstart_protocol():\n    # Input phase\n    arr = array(sint, N)\n    for i in 0 to N-1:\n        arr[i] = input(sint, \"Party0\")  # Assuming input from Party0\n\n    # Compute\n    result = array_inc(arr)\n\n    # Output phase\n    for i in 0 to N-1:\n        output(result[i], \"Party0\")  # Output to Party0\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    result = [0] * n\n    for i in range(n):\n        result[i] = arr[i] + 1\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "count_rises", "response_0": "def count_rises(arr: Array(10, Int(32))) -> Int(32):\n    comparisons = [lt(arr[i], arr[i+1]) for i in range(len(arr)-1)]\n    count = sum(comparisons)\n    return count\n", "response_1": "from mp_spdz import *\n\n# Define the number of parties\nparties = 2\n\n# Assume the array length is known\nlength = 10  # Example length\n\n# Combine the array parts securely\narr = Array.empty(length)\nfor i in range(length):\n    if party == 0:\n        arr[i] = Input(private_input[i])\n    else:\n        arr[i] = Input(private_input[i])\n\n# Count rises\ncount = 0\nfor i in range(length - 1):\n    is_rise = secure_compare(arr[i], arr[i+1], '<')\n    count += is_rise\n\n# Output the result\nOutput(\"Number of rises:\", count)\n", "model_name": "qwen-qwq"}
{"test_name": "skip_at_zero", "response_0": "def skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    for i in range(len(array)):\n        if array[i] == 0:\n            continue\n        array[i] += 1\n    return array\n", "response_1": "def skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    for i in range(len(array)):\n        is_zero = eqz(array[i])\n        array[i] = if_else(is_zero, array[i], array[i] + 1)\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "array_intersect", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Square each element of the vector\n    squared = [x * x for x in vec]\n    \n    # Sum the squared elements\n    total = squared[0]\n    for i in range(1, len(squared)):\n        total = total + squared[i]\n    \n    # Compute the square root of the sum\n    # Assuming MP-SPDZ has a function for square root, e.g., math.sqrt\n    # If not, an approximation method may be needed\n    norm = math.sqrt(total)\n    \n    return norm\n", "response_1": "def two_norm(vec):\n    sum_squares = dot(vec, vec)\n    norm = sqrt(sum_squares)\n    return norm\n", "model_name": "qwen-qwq"}
{"test_name": "sum_between", "response_0": "function sum_between(arr, l, u):\n    var sum = 0\n    for item in arr:\n        if l <= item and item <= u:\n            sum = sum + item\n    return sum\n", "response_1": "from msp.spdz import SecureInt, secure_leq, secure_and\n\ndef sum_between(arr, l, u):\n    sum = SecureInt(0)\n    for item in arr:\n        bit1 = secure_leq(l, item)\n        bit2 = secure_leq(item, u)\n        condition = secure_and(bit1, bit2)\n        sum += item * condition\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "largest_gap", "response_0": "", "response_1": "from mpyc.runtime import mpc\nfrom mpyc.sectypes import SecureFixedPoint\n\n# Define the prime p and the secure fixed-point type\np = 2**32 + 1\nZp = SecureFixedPoint(p, f_bits=0)\n\n@mpc.coroutine\nasync def largest_gap(arr):\n    n = len(arr)\n    arr = await mpc.input(mpc.make_array(Zp, n), senders=0)\n    cur = Zp(0)\n    for i in range(n - 1):\n        diff = await mpc.abs(arr[i + 1] - arr[i])\n        cur = await mpc.if_else(diff > cur, diff, cur)\n    return await mpc.output(cur)\n\ndef main():\n    # Example input array\n    arr = [1, 3, 7, 9, 12]\n    # Convert to secret-shared array\n    arr_shared = mpc.make_array(Zp, arr)\n    # Run the largest_gap function\n    result = mpc.run(largest_gap(arr_shared))\n    print(\"Largest gap:\", result)\n\nif __name__ == \"__main__\":\n    mpc.run(mpc.start())\n    main()\n    mpc.run(mpc.shutdown())\n", "model_name": "qwen-qwq"}
{"test_name": "totally_dominate", "response_0": "function totally_dominate(a: array[int], b: array[int]): bool {\n    let amin = min(a);\n    let bmax = max(b);\n    return amin >= bmax;\n}\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "element_count", "response_0": "def element_count(arr, target):\n    ret = 0\n    for i in range(len(arr)):\n        if arr[i] == target:\n            ret = ret + 1\n    return ret\n", "response_1": "def element_count(arr, target):\n    return count_occurrences(arr, target)\n", "model_name": "qwen-qwq"}
{"test_name": "is_subarray", "response_0": "function is_subarray(c: array[int], d: array[int]): bool {\n    var n = len(d);\n    var m = len(c);\n    for (var i = 0; i <= n - m; i = i + 1) {\n        var flag = true;\n        for (var j = 0; j < m; j = j + 1) {\n            if (d[i + j] != c[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n}\n", "response_1": "from Compiler import Program\nfrom Compiler.types import sfix, Array, sbit\nfrom Compiler.util import or_reduce\n\n@Program.Program\ndef is_subarray(c: Array, d: Array):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    n = len(d)\n    m = len(c)\n    if m == 0:\n        return True\n    if m > n:\n        return False\n    flags = Array(n - m + 1, sbit)\n    for i in range(n - m + 1):\n        flag = sbit(1)\n        for j in range(m):\n            flag = flag & (d[i + j] == c[j])\n        flags[i] = flag\n    return or_reduce(flags).reveal()\n", "model_name": "qwen-qwq"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    result = 0\n    for item in arr:\n        condition = (item == 5) | (item == 7)\n        result = condition.if_else(1, result)\n    return result\n", "response_1": "def exists_5_or_7(arr: Array[Int]):\n    for item in arr:\n        if item == 5 || item == 7:\n            return True\n    return False\n", "model_name": "qwen-qwq"}
{"test_name": "variance", "response_0": "def variance(arr):\n    n = len(arr)\n    sum_arr = 0\n    for item in arr:\n        sum_arr += item\n    average = sum_arr * (1/n)  # 1/n is a public value\n\n    sum_sq_diff = 0\n    for item in arr:\n        diff = item - average\n        sq_diff = diff * diff\n        sum_sq_diff += sq_diff\n    variance = sum_sq_diff * (1/n)\n    return variance\n", "response_1": "def variance(arr):\n    n = len(arr)\n    sum_elements = 0\n    for item in arr:\n        sum_elements += item\n    average = sum_elements / n\n\n    sum_squares = 0\n    for item in arr:\n        difference = item - average\n        sum_squares += difference * difference\n    variance = sum_squares / n\n    return variance\n", "model_name": "qwen-qwq"}
{"test_name": "is_ascending", "response_0": "@mpc.coroutine\ndef is_ascending(arr):\n    n = arr.size\n    if n == 1:\n        return mpc.one\n    comparisons = []\n    for i in range(n - 1):\n        comparisons.append(mpc.less_than(arr[i], arr[i + 1]))\n    result = mpc.and_all(comparisons)\n    return result\n", "response_1": "// Return whether or not the array is in strictly ascending order.\n// If the length of input array is 1, you should return True.\nproc is_ascending(arr):\n    for i in 0 .. len(arr)-1:\n        if arr[i] >= arr[i+1]:\n            return False\n    return True\n", "model_name": "qwen-qwq"}
{"test_name": "xor_all", "response_0": "def xor_all(arr):\n    from sctypes import Bit\n    from operators import xor\n\n    ret = arr[0]\n    for i in xrange(1, len(arr)):\n        ret = xor(ret, arr[i])\n    return ret\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "upper_bound", "response_0": "def upper_bound(arr, x):\n    n = len(arr)\n    ret = -1\n    distance = maxint  # Initialize to a large value\n    found = 0\n\n    for i in range(n):\n        gt = greater_than(arr[i], x)\n        if found == 0:\n            update = gt\n        else:\n            diff = arr[i] - x\n            update = and(gt, lt(diff, distance))\n        update_secure = sint(update)\n        ret = ternary(update_secure, i, ret)\n        distance = ternary(update_secure, arr[i] - x, distance)\n        found = ternary(update_secure, 1, found)\n\n    return ret\n", "response_1": "def upper_bound(arr, x):\n    n = len(arr)\n    MAX_VAL = ...  # Define appropriately based on arr's value range\n    distance = MAX_VAL + 1\n    ret = n  # Initialize to n, representing -1\n\n    for i in range(n):\n        mask = greater_than(arr[i], x)\n        diff = arr[i] - x\n        better = less_than(diff, distance)\n        update = mask * better\n        ret = update * i + (1 - update) * ret\n        distance = update * diff + (1 - update) * distance\n\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "array_process_then_sum", "response_0": "def array_process_then_sum(arr, func):\n    sum = 0\n    for i in range(arr.size()):\n        arr[i] = func(arr[i])\n        sum += arr[i]\n    return sum\n", "response_1": "def array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function,\n    then sum up the processed elements.\n    \"\"\"\n    # Apply the function to each element in the array\n    processed_arr = mpspdz.prep.map(func, arr)\n    # Sum up the processed elements\n    sum = mpspdz.sum(processed_arr)\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "average", "response_0": "def average(arr):\n    sum = sint.sum_array(arr)\n    length = len(arr)\n    ret = sum.div_public(length)\n    return ret\n", "response_1": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = 0\n    length = arr.length\n    for i in range(length):\n        sum = sum + arr[i]\n    ret = sum / length  # Assuming MP-SPDZ supports direct division or use div function if necessary\n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "array_filter", "response_0": "def array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array,\n    if the predicator returns True, then preserve the element,\n    otherwise set the element to 0.\n    \"\"\"\n    for i in Range(len(arr)):\n        if predicator(arr[i]):\n            arr[i] = arr[i]\n        else:\n            arr[i] = 0\n    return arr\n", "response_1": "def array_filter(arr, predicator):\n    /*\n    For each element in the input array,\n    if the predicator returns True, then preserve the element,\n    otherwise set the element to 0.\n    */\n    for i in range(len(arr)):\n        arr[i] = if_else(predicator(arr[i]), arr[i], 0)\n    return arr\n", "model_name": "qwen-qwq"}
{"test_name": "sum_up", "response_0": "# Read the array from input\narray = getMPI().read_int_list_from_file(\"input_array.txt\")\n\n# Compute the sum using a built-in function\nsum = MP_Sum(array)\n\n# Output the sum to a file\ngetMPI().write_int_to_file(\"sum_output.txt\", sum)\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "negative_to_zero", "response_0": "def negative_to_zero(array):\n    zero = Constant(0, Type\u6a21\u7248[2], size=len(array))\n    condition = GreaterOrEqual(array, zero)\n    array = IfElse(condition, array, zero)\n    return array\n", "response_1": "def negative_to_zero(array):\n    return smax(array, 0)\n", "model_name": "qwen-qwq"}
{"test_name": "sum_only_positive_to_ten", "response_0": "def sum_only_positive_to_ten(array):\n    sum = 0\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        if sum >= 10:\n            break\n        sum = sum + array[i]\n    return sum\n", "response_1": "proc sum_only_positive_to_ten(array: array[SecureFixedPoint]) -> SecureFixedPoint:\n    sum = 0.0f\n    n = len(array)\n    for i in 0 .. n-1:\n        if array[i] > 0.0f:\n            if sum < 10.0f:\n                sum = sum + array[i]\n            else:\n                # No need to add more, sum already >= 10\n                pass\n        else:\n            # Skip non-positive elements\n            pass\n    return sum\n", "model_name": "qwen-qwq"}
{"test_name": "bubble_sort", "response_0": "", "response_1": "def bubble_sort(arr):\n\n    n = len(arr)\n\n    for i in 0 to n-1:\n\n        for j in 0 to n-1-i:\n\n            if arr[j] >= arr[j+1]:\n\n                temp = arr[j]\n\n                arr[j] = arr[j+1]\n\n                arr[j+1] = temp\n\n    return arr\n\n", "model_name": "qwen-qwq"}
