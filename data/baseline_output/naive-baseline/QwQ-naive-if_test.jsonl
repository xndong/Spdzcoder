{"test_name": "sin_or_cos", "response_0": "from program import Online, sin, cos, ge, ifElse\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Check if x is nonnegative\n    condition = ge(x, 0)  # Secure comparison: x >= 0\n\n    # Compute sin(x) and cos(x)\n    sin_x = sin(x)\n    cos_x = cos(x)\n\n    # Use secure conditional operation to select sin(x) or cos(x)\n    result = ifElse(condition, sin_x, cos_x)\n\n    return result\n", "response_1": "from mp_spdz import *\n\ndef sin_or_cos(x):\n    # Step 1: Secure comparison to check if x >= 0\n    is_nonnegative = x >= 0\n    \n    # Step 2: Approximate sin(x) and cos(x)\n    sin_x = approx_sin(x)\n    cos_x = approx_cos(x)\n    \n    # Step 3: Select sin(x) if x >= 0, else cos(x)\n    result = is_nonnegative * sin_x + (1 - is_nonnegative) * cos_x\n    \n    return result\n\ndef approx_sin(x, terms=10):\n    # Approximate sin(x) using Taylor series expansion\n    sin_approx = 0\n    for n in range(terms):\n        coefficient = (-1)**n / factorial(2*n + 1)\n        term = coefficient * x**(2*n + 1)\n        sin_approx += term\n    return sin_approx\n\ndef approx_cos(x, terms=10):\n    # Approximate cos(x) using Taylor series expansion\n    cos_approx = 0\n    for n in range(terms):\n        coefficient = (-1)**n / factorial(2*n)\n        term = coefficient * x**(2*n)\n        cos_approx += term\n    return cos_approx\n\ndef factorial(n):\n    # Compute factorial of n\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n", "model_name": "qwen-qwq"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    is_negative = input.less_than(0)\n    result = is_negative * input + (1 - is_negative) * 0\n    return result\n", "response_1": "def negative_relu(a):\n    return where(a < 0, a, 0)\n", "model_name": "qwen-qwq"}
{"test_name": "is_close", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "hardswish", "response_0": "function hardswish(x):\n    # Compute masks for the conditions\n    mask_less_than_minus3 = secure_less_than(x, -3)\n    mask_greater_than_3 = secure_less_than(3, x)\n    \n    # Compute the polynomial part\n    polynomial_part = secure_multiply(x, secure_add(x, 3))\n    polynomial_part = secure_divide(polynomial_part, 6)\n    \n    # Select the output based on the masks\n    result = secure_select(mask_less_than_minus3, 0, secure_select(mask_greater_than_3, x, polynomial_part))\n    \n    return result\n", "response_1": "def hardswish(x):\n    # Define the polynomial approximation for the hardswish function\n    # For x in [-3, 3], hardswish(x) = x*(x + 3)/6\n    # Outside this range, we need to clamp the values accordingly\n    \n    # First, compute the polynomial part\n    poly_part = (x * (x + 3)) / 6\n    \n    # Now, handle the conditions for x < -3 and x > 3\n    # Since direct conditionals are not secure, we use step functions\n    \n    # Step function for x < -3: if x < -3, output 0; else, output 1\n    # Step function for x > 3: if x > 3, output 1; else, output 0\n    \n    # In MP-SPDZ, we can use the step function provided\n    less_than_minus3 = step(x + 3)\n    greater_than_3 = step(x - 3)\n    \n    # The output should be:\n    # 0 when x < -3\n    # poly_part when -3 <= x <= 3\n    # x when x > 3\n    \n    # So, the final output is:\n    # (1 - less_than_minus3) * (poly_part + (greater_than_3 * (x - poly_part)))\n    \n    # Simplifying:\n    # When x < -3: less_than_minus3 = 1, so (1 - 1) * (...) = 0\n    # When -3 <= x <= 3: less_than_minus3 = 0, greater_than_3 = 0, so 1 * (poly_part + 0) = poly_part\n    # When x > 3: less_than_minus3 = 0, greater_than_3 = 1, so 1 * (poly_part + (1 * (x - poly_part))) = x\n    \n    result = (1 - less_than_minus3) * (poly_part + greater_than_3 * (x - poly_part))\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    temp = smin(x, sint(6))\n    result = smax(temp, sint(-6))\n    return result\n", "response_1": "def test_clip_at_6():\n\n    test_cases = [\n\n        (7, 6),\n\n        (-7, -6),\n\n        (0, 0),\n\n        (5, 5),\n\n        (-5, -5),\n\n    ]\n\n    scale = 16\n\n    for input_val, expected in test_cases:\n\n        # Create secret shared input\n\n        x = Constant(input_val << scale)\n\n        clipped_x = clip_at_6(x)\n\n        # Reveal the result for testing\n\n        result = reveal(clipped_x)\n\n        # Check if the result matches the expected value\n\n        assert result == expected << scale, f\"Failed for input {input_val}\"\n\n    print(\"All tests passed!\")\n\n", "model_name": "qwen-qwq"}
{"test_name": "piecewise_function", "response_0": "define function piecewise_function(x):\n    var cond1 = GT(x, 1);\n    var ret = cond1 * x;\n\n    var cond2 = LT(x, -1) * (1 - cond1);\n    ret = ret + cond2 * x;\n\n    var cond3 = GT(x, 0) * (1 - cond1 - cond2);\n    ret = ret + cond3 * 1;\n\n    var cond4 = LT(x, 0) * (1 - cond1 - cond2 - cond3);\n    ret = ret + cond4 * (-1);\n\n    var cond5 = 1 - cond1 - cond2 - cond3 - cond4;\n    ret = ret + cond5 * 0;\n\n    return ret;\nendfunction;\n", "response_1": "def piecewise_function(x):\n    # Define conditions using secure comparisons\n    cond1 = s_gt(x, s_const(1))\n    cond2 = s_lt(x, s_const(-1))\n    cond3 = s_gt(x, s_const(0)) * s_le(x, s_const(1))\n    cond4 = s_lt(x, s_const(0)) * s_ge(x, s_const(-1))\n    cond5 = 1 - (cond1 + cond2 + cond3 + cond4)\n    \n    # Compute the return value based on the conditions\n    ret = (cond1 * x) + (cond2 * x) + (cond3 * s_const(1)) + (cond4 * s_const(-1)) + (cond5 * s_const(0))\n    \n    return ret\n", "model_name": "qwen-qwq"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    # Compare a and b, swap if necessary\n    cmp_ab = greater_or_equal(a, b)\n    temp_a = if_else(cmp_ab, b, a)\n    temp_b = if_else(cmp_ab, a, b)\n    \n    # Compare b and c, swap if necessary\n    cmp_bc = greater_or_equal(temp_b, c)\n    temp_b = if_else(cmp_bc, c, temp_b)\n    temp_c = if_else(cmp_bc, temp_b, c)\n    \n    # Compare a and b again, swap if necessary\n    cmp_ab = greater_or_equal(temp_a, temp_b)\n    temp_a = if_else(cmp_ab, temp_b, temp_a)\n    temp_b = if_else(cmp_ab, temp_a, temp_b)\n    \n    # The middle value is now temp_b\n    return temp_b\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "indicated_sin_or_cos", "response_0": "def indicated_sin_or_cos(x, ind):\n    return if_else(ind, sin(x), cos(x))\n", "response_1": "from mpspdz.math import sin, cos\nfrom mpspdz.runtime import if_else\n\ndef indicated_sin_or_cos(x, ind):\n    return if_else(ind, sin(x), cos(x))\n", "model_name": "qwen-qwq"}
{"test_name": "minus2_if_else", "response_0": "from mpspdz import *\n\ndef minus2_if_else(x):\n\ndiff = x - Constant(2)\n\ncondition = greater_or_equal(diff, Constant(0))\n\nresult = cond_select(condition, diff, x)\n\nreturn result\n\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "relu6", "response_0": "", "response_1": "def relu6(x):\n    from mp_spdz import sint\n    zero = sint(0)\n    six = sint(6)\n    is_less_than_zero = x.less_than(zero)\n    is_greater_than_six = x.greater_than(six)\n    return is_less_than_zero.if_else(zero, is_greater_than_six.if_else(six, x))\n", "model_name": "qwen-qwq"}
{"test_name": "exp_slide", "response_0": "from mp_spdz import secure_compare, if_else, exp\n\ndef exp_slide(x):\n\n    is_nonnegative = secure_compare(x, 0, 'GE')\n\n    exp_val = exp(x)\n\n    add_val = x + 1\n\n    result = if_else(is_nonnegative, exp_val, add_val)\n\n    return result\n\n", "response_1": "def exp_slide(x):\n    # Perform secure comparison: x >= 0\n    condition = sge(x, 0)\n    \n    # Compute e^x\n    exp_x = sexp(x)\n    \n    # Compute x + 1\n    add_x = x + 1\n    \n    # Select between e^x and x + 1 based on the condition\n    result = condition * exp_x + (1 - condition) * add_x\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "pass_or_not", "response_0": "from mp_spdz import *\n\nclass PassOrNot(Protocol):\n    def __init__(self, player):\n        super().__init__(player)\n\n    def run(self):\n        # Get secret input for score from party 0 (student)\n        score = self.get_secret_input(0, 'score', SecureInteger(8))\n        \n        # Compute passed and adjusted score\n        passed, adjusted_score = self.compute_pass(score)\n        \n        # Reveal the results to party 1 (professor)\n        self.send_reveal(1, 'passed', passed)\n        self.send_reveal(1, 'adjusted_score', adjusted_score)\n\n    def compute_pass(self, score):\n        # Compute score - 60\n        delta = score - SecureInteger(8).set(60)\n        \n        # Determine if passed using secure comparison\n        mask = if_positive(delta)\n        condition = Condition(mask)\n        \n        # Select adjusted_score based on the condition\n        adjusted_score = condition.then_return(score).else_return(SecureInteger(8).set(59))\n        \n        # Select passed status based on the condition\n        passed = condition.then_return(SecureInteger(8).set(1)).else_return(SecureInteger(8).set(0))\n        \n        return passed, adjusted_score\n", "response_1": "def pass_or_not(score):\n    passed = greater_or_equal(score, 60)\n    result_score = passed * score + (1 - passed) * 59\n    return result_score, passed\n", "model_name": "qwen-qwq"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    # Compute the discriminant\n    D = b * b - 4 * a * c\n\n    # Secure comparisons\n    is_a_zero = equal(a, 0)\n    is_b_zero = equal(b, 0)\n    is_d_positive = greater_than(D, 0)\n    is_d_zero = equal(D, 0)\n\n    # Calculate number of roots when a is zero\n    num_roots_a_zero = (1 - is_b_zero)\n\n    # Calculate number of roots when a is not zero\n    num_roots_a_nonzero = 2 * is_d_positive + is_d_zero\n\n    # Combine the results based on whether a is zero or not\n    num_roots = is_a_zero * num_roots_a_zero + (1 - is_a_zero) * num_roots_a_nonzero\n\n    return num_roots\n", "response_1": "def how_many_roots(a, b, c):\n\nzero = a.zeros()\n\none = a.ones()\n\ntwo = a.ones() + a.ones()\n\nis_a_zero = EqZero(a)\n\nroots_when_a_zero = one - EqZero(b)\n\nroots_when_a_zero = roots_when_a_zero * is_a_zero\n\nis_a_nonzero = one - is_a_zero\n\nd = b*b - four*a*c\n\nis_d_positive = GT(d, zero)\n\nis_d_zero = EqZero(d)\n\nroots_when_a_nonzero = two*is_d_positive + is_d_zero\n\nroots_when_a_nonzero = roots_when_a_nonzero * is_a_nonzero\n\nroots = roots_when_a_zero + roots_when_a_nonzero\n\nreturn roots\n\n", "model_name": "qwen-qwq"}
{"test_name": "elu", "response_0": "", "response_1": "from mp_spdz import *\n\ndef elu(x):\n    m = x > 0\n    m_sfix = m * sfix(1)\n    true_value = x\n    false_value = x.exp() - sfix(1)\n    result = m_sfix * true_value + (sfix(1) - m_sfix) * false_value\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "relu", "response_0": "from mp_spdz import *\n\ndef relu(x):\n    \"\"\"\n    ReLU function implemented for MP-SPDZ\n    \"\"\"\n    zero = 0  # Assuming 0 is of the same type as x, e.g., sfix\n    positive = x > zero\n    return if_else(positive, x, zero)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    condition = greater_than(x, 0)\n    return x * condition\n", "model_name": "qwen-qwq"}
{"test_name": "leaky_relu", "response_0": "", "response_1": "from mpspdz import Program, if_else01\n\nclass LeakyReLUProgram(Program):\n    def leaky_relu(self, x, alpha):\n        condition = x > 0\n        return if_else01(condition, x, x * alpha)\n\n    def run(self):\n        # Assuming x is a secret shared value and alpha is a public value\n        # For demonstration, let's assume x and alpha are obtained from parties\n        x = self.get_input_from_party(0)  # Replace with actual input method\n        alpha = self.get_public_input_from_party(1)  # Replace with actual input method\n        result = self.leaky_relu(x, alpha)\n        print(\"Leaky ReLU result:\", result.reconstruct())\n\nif __name__ == \"__main__\":\n    program = LeakyReLUProgram()\n    program.run()\n", "model_name": "qwen-qwq"}
{"test_name": "max", "response_0": "def max(a, b):\n    condition = secure_compare_gte(a, b)\n    return select(condition, a, b)\n", "response_1": "# Option 1: Using built-in max function\ndef max(a, b):\n    return max(a, b)\n\n# Option 2: Implementing manually using conditional_value\ndef max(a, b):\n    cond = a >= b\n    return conditional_value(cond, a, b)\n", "model_name": "qwen-qwq"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    cond1 = secure_compare_gt(x, 1)\n    cond2 = secure_compare_lt(x, -1)\n    expr1 = x - 1\n    expr2 = -x - 1\n    result = (cond1 * expr1) + (cond2 * expr2)\n    return result\n", "response_1": "from mpspdz import *\n\ndef bowl_shape(x):\n    is_gt_1 = secure_gt(x, 1)\n    is_lt_neg1 = secure_gt(-1, x)\n    output_gt_1 = (x - 1) * is_gt_1\n    output_lt_neg1 = (-x - 1) * is_lt_neg1\n    return output_gt_1 + output_lt_neg1\n", "model_name": "qwen-qwq"}
{"test_name": "rounded_kinetic_energy", "response_0": "def rounded_kinetic_energy(m, v):\n    k = (m * v * v) / 2\n    k_rounded = Floor(k + 0.5)\n    return k_rounded\n", "response_1": "def rounded_kinetic_energy(m, v):\n    # Calculate v squared\n    v_squared = v * v\n    # Calculate m * v_squared\n    m_v_squared = m * v_squared\n    # Divide by 2\n    k = m_v_squared / 2\n    # Floor the kinetic energy\n    k_int = floor(k)\n    # Calculate the decimal part\n    decimal_part = k - k_int\n    # Check if decimal part is greater than or equal to 0.5\n    round_up = decimal_part >= 0.5\n    # Round up if necessary\n    result = k_int + round_up\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "danger_test", "response_0": "from mp_spdz import Program, SecureInt, Party, reconstruct\n\n# Define parties\n\nparties = [Party(0), Party(1)]\n\nwith Program():\n\n    # Load private inputs\n\n    origin = parties[0].input(SecureInt)\n\n    damage = parties[1].input(SecureInt)\n\n    # Compute result\n\n    result = origin - damage\n\n    # Check if dangerous\n\n    is_dangerous = result <= SecureInt(10)\n\n    # Reconstruct and output the result\n\n    output = reconstruct(is_dangerous)\n\n    print(output)\n\n", "response_1": "protocol danger_test(origin: SInt, damage: SInt):\n    temp = origin - damage\n    result = secure_less_or_equal(temp, 10)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n\n    sum_result = secure_add(x, y)\n\n    mul_result = secure_mul(x, y)\n\n    # Assuming ind is a secure bit (0 or 1)\n\n    result = secure_add(secure_mul(ind, sum_result), secure_mul(secure_sub(1, ind), mul_result))\n\n    return result\n\n", "response_1": "from mp_python import *\n\nclass Main(object):\n    def main(self):\n        # Read inputs from party 0\n        x = sint.input_from(0, \"Enter x: \")\n        y = sint.input_from(0, \"Enter y: \")\n        ind = sint.input_from(0, \"Enter ind (0 or 1): \")\n\n        # Conditionally select sum or product using sint.select\n        result = sint.select(ind, x + y, x * y)\n\n        # Output the result to party 0\n        result.output(0)\n\nif __name__ == \"__main__\":\n    Main().main()\n", "model_name": "qwen-qwq"}
{"test_name": "median", "response_0": "", "response_1": "from MPC import *\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array.\n    Check first whether the array is empty.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    if n % 2 == 1:\n        # For odd-length array, median is the middle element\n        k = n // 2\n        median = kth_smallest(arr, k)\n    else:\n        # For even-length array, median is the average of the two middle elements\n        k = n // 2\n        left = kth_smallest(arr, k - 1)\n        right = kth_smallest(arr, k)\n        # Convert to FixedPoint for accurate averaging\n        median = (FixedPoint(left) + FixedPoint(right)) / 2\n    return median\n", "model_name": "qwen-qwq"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    sum_ab = a + b\n    clipped_sum = clip(sum_ab, 0, 10)\n    return clipped_sum\n", "response_1": "from mp_spdz import *\n\ndef add_upto_10(a, b):\n    sum = a + b\n    gt_10 = greater_than(sum, Constant(10))\n    result = (gt_10 * Constant(10)) + ((Constant(1) - gt_10) * sum)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "taxi_fare", "response_0": "from secure_types import SecureFixedPoint\nfrom secure_ops import if_else, less_than_or_equal\n\ndef taxi_fare(m):\n    delta5 = m - SecureFixedPoint(5)\n    delta10 = m - SecureFixedPoint(10)\n    fare1 = SecureFixedPoint(5)\n    fare2 = SecureFixedPoint(5) + SecureFixedPoint(1.2) * delta5\n    fare3 = SecureFixedPoint(11) + SecureFixedPoint(1.5) * delta10\n    condition1 = less_than_or_equal(m, SecureFixedPoint(5))\n    condition2 = less_than_or_equal(m, SecureFixedPoint(10))\n    result = if_else(condition1, fare1, if_else(condition2, fare2, fare3))\n    return result\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "round", "response_0": "def round(x: Fix) -> Fix:\n    # Extract integer part by right-shifting\n    x_int = x.value >> 16  # Assuming 16 fractional bits\n    # Convert integer part back to fixed-point\n    x_int_fix = Fix(x_int)\n    # Calculate decimal part\n    decimal_part = x - x_int_fix\n    # Define 0.5 in fixed-point\n    half = Fix(0.5)\n    # Compare decimal part with 0.5\n    should_round_up = decimal_part >= half\n    # If should_round_up, add one to integer part\n    if should_round_up:\n        x_int += 1\n    return Fix(x_int)\n", "response_1": "def round(x):\n    return x.round()\n", "model_name": "qwen-qwq"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n\n    cmp1 = secure_ge(score, 90)\n\n    cmp2 = secure_ge(score, 85)\n\n    cmp3 = secure_ge(score, 80)\n\n    cmp4 = secure_ge(score, 75)\n\n    cmp5 = secure_ge(score, 70)\n\n    \n\n    gpa = if_else(\n\n        cmp1,\n\n        40,  # 4.0 * 10\n\n        if_else(\n\n            cmp2,\n\n            36,  # 3.6 * 10\n\n            if_else(\n\n                cmp3,\n\n                33,  # 3.3 * 10\n\n                if_else(\n\n                    cmp4,\n\n                    30,  # 3.0 * 10\n\n                    if_else(\n\n                        cmp5,\n\n                        26,  # 2.6 * 10\n\n                        23  # 2.3 * 10\n\n                    )\n\n                )\n\n            )\n\n        )\n\n    )\n\n    return gpa\n\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "sign", "response_0": "def sign(x):\n    zero = sfix(0)\n    one = sfix(1)\n    neg_one = sfix(-1)\n\n    is_zero = eq_zero(x)\n    is_positive = greater_than(x, zero)\n\n    is_negative = sub(one, add(is_zero, is_positive))\n\n    zero_contribution = mul(is_zero, zero)\n    positive_contribution = mul(is_positive, one)\n    negative_contribution = mul(is_negative, neg_one)\n\n    return add(add(zero_contribution, positive_contribution), negative_contribution)\n", "response_1": "def sign(x):\n    is_zero = equal_zero(x)\n    is_positive = greater_than_zero(x)\n    \n    result = if_else(is_zero, 0, if_else(is_positive, 1, -1))\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "sum_or_difference", "response_0": "", "response_1": "from mp_spdz import *\n\ndef sum_or_difference(a, b):\n    # Perform secure comparison\n    c = secure_compare(a, b)\n    \n    # Compute sum and difference\n    s = a + b\n    d = a - b\n    \n    # Select between sum and difference based on comparison\n    result = c * s + (1 - c) * d\n    \n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    return control_bit.xor(flip_bit)\n", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    return MPC.xor(control_bit, flip_bit)\n", "model_name": "qwen-qwq"}
{"test_name": "negative_plus1", "response_0": "from Compiler import program, types, utils\nfrom Compiler.types import SecureInteger\n\ndef negative_plus1(y):\n    is_negative = y < SecureInteger(0)\n    y_plus_one = y + SecureInteger(1)\n    result = utils.if_else(is_negative, y_plus_one, y)\n    return result\n\ndef main():\n    y = SecureInteger.input_from(0, \"y\")\n    result = negative_plus1(y)\n    result.output(0)\n\nif __name__ == \"__main__\":\n    main()\n", "response_1": "def negative_plus1(y: Int):\n    condition = LT(y, Int(0))\n    result = IfElse(condition, y + Int(1), y)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "is_a_parallelogram", "response_0": "def is_a_parallelogram(a, b, c, d):\n    # Helper function to check if two points are the same\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n\n    # Check for duplicate vertices\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n\n    # Check parallelogram conditions\n    condition1 = (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1])\n    return condition1 or condition2 or condition3\n", "response_1": "protocol is_a_parallelogram(a, b, c, d):\n    # Define a function to check if two points are the same\n    def same(p1, p2):\n        # Securely compare coordinates\n        eq_x = eq(p1[0], p2[0])\n        eq_y = eq(p1[1], p2[1])\n        # Both coordinates must be equal\n        return eq_x && eq_y\n\n    # Check if any two vertices are the same\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return 0  # False\n\n    # Check midpoint conditions\n    cond1 = (a[0] + b[0] == c[0] + d[0]) && (a[1] + b[1] == c[1] + d[1])\n    cond2 = (a[0] + c[0] == b[0] + d[0]) && (a[1] + c[1] == b[1] + d[1])\n    cond3 = (a[0] + d[0] == b[0] + c[0]) && (a[1] + d[1] == b[1] + c[1])\n\n    # Return True if any condition is met\n    return cond1 || cond2 || cond3\n", "model_name": "qwen-qwq"}
{"test_name": "min", "response_0": "def min(a, b):\n    # Compare a and b\n    lt = secure_compare(a, b, \"less_than_or_equal\")\n    # Select the minimum value\n    result = lt * a + (1 - lt) * b\n    return result\n", "response_1": "def min(a, b):\n    if (a <= b):\n        return a\n    else:\n        return b\n", "model_name": "qwen-qwq"}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x, y):\n    def legal(a, b):\n        return (0 <= a <= 7) and (0 <= b <= 7)\n\n    counter = 0\n\n    # Define all possible knight moves\n    moves = [\n        (x + 1, y + 2),\n        (x - 1, y + 2),\n        (x + 1, y - 2),\n        (x - 1, y - 2),\n        (x + 2, y + 1),\n        (x - 2, y + 1),\n        (x + 2, y - 1),\n        (x - 2, y - 1)\n    ]\n\n    for move in moves:\n        a, b = move\n        if legal(a, b):\n            counter += 1\n\n    return counter\n", "response_1": "function int legal(int a, int b):\n    int a_ge_0 = GE(a, 0);\n    int a_le_7 = LE(a, 7);\n    int b_ge_0 = GE(b, 0);\n    int b_le_7 = LE(b, 7);\n    return a_ge_0 * a_le_7 * b_ge_0 * b_le_7;\n\nfunction int choice_of_the_knight(int x, int y):\n    int counter = 0;\n    counter = counter + legal(x + 1, y + 2);\n    counter = counter + legal(x - 1, y + 2);\n    counter = counter + legal(x + 1, y - 2);\n    counter = counter + legal(x - 1, y - 2);\n    counter = counter + legal(x + 2, y + 1);\n    counter = counter + legal(x - 2, y + 1);\n    counter = counter + legal(x + 2, y - 1);\n    counter = counter + legal(x - 2, y - 1);\n    return counter;\n", "model_name": "qwen-qwq"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n\nc = a + b\n\nd = a - b\n\ncmp = sgt(c, d)\n\nreturn if_else(cmp, c, d)\n\n", "response_1": "def main():\n\n    # Load inputs\n\n    a = load_secret_input(\"a\")\n\n    b = load_secret_input(\"b\")\n\n    # Compute c = a + b and d = a - b\n\n    c = a + b\n\n    d = a - b\n\n    # Compare c and d\n\n    bit = greater(c, d)\n\n    # Select the maximum value\n\n    result = bit * c + (1 - bit) * d\n\n    # Output the result\n\n    output(result, path=\"output\")\n\nif __name__ == \"__main__\":\n\n    main()\n\n", "model_name": "qwen-qwq"}
