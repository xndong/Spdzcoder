{"test_name": "next_integer", "response_0": "", "response_1": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    import math\n    return math.floor(t) + 1\n", "model_name": "qwen-qwq"}
{"test_name": "father_and_son", "response_0": "from mp_spdz.compiler import sint, Runtime\n\ndef father_and_son(father_age, son_age):\n    diff = father_age - (son_age * 2)\n    return diff.abs()\n\ndef Main():\n    with Runtime() as runtime:\n        father_age = sint.read('Father age: ')\n        son_age = sint.read('Son age: ')\n        result = father_and_son(father_age, son_age)\n        print('Years difference:', result.reveal())\n", "response_1": "def father_and_son(father_age: Int, son_age: Int) -> Int:\n    diff = father_age - (son_age * 2)\n    return diff.abs()\n", "model_name": "qwen-qwq"}
{"test_name": "triangle_area", "response_0": "function triangle_area(side: Int, height: Int): Int\n    let product = mul(side, height)\n    let area = div(product, 2)\n    return area\nend function\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "sin_plus_cos", "response_0": "", "response_1": "from mp_spdz import Double, math\n\ndef sin_plus_cos(a: Double) -> Double:\n    return math.sin(a) + math.cos(a)\n", "model_name": "qwen-qwq"}
{"test_name": "sigmoid", "response_0": "def sigmoid(x):\n    \"\"\"\n    Sigmoid function for MP-SPDZ\n    \"\"\"\n    exp_x = Double.exp(-x)\n    return 1 / (1 + exp_x)\n", "response_1": "def sigmoid(x):\n    from mp_spdz import recip, fix\n\n    x_squared = x * x\n    numerator = x_squared + 2 * x + fix(2)\n    denominator = x_squared + 2 * x + fix(6)\n    sigmoid_x = numerator * recip(denominator)\n    return sigmoid_x\n", "model_name": "qwen-qwq"}
{"test_name": "self_exponent", "response_0": "from mp_spdz import SecureFixedPoint, exp, log\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    # Assuming k is a SecureFixedPoint object\n    return exp(k * log(k))\n", "response_1": "def self_exponent(k):\n    log_k = Log(k)\n    product = k * log_k\n    result = Exp(product)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "silu", "response_0": "def silu(x):\n    \"\"\"\n    SiLU function implemented for MP-SPDZ\n    \"\"\"\n    # Compute e^{-x} using the exp function\n    exp_term = exp(-x)\n    # Compute the denominator: 1 + e^{-x}\n    denominator = 1 + exp_term\n    # Compute the reciprocal of the denominator\n    reciprocal_denominator = reciprocal(denominator)\n    # Compute the result: x * (1 / (1 + e^{-x}))\n    result = x * reciprocal_denominator\n    return result\n", "response_1": "def silu(x):\n    one = SecureFixedPoint(1)\n    exp_x = exp(-x)\n    denominator = one + exp_x\n    result = x / denominator\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "Gaussian_bracket", "response_0": "", "response_1": "def Gaussian_bracket(x):\n    x_int = floor(x)\n    return x - x_int\n", "model_name": "qwen-qwq"}
{"test_name": "asin_and_square", "response_0": "from mp_spdz import Number, sqrt, atan, pow\n\ndef asin_and_square(x):\n    if not isinstance(x, Number):\n        raise TypeError(\"Input must be of type Number\")\n    \n    one = Number(1)\n    x_squared = x * x\n    one_minus_x_squared = one - x_squared\n    sqrt_one_minus_x_squared = sqrt(one_minus_x_squared)\n    x_over_sqrt = x / sqrt_one_minus_x_squared\n    atan_value = atan(x_over_sqrt)\n    result = pow(atan_value, 2)\n    return result\n", "response_1": "def asin_and_square(x):\n    \"\"\"\n    Approximate arcsin of the input x and then compute the square of the result.\n    \n    Args:\n    x (Fix): Input fixed-point number within the range [-1, 1].\n    \n    Returns:\n    Fix: The square of the arcsin approximation.\n    \"\"\"\n    from mpspdz import Fix\n\n    # Define fixed-point coefficients for the polynomial approximation of arcsin\n    # Coefficients are based on a 5th-degree polynomial approximation\n    # Convert floating-point coefficients to fixed-point representation\n    a0 = Fix(0)\n    a1 = Fix(65536)         # 1.0\n    a2 = Fix(0)\n    a3 = Fix(12799)         # Approximately 0.1951846054 * 2^16\n    a4 = Fix(0)\n    a5 = Fix(5145)          # Approximately 0.0785398163 * 2^16\n\n    # Compute the polynomial using Horner's method\n    innermost = a5 * x\n    innermost = (a4 + innermost) >> 16  # Shift to maintain 16 fractional bits\n    innermost = innermost * x\n    innermost = (a3 + innermost) >> 16\n    innermost = innermost * x\n    innermost = (a2 + innermost) >> 16\n    innermost = innermost * x\n    innermost = (a1 + innermost) >> 16\n    arcsin_approx = a0 + (innermost * x) >> 16\n\n    # Square the result\n    squared = (arcsin_approx * arcsin_approx) >> 16\n\n    return squared\n", "model_name": "qwen-qwq"}
{"test_name": "cylinder_surface", "response_0": "def cylinder_surface():\n    # Read secret-shared inputs\n    r = sread_float(\"r\")\n    h = sread_float(\"h\")\n\n    # Define constant pi\n    pi = 3.141592653589793\n\n    # Compute r squared\n    r_squared = smul(r, r)\n\n    # Compute 2*pi*r_squared\n    two_pi = 2 * pi\n    term1 = smul(two_pi, r_squared)\n\n    # Compute 2*pi*r*h\n    term_Rh = smul(two_pi, r)\n    term2 = smul(term_Rh, h)\n\n    # Compute total surface area\n    surface_area = sadd(term1, term2)\n\n    # Reveal the result\n    result = sreveal(surface_area)\n    return result\n", "response_1": "from some_module import PI  # Assuming PI is defined in some module\n\ndef cylinder_surface(r, h):\n    two = fix(2.0)\n    two_pi = two * PI\n    term1 = two_pi * r * r\n    term2 = two_pi * r * h\n    return term1 + term2\n", "model_name": "qwen-qwq"}
{"test_name": "radian_to_degree", "response_0": "from mpspdz import Double, PI\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    factor = Double(180) / PI\n    degrees = r * factor\n    return degrees\n", "response_1": "# Define the constant for degrees per radian in fixed-point representation\nDEGREES_PER_RADIAN = Fix16(3764593)  # Approximately 57.2957795131 with 16 fractional bits\n\ndef radian_to_degree(r: Fix16) -> Fix16:\n    # Multiply by degrees per radian and shift right to simulate division by 2^16\n    degrees = (r * DEGREES_PER_RADIAN) >> 16\n    return degrees\n", "model_name": "qwen-qwq"}
{"test_name": "square_root", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "cosine_theorem", "response_0": "from mpspdz import sqrt, cos\n\ndef cosine_theorem(a, b, rad):\n    a_squared = a * a\n    b_squared = b * b\n    cos_rad = cos(rad)\n    product = 2 * a * b * cos_rad\n    sum_squared = a_squared + b_squared - product\n    c = sqrt(sum_squared)\n    return c\n", "response_1": "from mpyc.runtime import mpc\nimport mpyc.fp\n\nasync def cos_approx(x):\n    x2 = await mpc.sqr(x)\n    x4 = await mpc.sqr(x2)\n    cos_val = 1 - x2/mpyc.fp.mpfi(2) + x4/mpyc.fp.mpfi(24)\n    return cos_val\n\nasync def sqrt_approx(y, iterations=5):\n    g = y / mpyc.fp.mpfi(2)\n    for _ in range(iterations):\n        g = (g + y / g) / mpyc.fp.mpfi(2)\n    return g\n\nasync def cosine_theorem(a, b, rad):\n    a2 = await mpc.sqr(a)\n    b2 = await mpc.sqr(b)\n    cos_rad = await cos_approx(rad)\n    term = 2 * a * b * cos_rad\n    inside_sqrt = a2 + b2 - term\n    c = await sqrt_approx(inside_sqrt)\n    c_public = await mpc.output(c)\n    return c_public\n", "model_name": "qwen-qwq"}
{"test_name": "lights_states", "response_0": "", "response_1": "from mp_spdz import *\n\ndef main():\n    num = read_input(\"num\")\n    result = 1\n    for _ in range(num):\n        result *= 2\n    print(\"Total states:\", result)\n\nif __name__ == \"__main__\":\n    main()\n", "model_name": "qwen-qwq"}
{"test_name": "degree_to_radian", "response_0": "", "response_1": "def degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    from MPmath import pi, mul, div\n    rad = mul(d, pi)\n    rad = div(rad, 180)\n    return rad\n", "model_name": "qwen-qwq"}
{"test_name": "Fah_to_Cel", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "elliptic_area", "response_0": "# Assuming MP-SPDZ has a built-in constant for pi, or it needs to be defined.\n\n# Define the constant pi in fixed-point representation\nPI = FixPoint(3.1415926535)  # Adjust the precision as per MP-SPDZ's fixed-point format\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    # Compute the area using secret-shared multiplication\n    area = PI * a * b\n    return area\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "floor", "response_0": "def floor(z, fractional_bits):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    z is a secret shared integer in fixed-point representation with fractional_bits fractional bits.\n    \"\"\"\n    return z >> fractional_bits\n", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "log_and_cube", "response_0": "from mspdz import *\n\nclass Config:\n    sint_type = 'sfix'\n    sfix_precision = 32  # Set the precision as needed\n\ndef log_and_cube(honest_val):\n    x = sfix(honest_val)\n    ln_x = x.ln()\n    ln_2 = sfix(0.6931471805599453)  # Precomputed ln(2)\n    log2_x = ln_x / ln_2\n    result = log2_x * log2_x * log2_x\n    return result.reveal()\n", "response_1": "from spdz import *\nfrom SecureMath import *\n\ndef log_and_cube(x: SecureFixedPoint) -> SecureFixedPoint:\n    log_x = SecureMath.log2(x)\n    result = SecureMath.pow(log_x, 3)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "floor_and_square", "response_0": "from mspdz import Runtime, SecureFixedPoint, secureint\n\ndef floor_and_square(z):\n    trunc_z = z.trunc()\n    frac_z = z - trunc_z\n    is_nonzero = frac_z != 0\n    is_negative = z < 0\n    needs_adjustment = is_nonzero & is_negative\n    floor_z = trunc_z - needs_adjustment.if_else(1, 0)\n    return floor_z ** 2\n", "response_1": "function floor_and_square(z: In[Fix[16]]): Out[Int]:\n\n    floored_z = Floor(z)\n\n    squared_z = floored_z * floored_z\n\n    return squared_z\n\n", "model_name": "qwen-qwq"}
{"test_name": "meters_to_feet", "response_0": "", "response_1": "from programmpc import *\n\n@mpc.run\ndef meters_to_feet(m: sfix):\n    conversion_factor = sfix(3.2808)\n    feet = m * conversion_factor\n    return feet\n", "model_name": "qwen-qwq"}
{"test_name": "sphere_area", "response_0": "def sphere_area(r):\n    from math import pi\n    from constants import FIXPREC\n    four = Constant(4 * (1 << FIXPREC))\n    pi_const = Constant(int(pi * (1 << FIXPREC)))\n    r_squared = r * r\n    area = (four * pi_const * r_squared) >> (2 * FIXPREC)\n    return area\n", "response_1": "from mpc import PI, Constant, TypeFix, square\n\ndef sphere_area(r: TypeFix(16,16)) -> TypeFix(16,16):\n    four = Constant(4, type=TypeFix(16,16))\n    pi = Constant(PI, type=TypeFix(16,16))\n    return four * pi * square(r)\n", "model_name": "qwen-qwq"}
{"test_name": "coarse_abs", "response_0": "def coarse_abs(x):\n    # Assuming MP-SPDZ provides SecureAbs and SecureFloor functions\n    abs_x = SecureAbs(x)\n    result = SecureFloor(abs_x)\n    return result\n", "response_1": "def coarse_abs(x):\n    return int(x.abs())\n", "model_name": "qwen-qwq"}
{"test_name": "how_many_chickens", "response_0": "def how_many_chickens(heads, legs):\n    two = to_secfxp(2)\n    heads_times_two = heads * two\n    diff = sub(legs, heads_times_two)\n    rabbits = right_shift(diff, 1)\n    chickens = sub(heads, rabbits)\n    return chickens\n", "response_1": "# Import necessary modules\nfrom mp_spdz import *\n\n# Define the main function\ndef main():\n    # Read inputs from party 0\n    heads = get_input(0, 'Int64')\n    legs = get_input(0, 'Int64')\n    \n    # Compute legs - heads * 2\n    temp = legs - (heads * 2)\n    \n    # Integer division by 2\n    rabbits = temp // 2\n    \n    # Calculate number of chickens\n    chickens = heads - rabbits\n    \n    # Reconstruct and print the result\n    result = reconstruct(chickens)\n    print(\"Number of chickens:\", result)\n\nif __name__ == \"__main__\":\n    main()\n", "model_name": "qwen-qwq"}
{"test_name": "interest_calculator", "response_0": "def interest_calculator(capital, ratio, months):\n    from mp_spdz import FixedPoint, secure_mul, secure_sub, secure_pow\n\n    # Assuming FixedPoint is a class that handles fixed-point arithmetic\n    # with a scale factor of 2^16\n    scale = 2**16\n\n    # Convert inputs to fixed-point\n    capital_fixed = FixedPoint(int(capital * scale))\n    ratio_fixed = FixedPoint(int(ratio * scale))\n\n    # Compute (1 + ratio)^months - 1\n    one = FixedPoint(scale)  # Fixed-point representation of 1\n    base = secure_add(one, ratio_fixed)\n    power_result = secure_pow(base, months)\n    subtract_one = secure_sub(power_result, one)\n\n    # Multiply by capital\n    interest_fixed = secure_mul(subtract_one, capital_fixed)\n\n    # Convert back to floating-point\n    interest = interest_fixed.value / scale\n\n    return interest\n", "response_1": "# Define fixed-point type with 16 fractional bits\nFixedPoint = Type.create('fixed_point', 16)\n\n# Read inputs\ncapital = FixedPoint(Input(PLAYER_0))\nratio = FixedPoint(Input(PLAYER_0))\nmonths = Int(Input(PLAYER_0))\n\n# Define the constant 1 as a fixed-point number\none = FixedPoint(1)\n\n# Compute base = 1 + ratio\nbase = one + ratio\n\n# Compute result = base ** months\nresult = pow(base, months)\n\n# Compute interest = (result - 1) * capital\ninterest = (result - one) * capital\n\n# Output the interest\nOutput(interest, PLAYER_0)\n", "model_name": "qwen-qwq"}
{"test_name": "circle_area", "response_0": "# Define the value of pi with 30 fractional bits\nPI = 3.1415926535 * (1 << 30)\n\ndef circle_area(r):\n    \"\"\"\n    Compute the area of a circle with given radius r, where r is a secret shared value with 30 fractional bits.\n    \"\"\"\n    # Square the radius\n    r_squared = r * r\n    # r_squared now has 60 fractional bits (30 from each r)\n    # Multiply by pi, which has 30 fractional bits\n    # The multiplication will have 90 fractional bits (30 from pi + 60 from r_squared)\n    area = r_squared * PI\n    # Adjust the scaling to get the area with 30 fractional bits\n    # Shift right by 60 bits (90 - 30 = 60)\n    area = area >> 60\n    return area\n", "response_1": "from mpspdz import *\n\ndef circle_area(r):\n    # Define type with 16 integer bits and 16 fractional bits\n    type = Type(16, 16)\n    \n    # Define \u03c0 as a constant with the appropriate scaling\n    pi = Constant(int(3.141592653589793 * (1 << 16)), type)\n    \n    # Square the radius\n    r_squared = Mul(r, r)\n    \n    # Multiply by \u03c0\n    area = Mul(pi, r_squared)\n    \n    return area\n", "model_name": "qwen-qwq"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler.types import sfix\n\ndef cube_and_square_root(x: sfix):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    return x ** 1.5\n", "response_1": "def cube_and_square_root(x):\n    \"\"\"\n    Take cube of the input, then compute the square root of the outcome.\n    Assumes that x is non-negative.\n    \"\"\"\n    cube = Pow(x, 3)\n    result = Sqrt(cube)\n    return result\n\n", "model_name": "qwen-qwq"}
{"test_name": "round", "response_0": "function round(x: FixedPoint) -> Integer:\n    x_int = floor(x)\n    fractional_part = x - x_int\n    if fractional_part < 0.5:\n        return x_int\n    else:\n        return x_int + 1\n", "response_1": "def round(x):\n\n    return SInt(x)\n\n", "model_name": "qwen-qwq"}
{"test_name": "cryptic_adjustment", "response_0": "10 * sqrt(10 * sqrt(100)) = 10 * sqrt(10 * 10) = 10 * sqrt(100) = 10 * 10 = 100\n", "response_1": "from mp_spdz import Math, SecretSharing, secure_computation\n\n@secure_computation\ndef cryptic_adjustment(origin):\n    origin_shared = SecretSharing.convert_to_shared(origin)\n    inner_sqrt = Math.sqrt(origin_shared)\n    mul_inner = Math.mul(10, inner_sqrt)\n    outer_sqrt = Math.sqrt(mul_inner)\n    result = Math.mul(10, outer_sqrt)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "specific_pow", "response_0": "", "response_1": "macro specific_pow(x):\n    x2 = MulP(x, x)\n    sqrt_x = SqrtP(x)\n    result = MulP(x2, sqrt_x)\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "soft_plus", "response_0": "", "response_1": "def soft_plus(x):\n    return x + sfloat.log(1 + sfloat.exp(-x))\n", "model_name": "qwen-qwq"}
{"test_name": "ball_volume", "response_0": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    from Program import Constant, Truncate, Mult, Div, Pi\n\n    # Assuming r is a secret shared value\n    pi = Pi()\n    r_cubed = Mult(r, Mult(r, r))  # r^3\n    four_thirds = Div(Constant(4), Constant(3))\n    volume = Mult(pi, Mult(r_cubed, four_thirds))\n    return Truncate(volume)\n", "response_1": "# Import necessary libraries\nfrom lib.NumLib import *\nfrom lib.Protocols import *\n\n# Define the protocol\ndef ball_volume():\n    # Read the secret-shared radius from input\n    r = readSharedInput(\"radius\")\n\n    # Compute r**3\n    r_squared = r * r\n    r_cubed = r_squared * r\n\n    # Define \u03c0 as a public constant\n    pi = 3.141592653589793\n\n    # Compute (4/3) * \u03c0\n    coefficient = (4.0 / 3.0) * pi\n\n    # Compute the volume\n    volume = coefficient * r_cubed\n\n    # Output the secret-shared volume\n    writeSharedOutput(\"volume\", volume)\n\n# Execute the protocol\nball_volume()\n", "model_name": "qwen-qwq"}
{"test_name": "Heron", "response_0": "def Heron(a, b, c):\n    p = (a + b + c) / 2\n    area = sqrt(p * (p - a) * (p - b) * (p - c))\n    return area\n", "response_1": "def Heron(a, b, c):\n    p = (a + b + c) / 2\n    area = sqrt(p * (p - a) * (p - b) * (p - c))\n    return area\n", "model_name": "qwen-qwq"}
{"test_name": "next_perfect_square", "response_0": "def next_perfect_square(x):\n\nlow = Constant(1)\n\nhigh = x\n\nfor _ in range(16):\n\nmid = TruncDiv(low + high, 2)\n\nmid_squared = mid * mid\n\ncondition = GreaterThan(mid_squared, x)\n\nhigh = IfElse(condition, mid, high)\n\nlow = IfElse(condition, low, mid + 1)\n\nreturn low * low\n\n", "response_1": "function next_perfect_square(x: Int):\n    low: Int = 1\n    high: Int = x\n    while low < high:\n        mid: Int = (low + high) / 2\n        mid2: Int = mid * mid\n        if mid2 > x:\n            high = mid\n        else:\n            low = mid + 1\n    return low * low\n", "model_name": "qwen-qwq"}
{"test_name": "pi_to_the_x", "response_0": "from mpspdz import math\n\ndef pi_to_the_x(x):\n    log_pi = math.log(math.pi)\n    return math.exp(x * log_pi)\n", "response_1": "from mp_spdz import *\n\n# Precompute ln(pi)\nln_pi = math.log(math.pi)\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x using the identity pi^x = e^(x * ln(pi)).\n    \"\"\"\n    import math\n    return math.exp(x * ln_pi)\n", "model_name": "qwen-qwq"}
{"test_name": "spring_rocket", "response_0": "", "response_1": "def spring_rocket(height, m, k):\n    # Assuming height, m, and k are secure numbers\n    g = 9.8  # Need to convert this to a secure number if necessary\n    numerator = 2 * m * g * height\n    denominator = k\n    ratio = numerator / denominator\n    compression = sqrt(ratio)\n    return compression\n", "model_name": "qwen-qwq"}
{"test_name": "cone_volume", "response_0": "", "response_1": "from constants import PI\nfrom types import FP\n\ndef cone_volume(r: FP, h: FP):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    return PI * r * r * h / 3\n", "model_name": "qwen-qwq"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits():\n    # Define input types for heads and legs\n    heads = get SemiPrivate Int 0\n    legs = get SemiPrivate Int 0\n\n    # Compute the number of rabbits using the formula (legs - heads * 2) // 2\n    rabbit_legs_excess = sub(legs, mul(heads, 2))\n    rabbits = div(rabbit_legs_excess, 2)\n\n    # Output the result\n    reveal SemiPrivate rabbits\n", "response_1": "", "model_name": "qwen-qwq"}
