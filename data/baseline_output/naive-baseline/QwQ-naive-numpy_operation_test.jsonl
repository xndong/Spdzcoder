{"test_name": "array_from_intrinsic_linspace", "response_0": "from mp_spdz import Array\n\nstart = 0\nend = 99\nnum = 10\n\nstep = (end - start) / (num - 1)\na = Array.public([start + step * i for i in range(num)])\n", "response_1": "from mp_spdz import *\n\nstart = SecInt(0)\nend = SecInt(99)\nnum = 10\nstep = (end - start).div(SecInt(num - 1))\na = Array.create(num, start)\nfor i in range(num):\n    a[i] = start + SecInt(i) * step\n", "model_name": "qwen-qwq"}
{"test_name": "more_positive", "response_0": "from mp_spdz import Array, Int, run\n\ndef more_positive(arr):\n    size = len(arr)\n    signs = Array(Int, size)\n    for i in range(size):\n        signs[i] = if_else(arr[i] > 0, 1, if_else(arr[i] < 0, -1, 0))\n    count = sum(signs)\n    return count > 0\n\n# Example usage:\n# Assuming 'arr' is a secret shared array\n# result = run(more_positive, arr)\n", "response_1": "from mpyc.runtime import mpc\nfrom mpyc.sectypes import SecureInteger, SecureBoolean\nfrom mpyc.array import Array\n\nclass MorePositiveProgram:\n    def main(self, arr):\n        secint = SecureInteger(32)  # assuming 32-bit integers\n        secbool = SecureBoolean()\n        \n        if len(arr) == 0:\n            return secbool(False)\n        \n        arr_sec = Array.create(len(arr), secint, arr)\n        \n        signs = Array.create(len(arr), secint)\n        for i in range(len(arr)):\n            elem = arr_sec[i]\n            is_positive = mpc.greater(elem, secint(0))\n            is_negative = mpc.less(elem, secint(0))\n            sign = mpc.if_else(is_positive, secint(1),\n                               mpc.if_else(is_negative, secint(-1), secint(0)))\n            signs[i] = sign\n        \n        sum_signs = signs.sum()\n        result = mpc.greater(sum_signs, secint(0))\n        return result\n", "model_name": "qwen-qwq"}
{"test_name": "select", "response_0": "def select(ind, a, b):\n    return ind * a + (1 - ind) * b\n", "response_1": "def select(ind, a, b):\n    return a * ind + b * (1 - ind)\n", "model_name": "qwen-qwq"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    from mpyc.runtime import mpc\n    zero = mpc.sfix(0)\n    return mpc.smax(zero, y)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function securely.\n    \n    Parameters:\n    y (array of Number): The input array containing shared secret numbers.\n    \n    Returns:\n    array of Number: The ReLU of the input array.\n    \"\"\"\n    # Import necessary MP-SPDZ modules\n    from spdz import Player, get_party_cookie, Number\n    from spdz.secure_comparison import secure_gt\n\n    # Compute mask where y >= 0\n    mask = secure_gt(y, 0)\n\n    # Set negative values to zero\n    relu_y = y * mask\n\n    return relu_y\n", "model_name": "qwen-qwq"}
{"test_name": "cost_matrix", "response_0": "", "response_1": "def cost_matrix(profit_matrix):\n    # Determine the shape of the profit matrix\n    n_rows = len(profit_matrix)\n    n_cols = len(profit_matrix[0])\n    \n    # Find the maximum value in the profit matrix\n    max_val = profit_matrix[0][0]\n    for i in range(n_rows):\n        for j in range(n_cols):\n            if profit_matrix[i][j] > max_val:\n                max_val = profit_matrix[i][j]\n    \n    # Create an offset matrix where each element is the maximum value\n    offset_matrix = [[max_val for _ in range(n_cols)] for _ in range(n_rows)]\n    \n    # Subtract the profit matrix from the offset matrix to get the cost matrix\n    cost_matrix = [[offset_matrix[i][j] - profit_matrix[i][j] for j in range(n_cols)] for i in range(n_rows)]\n    \n    return cost_matrix\n", "model_name": "qwen-qwq"}
{"test_name": "np_zeros", "response_0": "from mpc import mpc, Float\n\nn = 10\na = mpc.zeros(Float, n)\n", "response_1": "from mpc import mpc, SecureFixedPoint as SFixed\n\nn = 10\na = mpc.zeros(n, SFixed)\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    if not isinstance(ndarray, SecureArray):\n        raise TypeError(\"ndarray must be a SecureArray\")\n    if ndarray.ndim != 2:\n        raise ValueError(\"ndarray must be 2-D\")\n    if row_index < 0 or row_index >= ndarray.shape[0]:\n        raise IndexError(\"Row index out of bounds\")\n    array = ndarray[row_index, :]\n    return array\n", "response_1": "from mp_spdz import Array, Int\n\ndef array_dimensional_indexing(ndarray: Array, row_index: Int) -> Array:\n    array = ndarray[row_index, :]\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    from mpyc.runtime import mpc\n    return mpc.zeros(n, mpc.sfix)\n", "response_1": "from mp_spdz import zeros\n\ndef create_zeros(shape):\n    return zeros(shape)\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_slicing_stride", "response_0": "def array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays.\n    Specifically, collect all even index elements from the first array\n    and all odd index elements from the second array.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are MP-SPDZ Array objects\n\n    # Extract even-indexed elements from ndarrayA\n    viewA = ndarrayA[::2]\n    \n    # Extract odd-indexed elements from ndarrayB\n    # Start from index 1 and take every second element\n    viewB = ndarrayB[1::2]\n    \n    # Concatenate viewA and viewB\n    array = concat(viewA, viewB)\n    \n    # MP-SPDZ arrays are handled differently; copying might not be necessary\n    return array\n", "response_1": "def array_concate(ndarrayA, ndarrayB):\n    lenA = len(ndarrayA)\n    lenB = len(ndarrayB)\n    lenViewA = (lenA + 1) // 2\n    lenViewB = lenB // 2\n    result = make_array(lenViewA + lenViewB)\n    idx = 0\n    for i in range(0, lenA, 2):\n        result[idx] = ndarrayA[i]\n        idx += 1\n    for i in range(1, lenB, 2):\n        result[idx] = ndarrayB[i]\n        idx += 1\n    return result\n", "model_name": "qwen-qwq"}
{"test_name": "QR_decomposition", "response_0": "", "response_1": "", "model_name": "qwen-qwq"}
{"test_name": "find_nearest_index", "response_0": "proc find_nearest_index(array: array[fix], value: fix) return (int):\n    // Compute absolute differences\n    diffs: array[fix] = new array[fix](len(array))\n    for i in 0 to len(array)-1:\n        diffs[i] = abs(array[i] - value)\n\n    // Find the index of the minimum difference\n    min_diff = diffs[0]\n    min_index = 0\n    for i in 1 to len(diffs)-1:\n        if diffs[i] < min_diff:\n            min_diff = diffs[i]\n            min_index = i\n\n    return min_index\nendproc\n", "response_1": "def find_nearest_index(array, value):\n    from mpyc.runtime import mpc\n    from mpyc.sectypes import sfloat\n\n    secure_array = [sfloat(a) for a in array]\n    secure_value = sfloat(value)\n    differences = [a - secure_value for a in secure_array]\n    abs_differences = [mpc.sabs(d) for d in differences]\n    min_index = mpc.smin_pos(abs_differences)\n    return min_index\n", "model_name": "qwen-qwq"}
{"test_name": "np_concat_simple_row", "response_0": "", "response_1": "from mpspdz import Array, sfix\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    assert ndarrayA.shape[1] == ndarrayB.shape[1], \"Arrays must have the same number of columns\"\n    concatenated_array = Array.vstack((ndarrayA, ndarrayB))\n    return concatenated_array\n", "model_name": "qwen-qwq"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    array = ndarray.copy()\n    return array\n", "response_1": "from mp_spdz import make_array\n\ndef array_copy(ndarray):\n    \"\"\"\n    Copies a NumPy array into an MP-SPDZ array.\n\n    Args:\n    ndarray: A NumPy array to be copied.\n\n    Returns:\n    An MP-SPDZ array that is a copy of the input NumPy array.\n    \"\"\"\n    # Convert NumPy array to list\n    list_data = ndarray.tolist()\n    # Create an MP-SPDZ array from the list\n    array = make_array(list_data)\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "max_pooling", "response_0": "def max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    \"\"\"\n    # Calculate output dimensions\n    out_height = x.shape[1] / stride\n    out_width = x.shape[2] / stride\n    out = zeros([x.shape[0], out_height, out_width])\n\n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                # Extract the window\n                window = x[b, i:i+stride, j:j+stride]\n                # Compute the maximum value in the window\n                window_max = np.max(window)\n                # Assign the max value to the output array\n                out[b, i / stride, j / stride] = window_max\n\n    return out\n", "response_1": "# Assuming x is a secret-shared array and stride is a public integer\n\n# Function to perform max pooling\ndef max_pooling(x, stride):\n    # Calculate output dimensions\n    batch_size = x.shape[0]\n    height = x.shape[1] / stride\n    width = x.shape[2] / stride\n\n    # Initialize output array\n    out = make_array(batch_size, height, width)\n\n    # Iterate over batches\n    for b in range(batch_size):\n        # Iterate over height with stride\n        for i in range(0, x.shape[1], stride):\n            # Iterate over width with stride\n            for j in range(0, x.shape[2], stride):\n                # Compute max in the pool\n                pool = x[b, i:i+stride, j:j+stride]\n                max_val = pool[0,0]  # Initialize with first element\n                for p in range(stride):\n                    for q in range(stride):\n                        if pool[p,q] > max_val:\n                            max_val = pool[p,q]\n                # Assign max value to output\n                out[b, i/stride, j/stride] = max_val\n\n    return out\n", "model_name": "qwen-qwq"}
{"test_name": "array_reshape", "response_0": "", "response_1": "# Define the size of the array\nsize = 15\n\n# Create a secret-shared array with values from 0 to 14\na = Array.create(size)\n\nfor i in range(size):\n    a[i] = i\n\n# Reshape the array into 3x5\na = a.reshape(3, 5)\n", "model_name": "qwen-qwq"}
{"test_name": "np_concat_simple_column", "response_0": "from mpyc.runtime import mpc\nfrom mpyc.sectypes import SecureFixedPoint\n\nasync def array_simple_concate_column(ndarrayA, ndarrayB):\n    # Assuming ndarrayA and ndarrayB are securely shared arrays\n    # Check if the number of rows matches\n    if ndarrayA.shape[0] != ndarrayB.shape[0]:\n        raise ValueError(\"Number of rows in ndarrayA and ndarrayB must match for axis=1 concatenation.\")\n    \n    # Get the number of rows and columns\n    num_rows = ndarrayA.shape[0]\n    cols_A = ndarrayA.shape[1]\n    cols_B = ndarrayB.shape[1]\n    \n    # Create a new array to hold the concatenated result\n    result = mpc.Array(SecureFixedPoint(), (num_rows, cols_A + cols_B))\n    \n    # Assign values from ndarrayA and ndarrayB to the result array\n    for i in range(num_rows):\n        for j in range(cols_A):\n            result[i, j] = ndarrayA[i, j]\n        for j in range(cols_B):\n            result[i, j + cols_A] = ndarrayB[i, j]\n    \n    return result\n", "response_1": "%macro\nm = 3\nn = 4\np = 2\n%emacro\n\nIn arrayA[m][n]\nIn arrayB[m][p]\n\nOut array[m][n+p]\n\ndef array_simple_concate_column():\n    array = hstack(arrayA, arrayB)\n    return array\n\nstart_mpc()\narray = array_simple_concate_column()\nsend(All, array)\nend_mpc()\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "def array_dimensional_indexing(ndarray, column_index):\n    array = col(ndarray, column_index)\n    return array\n", "response_1": "# Assuming MP-SPDZ has a way to define functions\ndef array_dimensional_indexing(ndarray, column_index):\n    # Assuming ndarray is a 2-D array\n    # Need to extract the column at column_index\n    # Assuming ndarray is a list of lists\n    column = []\n    for row in ndarray:\n        column.append(row[column_index])\n    return column\n", "model_name": "qwen-qwq"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    # Determine the size of the array (assuming it's a square matrix)\n    n = array.length\n    \n    # Create a new array to store the diagonal elements\n    diag_elements = Array(n)\n    \n    # Extract diagonal elements\n    for i in range(n):\n        diag_elements[i] = array[i][i]\n    \n    return diag_elements\n", "response_1": "def diag(array):\n    return array.diagonal()\n", "model_name": "qwen-qwq"}
{"test_name": "np_concat_special", "response_0": "def array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    Specifically, collect all even columns from the first array and all odd columns from the second array.\n    \"\"\"\n    # Select even columns from ndarrayA (columns 0, 2, 4, ...)\n    even_cols_A = select_columns(ndarrayA, range(0, ndarrayA.shape[1], 2))\n    \n    # Select odd columns from ndarrayB (columns 1, 3, 5, ...)\n    odd_cols_B = select_columns(ndarrayB, range(1, ndarrayB.shape[1], 2))\n    \n    # Concatenate along axis 1\n    result = hstack([even_cols_A, odd_cols_B])\n    \n    return result\n", "response_1": "from mpyc.runtime import mpc\n\n@mpc.coroutine\nasync def array_special_concate(A, B):\n    # Select even columns from A\n    viewA = A[:, ::2]\n    # Select odd columns from B\n    viewB = B[:, 1::2]\n    # Concatenate viewA and viewB along axis 1\n    array = await mpc.concatenate([viewA, viewB], axis=1)\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "np_arange", "response_0": "from program import Party, get_party, Main, Array\n\nfrom protocols import *\n\nfrom runtime import Runtime, start_runtime, in_thread\n\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-d numpy array by calling intrinsic numpy function numpy.arange\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    def arange_length(start, stop, step):\n        # Compute the length of the sequence\n        # length = ceil((stop - start) / step)\n        # Using integer arithmetic: length = ((stop - start - 1) / step) + 1\n        from mp_spdz import floor\n        return floor((stop - start - 1) / step) + 1\n\n    def arange_element(start, stop, step, i):\n        length = arange_length(start, stop, step)\n        if i >= length:\n            raise IndexError(\"Index out of range\")\n        return start + step * i\n\n    # Return a function that can generate elements on the fly\n    return lambda i: arange_element(start, stop, step, i), arange_length(start, stop, step)\n", "model_name": "qwen-qwq"}
{"test_name": "np_eye_2", "response_0": "m = 3\nn = 5\na = Array(m, n, Int)\n\nfor i in range(m):\n    for j in range(n):\n        a[i][j] = 0\nfor i in range(min(m, n)):\n    a[i][i] = 1\n", "response_1": "m = 3\n\nn = 5\n\na = MakeArray([MakeArray([1 if i == j else 0 for j in range(n)]) for i in range(m)])\n", "model_name": "qwen-qwq"}
{"test_name": "third_smallest", "response_0": "", "response_1": "def third_smallest(arr):\n    n = len(arr)\n    if n < 3:\n        return \"Array must contain at least three elements.\"\n    sorted_arr = sorted(arr)\n    return sorted_arr[2]\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "def array_dimensional_indexing(array, row_index, num_columns):\n    \"\"\"\n    MP-SPDZ function to index the i-th row from a 2-D array represented as a flat list of shares.\n    \n    Parameters:\n    - array: The flat list of shares representing the 2-D array.\n    - row_index: The index of the row to be accessed.\n    - num_columns: The number of columns in the 2-D array.\n    \n    Returns:\n    - A list of shares corresponding to the i-th row.\n    \"\"\"\n    start = row_index * num_columns\n    end = start + num_columns\n    return array[start:end]\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ function to index the i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index, :]\n    return array\n", "model_name": "qwen-qwq"}
{"test_name": "array_from_intrinsic_arange", "response_0": "", "response_1": "n = 10\na = Array.create_clear(n)\nfor i in 0..n-1:\n    a[i] = i\n", "model_name": "qwen-qwq"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    array = ndarray[row_index, :]\n    return array\n", "response_1": "from spdz import *\nfrom program import *\n\ndef array_dimensional_indexing(array, row_index):\n    return array[row_index]\n", "model_name": "qwen-qwq"}
{"test_name": "array_from_python_structure", "response_0": "from mp_spdz import Party, sfix, Array, convert\n\n# Assuming party initialization and setup\n\n# Define the list of integers\na_l = [0, 10, 20, 30, 40]\n\n# Convert the list of integers to a list of sfix elements\na_sfix = convert(sfix, a_l)\n\n# Create an array of sfix elements with length 5\na = Array(5, sfix)\n\n# Assign each element of the array from the list of sfix elements\nfor i in range(5):\n    a[i] = a_sfix[i]\n", "response_1": "from mpyc.runtime import mpc\n\n# Define the list of integers\na_l = [0, 10, 20, 30, 40]\n\n# Convert the list to an array of secure integers\na = mpc.Array(mpc.SecInt(), a_l)\n\n# Securely input the array from party 0\na_shared = mpc.input(a, sender=0)\n", "model_name": "qwen-qwq"}
{"test_name": "np_reshape", "response_0": "def array_reshape(ndarray, m, n):\n    # Flatten the input array\n    flat_list = []\n    for row in ndarray:\n        for elem in row:\n            flat_list.append(elem)\n\n    # Check if the total number of elements matches the new shape\n    if len(flat_list) != m * n:\n        raise ValueError(\"Total number of elements cannot be reshaped to (m, n)\")\n\n    # Reshape the flat list into the new shape\n    new_array = []\n    start = 0\n    for i in range(m):\n        row = flat_list[start:start+n]\n        new_array.append(row)\n        start += n\n\n    return new_array\n", "response_1": "from mpyc import mpc\n\nasync def array_reshape(ndarray, m, n):\n    return await mpc.reshape(ndarray, (m, n))\n\n# Example usage within an MP-SPDZ computation\nasync def compute():\n    # Assume input_array is a secret-shared array\n    input_array = ...\n    m = ...  # desired number of rows\n    n = ...  # desired number of columns\n    reshaped_array = await array_reshape(input_array, m, n)\n    # Further computations can be performed here\n    return reshaped_array\n\n# Run the computation\nresult = mpc.run(mpc.gather(compute()))\n", "model_name": "qwen-qwq"}
{"test_name": "np_ones", "response_0": "from mpc import Array\n\nn = 10\na = Array.create(1, n, 1)\n", "response_1": "n = 10\n\na = Array.create(n, 1.0, type_info=Float64)\n\n", "model_name": "qwen-qwq"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    mask = y.eq(1)\n    y = y - mask\n    return y\n", "response_1": "def set_one_to_zero(y):\n    n = y.size\n    for i in range(n):\n        if y[i] == 1:\n            y[i] = 0\n    return y\n", "model_name": "qwen-qwq"}
{"test_name": "np_eye", "response_0": "", "response_1": "from mp_spdz import Array, Player, Context\n\nn = 10\n\n# Initialize context and players\nctx = Context()\nplayers = [Player(0), Player(1), Player(2)]\n\n# Create a secret shared array\na = Array(ctx, players, (n, n))\n\n# Set values in the array\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i,j] = 1\n        else:\n            a[i,j] = 0\n", "model_name": "qwen-qwq"}
{"test_name": "np_diag", "response_0": "# Define the list a_l\na_l = Array(6, Int(32))\nSet(a_l, 0, 1)\nSet(a_l, 1, 3)\nSet(a_l, 2, 5)\nSet(a_l, 3, 2)\nSet(a_l, 4, 4)\nSet(a_l, 5, 6)\n\n# Create a 6x6 zero matrix\na = Array(6, 6, Int(32), [0]*(6*6))\n\n# Set the diagonal elements\nfor i in range(6):\n    a[i][i] = a_l[i]\n", "response_1": "from mpspdz import *\n\ndef create_diagonal_matrix():\n    a_l = PublicArray([1,3,5,2,4,6])\n    n = len(a_l)\n    a = zero_matrix(n, n)\n    for i in range(n):\n        a[i,i] = a_l[i]\n    print_matrix(a)\n", "model_name": "qwen-qwq"}
{"test_name": "np_advanced_integer_indexing", "response_0": "from mp_spdz import Array\n\ndef integer_array_indexing(array, indices):\n    # Convert indices to MP-SPDZ array\n    indices_array = Array.create_from(indices)\n    \n    # Create an array to hold the results\n    ret_array = Array.create(len(indices_array))\n    \n    # Populate the result array by indexing into the main array\n    for i in range(len(indices_array)):\n        idx = indices_array[i]\n        ret_array[i] = array[idx]\n    \n    return ret_array\n", "response_1": "def integer_array_indexing(array, indices):\n    ret_array = mpc.gather(array, indices)\n    return ret_array\n", "model_name": "qwen-qwq"}
