{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    # Get the length of the array\n    n = len(arr)\n    \n    # Create a new array to store the result\n    result = array(n-1)\n    \n    # Copy elements before the index\n    for i in range(index):\n        result[i] = arr[i]\n    \n    # Copy elements after the index\n    for i in range(index+1, n):\n        result[i-1] = arr[i]\n    \n    # Append the element at the given index to the end\n    result[n-2] = arr[index]\n    \n    return result\n", "response_1": "def move_to_end(arr, index, n):\n    // n is the size of the array\n    var array[n]\n    for i from 0 to n-1 do\n        if i < index then\n            array[i] = arr[i]\n        elif i > index then\n            array[i-1] = arr[i]\n        else\n            // Do nothing, we will place arr[index] at the end later\n        fi\n    endfor\n\n    // Place the element at the end\n    array[n-1] = arr[index]\n\n    // Return the modified array\n    return array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "second_largest", "response_0": "// Function to find the second largest element in the array\ndef second_largest(arr):\n    // Initialize the first two elements as the largest and second largest\n    sint largest, second_largest\n    largest = arr[0]\n    second_largest = arr[1]\n\n    // Ensure largest is indeed the largest of the first two elements\n    if largest < second_largest:\n        sint temp\n        temp = largest\n        largest = second_largest\n        second_largest = temp\n\n    // Iterate over the array starting from the third element\n    for i in range(2, arr.size()):\n        sint current\n        current = arr[i]\n        if current > largest:\n            second_largest = largest\n            largest = current\n        elif current > second_largest:\n            second_largest = current\n\n    return second_largest\n", "response_1": "function second_largest(arr)\n    int n = len(arr)\n    int idx\n    sint max1 = arr[0]\n    sint max2 = arr[1]\n\n    if (max1 < max2)\n        idx = 1\n    else\n        idx = 0\n\n    for i from 2 to n - 1\n        sint current = arr[i]\n        sint is_greater_than_max1 = current > max1\n        sint is_greater_than_max2 = current > max2\n\n        if (is_greater_than_max1 OR is_greater_than_max2)\n            if (max1 < max2)\n                idx = 0\n            else\n                idx = 1\n\n            if (current > max1)\n                max2 = max1\n                max1 = current\n            else\n                max2 = current\n\n    if (max1 < max2)\n        return max1\n    else\n        return max2\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exists_true", "response_0": "", "response_1": "def exists_true(arr):\n    # Initialize a variable to hold the result, starting with 0 (False)\n    ret = sint(0)\n\n    # Iterate over the array\n    for element in arr:\n        # Use the fact that True is represented as 1 and False as 0\n        # Add the element to ret, which will be non-zero if any element is True\n        ret += element\n\n    # Use a comparison to set ret to 1 if any element was True, otherwise 0\n    ret = ret > sint(0)\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_indicator", "response_0": "function array_indicator(*arr, predicator)\n    n = len(arr)\n    ret = array(n)\n    for i from 0 to n-1\n        ret[i] = predicator(arr[i])\n    return ret\nendfunction\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "inner_product", "response_0": "", "response_1": "def inner_product(*vec1, *vec2):\n    # Ensure both vectors have the same length\n    assert len(vec1) == len(vec2)\n\n    summation = 0\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n\n    return summation\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_shift_2", "response_0": "function array<int> array_shift(array<int> a) {\n    int n = a.size();\n    array<int> array(n);\n    for (int i = 0; i < n; i++) {\n        array[i] = a[(i - 1) % n];\n    }\n    return array;\n}\n", "response_1": "program array_shift\ninput int a[3] # Assuming the array length is 3 for this example\n\nint n = 3 # Length of the array\nint array[n]\n\nfor i from 0 to n-1 do\n    array[i] = a[(i-1) % n]\nendfor\n\n# Output the shifted array\nfor i from 0 to n-1 do\n    print_int(array[i])\nendfor\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_greater_than_scalar", "response_0": "program array_greater_than_scalar\n\n// Assuming arr is an array of sint (secure integers) and bound is a sint\narray_greater_than_scalar(sint arr[], sint bound, sint ret[]) {\n    int n = len(arr);\n    for (int i = 0; i < n; i++) {\n        ret[i] = arr[i] > bound;\n    }\n}\n\n// Example of how you might call this function in MP-SPDZ\nint main() {\n    int n = 5; // Example size of the array\n    sint arr[n];\n    sint bound;\n    sint ret[n];\n\n    // Initialize arr and bound with some values\n    // This part is just for demonstration; actual initialization would depend on your use case\n    for (int i = 0; i < n; i++) {\n        arr[i] = i * 10; // Example initialization\n    }\n    bound = 20;\n\n    array_greater_than_scalar(arr, bound, ret);\n\n    // Output the result (for demonstration purposes)\n    for (int i = 0; i < n; i++) {\n        print_int(ret[i]);\n    }\n\n    return 0;\n}\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    # Initialize an array to store the results\n    ret = sint[len(arr)]\n\n    # Iterate over the array elements\n    for i in range(len(arr)):\n        # Perform the comparison and store the result in ret\n        ret[i] = arr[i] > bound\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_rises_2", "response_0": "# Define the function to count rises in the array\ndef count_rises(arr):\n    n = len(arr) - 1\n    flag = sintArray(n)\n    \n    # Loop to fill the flag array\n    for i in range(n):\n        flag[i] = arr[i] < arr[i+1]\n    \n    # Initialize count to zero\n    count = sint(0)\n    \n    # Sum up the flag array to get the count of rises\n    for i in range(n):\n        count += flag[i]\n    \n    return count\n", "response_1": "def count_rises(arr):\n    n = len(arr) - 1\n    flag = sint.Array(n)\n    for i in range(n):\n        flag[i] = sbit(arr[i] < arr[i+1])\n    count = sint(0)\n    for i in range(n):\n        count += flag[i]\n    return count\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "choppy_plus_minus", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "how_many_roots", "response_0": "# MP-SPDZ program to determine the number of roots of a quadratic equation\n\ndef how_many_roots(a, b, c):\n    # Check if 'a' is zero\n    is_a_zero = a == 0\n    # Check if 'b' is zero\n    is_b_zero = b == 0\n    # Calculate the discriminant\n    discriminant = b * b - 4 * a * c\n    \n    # If 'a' is zero, return 0 if 'b' is also zero, otherwise return 1\n    roots = is_a_zero * (is_b_zero * 0 + (1 - is_b_zero) * 1)\n    \n    # If 'a' is not zero, determine the number of roots based on the discriminant\n    roots += (1 - is_a_zero) * (\n        (discriminant > 0) * 2 +\n        (discriminant == 0) * 1 +\n        (discriminant < 0) * 0\n    )\n    \n    return roots\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_satisfied", "response_0": "", "response_1": "# Define the predicate function\ndef predicator(e):\n    # Example predicate: check if e is greater than 0\n    return e > 0\n\n# Function to count satisfied elements\ndef count_satisfied(arr, predicator):\n    n = len(arr)\n    flag = sintArray(n)\n    \n    # Apply the predicate to each element\n    for i in range(n):\n        flag[i] = predicator(arr[i])\n    \n    # Sum the flags\n    summmation = sint(0)\n    for i in range(n):\n        summmation += flag[i]\n    \n    return summmation\n\n# Example usage (assuming arr is defined and contains secret integers)\n# arr = [sint(x) for x in [1, -1, 2, -2, 3]]\n# result = count_satisfied(arr, predicator)\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "traverse_and_sum", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_round", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    # Initialize the return array with zeros\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        # Compute the comparison arr[i] >= brr[i]\n        ret[i] = (arr[i] >= brr[i]).reveal()\n    return ret\n", "response_1": "program array_greater_eq\n\ninput array arr[10] of sint\ninput array brr[10] of sint\noutput array ret[10] of sint\n\nvar i\n\nfor i from 0 to 9 do\n    ret[i] = arr[i] >= brr[i]\nendfor\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "indicate_negative", "response_0": "c\nfunction indicate_negative(arr) {\n    int n = arr.size();\n    sint ret[n];\n    for (int i = 0; i < n; i++) {\n        sint is_negative = arr[i] < 0;\n        ret[i] = is_negative;\n    }\n    return ret;\n}\n", "response_1": "def indicate_negative(arr):\n    n = len(arr)\n    ret = sintArray(n)\n    for i in range(n):\n        ret[i] = sbit(arr[i] < 0)\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_subtract_2", "response_0": "", "response_1": "program array_subtract\n\n// Define the lengths of the arrays\nint n = a.size()\nint m = b.size()\n\n// Determine the pad length\nint pad_length = n - m\nif pad_length < 0:\n    pad_length = m - n\n\n// Initialize the result array with size max(n, m)\nint result_size = n > m ? n : m\nsint result[result_size]\n\n// Perform element-wise subtraction\nint i\nfor i from 0 to min(n, m) - 1:\n    result[i] = a[i] - b[i]\n\n// Handle padding\nif n < m:\n    for i from 0 to pad_length - 1:\n        result[n + i] = -b[m - pad_length + i]\nelse:\n    for i from 0 to pad_length - 1:\n        result[m + i] = a[n - pad_length + i]\n\n// result now contains the element-wise subtraction with padding\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_process", "response_0": "", "response_1": "def array_process(arr, func):\n    processed_arr = []\n    for i in range(len(arr)):\n        processed_arr.append(func(arr[i]))\n    return processed_arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_shift", "response_0": "def array_shift(a[*]):\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1, 0, -1):\n        a[i] = a[i-1]\n    a[0] = temp\n    return a\n", "response_1": "def array_shift(a):\n    n = len(a)\n    # Create a new array to hold the shifted result\n    b = [0] * n\n    # Perform the shift operation\n    for i in range(n):\n        b[i] = a[(i - 1) % n]\n    return b\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    n = len(a)  # Assuming both arrays are of the same length\n    ret_array = sintArray(n)\n    for i in range(n):\n        ret_array[i] = ifelse(a[i] > b[i], a[i], b[i])\n    return ret_array\n", "response_1": "def compare_and_select(a, b, n):\n    # Preallocate the return array with the same length as a and b\n    ret_array = sintArray(n)\n\n    # Loop through each element of the arrays\n    for i in range(n):\n        # Compare elements and store the larger one in ret_array\n        if a[i] > b[i]:\n            ret_array[i] = a[i]\n        else:\n            ret_array[i] = b[i]\n\n    return ret_array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_subtract", "response_0": "# Assuming a and b are input arrays of sfix or sint type\ndef array_subtract(a, b):\n    len_a = len(a)\n    len_b = len(b)\n    \n    # Determine the padding length\n    if len_a < len_b:\n        pad_length = len_b - len_a\n        a = a + [sfix(0) for _ in range(pad_length)]\n    elif len_b < len_a:\n        pad_length = len_a - len_b\n        b = b + [sfix(0) for _ in range(pad_length)]\n    \n    # Perform element-wise subtraction\n    ret = []\n    for i in range(max(len_a, len_b)):\n        ret.append(a[i] - b[i])\n    \n    return ret\n", "response_1": "# Assuming a and b are input arrays of fixed-point numbers\n# and their lengths are provided as n and m respectively\n\nn = input(1)  # Length of array a\nm = input(1)  # Length of array b\n\n# Read arrays a and b\na = [sfix(0)] * n\nb = [sfix(0)] * m\n\nfor i in range(n):\n    a[i] = input(1)\n\nfor i in range(m):\n    b[i] = input(1)\n\n# Determine the maximum length and pad the shorter array\nmax_len = n if n > m else m\n\n# Pad arrays with zeros\na_padded = a + [sfix(0)] * (max_len - n)\nb_padded = b + [sfix(0)] * (max_len - m)\n\n# Perform element-wise subtraction\nret = [sfix(0)] * max_len\nfor i in range(max_len):\n    ret[i] = a_padded[i] - b_padded[i]\n\n# Output the result\nfor i in range(max_len):\n    print_ln(ret[i])\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "repeat_array", "response_0": "# Assuming c is an array of clear integers or another type supported by MP-SPDZ\n# We will use a clear array for demonstration purposes\n\ndef repeat_array(c):\n    # Create a new array with double the length of c\n    result = Array(len(c) * 2, c[0].ctype)\n\n    # Copy the elements of c into the first half of result\n    for i in range(len(c)):\n        result[i] = c[i]\n\n    # Copy the elements of c into the second half of result\n    for i in range(len(c)):\n        result[i + len(c)] = c[i]\n\n    return result\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "zeros", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "clip", "response_0": "function clip(*arr, upper_bound=1, lower_bound=-1)\n    # Initialize an array to store the clipped values\n    clipped_arr = array(len(arr))\n\n    # Iterate over each element in the input array\n    for i from 0 to len(arr) - 1\n        # Use secure comparison to determine the clipped value\n        if arr[i] >= upper_bound\n            clipped_arr[i] = upper_bound\n        elif arr[i] <= lower_bound\n            clipped_arr[i] = lower_bound\n        else\n            clipped_arr[i] = arr[i]\n\n    return clipped_arr\n", "response_1": "def clip(arr, upper_bound=1, lower_bound=-1):\n    n = len(arr)\n    clipped_arr = sint.Array(n)\n\n    for i in range(n):\n        x = arr[i]\n        upper_bound_clear = clear(upper_bound)\n        lower_bound_clear = clear(lower_bound)\n\n        # Calculate clipped value\n        clipped_value = if_then_else(x >= upper_bound_clear, upper_bound_clear, \n                                    if_then_else(x > lower_bound_clear, x, lower_bound_clear))\n        \n        clipped_arr[i] = clipped_value\n\n    return clipped_arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_satisfied_2", "response_0": "// Define a function to count the number of elements satisfying a predicate\ndef int count_satisfied(int[] arr, function(int) -> int predicator) {\n    int n = len(arr); // Get the length of the array\n    int summmation = 0; // Initialize the summmation to 0\n\n    // Iterate over each element in the array\n    for (int i = 0; i < n; i++) {\n        int flag = predicator(arr[i]); // Apply the predicate to the current element\n        summmation += flag; // Add the result to the summmation\n    }\n\n    return summmation; // Return the total count\n}\n", "response_1": "// Assuming arr is an array of integers and predicator is a function that returns 1 if the condition is met, 0 otherwise\n// Define the length of the array\nint n = 10; // Example length, this should be defined based on input or another mechanism\n\n// Define the array and the predicate function\nint arr[n];\nint predicator(int x) {\n    // Example predicate: return 1 if x is greater than 5, otherwise 0\n    return (x > 5);\n}\n\n// Initialize the sum\nint summmation = 0;\n\n// Loop through the array and apply the predicate\nfor (int i = 0; i < n; i++) {\n    summmation += predicator(arr[i]);\n}\n\n// Output the result\nprint_int(summmation);\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "reverse_order_pair", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_inc", "response_0": "// Assuming 'arr' is an array of secret shared values and 'n' is the length of the array\n// Load the length of the array\nint n = 10; // Example length, replace with actual length loading mechanism\n\n// Array of secret shared integers\nsint arr[n];\n\n// Increment each element of the array by 1\nfor (int i = 0; i < n; i++) {\n    arr[i] = arr[i] + 1;\n}\n\n// At this point, 'arr' contains the incremented values\n", "response_1": "function array_inc(*arr)\n    for i from 0 to len(arr) - 1 do\n        arr[i] = arr[i] + 1\n    endfor\n    return arr\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_rises", "response_0": "program count_rises\n\ncint count = 0\nint n = io.input(1)  // Assuming the first input is the length of the array\nvar int arr[n]\n\n// Input the array elements\nfor i from 0 to n-1:\n    arr[i] = io.input(1)\n\n// Count the rises\nfor i from 0 to n-2:\n    if arr[i] < arr[i+1]:\n        count += 1\n\n// Output the result\nio.output(count)\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_process_2", "response_0": "function array_process(*arr, function(*int) -> int func) -> *int {\n    int n = arr.size();\n    *int result[n];\n    for (int i = 0; i < n; i++) {\n        result[i] = func(arr[i]);\n    }\n    return result;\n}\n", "response_1": "function array_process(arr, func)\n    // Assuming arr is an array of sint (secret integers) and func is a function that operates on sint\n    for i from 0 to len(arr) - 1\n        arr[i] = func(arr[i])\n    return arr\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "two_norm", "response_0": "# Define the function to compute the two-norm of a vector\ndef two_norm(vec):\n    # Square each element in the vector\n    squared_vec = [item * item for item in vec]\n    \n    # Sum all squared elements\n    sum_squared = sum(squared_vec)\n    \n    # Initialize the approximation for the square root\n    # Start with a reasonable guess, e.g., sum_squared / 2\n    x = sum_squared / 2\n    \n    # Perform a few iterations of Newton's method\n    for _ in range(10):  # Number of iterations can be adjusted\n        x = (x + sum_squared / x) / 2\n    \n    # x now contains the approximate square root\n    result = x\n    \n    return result\n", "response_1": "def two_norm(vec):\n    # Step 1: Square each element\n    squared_vec = [item * item for item in vec]\n\n    # Step 2: Sum the squared elements\n    sum_squared = sum(squared_vec)\n\n    # Step 3: Compute the square root using Newton's method\n    # Initialize the guess for the square root\n    guess = sum_squared / 2\n    tolerance = 1  # Define a tolerance level for convergence\n\n    # Perform Newton's method iterations\n    for _ in range(10):  # Number of iterations can be adjusted\n        new_guess = (guess + sum_squared / guess) / 2\n        if abs(new_guess - guess) < tolerance:\n            break\n        guess = new_guess\n\n    return guess\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "totally_dominate", "response_0": "function bool totally_dominate(int[] a, int[] b) {\n    int amin = a[0];\n    int bmax = b[0];\n    int i;\n\n    // Find the minimum in array a\n    for i from 1 to len(a) - 1 {\n        if (a[i] < amin) {\n            amin = a[i];\n        }\n    }\n\n    // Find the maximum in array b\n    for i from 1 to len(b) - 1 {\n        if (b[i] > bmax) {\n            bmax = b[i];\n        }\n    }\n\n    // Return true if amin is greater than or equal to bmax, else false\n    return amin >= bmax;\n}\n", "response_1": "def totally_dominate(a, b):\n    # Initialize amin and bmax with the first elements of a and b\n    amin = a[0]\n    bmax = b[0]\n\n    # Find the minimum in array a\n    for i in range(1, len(a)):\n        amin = amin if amin < a[i] else a[i]\n\n    # Find the maximum in array b\n    for i in range(1, len(b)):\n        bmax = bmax if bmax > b[i] else b[i]\n\n    # Compare amin and bmax\n    result = 1 if amin >= bmax else 0\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "inner_product_2", "response_0": "program inner_product\n\n// Assuming vec1 and vec2 are input arrays of the same length\nint vec1[INPUT_SIZE]\nint vec2[INPUT_SIZE]\nint summation\nint i\n\n// Initialize summation to 0\nsummation = 0\n\n// Compute the inner product\nfor i from 0 to INPUT_SIZE - 1 do\n    summation += vec1[i] * vec2[i]\nendfor\n\n// Output the result\nprint_int summation\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "get_subarr_by_indices", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    n = len(arr)\n    flag = sintArray(n)\n    for i in range(n):\n        flag[i] = (arr[i] == 5) | (arr[i] == 7)\n    result = sint(0)\n    for i in range(n):\n        result = result | flag[i]\n    return result\n", "response_1": "def exists_5_or_7(arr):\n    n = len(arr)\n    flag = [sint(0) for _ in range(n)]  # Initialize flag array with 0s (False)\n\n    for i in range(n):\n        flag[i] = (arr[i] == sint(5)) | (arr[i] == sint(7))  # Set flag to True if item is 5 or 7\n\n    result = sint(0)\n    for i in range(n):\n        result |= flag[i]  # Use bitwise OR to check if any flag is True\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "remove_by_index", "response_0": "c\nfunction array<int> remove_by_index(array<int> arr, int index) {\n    int n = arr.size();\n    array<int> ret(n - 1);\n    for (int i = 0; i < n; i++) {\n        if (i < index) {\n            ret[i] = arr[i];\n        } else if (i > index) {\n            ret[i - 1] = arr[i];\n        }\n    }\n    return ret;\n}\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "average", "response_0": "", "response_1": "# Define the function to compute the average\ndef int average(*arr):\n    # Initialize summmation to 0\n    summmation = 0\n\n    # Compute the sum of the array elements\n    for i in range(len(arr)):\n        summmation += arr[i]\n\n    # Compute the length of the array\n    length = len(arr)\n\n    # Compute the average\n    ret = summmation / length\n\n    # Return the result\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
