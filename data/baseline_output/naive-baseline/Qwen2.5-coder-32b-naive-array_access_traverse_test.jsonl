{"test_name": "indicate_positive", "response_0": "def indicate_positive(arr):\n    n = len(arr)\n    ret = [sint(0) for i in range(n)]\n    for i in range(n):\n        ret[i] = arr[i] > 0\n    return ret\n", "response_1": "def indicate_positive(arr):\n    n = len(arr)\n    ret = sintArray(n)\n    for i in range(n):\n        ret[i] = (arr[i] > 0).select(sint(1), sint(0))\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_xor", "response_0": "def array_xor(a, b):\n    # Initialize the return array with zeros, same length as input arrays\n    ret = sintArray(len(a))\n    for i in range(len(a)):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "response_1": "def array_xor(a, b):\n    # Initialize the return array with the same length as a and b\n    ret = Array(len(a), sint)\n    \n    # Perform element-wise XOR\n    for i in range(len(a)):\n        ret[i] = a[i] ^ b[i]\n    \n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "interlaced_placement", "response_0": "function array<int> interlaced_placement(array<int> a, array<int> b) {\n    int n = a.size();\n    array<int> ret(2 * n);\n    \n    for (int i = 0; i < 2 * n; i++) {\n        if (i % 2 == 1) {\n            ret[i] = b[(i - 1) / 2];\n        } else {\n            ret[i] = a[i / 2];\n        }\n    }\n    \n    return ret;\n}\n", "response_1": "function interlaced_placement(a, b) {\n    int n = len(a);\n    int ret[n*2];\n    \n    for (int i = 0; i < n*2; i++) {\n        if (i % 2 == 1) {\n            ret[i] = b[(i-1) / 2];\n        } else {\n            ret[i] = a[i / 2];\n        }\n    }\n    \n    return ret;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_and", "response_0": "def array_and(a, b):\n    # Initialize the return array with the same length as a and b\n    ret = sintArray(len(a))\n    \n    # Iterate over the arrays and compute the elementwise AND\n    for i in range(len(ret)):\n        ret[i] = a[i] & b[i]\n    \n    return ret\n", "response_1": "def array_and(a, b):\n    # Ensure both arrays have the same length\n    n = len(a)\n    ret = sintArray(n)\n\n    for i in range(n):\n        ret[i] = a[i] & b[i]  # Bitwise AND operation\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_indicator", "response_0": "# Define a simple predicator function, e.g., check if a number is greater than 10\ndef is_greater_than_10(x):\n    # In MP-SPDZ, you would use secret-shared comparisons\n    # This is a placeholder for the actual secure comparison operation\n    return x > 10\n\n# Define the array_indicator function\ndef array_indicator(arr):\n    # Initialize an array of False values with the same length as arr\n    ret = sintArray(len(arr))\n    \n    # Iterate over the array\n    for i in range(len(arr)):\n        # Apply the predicator function to each element\n        ret[i] = is_greater_than_10(arr[i])\n    \n    # Return the resulting array\n    return ret\n", "response_1": "def array_indicator(*arr, predicator):\n    int n = arr.size\n    sint ret[n]\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_greater_than_scalar", "response_0": "function array_greater_than_scalar(arr, bound) {\n    // Initialize the return array with zeros (False in boolean context)\n    int n = arr.size();\n    array[n] ret = 0;\n\n    // Iterate over the array\n    for (int i = 0; i < n; i++) {\n        // Perform the comparison and store the result in ret[i]\n        ret[i] = arr[i] > bound;\n    }\n\n    // Return the result array\n    return ret;\n}\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_no_greater_than_scalar", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    # Get the length of the array\n    n = len(a)\n    \n    # Create an array b to store the reversed elements\n    b = [sint(0)] * n\n    \n    # Reverse the array a and store it in b\n    for i in range(n):\n        b[i] = a[n - 1 - i]\n    \n    # Create an array to store the concatenated result\n    result = [sint(0)] * (2 * n)\n    \n    # Copy the original array a to the result array\n    for i in range(n):\n        result[i] = a[i]\n    \n    # Copy the reversed array b to the result array\n    for i in range(n):\n        result[n + i] = b[i]\n    \n    return result\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_round", "response_0": "program array_round\n\n// Function to round an array of fixed-point numbers to the nearest integer\nfunction array_round(arr)\n    // Length of the array\n    n = len(arr)\n    // Array to store the rounded results\n    ret[n]\n\n    // Loop over each element in the array\n    for i from 0 to n-1 do\n        // Convert the fixed-point number to an integer part\n        int_part = arr[i] >> 16 // Assuming 16 bits for the fractional part\n        // Calculate the fractional part\n        frac_part = arr[i] - (int_part << 16)\n        // Check if the fractional part is less than 0.5 (32768 in fixed-point with 16 bits)\n        if frac_part < 32768 then\n            ret[i] = int_part\n        else\n            ret[i] = int_part + 1\n        endif\n    endfor\n\n    // Return the rounded array\n    return ret\nendfunction\n\n// Example usage (this part is not executable in MP-SPDZ, just for illustration)\n// arr = [12345, 67890, 101112, 131415] // Example fixed-point numbers\n// result = array_round(arr)\n// print(result)\n", "response_1": "function array_round(arr)\n    n = len(arr)\n    ret = sintarray(n)\n    for i from 0 to n-1 do\n        int_part = floor(arr[i])\n        half = 0.5\n        diff = arr[i] - int_part\n        ret[i] = int_part + (diff >= half)\n    return ret\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_greater_eq", "response_0": "# MP-SPDZ code to implement the array_greater_eq function\n\n# Assuming arr and brr are input arrays of the same length\n# and are already loaded into the program as sfix arrays\n\n# Length of the arrays\nn = len(arr)\n\n# Initialize the result array with zeros\nret = sfixArray(n)\nfor i in range(n):\n    ret[i] = sfix(0)\n\n# Compare elements and set ret[i] to 1 if arr[i] >= brr[i]\nfor i in range(n):\n    ret[i] = (arr[i] >= brr[i]).if_else(sfix(1), sfix(0))\n\n# ret now contains the desired output\n", "response_1": "# MP-SPDZ code for the array_greater_eq function\n\ndef array_greater_eq(arr, brr):\n    n = len(arr)\n    ret = sintArray(n)  # Initialize an array of secure integers for the result\n\n    for i in range(n):\n        # Use the ge (greater than or equal to) function to compare elements\n        ret[i] = arr[i].ge(brr[i])\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "reverse", "response_0": "", "response_1": "def reverse(arr):\n    n = len(arr)\n    ret = array(n, sint)\n    for i in range(n):\n        ret[i] = arr[n-1-i]\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    # Initialize the return array with zeros\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        # Check if the element is negative\n        is_negative = arr[i] < 0\n        # Convert the boolean result to an integer (1 or 0)\n        ret[i] = is_negative.select(1, 0)\n    return ret\n", "response_1": "def indicate_negative(arr):\n    n = len(arr)\n    ret = sintArray(n)\n    for i in range(n):\n        ret[i] = arr[i] < 0\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "max_sub_sequence", "response_0": "# Define the length of the array\nn = 10  # Example length, should be defined based on input\n\n# Input array\narr = sintarray(n)  # Assuming sint is used for integer operations\n\n# Initialize partial_max and suffix_max arrays\npartial_max = sintarray(n)\nsuffix_max = sintarray(n)\n\n# Initialize the first elements\npartial_max[0] = arr[0]\nsuffix_max[0] = arr[0]\n\n# Loop through the array starting from the second element\nfor i in range(1, n):\n    # Calculate suffix_max[i]\n    temp = suffix_max[i-1] + arr[i]\n    suffix_max[i] = if_then_else(suffix_max[i-1] >= 0, temp, arr[i])\n    \n    # Calculate partial_max[i]\n    partial_max[i] = if_then_else(partial_max[i-1] >= suffix_max[i], partial_max[i-1], suffix_max[i])\n\n# The result is the last element of partial_max\nresult = partial_max[n-1]\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "compare_and_select", "response_0": "", "response_1": "def compare_and_select(a, b):\n    # Initialize the return array with the same length as a and b\n    ret_array = sarray(len(a))\n\n    # Loop through each element of the arrays\n    for i in range(len(a)):\n        # Secure comparison: c will be 1 if a[i] > b[i], otherwise 0\n        c = a[i] > b[i]\n        \n        # Secure selection: ret_array[i] = c * a[i] + (1 - c) * b[i]\n        ret_array[i] = c * a[i] + (1 - c) * b[i]\n\n    return ret_array\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "count_element_frequency", "response_0": "function array[int] count_element_frequency(array[int] l)\n{\n    int n = len(l);\n    array[int] ret[n];\n    for (int i = 0; i < n; i++)\n    {\n        ret[i] = 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (l[j] == l[i])\n            {\n                ret[i] = ret[i] + 1;\n            }\n        }\n    }\n    return ret;\n}\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_or", "response_0": "# Define the length of the arrays\nn = 10  # Example length, should be defined or input as needed\n\n# Input arrays of secret shares\na = sintArray(n)\nb = sintArray(n)\n\n# Output array for the result\nret = sintArray(n)\n\n# Element-wise OR operation\nfor i in range(n):\n    ret[i] = a[i] | b[i]\n\n# Optionally, open the result if needed (for debugging or output)\nfor i in range(n):\n    open(ret[i])\n", "response_1": "function array_or(a, b)\n    int n = len(a)\n    sint ret[n]\n    for i from 0 to n-1\n        ret[i] = a[i] + b[i] - a[i] * b[i]\n    return ret\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "stock_predicator", "response_0": "program stock_predicator\n\n// Input: array of stock prices\nvar sint days[INPUT_SIZE]\n\n// Initialize arrays\nvar sint lowest[INPUT_SIZE]\nvar sint partial_max[INPUT_SIZE]\n\n// Initialize the first elements\nlowest[0] = days[0]\npartial_max[0] = 0\n\n// Loop through the days to fill the lowest and partial_max arrays\nfor i from 1 to INPUT_SIZE - 1 do\n    // Calculate the lowest price up to day i\n    if lowest[i-1] <= days[i] then\n        lowest[i] = lowest[i-1]\n    else\n        lowest[i] = days[i]\n    fi\n\n    // Calculate the maximum profit up to day i\n    if partial_max[i-1] >= days[i] - lowest[i-1] then\n        partial_max[i] = partial_max[i-1]\n    else\n        partial_max[i] = days[i] - lowest[i-1]\n    fi\nendfor\n\n// The result is the maximum profit found\nvar sint result = partial_max[INPUT_SIZE - 1]\n\n// Print the result\nprint_int(result)\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "len5_inc_array", "response_0": "def len5_inc_array(init):\n    # Declare an array of length 5\n    var ret[5]\n\n    # Loop to fill the array with values incrementing by 1 from init\n    for i from 0 to 4 do\n        ret[i] = init + i\n    endfor\n\n    # Return the array\n    return ret\n", "response_1": "program len5_inc_array\n\n// Input: init (initial element of the array)\nint init\n\n// Output: ret (array of length 5, incremented by one)\nint ret[5]\n\n// Initialize the array\nfor i from 0 to 4 do\n    ret[i] = init + i\nendfor\n\n// Output the array\noutput ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "cut_first_five", "response_0": "", "response_1": "def cut_first_five(arr):\n    # Initialize an array of 5 elements with 0s\n    ret = [0] * 5\n    \n    # Determine the number of elements to copy\n    len_arr = len(arr)\n    num_elements_to_copy = min(5, len_arr)\n    \n    # Copy elements from arr to ret\n    for i in range(num_elements_to_copy):\n        ret[i] = arr[i]\n    \n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "max_pooling_1d", "response_0": "# Assuming vec is an array of sint and step is a clear integer\ndef max_pooling_1d(vec, step):\n    n = len(vec)\n    ret_length = n / step\n    ret = sintArray(ret_length)\n\n    for i in range(ret_length):\n        max_val = vec[i * step]\n        for j in range(step):\n            if vec[i * step + j] > max_val:\n                max_val = vec[i * step + j]\n        ret[i] = max_val\n\n    return ret\n", "response_1": "int max_pooling_1d(int[] vec, int step) {\n    int ret_length = vec.size() / step;\n    int[] ret = new int[ret_length];\n\n    for (int i = 0; i < ret_length; i++) {\n        int max = vec[i * step];\n        for (int j = 0; j < step; j++) {\n            if (vec[i * step + j] > max) {\n                max = vec[i * step + j];\n            }\n        }\n        ret[i] = max;\n    }\n\n    return ret;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_greater", "response_0": "function array_greater(arr, brr) {\n    int n = arr.size;\n    array int ret[n];\n    for (int i = 0; i < n; i++) {\n        int condition = arr[i] > brr[i];\n        ret[i] = condition;\n    }\n    return ret;\n}\n", "response_1": "program array_greater\n\n# Assuming arr and brr are input arrays of the same length n\nint n = 10  # Example length, this should be dynamically set based on input\narray<int> arr[n]\narray<int> brr[n]\narray<int> ret[n]\n\n# Initialize ret array to 0\nfor i in range(n):\n    ret[i] = 0\n\n# Compare elements and set ret[i] accordingly\nfor i in range(n):\n    int comparison = arr[i] > brr[i]\n    ret[i] = comparison\n\n# ret now contains the result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "dumb_concat", "response_0": "def dumb_concat(arr, brr):\n    length = arr.size() + brr.size()\n    ret = sint_array(length)\n    for i in range(arr.size()):\n        ret[i] = arr[i]\n    for j in range(brr.size()):\n        ret[arr.size() + j] = brr[j]\n    return ret\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "indicator_if_else", "response_0": "def indicator_if_else(a, b, ind):\n    # Initialize the result array with the same length as a and b\n    c = Array(len(ind))\n\n    # Loop over the elements of the arrays\n    for i in range(len(ind)):\n        # Use a conditional assignment to set c[i]\n        c[i] = (1 - ind[i]) * b[i] + ind[i] * a[i]\n    \n    return c\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "elementwise_multiplication", "response_0": "def elementwise_multiplication(a, b):\n    n = len(a)\n    ret = sintArray(n)\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "function elementwise_multiplication(a, b)\n{\n    var int n = len(a)\n    var sint ret[n]\n    for var int i = 0; i < n; i++\n    {\n        ret[i] = a[i] * b[i]\n    }\n    return ret\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "get_subarr_by_indices", "response_0": "int get_subarr_by_indices(int[] a, int[] indices, int[] ret, int n_indices) {\n    // n_indices is the length of the indices array\n    for (int i = 0; i < n_indices; i++) {\n        ret[i] = a[indices[i]];\n    }\n    return 0; // Return statement is not strictly necessary in MP-SPDZ for void functions, but added for consistency\n}\n", "response_1": "def get_subarr_by_indices(*a, *indices) -> *ret:\n    int n_indices = len(indices)\n    *ret = [0] * n_indices\n    for i in range(n_indices):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "inc_array", "response_0": "def inc_array(num):\n    # Initialize an empty array to store the results\n    result = []\n\n    # Loop from 0 to num-1\n    for i in range(num):\n        # Append i+1 to the result array\n        result.append(i + 1)\n\n    # Return the result array\n    return result\n", "response_1": "def inc_array(num):\n    # Declare an array to hold the result\n    int res[num]\n\n    # Loop from 0 to num-1\n    for i in range(num):\n        # Assign i+1 to the corresponding index in the result array\n        res[i] = i + 1\n\n    # Return the result array\n    return res\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "cut_last_five", "response_0": "def cut_last_five(arr):\n    # Initialize the return array with zeros\n    ret = [sint(0) for _ in range(5)]\n    \n    # Determine the number of elements to copy\n    num_elements = min(5, len(arr))\n    \n    # Copy the last elements of the input array\n    for i in range(num_elements):\n        ret[4 - i] = arr[len(arr) - 1 - i]\n    \n    # ret now contains the last 5 elements of arr, padded with zeros if necessary\n", "response_1": "# MP-SPDZ code to achieve the same functionality as the provided Python function\n\ndef cut_last_five(arr):\n    # Initialize an array of 5 zeros\n    ret = [sint(0) for _ in range(5)]\n    \n    # Calculate the number of elements to copy from the input array\n    num_elements_to_copy = min(5, len(arr))\n    \n    # Copy the last num_elements_to_copy elements from arr to ret\n    for i in range(num_elements_to_copy):\n        ret[4 - i] = arr[len(arr) - 1 - i]\n    \n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "average_pooling_1d", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_relu", "response_0": "function array_relu(*arr)\n    n = len(arr)\n    ret = array(n)\n    for i from 0 to n-1 do\n        if arr[i] >= 0 then\n            ret[i] = arr[i]\n        else\n            ret[i] = 0\n        fi\n    rof\n    return ret\nendfunction\n", "response_1": "program relu_example\n\n// Assuming arr is an array of sint (secret integers)\narray[10] of sint arr = [sint(0), sint(-1), sint(2), sint(-3), sint(4), sint(-5), sint(6), sint(-7), sint(8), sint(-9)]\narray[10] of sint ret\n\n// Apply ReLU function element-wise\nfor i from 0 to 9 do\n    sint temp\n    temp = arr[i]\n    // Using a conditional move to implement ReLU\n    ret[i] = temp * (temp >= 0)\nendfor\n\n// ret now contains the ReLU of arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "move_to_end", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "set_to_zero", "response_0": "def set_to_zero(*arr, index):\n    # Set the element in the input array with given index to zero\n    arr[index] = 0\n    return arr\n", "response_1": "function void set_to_zero(*int arr, int index)\n{\n    arr[index] = 0;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "last_partial_sum", "response_0": "", "response_1": "def last_partial_sum(arr[n], n):\n    # Initialize the return variable\n    int ret = 0\n    # Calculate the starting index for the sum\n    int start_index = len(arr) - n\n    # Loop through the last n elements\n    for int i = start_index to len(arr) - 1:\n        ret = ret + arr[i]\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "permute_by_indices", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "get_rank", "response_0": "", "response_1": "function int get_rank(int[] arr, int index) {\n    int rank = 0;\n    int n = arr.length();\n    for (int i = 0; i < n; i = i + 1) {\n        if (arr[i] < arr[index]) {\n            rank = rank + 1;\n        }\n    }\n    return rank;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "interchange_by_indices", "response_0": "def interchange_by_indices(arr, index1, index2):\n    # Create a temporary variable to hold the value at index1\n    temp = arr[index1]\n    \n    # Assign the value at index2 to index1\n    arr[index1] = arr[index2]\n    \n    # Assign the value stored in temp to index2\n    arr[index2] = temp\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "increase_by", "response_0": "function array<int> increase_by(array<int> arr, int index, int k) {\n    arr[index] = arr[index] + k;\n    return arr;\n}\n", "response_1": "function increase_by(*arr, index, k)\n    arr[index] = arr[index] + k\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "retrieve_by_index", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "scale_by", "response_0": "def scale_by(arr: Array[sint], index: sint, k: sint) -> Array[sint]:\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n", "response_1": "function scale_by(*arr, index, k)\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "take_opposite_to", "response_0": "function take_opposite_to(*arr, index)\n    # In MP-SPDZ, arrays are passed by reference, so we modify arr directly\n    arr[index] = -arr[index]\n    return arr\nendfunction\n", "response_1": "function take_opposite_to(*arr, index)\n    # arr is a pointer to an array of secret shared values\n    # index is a clear integer\n    arr[index] = -arr[index]\n    return arr\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "array_rank", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    n = len(arr)\n    ret = sintArray(n - 1)\n    \n    for i in range(n - 1):\n        if_statement(i < index, lambda: ret[i] = arr[i], lambda: ret[i] = arr[i + 1])\n    \n    return ret\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "process_by_index", "response_0": "function process_by_index(*int arr, int index, *int func)\n    arr[index] = func(arr[index])\n    return arr\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_by_indices", "response_0": "int sum_by_indices(int[] arr, int[] indices) {\n    int sum = 0;\n    int i;\n    for i from 0 to len(indices) - 1 {\n        sum = sum + arr[indices[i]];\n    }\n    return sum;\n}\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
