{"test_name": "sin_or_cos", "response_0": "", "response_1": "// sin_or_cos.mpc\nprogram sin_or_cos {\n    // Input: x\n    sint x;\n    input x from player 0;\n\n    // Compute sin(x) and cos(x)\n    sint sin_x = sint(sin(x));\n    sint cos_x = sint(cos(x));\n\n    // Conditional: if x >= 0, return sin(x), else return cos(x)\n    sint result;\n    if (x >= 0) {\n        result = sin_x;\n    } else {\n        result = cos_x;\n    }\n\n    // Output the result\n    output result to player 0;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "negative_relu", "response_0": "c\n// Function to compute the negative ReLU using secret integers\nsint negative_relu(sint input) {\n    // Variable to store the result\n    sint result;\n\n    // Check if input is less than 0\n    sint condition = (input < 0);\n    result = condition * input;\n\n    // Return the result\n    return result;\n}\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "is_close", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "hardswish", "response_0": "function hardswish(x)\n    var res\n    if (x < -3)\n        res = 0\n    elif (x > 3)\n        res = x\n    else\n        res = (x * (x + 3)) / 6\n    endif\n    return res\nendfunction\n", "response_1": "function hardswish(x)\n    var result\n    if (x < -3)\n        result = 0\n    elif (x > 3)\n        result = x\n    else\n        result = x * (x + 3) / 6\n    endif\n    return result\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "clip_at_6", "response_0": "", "response_1": "function int clip_at_6(int x)\n{\n    int result;\n    if (x > 6)\n    {\n        result = 6;\n    }\n    else if (x < -6)\n    {\n        result = -6;\n    }\n    else\n    {\n        result = x;\n    }\n    return result;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    ret = sint(0)\n    cond1 = (x > sint(1))\n    cond2 = (x < sint(-1))\n    cond3 = (x > sint(0))\n    cond4 = (x < sint(0))\n\n    # Using conditional moves to assign values to ret based on conditions\n    ret = if_then_else(cond1, x, ret)\n    ret = if_then_else(cond2, x, ret)\n    ret = if_then_else(cond3, sint(1), ret)\n    ret = if_then_else(cond4, sint(-1), ret)\n\n    return ret\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "middle", "response_0": "", "response_1": "int a, b, c, temp\n\n# Assume a, b, c are input values\n# a = ...\n# b = ...\n# c = ...\n\nif a >= b:\n    temp = a\n    a = b\n    b = temp\nendif\n\nif b >= c:\n    temp = b\n    b = c\n    c = temp\nendif\n\nif a >= b:\n    temp = a\n    a = b\n    b = temp\nendif\n\nreturn b\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "indicated_sin_or_cos", "response_0": "// Function to compute sine or cosine based on the indicator\nfunction indicated_sin_or_cos(x, ind) {\n    // Convert the boolean indicator to an integer (0 or 1)\n    ind_int = 1 * ind;\n\n    // Compute sine and cosine of x\n    sin_x = sin(x);\n    cos_x = cos(x);\n\n    // Use the indicator to select between sine and cosine\n    result = (1 - ind_int) * cos_x + ind_int * sin_x;\n\n    // Return the result\n    return result;\n}\n", "response_1": "function indicated_sin_or_cos(x, ind)\n    # Assuming x is a clear or secret fixed-point number\n    # and ind is a clear bit (0 or 1)\n\n    # Securely compute sin(x) and cos(x)\n    sin_x = sin(x)\n    cos_x = cos(x)\n\n    # Use a secure conditional to select between sin_x and cos_x based on ind\n    result = ind * sin_x + (1 - ind) * cos_x\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "minus2_if_else", "response_0": "", "response_1": "def minus2_if_else(x):\n    if (x - 2) >= 0:\n        return x - 2\n    else:\n        return x\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "relu6", "response_0": "function relu6(i64 x) -> i64\n{\n    i64 result;\n    if (x < 0)\n    {\n        result = 0;\n    }\n    else if (x > 6)\n    {\n        result = 6;\n    }\n    else\n    {\n        result = x;\n    }\n    return result;\n}\n", "response_1": "// ReLU6 function in MP-SPDZ\nfunction relu6(x)\n{\n    // Temporary variable to store the result\n    var res;\n\n    // Check if x < 0\n    if (x < 0)\n    {\n        res = 0;\n    }\n    // Check if x > 6\n    else if (x > 6)\n    {\n        res = 6;\n    }\n    // Otherwise, return x\n    else\n    {\n        res = x;\n    }\n\n    // Return the result\n    return res;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "exp_slide", "response_0": "def exp_slide(x):\n    # Convert x to a fixed-point number if it's not already\n    x_fixed = fxp(x)\n\n    # Define the constant e as a fixed-point number\n    e = fxp(2.718281828459045)\n\n    # Check if x is nonnegative\n    if x_fixed >= fxp(0):\n        # Compute e^x using a fixed-point exponential function\n        result = exp(x_fixed)\n    else:\n        # Compute x + 1\n        result = x_fixed + fxp(1)\n\n    # Return the result\n    return result\n", "response_1": "function exp_slide(x)\n    # Check if x is nonnegative\n    if (x >= 0)\n        # Compute e^x using the exp function in MP-SPDZ\n        return exp(x)\n    else\n        # Return x + 1\n        return x + 1\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "pass_or_not", "response_0": "def pass_or_not(score):\n    # Convert input to sint for secure computation\n    score = sint(score)\n    \n    # Check if the score is greater than or equal to 60\n    passed = (score >= 60)\n    \n    # Use conditional selection to determine the score to return\n    return_score = passed.if_else(score, sint(59))\n    \n    # Convert boolean to sint for return\n    return_passed = passed.if_else(sint(1), sint(0))\n    \n    return return_score, return_passed\n", "response_1": "def pass_or_not(score):\n    # Initialize a variable to store the result\n    result_score = score\n    result_passed = 0\n\n    # Use a conditional statement to check the score\n    if score >= 60:\n        result_score = score\n        result_passed = 1\n    else:\n        result_score = 59\n        result_passed = 0\n\n    # Return the result as a tuple\n    return result_score, result_passed\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "how_many_roots", "response_0": "# Define the function in MP-SPDZ syntax\ndef how_many_roots(a, b, c):\n    # Initialize the return value\n    result = sint(0)\n\n    # Check if a is zero\n    if a == sint(0):\n        # Check if b is zero\n        if b == sint(0):\n            result = sint(0)\n        else:\n            result = sint(1)\n    else:\n        # Calculate the discriminant\n        discriminant = b * b - sint(4) * a * c\n\n        # Check the value of the discriminant\n        if discriminant > sint(0):\n            result = sint(2)\n        elif discriminant == sint(0):\n            result = sint(1)\n        else:\n            result = sint(0)\n\n    return result\n", "response_1": "def how_many_roots(a, b, c):\n    # Check if a is zero\n    ifeqzero_a = (a == 0)\n    # Check if b is zero\n    ifeqzero_b = (b == 0)\n    # Calculate the discriminant\n    discriminant = (b * b) - (4 * a * c)\n    \n    # If a is zero, further checks\n    ifeqzero_a_then_zero = ifeqzero_a * ifeqzero_b\n    ifeqzero_a_then_one = ifeqzero_a * (1 - ifeqzero_b)\n    \n    # If a is not zero, check the discriminant\n    ifgtzero_discriminant = (discriminant > 0)\n    ifeqzero_discriminant = (discriminant == 0)\n    \n    # Calculate the number of roots based on conditions\n    roots = ifeqzero_a_then_zero * 0 + \\\n            ifeqzero_a_then_one * 1 + \\\n            ifgtzero_discriminant * 2 + \\\n            ifeqzero_discriminant * 1\n    \n    return roots\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "elu", "response_0": "def elu(x):\n    # Define the constant e\n    e = 2.718281828459045\n\n    # Check if x is greater than 0\n    condition = x > 0\n\n    # Compute e^x - 1 for the case when x <= 0\n    exp_x_minus_1 = exp(x) - 1\n\n    # Use a conditional selection to return x if condition is true, else return exp_x_minus_1\n    result = select(condition, x, exp_x_minus_1)\n\n    return result\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "relu", "response_0": "", "response_1": "def relu(x):\n    # Initialize a variable to store the result\n    res = sint(0)\n    \n    # Use a conditional statement to implement the ReLU function\n    if x > sint(0):\n        res = x\n    \n    return res\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "leaky_relu", "response_0": "function int64 leaky_relu(int64 x, int64 alpha) {\n    int64 result;\n    if (x > 0) {\n        result = x;\n    } else {\n        result = x * alpha;\n    }\n    return result;\n}\n", "response_1": "function int leaky_relu(int x, int alpha)\n{\n    int result;\n    if (x > 0)\n    {\n        result = x;\n    }\n    else\n    {\n        result = x * alpha;\n    }\n    return result;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "max", "response_0": "function int max(int a, int b)\n{\n    int result;\n    if (a >= b)\n    {\n        result = a;\n    }\n    else\n    {\n        result = b;\n    }\n    return result;\n}\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "bowl_shape", "response_0": "function bowl_shape(x)\n    if x > 1 then\n        return x - 1\n    elif x < -1 then\n        return -x - 1\n    else\n        return 0\n    endif\nendfunction\n", "response_1": "function bowl_shape(x)\n{\n    // Declare a variable to store the result\n    var result\n\n    // Check if x > 1\n    if (x > 1)\n    {\n        result = x - 1\n    }\n    // Check if x < -1\n    else if (x < -1)\n    {\n        result = -x - 1\n    }\n    // If neither condition is true, result is 0\n    else\n    {\n        result = 0\n    }\n\n    // Return the computed result\n    return result\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "rounded_kinetic_energy", "response_0": "# Define the function to compute rounded kinetic energy\ndef rounded_kinetic_energy(m, v):\n    # Compute the kinetic energy k = m * v^2 / 2\n    v_squared = v * v\n    k = m * v_squared / 2\n\n    # Convert k to a fixed-point representation with a precision of 16 bits\n    k_fixed = k * (1 << 16)\n\n    # Compute k_int = floor(k)\n    k_int_fixed = k_fixed >> 16\n\n    # Compute the fractional part of k\n    fractional_part = k_fixed - (k_int_fixed << 16)\n\n    # Determine if we need to round up\n    half_fixed = (1 << 15)  # This represents 0.5 in fixed-point with 16 bits precision\n    round_up = fractional_part >= half_fixed\n\n    # Compute the final rounded integer value\n    k_int = k_int_fixed + round_up\n\n    return k_int\n", "response_1": "def rounded_kinetic_energy(m, v):\n    # Calculate kinetic energy: k = m * v^2 / 2\n    v_squared = v * v\n    k = (m * v_squared) / 2\n\n    # Convert k to fixed-point representation with a specific precision\n    # Assuming a precision of 16 bits for the fractional part\n    precision = 2**16\n    k_fixed = k * precision\n\n    # Calculate the integer part of k\n    k_int = k_fixed >> 16\n\n    # Calculate the fractional part of k\n    k_fractional = k_fixed - (k_int << 16)\n\n    # Determine if we need to round up or down\n    # If fractional part is >= 0.5 * precision, round up\n    half_precision = precision >> 1\n    if k_fractional >= half_precision:\n        k_int = k_int + 1\n\n    return k_int\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "danger_test", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "indicated_sum_or_multiply", "response_0": "", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "median", "response_0": "", "response_1": "# Assuming arr is an array of sint and n is the length of the array\ndef median(arr, n):\n    if n == 0:\n        # In MP-SPDZ, raising exceptions is not straightforward, so we handle it differently\n        print_int(\"The length of the array is 0!\")\n        return sint(0)  # Return a default value or handle as needed\n\n    # Implementing a simple bubble sort for demonstration purposes\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                # Swap arr[j] and arr[j+1]\n                temp = arr[j]\n                arr[j] = arr[j+1]\n                arr[j+1] = temp\n\n    ret = sint(0)\n    if n % 2 == 1:\n        ret = arr[n // 2]\n    else:\n        ret = (arr[n // 2] + arr[n // 2 - 1]) / sint(2)\n\n    return ret\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "add_upto_10", "response_0": "# MP-SPDZ code for the function add_upto_10\ndef add_upto_10(a, b):\n    sum_ab = a + b\n    result = sum_ab > 10\n    result = result * (10 - sum_ab) + sum_ab\n    return result\n", "response_1": "def add_upto_10(a, b):\n    sum = a + b\n    result = sum > 10\n    return (1 - result) * sum + result * 10\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    # Base fare\n    base_fare = sfix(5)\n    # Fare for miles between 5 and 10\n    mid_fare_rate = sfix(1.2)\n    # Fare for miles beyond 10\n    high_fare_rate = sfix(1.5)\n\n    # Calculate the fare\n    if m <= 5:\n        return base_fare\n    elif m <= 10:\n        return base_fare + mid_fare_rate * (m - 5)\n    else:\n        return base_fare + mid_fare_rate * 5 + high_fare_rate * (m - 10)\n", "response_1": "c++\n// MP-SPDZ program to compute the taxi fare given the miles it covers\n\n// Function to calculate the taxi fare\ninline sint taxi_fare(sint m) {\n    // Base fare\n    sint base_fare = 5;\n    \n    // Initialize the fare with the base fare\n    sint fare = base_fare;\n    \n    // Check if miles are within the first 5 miles\n    if (m <= 5) {\n        return fare;\n    }\n    \n    // Check if miles are within the range [5, 10]\n    if (m <= 10) {\n        fare += 1.2 * (m - 5);\n        return fare;\n    }\n    \n    // For miles greater than 10\n    fare += 1.2 * (10 - 5) + 1.5 * (m - 10);\n    return fare;\n}\n\nint main() {\n    // Assuming 'm' is input from the user or another part of the program\n    sint m = 12;  // Example input\n\n    // Calculate the taxi fare\n    sint result = taxi_fare(m);\n\n    // Print the result (in MP-SPDZ, printing might be done differently depending on the setup)\n    print_ln(result);\n    return 0;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "round", "response_0": "// Assuming x is a fixed-point number, scaled by a factor of 10 (e.g., 1234 represents 123.4)\ndef round(x):\n    // Define the scaling factor\n    int scale = 10\n    \n    // Calculate the integer part\n    int x_int = x / scale\n    \n    // Calculate the fractional part\n    int fractional_part = x % scale\n    \n    // Determine if we need to round up\n    int round_up = (fractional_part >= (scale / 2))\n    \n    // Return the rounded integer\n    return x_int + round_up\n", "response_1": "// Define a fixed-point precision\nint PRECISION = 16;\n\n// Function to perform floor operation on a fixed-point number\nint floor(fixed x) {\n    int x_int = (int)x; // Convert fixed-point to integer, effectively flooring it\n    return x_int;\n}\n\n// Function to round a fixed-point number to the nearest integer\nint round(fixed x) {\n    int x_int = floor(x); // Get the floored integer part\n    fixed fractional_part = x - x_int; // Calculate the fractional part\n    fixed half = 0.5; // Half value in fixed-point\n\n    // Compare fractional part with 0.5 and decide rounding\n    if (fractional_part < half) {\n        return x_int;\n    } else {\n        return x_int + 1;\n    }\n}\n\n// Example usage\nint main() {\n    fixed x = 3.7; // Example input\n    int result = round(x); // Call the round function\n    print_int(result); // Print the result\n    return 0;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "gpa_calculator", "response_0": "", "response_1": "# gpa_calculator.mpc\n# This function calculates the GPA based on the score input\n\nfunction gpa_calculator(score)\n    var gpa\n    if score >= 90\n        gpa = 4.0\n    elif score >= 85\n        gpa = 3.6\n    elif score >= 80\n        gpa = 3.3\n    elif score >= 75\n        gpa = 3.0\n    elif score >= 70\n        gpa = 2.6\n    else\n        gpa = 2.3\n    return gpa\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sign", "response_0": "def int sign(int x):\n    int result\n    result = 0\n    if x == 0:\n        result = 0\n    else:\n        result = (x > 0) ? 1 : -1\n    return result\n", "response_1": "def sign(x):\n    # Initialize the result variable\n    result = sint(0)\n\n    # Check if x is not zero\n    is_not_zero = (x != 0)\n\n    # Conditional assignment for positive x\n    result.if_else(1, -1, is_not_zero & (x > 0))\n\n    # Conditional assignment for zero x\n    result.if_else(0, result, x == 0)\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "sum_or_difference", "response_0": "function int sum_or_difference(int a, int b)\n{\n    int result;\n    if (a <= b)\n    {\n        result = a + b;\n    }\n    else\n    {\n        result = a - b;\n    }\n    return result;\n}\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    # Simulate NOT operation\n    not_flip_bit = 1 - flip_bit\n\n    # Simulate CNOT logic using arithmetic operations\n    result = (control_bit * flip_bit) + ((1 - control_bit) * not_flip_bit)\n\n    return result\n", "response_1": "def CNOT(control_bit, flip_bit):\n    # In MP-SPDZ, we use bitwise operations and conditions\n    # to simulate the CNOT gate.\n    # We assume control_bit and flip_bit are clear bits (integers 0 or 1).\n\n    # Calculate the result of the CNOT gate\n    result = flip_bit ^ (control_bit & 1)\n\n    return result\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "negative_plus1", "response_0": "", "response_1": "function int negative_plus1(int y) {\n    int result;\n    if (y < 0) {\n        result = y + 1;\n    } else {\n        result = y;\n    }\n    return result;\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "is_a_parallelogram", "response_0": "function bool is_a_parallelogram(cint a0, cint a1, cint b0, cint b1, cint c0, cint c1, cint d0, cint d1) {\n    // Helper function to check if two points are the same\n    function bool same(cint x0, cint x1, cint y0, cint y1) {\n        return (x0 == y0) & (x1 == y1);\n    }\n\n    // Check if any two points are the same\n    if (same(a0, a1, b0, b1) | same(a0, a1, c0, c1) | same(a0, a1, d0, d1) | \n        same(b0, b1, c0, c1) | same(b0, b1, d0, d1) | same(c0, c1, d0, d1)) {\n        return false;\n    }\n\n    // Check parallelogram conditions\n    bool cond1 = ((a0 + b0) == (c0 + d0)) & ((a1 + b1) == (c1 + d1));\n    bool cond2 = ((a0 + c0) == (b0 + d0)) & ((a1 + c1) == (b1 + d1));\n    bool cond3 = ((a0 + d0) == (b0 + c0)) & ((a1 + d1) == (b1 + c1));\n\n    return cond1 | cond2 | cond3;\n}\n", "response_1": "def is_a_parallelogram(a0, a1, b0, b1, c0, c1, d0, d1):\n    \"\"\"\n    Given four vertices (a0, a1), (b0, b1), (c0, c1), (d0, d1),\n    return whether the four vertices can form a parallelogram.\n    \"\"\"\n\n    # Function to check if two points are the same\n    def same(x0, x1, y0, y1):\n        return (x0 == y0) * (x1 == y1)\n\n    # Check if any two points are the same\n    if same(a0, a1, b0, b1) + same(a0, a1, c0, c1) + same(a0, a1, d0, d1) + \\\n       same(b0, b1, c0, c1) + same(b0, b1, d0, d1) + same(c0, c1, d0, d1) > 0:\n        return 0\n\n    # Check parallelogram conditions\n    cond1 = (a0 + b0 == c0 + d0) * (a1 + b1 == c1 + d1)\n    cond2 = (a0 + c0 == b0 + d0) * (a1 + c1 == b1 + d1)\n    cond3 = (a0 + d0 == b0 + c0) * (a1 + d1 == b1 + c1)\n\n    return cond1 + cond2 + cond3 > 0\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "min", "response_0": "", "response_1": "function int min(int a, int b)\n{\n    if (a <= b)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n}\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x, y):\n    counter = 0\n\n    def legal(a, b):\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n\n    return counter\n", "response_1": "program choice_of_the_knight\n\n// Function to check if a position is legal on the chessboard\nfunction legal(a, b)\n    return (a >= 0 and a <= 7) and (b >= 0 and b <= 7)\nendfunction\n\n// Main function to calculate the number of positions a knight can reach\nfunction choice_of_the_knight(x, y)\n    var int counter = 0\n\n    // Check all possible knight moves\n    if legal(x + 1, y + 2) then\n        counter = counter + 1\n    endif\n\n    if legal(x - 1, y + 2) then\n        counter = counter + 1\n    endif\n\n    if legal(x + 1, y - 2) then\n        counter = counter + 1\n    endif\n\n    if legal(x - 1, y - 2) then\n        counter = counter + 1\n    endif\n\n    if legal(x + 2, y + 1) then\n        counter = counter + 1\n    endif\n\n    if legal(x - 2, y + 1) then\n        counter = counter + 1\n    endif\n\n    if legal(x + 2, y - 1) then\n        counter = counter + 1\n    endif\n\n    if legal(x - 2, y - 1) then\n        counter = counter + 1\n    endif\n\n    return counter\nendfunction\n", "model_name": "qwen2.5-coder-32b"}
{"test_name": "max_sum_difference", "response_0": "# MP-SPDZ code for the max_sum_different function\n\ndef max_sum_different(a, b):\n    sum_ab = a + b\n    diff_ab = a - b\n    max_value = sum_ab if sum_ab > diff_ab else diff_ab\n    return max_value\n", "response_1": "", "model_name": "qwen2.5-coder-32b"}
