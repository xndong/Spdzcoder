{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    n = len(arr)\n    res = Array(n, arr.value_type)\n    for i in range(n):\n        if i < n - 1:\n            if i < index:\n                res[i] = arr[i]\n            else:\n                res[i] = arr[i + 1]\n        else:\n            res[i] = arr[index]\n    return res\n", "response_1": "def move_to_end(arr, index):\n    n = len(arr)\n    new_arr = Array(n, arr.value_type)\n    \n    @for_range(n)\n    def _(j):\n        if j < n - 1:\n            cond = j < index\n            new_arr[j] = cond.if_else(arr[j], arr[j + 1])\n        else:\n            new_arr[j] = arr[index]\n    \n    return new_arr\n", "model_name": "deepseek-r1"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n    n = len(arr)\n    for i in range(2, n):\n        cond = (arr[i] > arr[0]) | (arr[i] > arr[1])\n        smaller = arr[0] < arr[1]\n        new_a0 = cond.if_else(smaller.if_else(arr[i], arr[0]), arr[0])\n        new_a1 = cond.if_else(smaller.if_else(arr[1], arr[i]), arr[1])\n        arr[0] = new_a0\n        arr[1] = new_a1\n    return (arr[0] < arr[1]).if_else(arr[0], arr[1])\n", "response_1": "def second_largest(arr):\n    n = len(arr)\n    for i in range(2, n):\n        a0 = arr[0]\n        a1 = arr[1]\n        ai = arr[i]\n        update_cond = (ai > a0) | (ai > a1)\n        lt = a0 < a1\n        cond0 = update_cond * lt\n        cond1 = update_cond * (1 - lt)\n        arr[0] = cond0.if_else(ai, a0)\n        arr[1] = cond1.if_else(ai, a1)\n    lt_final = arr[0] < arr[1]\n    return lt_final.if_else(arr[0], arr[1])\n", "model_name": "deepseek-r1"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    res = sbit(0)\n    for a in arr:\n        res = res | a\n    return res\n", "response_1": "def exists_true(arr):\n    \"\"\"\n    Check whether the secret boolean array contains a True value.\n    \"\"\"\n    ret = sbool(false)\n    for x in arr:\n        ret = ret | x\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr):\n    res = Array(len(arr), sint)\n    for i in range(len(arr)):\n        res[i] = arr[i] > 0  # Example predicate (replace with actual condition)\n    return res\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Returns an Array with the same size as the input Array, where each element\n    is the result of applying the predicator (converted to sint 1/0).\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = predicator(arr[i]).to_sint()\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    summation = sfix(0)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    summation = sfix(0)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "model_name": "deepseek-r1"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    n = len(a)\n    shifted_array = sint.Array(n)\n    for i in range(n):\n        shifted_array[i] = a[(i + 1) % n]\n    return shifted_array\n", "response_1": "def array_shift(a):\n    len_a = len(a)\n    shifted = Array(len_a, a[0].reg_type)\n    for i in range(len_a):\n        index = (i - 1 + len_a) % len_a\n        shifted[i] = a[index]\n    return shifted\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    ret = Array(arr.length, sbit)\n    for i in range(arr.length):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    n = arr.length()\n    res = Array(n, sint)\n    for i in range(n):\n        res[i] = arr[i] > bound\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "count_rises_2", "response_0": "def count_rises(arr):\n    count = sint(0)\n    for i in range(len(arr)-1):\n        count += arr[i] < arr[i+1]\n    return count\n", "response_1": "def count_rises(arr):\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        count += (arr[i] < arr[i+1])\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    size = len(arr)\n    res = sint.Array(size)\n    for i in range(size):\n        if i % 2 == 0:\n            res[i] = arr[i] - 1\n        else:\n            res[i] = arr[i] + 1\n    return res\n", "response_1": "def choppy_plus_minus(arr):\n    size = len(arr)\n    result = Array(size, sint)\n    for i in range(size):\n        if i % 2 == 1:\n            result[i] = arr[i] + 1\n        else:\n            result[i] = arr[i] - 1\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    # Check if a is zero\n    a_zero = a == 0\n    # Handle linear case (a=0)\n    b_zero = b == 0\n    linear_roots = b_zero.if_else(0, 1)\n    \n    # Handle quadratic case (a\u22600)\n    discriminant = b*b - 4*a*c\n    gt_zero = discriminant > 0\n    eq_zero = discriminant == 0\n    quadratic_roots = gt_zero.if_else(2, eq_zero.if_else(1, 0))\n    \n    # Select appropriate result based on a_zero condition\n    return a_zero.if_else(linear_roots, quadratic_roots)\n", "response_1": "def how_many_roots(a, b, c):\n    a_is_zero = a == 0\n    res_a0 = (b == 0).if_else(0, 1)\n    disc = b * b - 4 * a * c\n    disc_gt_0 = disc > 0\n    disc_eq_0 = disc == 0\n    res_else = disc_gt_0.if_else(2, disc_eq_0.if_else(1, 0))\n    return a_is_zero.if_else(res_a0, res_else)\n", "model_name": "deepseek-r1"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicate):\n    res = sint(0)\n    for e in arr:\n        res += predicate(e)\n    return res\n", "response_1": "def count_satisfied(arr, predicate):\n    sum = sint(0)\n    for e in arr:\n        sum += sint(predicate(e))\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    sum = MemValue(sint(0))\n    n = min(arr1.size(), arr2.size())\n    @for_range(n)\n    def _(i):\n        sum.iadd(arr1[i] * arr2[i])\n    return sum.read()\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    sum = 0\n    for i in range(len(arr1)):\n        sum += arr1[i] * arr2[i]\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "array_round", "response_0": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    Returns Array of secret integers (sint)\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i].round_to_int()\n    return ret\n", "response_1": "def array_round(arr):\n    n = arr.size()\n    ret = Array(n, arr.type)\n    for i in range(n):\n        ret[i] = arr[i].round()\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    ret = []\n    for i in range(len(arr)):\n        ret.append(sint(arr[i] >= brr[i]))\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i] >= brr[i]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    return [sint(e < 0) for e in arr]\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import if_else\n\ndef indicate_negative(arr):\n    size = len(arr)\n    res = Array(size, sint)\n    for i in range(size):\n        res[i] = if_else(arr[i] < 0, sint(1), sint(0))\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b):\n    res = []\n    m = min(len(a), len(b))\n    @for_range(m)\n    def _(i):\n        res.append(a[i] - b[i])\n    if len(a) > len(b):\n        @for_range(m, len(a))\n        def _(i):\n            res.append(a[i])\n    else:\n        @for_range(m, len(b))\n        def _(i):\n            res.append(-b[i])\n    return res\n", "response_1": "def array_subtract(a, b):\n    len_a = a.size()\n    len_b = b.size()\n    min_len = min(len_a, len_b)\n    pad_length = abs(len_a - len_b)\n    result = Array(max(len_a, len_b), sint)\n    \n    for i in range(min_len):\n        result[i] = a[i] - b[i]\n    \n    if len_a > len_b:\n        for i in range(pad_length):\n            result[min_len + i] = a[min_len + i]\n    elif len_b > len_a:\n        for i in range(pad_length):\n            result[min_len + i] = -b[min_len + i]\n    \n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "array_process", "response_0": "def array_process(arr):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    res = []\n    for e in arr:\n        res.append(e * 2)  # Example operation, replace with actual processing\n    return res\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    n = len(arr)\n    result = Array(n, sint)\n    for i in range(n):\n        result[i] = func(arr[i])\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    n = a.size()\n    res = Array(n, a.type)\n    res[0] = a[n-1]\n    for i in range(1, n):\n        res[i] = a[i-1]\n    return res\n", "response_1": "def array_shift(a):\n    n = len(a)\n    res = Array(n, a.value_type)\n    res[0] = a[n-1]\n    for i in range(n-1):\n        res[i+1] = a[i]\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    n = len(a)\n    res = Array(n, a.value_type)\n    for i in range(n):\n        res[i] = if_else(a[i] > b[i], a[i], b[i])\n    return res\n", "response_1": "def compare_and_select(a: Array, b: Array, _):\n    ret_array = Array(a.size(), sint)\n    for i in range(a.size()):\n        x = a[i]\n        y = b[i]\n        ret_array[i] = if_else(x > y, x, y)\n    return ret_array\n", "model_name": "deepseek-r1"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    max_len = max(len(a), len(b))\n    a_padded = a + [sfix(0) for _ in range(max_len - len(a))]\n    b_padded = b + [sfix(0) for _ in range(max_len - len(b))]\n    return [x - y for x, y in zip(a_padded, b_padded)]\n", "response_1": "def array_subtract(a, b):\n    pad_length = abs(len(a) - len(b))\n    pad = [sfix(0) for _ in range(pad_length)]\n    if len(a) < len(b):\n        a = a + pad\n    else:\n        b = b + pad\n    return [x - y for x, y in zip(a, b)]\n", "model_name": "deepseek-r1"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    new_length = c.size() * 2\n    res = Array(new_length, c.value_type)\n    for i in range(c.size()):\n        res[i] = c[i]\n        res[i + c.size()] = c[i]\n    return res\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    length = len(c)\n    result = Array(length * 2, c.value_type)\n    for i in range(length):\n        result[i] = c[i]\n        result[i + length] = c[i]\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "zeros", "response_0": "def zeros(num):\n    \"\"\"\n    Return an array of zeros with length num using MP-SPDZ types.\n    \"\"\"\n    from Compiler.types import Array, sfix\n    arr = Array(num, sfix)\n    arr.assign_all(sfix(0))\n    return arr\n", "response_1": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num using secret integers.\n    \"\"\"\n    arr = sint.Array(num)\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound, lower_bound):\n    \"\"\"\n    Clips each element in the array to the range [lower_bound, upper_bound].\n    All values are secret sfix, and bounds are sfix (could be public or secret).\n    \"\"\"\n    return [x.min(upper_bound).max(lower_bound) for x in arr]\n", "response_1": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    Clips the elements of the array to the range [lower_bound, upper_bound]\n    using secure MPC operations. Assumes arr elements are secret values (sfix).\n    \"\"\"\n    res = []\n    for x in arr:\n        # Compute comparison results as secret bits\n        is_upper = x >= upper_bound\n        is_lower = x <= lower_bound\n        \n        # Nested if_else for secure conditional logic\n        clipped = is_upper.if_else(upper_bound, \n            is_lower.if_else(lower_bound, x)\n        )\n        res.append(clipped)\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr):\n    summmation = 0\n    for x in arr:\n        # Replace with actual predicate condition\n        flag = x != 0  # Example predicate: element not equal to zero\n        summmation += flag\n    return summmation\n", "response_1": "def count_satisfied(arr):\n    summmation = sint(0)\n    for x in arr:\n        # Replace with actual predicate condition (e.g., x > 0)\n        flag = x > 0  # Example predicate check\n        summmation += flag.if_else(sint(1), sint(0))\n    return summmation\n", "model_name": "deepseek-r1"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    count = sint(0)\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            count += arr[i] > arr[j]\n    return count\n", "response_1": "def reverse_order_pair(arr):\n    n = len(arr)\n    count = sint(0)\n    for i in range(n):\n        for j in range(i, n):\n            count += (arr[i] > arr[j])\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    n = len(arr)\n    res = arr.value_type.Array(n)\n    for i in range(n):\n        res[i] = arr[i] + 1\n    return res\n", "response_1": "def array_inc(arr):\n    size = len(arr)\n    res = Array(size, sint)\n    for i in range(size):\n        res[i] = arr[i] + 1\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    count = sint(0)\n    n = len(arr)\n    for i in range(n-1):\n        count += (arr[i] < arr[i+1]).if_else(sint(1), sint(0))\n    return count\n", "response_1": "def count_rises(arr):\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        count += arr[i] < arr[i + 1]\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "array_process_2", "response_0": "def array_process(arr, func):\n    res = Array(arr.size(), sint)\n    for i in range(arr.size()):\n        res[i] = func(arr[i])\n    return res\n", "response_1": "def array_process(arr):\n    res = []\n    for x in arr:\n        res.append(x)\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector using secure operations.\n    \"\"\"\n    sum_squares = sfix(0)\n    for item in vec:\n        sum_squares += item * item\n    return sum_squares.sqrt()\n", "response_1": "def two_norm(vec):\n    # Initialize sum with sfix type for secret fixed-point arithmetic\n    sum_squares = sfix(0)\n    # Square each element and accumulate securely\n    for x in vec:\n        sum_squares += x*x\n    # Compute square root using MPC-compatible operation\n    return sum_squares.sqrt()\n", "model_name": "deepseek-r1"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    # Compute minimum of a\n    amin = a[0]\n    for i in range(1, len(a)):\n        cmp = a[i] < amin\n        amin = cmp.if_else(a[i], amin)\n    \n    # Compute maximum of b\n    bmax = b[0]\n    for i in range(1, len(b)):\n        cmp = b[i] > bmax\n        bmax = cmp.if_else(b[i], bmax)\n    \n    # Return comparison result\n    return amin >= bmax\n", "response_1": "def totally_dominate(a, b):\n    # Compute minimum of a\n    amin = a[0]\n    for x in a[1:]:\n        amin = if_else(x < amin, x, amin)\n    \n    # Compute maximum of b\n    bmax = b[0]\n    for x in b[1:]:\n        bmax = if_else(x > bmax, x, bmax)\n    \n    # Return comparison result\n    return amin >= bmax\n", "model_name": "deepseek-r1"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1: Array, vec2: Array):\n    \"\"\"\n    Compute the inner product of two secret-shared arrays.\n    \"\"\"\n    summation = sfix(0)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret arrays.\n    \"\"\"\n    summation = sfix(0)\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "model_name": "deepseek-r1"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"Get the subarray of the input array indicated by secret indices.\"\"\"\n    ret = []\n    for index in indices:\n        element = mux_vect(index, a)\n        ret.append(element)\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    ret = Array(len(indices), a.type)\n    @for_range(len(indices))\n    def _(j):\n        ret[j] = a.get(indices[j])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    result = sbit(0)\n    for item in arr:\n        flag = (item == 5) | (item == 7)\n        result = result | flag\n    return result\n", "response_1": "def exists_5_or_7(arr):\n    flag = sbit(0)\n    for item in arr:\n        check = (item == 5) | (item == 7)\n        flag = flag | check\n    return sint(flag)\n", "model_name": "deepseek-r1"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    n = arr.size()\n    T = arr[0].type\n    new_arr = Array(n - 1, T)\n    for i in range(n - 1):\n        cond = i < index\n        new_arr[i] = cond.if_else(arr[i], arr[i + 1])\n    return new_arr\n", "response_1": "def remove_by_index(arr, index):\n    new_length = arr.size() - 1\n    new_arr = Array(new_length, arr.type)\n    @for_range(new_length)\n    def _(i):\n        cond = sint(i) < index\n        new_arr[i] = cond.if_else(arr[i], arr[i+1])\n    return new_arr\n", "model_name": "deepseek-r1"}
{"test_name": "average", "response_0": "def average(arr):\n    # Initialize sum as a floating-point secret shared value\n    summmation = sfloat(0)\n    # Accumulate secret shared array elements\n    for x in arr:\n        summmation += x\n    # Public array length known to all parties\n    length = len(arr)\n    # Secret shared division by public integer\n    return summmation / length\n", "response_1": "def average(arr):\n    \"\"\"\n    Compute the average value of the array using MP-SPDZ types.\n    \"\"\"\n    summmation = sfix(0)\n    for a in arr:\n        summmation += a\n    length = arr.length()\n    return summmation / length\n", "model_name": "deepseek-r1"}
