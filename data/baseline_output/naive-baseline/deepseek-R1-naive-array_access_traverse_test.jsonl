{"test_name": "indicate_positive", "response_0": "def indicate_positive(arr):\n    \"\"\"\n    For the given array of secret integers, returns an array with 1s where elements \n    are positive and 0s otherwise, maintaining secret integer type throughout.\n    \"\"\"\n    return [arr[i] > 0 for i in range(len(arr))]\n", "response_1": "def indicate_positive(arr):\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        cmp = arr[i] > 0\n        ret[i] = cmp.if_else(sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_xor", "response_0": "def array_xor(a, b):\n    \"\"\"Elementwise XOR of two secret arrays\"\"\"\n    res = Array(len(a), a.value_type)\n    for i in range(len(a)):\n        res[i] = a[i] ^ b[i]\n    return res\n", "response_1": "def array_xor(a, b):\n    ret = Array(len(a), sint)\n    for i in range(len(a)):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "interlaced_placement", "response_0": "def interlaced_placement(a: Array, b: Array) -> Array:\n    n = a.size()\n    ret = Array(2 * n, sint(0))\n    for i in range(2 * n):\n        if i % 2:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "response_1": "def interlaced_placement(a, b):\n    size = a.size\n    ret = Array(2 * size, a.value_type())\n    @for_range(2 * size)\n    def _(i):\n        if i % 2:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_and", "response_0": "def array_and(a, b):\n    return [sint((a[i] != 0) * (b[i] != 0)) for i in range(len(a))]\n", "response_1": "def array_and(a, b):\n    \"\"\"\n    Compute the elementwise logical AND of two secret integer vectors, returning 1 if both elements are non-zero, 0 otherwise.\n    \"\"\"\n    n = len(a)\n    return [sint((a[i] * b[i]) != 0) for i in range(n)]\n", "model_name": "deepseek-r1"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr, predicator):\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    ret = Array(arr.size(), sbit)\n    @for_range(arr.size())\n    def _(i):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        cmp = arr[i].greater_than(bound)\n        ret[i] = cmp.if_else(sint(1), sint(0))\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    res = sint.Array(n)\n    for i in range(n):\n        res[i] = arr[i] > bound\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "array_no_greater_than_scalar", "response_0": "def array_no_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = Array(n, sbit)\n    for i in range(n):\n        ret[i] = arr[i] <= bound\n    return ret\n", "response_1": "def array_no_greater_than_scalar(arr, bound):\n    ret = []  # Use list instead of pre-allocating for SPDZ compatibility\n    for i in range(len(arr)):\n        ret.append(arr[i] <= bound)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    l = len(a)\n    b = Array(l, a.value_type)\n    for i in range(l):\n        b[i] = a[l-1 -i]\n    result = Array(2 * l, a.value_type)\n    for i in range(l):\n        result[i] = a[i]\n    for i in range(l):\n        result[l + i] = b[i]\n    return result\n", "response_1": "def reverse_and_concat(a):\n    \"\"\"\n    Reverse the input array and concatenate it to the original array.\n    \"\"\"\n    n = len(a)\n    b = Array(n, a.value_type)\n    for i in range(n):\n        b[i] = a[n - 1 - i]\n    \n    result = Array(2 * n, a.value_type)\n    for i in range(n):\n        result[i] = a[i]\n    for i in range(n):\n        result[n + i] = b[i]\n    \n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "array_round", "response_0": "def array_round(arr):\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        int_part = arr[i].floor()\n        fractional = arr[i] - sfix(int_part)\n        condition = fractional < sfix(0.5)\n        ret[i] = condition.if_else(int_part, int_part + 1)\n    return ret\n", "response_1": "def array_round(arr):\n    f = sfix.f\n    res = sint.Array(len(arr))\n    for i in range(len(arr)):\n        x = arr[i].v\n        int_part = x.bit_shift_right(f)\n        frac_scaled = x - (int_part << f)\n        threshold = 2 ** (f - 1)\n        res[i] = int_part + (frac_scaled >= threshold)\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    n = len(arr)\n    res = sint.Array(n)\n    for i in range(n):\n        res[i] = arr[i] >= brr[i]\n    return res\n", "response_1": "def array_greater_eq(arr, brr):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        ret[i] = arr[i].greater_equal(brr[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "reverse", "response_0": "def reverse(arr):\n    n = arr.length\n    ret = Array(n, arr.value_type())\n    for i in for_range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "response_1": "def reverse(arr):\n    n = len(arr)\n    ret = Array(n, arr.value_type())\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] < 0\n    return ret\n", "response_1": "def indicate_negative(arr):\n    \"\"\"\n    For the given array of secret values, return an array with the same size where\n    each element is 1 if the corresponding input element is negative, 0 otherwise.\n    \"\"\"\n    size = len(arr)\n    ret = Array(size, sfix)\n    for i in range(size):\n        # Compare if element is negative and convert sbit to sfix (1/0)\n        ret[i] = (arr[i] < 0).if_else(sfix(1), sfix(0))\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "max_sub_sequence", "response_0": "def max_sub_sequence(arr):\n    n = len(arr)\n    partial_max = Array(n, sint)\n    suffix_max = Array(n, sint)\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    \n    for i in for_range(1, n):\n        # Update suffix_max[i]\n        prev_suffix = suffix_max[i-1]\n        cond1 = prev_suffix >= 0\n        new_suffix = cond1.if_else(prev_suffix + arr[i], arr[i])\n        suffix_max[i] = new_suffix\n        \n        # Update partial_max[i]\n        prev_partial = partial_max[i-1]\n        current_suffix = suffix_max[i]\n        cond2 = prev_partial >= current_suffix\n        partial_max[i] = cond2.if_else(prev_partial, current_suffix)\n    \n    return partial_max[n-1]\n", "response_1": "def max_sub_sequence(arr):\n    n = len(arr)\n    partial_max = Array(n, sint)\n    suffix_max = Array(n, sint)\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    for i in range(1, n):\n        suffix_prev = suffix_max[i-1]\n        # Calculate condition (secret integer 0/1)\n        condition = suffix_prev >= 0\n        # Compute current suffix max using arithmetic selection\n        suffix_current = arr[i] + condition * suffix_prev\n        suffix_max[i] = suffix_current\n        # Compute current partial max using built-in max\n        partial_current = max(partial_max[i-1], suffix_current)\n        partial_max[i] = partial_current\n    return partial_max[n-1]\n", "model_name": "deepseek-r1"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    n = a.size()\n    ret_array = Array(n, sint)\n    for i in range(n):\n        ret_array[i] = if_else(a[i] > b[i], a[i], b[i])\n    return ret_array\n", "response_1": "def compare_and_select(a, b):\n    ret_array = Array(len(a), sint(0))\n    for i in range(len(a)):\n        comp = a[i] > b[i]\n        ret_array[i] = mux(comp, a[i], b[i])\n    return ret_array\n", "model_name": "deepseek-r1"}
{"test_name": "count_element_frequency", "response_0": "def count_element_frequency(l):\n    n = len(l)\n    ret = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        ret[i] = sint(0)\n        @for_range(n)\n        def _(j):\n            eq = l[j].equal(l[i])\n            ret[i] = ret[i] + eq\n    return ret\n", "response_1": "def count_element_frequency(l):\n    n = len(l)\n    ret = Array(n, sint)\n    for i in range(n):\n        total = sint(0)\n        for j in range(n):\n            total += (l[j] == l[i]) * 1\n        ret[i] = total\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_or", "response_0": "def array_or(a,b):\n    ret = Array(len(a), sint)\n    for i in range(len(a)):\n        ret[i] = a[i] + b[i] - a[i] * b[i]\n    return ret\n", "response_1": "def array_or(a, b):\n    ret = Array(len(a), sbits)\n    for i in range(len(ret)):\n        ret[i] = a[i] | b[i]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "stock_predicator", "response_0": "def stock_predicator(days):\n    n = days.size()\n    lowest = Array(n, sint)\n    partial_max = Array(n, sint)\n    lowest[0] = days[0]\n    \n    for i in range(1, n):\n        lowest[i] = sint.min(lowest[i-1], days[i])\n        current_profit = days[i] - lowest[i-1]\n        partial_max[i] = sint.max(partial_max[i-1], current_profit)\n    \n    max_profit = partial_max[n-1]\n    return sint.max(max_profit, 0)\n", "response_1": "def stock_predicator(days):\n    n = len(days)\n    lowest = Array(n, sint)\n    partial_max = Array(n, sint)\n    \n    lowest[0] = days[0]\n    partial_max[0] = sint(0)\n    \n    for i in range(1, n):\n        current_profit = days[i] - lowest[i-1]\n        partial_max[i] = partial_max[i-1].max(current_profit)\n        lowest[i] = lowest[i-1].min(days[i])\n    \n    final_result = partial_max[n-1].max(sint(0))\n    return final_result\n", "model_name": "deepseek-r1"}
{"test_name": "len5_inc_array", "response_0": "def len5_inc_array(init):\n    \"\"\"Return an increase-by-one array with given initial element and length 5.\"\"\"\n    ret = type(init).Array(5)\n    for i in range(5):\n        ret[i] = init + i\n    return ret\n", "response_1": "def len5_inc_array(init):\n    \"\"\"\n    Return an increase-by-one array with given initial element and length 5.\n    \"\"\"\n    ret = Array(5, cint)\n    for i in range(5):\n        ret[i] = init + i\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "cut_first_five", "response_0": "def cut_first_five(arr):\n    # Truncate to first 5 elements, then pad with zeros and take first 5\n    truncated = arr[:5]\n    padded = truncated + [sint(0)] * 5\n    return padded[:5]\n", "response_1": "def cut_first_five(arr):\n    res = []\n    T = type(arr[0]) if len(arr) > 0 else sint  # Default to secret type if empty\n    for i in range(5):\n        res.append(T(0))\n    for i in range(min(5, len(arr))):\n        res[i] = arr[i]\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "max_pooling_1d", "response_0": "template<class T>\nArray<T> max_pooling_1d(Array<T>& vec, int step) {\n    int ret_length = vec.size() / step;\n    Array<T> ret(ret_length);\n    for (int i = 0; i < ret_length; ++i) {\n        T current_max = vec[i * step];\n        for (int j = 1; j < step; ++j) {\n            T candidate = vec[i * step + j];\n            current_max = (current_max > candidate).if_else(current_max, candidate);\n        }\n        ret[i] = current_max;\n    }\n    return ret;\n}\n", "response_1": "def max_pooling_1d(vec, step):\n    ret_length = vec.size() // step\n    ret = Array(ret_length, sint)\n    for i in range(ret_length):\n        start = i * step\n        max_val = vec[start]\n        for j in range(1, step):\n            current = vec[start + j]\n            max_val = max_val.max(current)\n        ret[i] = max_val\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_greater", "response_0": "def array_greater(arr, brr):\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] > brr[i])\n    return ret\n", "response_1": "def array_greater(arr, brr):\n    ret = sint.Array(len(arr))\n    @for_range(len(arr))\n    def _(i):\n        ret[i] = arr[i] > brr[i]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "dumb_concat", "response_0": "def dumb_concat(arr, brr):\n    ret = Vector()\n    n = arr.size()\n    m = brr.size()\n    @for_range_opt(n)\n    def _(i):\n        ret.push_back(arr[i])\n    @for_range_opt(m)\n    def _(j):\n        ret.push_back(brr[j])\n    return ret\n", "response_1": "def dumb_concat(arr, brr):\n    \"\"\"Concatenate the second array to the first array in a dumb way.\"\"\"\n    n = arr.size()\n    m = brr.size()\n    length = n + m\n    ret = sint.Array(length)\n    for i in range(n):\n        ret[i] = arr[i]\n    for j in range(m):\n        ret[n + j] = brr[j]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "indicator_if_else", "response_0": "def indicator_if_else(a, b, ind):\n    c = sint.Array(len(ind))\n    @for_range(len(ind))\n    def _(i):\n        c[i] = ind[i].if_else(a[i], b[i])\n    return c\n", "response_1": "def indicator_if_else(a, b, ind):\n    c = sint.Array(len(ind))\n    @for_range(len(ind))\n    def _(i):\n        c[i] = ind[i] * a[i] + (1 - ind[i]) * b[i]\n    return c\n", "model_name": "deepseek-r1"}
{"test_name": "elementwise_multiplication", "response_0": "def elementwise_multiplication(a, b):\n    n = a.size()\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "def elementwise_multiplication(a, b):\n    \"\"\"Compute the elementwise multiplication of two secret integer arrays.\"\"\"\n    ret = Array(len(a), sint)\n    for i in range(len(a)):\n        ret[i] = a[i] * b[i]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    ret = Array(len(indices), a.type)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    n = len(indices)\n    T = a.value_type()\n    ret = Array(n, T)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "inc_array", "response_0": "def inc_array(num):\n    \"\"\"\n    Return an array with length num and elements 1 to num. \n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    return Array(num, cint).set_values([i+1 for i in range(num)])\n", "response_1": "def inc_array(num):\n    \"\"\"Returns Array[SecretInteger] with values 1 to num\"\"\"\n    return [sint(i+1) for i in range(num)]\n", "model_name": "deepseek-r1"}
{"test_name": "cut_last_five", "response_0": "def cut_last_five(arr):\n    res = Array(5, sint(0))\n    n = len(arr)\n    if n >= 5:\n        for i in range(5):\n            res[i] = arr[n - 5 + i]\n    else:\n        for i in range(n):\n            res[5 - n + i] = arr[i]\n    return res\n", "response_1": "def cut_last_five(arr, length):\n    ret = Array(5, sint(0))\n    for i in range(5):\n        idx = length - 1 - i\n        in_bounds = (idx >= 0) * (idx < length)\n        element = arr[idx] * in_bounds\n        ret[4 - i] = element\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "average_pooling_1d", "response_0": "def average_pooling_1d(vec, step):\n    MAX_STEP = 10  # Set to maximum possible step size\n    assert_step(step <= MAX_STEP)\n    ret_length = vec.length // step\n    ret = Array(ret_length, sfix)\n    \n    @for_range(ret_length)\n    def _(i):\n        sum = sfix(0)\n        @for_range(MAX_STEP)\n        def _(j):\n            current_j = regint(j)\n            cond = current_j < step\n            idx = i * step + current_j\n            sum += vec[idx] * cond\n        ret[i] = sum * (1 / cfix(step, val_type=cfix))\n    \n    return ret\n", "response_1": "def average_pooling_1d(vec, step):\n    ret_length = len(vec) // step\n    ret = Array(ret_length, sfix)\n    inv_step = sfix(1) / step\n    for i in range(ret_length):\n        sum = sfix(0)\n        for j in range(step):\n            sum += vec[i*step + j]\n        ret[i] = sum * inv_step\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_relu", "response_0": "def array_relu(arr):\n    ret = Array(len(arr), 0)\n    for i in range(len(arr)):\n        ret[i] = mux(arr[i] >= 0, arr[i], 0)\n    return ret\n", "response_1": "def array_relu(arr):\n    \"\"\"\n    Apply ReLU function elementwisely to the input array.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        comp = arr[i] >= 0\n        ret[i] = arr[i] * comp\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    temp = arr[index]\n    for i in range(index + 1, len(arr)):\n        arr[i - 1] = arr[i]\n    arr[len(arr) - 1] = temp\n    return arr\n", "response_1": "def move_to_end(arr, index):\n    temp = arr[index]\n    n = len(arr)\n    @for_range_opt(n - index - 1)\n    def _(i):\n        arr[index + i] = arr[index + i + 1]\n    arr[-1] = temp\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "set_to_zero", "response_0": "def set_to_zero(arr, index):\n    arr[index] = sint(0)\n    return arr\n", "response_1": "def set_to_zero(arr, index):\n    \"\"\"\n    Set the element in the input array with given index to zero.\n    The input index is guaranteed to be legal. \n    \"\"\"\n    # Create zero value matching array's secret type\n    zero = regint(0) if isinstance(arr[0], regint) else sfix(0) if isinstance(arr[0], sfix) else sint(0)\n    arr[index] = zero\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "last_partial_sum", "response_0": "def last_partial_sum(arr, n):\n    ret = sint(0)\n    for i in range(len(arr)-n, len(arr)):\n        ret += arr[i]\n    return ret\n", "response_1": "def last_partial_sum(arr: sint.Array, n: cint) -> sint:\n    start = arr.length() - n\n    sum = sint(0)\n    @for_range(n)\n    def _(i):\n        sum.iadd(arr[start + i])\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "permute_by_indices", "response_0": "def permute_by_indices(a, indices):\n    ret = Array(len(a), a.value_type())\n    for i in range(len(a)):\n        ret[i] = a.get(indices[i])\n    return ret\n", "response_1": "def permute_by_indices(a, indices):\n    n = len(a)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "get_rank", "response_0": "def get_rank(arr, index):\n    target = arr[index]\n    rank = sint(0)\n    for item in arr:\n        rank += (item < target)\n    return rank\n", "response_1": "def get_rank(arr, index):\n    pivot = arr[index]\n    rank = sint(0)\n    for item in arr:\n        rank += (item < pivot)\n    return rank\n", "model_name": "deepseek-r1"}
{"test_name": "interchange_by_indices", "response_0": "", "response_1": "def interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange the two elements in the array with given indices. \n    The input indices are guaranteed to be legal. \n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "increase_by", "response_0": "def increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    # MP-SPDZ uses direct assignment for public indexes\n    current = arr[index]\n    new_value = current + k\n    arr.set(index, new_value)\n    return arr\n", "response_1": "def increase_by(arr, index, k):\n    arr[index] = arr[index] + k\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "retrieve_by_index", "response_0": "def retrieve_by_index(arr, index):\n    result = sint(0)\n    n = len(arr)\n    for i in range(n):\n        cond = (index == i)\n        result += cond * arr[i]\n    return result\n", "response_1": "def retrieve_by_index(arr, index):\n    return arr[index]\n", "model_name": "deepseek-r1"}
{"test_name": "scale_by", "response_0": "def scale_by(arr, index, k):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n", "response_1": "def scale_by(arr, index, k):\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "take_opposite_to", "response_0": "def take_opposite_to(arr, index):\n    arr[index] = -arr[index]\n    return arr\n", "response_1": "def take_opposite_to(arr, index):\n    arr[index] = -arr[index]\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "array_rank", "response_0": "def array_rank(l):\n    n = len(l)\n    ret = Array(n, sint)\n    for i in range(n):\n        sum = sint(0)\n        for j in range(n):\n            sum += (l[j] < l[i]).if_else(1, 0)\n        ret[i] = sum\n    return ret\n", "response_1": "def array_rank(l):\n    n = len(l)\n    ret = sint.Array(n)\n    @for_range(n)\n    def _(i):\n        @for_range(n)\n        def _(j):\n            ret[i] += (l[j] < l[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    new_length = arr.size() - 1\n    res = Array(new_length, arr.value_type())\n    for i in range(new_length):\n        cond = i < index\n        res[i] = cond.if_else(arr[i], arr[i+1])\n    return res\n", "response_1": "def remove_by_index(arr, index):\n    new_len = arr.size() - 1\n    res = Array(new_len, sfix)\n    for i in range(new_len):\n        cond = i < index\n        res[i] = cond.if_else(arr[i], arr[i+1])\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "process_by_index", "response_0": "def process_by_index(arr, index, func):\n    new_arr = Array(len(arr), sint)\n    for i in range(len(arr)):\n        cond = sint(i) == index\n        new_val = func(arr[i])\n        new_arr[i] = cond.if_else(new_val, arr[i])\n    return new_arr\n", "response_1": "def process_by_index(arr, index):\n    size = len(arr)\n    new_arr = Array(size, arr.type)\n    for i in range(size):\n        current = arr[i]\n        is_target = i == index\n        # Apply your specific function to 'current' here\n        modified = current  # Replace with func(current)\n        new_val = is_target.if_else(modified, current)\n        new_arr[i] = new_val\n    return new_arr\n", "model_name": "deepseek-r1"}
{"test_name": "sum_by_indices", "response_0": "def sum_by_indices(arr, indices):\n    sum = sint(0)\n    for index in indices:\n        sum = sum + arr[index]\n    return sum\n", "response_1": "def sum_by_indices(arr, indices):\n    sum = sint(0)\n    for index in indices:\n        sum += arr[index]\n    return sum\n", "model_name": "deepseek-r1"}
