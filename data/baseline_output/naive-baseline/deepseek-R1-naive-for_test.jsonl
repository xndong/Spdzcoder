{"test_name": "multiply_first_five", "response_0": "def multiply_first_five(array):\n    prod = MemValue(cint(1))\n    max_loop = min(array.size, 5)\n    @for_range(max_loop)\n    def _(i):\n        prod.write(prod.read() * array[i])\n    return prod.read()\n", "response_1": "def multiply_first_five(array):\n    prod = 1\n    n = min(5, array.size())\n    for i in range(n):\n        prod *= array[i]\n    return prod\n", "model_name": "deepseek-r1"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n    # Handle first two elements\n    c = arr[0] >= arr[1]\n    largest = c.if_else(arr[0], arr[1])\n    second = c.if_else(arr[1], arr[0])\n    \n    # Iterate through remaining elements\n    for i in range(2, len(arr)):\n        current = arr[i]\n        ge_largest = current >= largest\n        new_largest = ge_largest.if_else(current, largest)\n        \n        # Calculate potential new second\n        ge_second = current >= second\n        temp_second = ge_second.if_else(current, second)\n        new_second = ge_largest.if_else(largest, temp_second)\n        \n        # Update values for next iteration\n        largest = new_largest\n        second = new_second\n    \n    return second\n", "response_1": "def second_largest(arr):\n    n = len(arr)\n    # Initialize with first two elements\n    condition_init = arr[0] >= arr[1]\n    largest = condition_init.if_else(arr[0], arr[1])\n    second = condition_init.if_else(arr[1], arr[0])\n    \n    for i in range(2, n):\n        x = arr[i]\n        # Compare with current largest\n        condition1 = x >= largest\n        new_largest = condition1.if_else(x, largest)\n        new_second_candidate = condition1.if_else(largest, second)\n        \n        # Compare with current second candidate\n        condition2 = x >= new_second_candidate\n        new_second = condition2.if_else(x, new_second_candidate)\n        \n        # Update values for next iteration\n        largest = new_largest\n        second = new_second\n    \n    return second\n", "model_name": "deepseek-r1"}
{"test_name": "partial_sum", "response_0": "def partial_sum(arr):\n    partial = sint(0)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "def partial_sum(arr):\n    partial = sfix(0)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "max_adjacent_product", "response_0": "def max_adjacent_product(arr):\n    max_prod = arr[0] * arr[1]\n    n = len(arr)\n    for i in range(n-1):\n        product = arr[i] * arr[i+1]\n        greater = product > max_prod\n        max_prod = mux(greater, product, max_prod)\n    return max_prod\n", "response_1": "def max_adjacent_product(arr):\n    cur = arr[0] * arr[1]\n    for i in range(len(arr)-1):\n        prod = arr[i] * arr[i+1]\n        cur = (prod > cur).if_else(prod, cur)\n    return cur\n", "model_name": "deepseek-r1"}
{"test_name": "argmax", "response_0": "def argmax(a):\n    current = a[0]\n    index = 0\n    for i in range(len(a)):\n        greater = a[i] > current\n        index = mux(greater, i, index)\n        current = mux(greater, a[i], current)\n    return index\n", "response_1": "def argmax(a):\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        condition = current >= a[i]\n        index = mux(condition, index, sint(i))\n        current = mux(condition, current, a[i])\n    return index\n", "model_name": "deepseek-r1"}
{"test_name": "count_distinct", "response_0": "def count_distinct(arr):\n    counter = sfix(0)\n    n = len(arr)\n    for i in range(n):\n        unique = sfix(1)\n        for j in range(i):\n            eq = arr[j] == arr[i]\n            term = sfix(1) - eq.if_else(sfix(1), sfix(0))\n            unique = unique * term\n        counter += unique\n    return counter\n", "response_1": "def count_distinct(arr):\n    N = len(arr)\n    counter = sint(0)\n    for i in range(N):\n        unique = sint(1)\n        for j in range(i):\n            eq = arr[j] == arr[i]\n            unique *= 1 - eq\n        counter += unique\n    return counter\n", "model_name": "deepseek-r1"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    ret = sint(0)\n    for item in arr:\n        ret = ret | item\n    return ret\n", "response_1": "def exists_true(arr):\n    \"\"\"\n    Check whether the secret boolean array contains a True value.\n    \"\"\"\n    ret = sbit(0)\n    for item in arr:\n        ret = ret | item\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "range", "response_0": "def range(arr):\n    max_value = arr[0]\n    min_value = arr[0]\n    n = arr.size()\n    for i in range(1, n):\n        item = arr[i]\n        max_value = mux(max_value >= item, max_value, item)\n        min_value = mux(min_value <= item, min_value, item)\n    return max_value - min_value\n", "response_1": "def range(arr):\n    max_val = arr[0]\n    min_val = arr[0]\n    for item in arr:\n        max_val = mux(item > max_val, item, max_val)\n        min_val = mux(item < min_val, item, min_val)\n    return max_val - min_val\n", "model_name": "deepseek-r1"}
{"test_name": "count_larger_than_5", "response_0": "def count_larger_than_5(arr):\n    counter = sint(0)\n    for item in arr:\n        cmp = item > 5\n        counter += cmp.if_else(sint(1), sint(0))\n    return counter\n", "response_1": "def count_larger_than_5(arr):\n    counter = sint(0)\n    for item in arr:\n        counter += sint(item > 5)\n    return counter\n", "model_name": "deepseek-r1"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr):\n    max_val = sint(0)\n    sum_val = sint(0)\n    for item in arr:\n        abs_item = sabs(item)\n        max_val = max(max_val, abs_item)\n        sum_val += abs_item\n    return (2 * max_val > sum_val).reveal()\n", "response_1": "def exists_dominator(arr):\n    max_val = sint(0)\n    total_sum = sint(0)\n    for item in arr:\n        abs_item = sabs(item)\n        total_sum += abs_item\n        max_val = max(max_val, abs_item)\n    twice_max = max_val * 2\n    return twice_max > total_sum\n", "model_name": "deepseek-r1"}
{"test_name": "greedy_picker", "response_0": "def greedy_picker(items, captivity):\n    num = sint(0)\n    for item in items:\n        cond = item <= captivity\n        captivity -= cond * item\n        num += cond\n    return num\n", "response_1": "def greedy_picker(items, captivity):\n    num = sint(0)\n    for item in items:\n        cond = item <= captivity\n        captivity = cond.if_else(captivity - item, captivity)\n        num += cond.if_else(sint(1), sint(0))\n    return num\n", "model_name": "deepseek-r1"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s: sfix, l: Array):\n    \"\"\"\n    Add all elements in the array to the scalar (sfix) and return the result.\n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n", "response_1": "def scalar_add_array(s: sint, l: Array):\n    for item in l:\n        s = s + item\n    return s\n", "model_name": "deepseek-r1"}
{"test_name": "is_equidistant_seq", "response_0": "def is_equidistant_seq(arr):\n    n = len(arr)\n    if n <= 1:\n        return sint(1)\n    d = arr[1] - arr[0]\n    flag = sint(0)\n    for i in range(n-1):\n        current_diff = arr[i+1] - arr[i]\n        if i > 0:\n            not_equal = (current_diff != d).if_else(sint(1), sint(0))\n            flag += not_equal\n        d = current_diff\n    return (flag == 0).if_else(sint(1), sint(0))\n", "response_1": "def is_equidistant_seq(arr):\n    n = len(arr)\n    if n <= 1:\n        return 1\n    differences = Array(n-1, sint)\n    for i in range(n-1):\n        differences[i] = arr[i+1] - arr[i]\n    d = differences[0]\n    all_equal = 1\n    for i in range(1, len(differences)):\n        all_equal = all_equal * (differences[i] == d)\n    return all_equal\n", "model_name": "deepseek-r1"}
{"test_name": "inner_product", "response_0": "from util import for_range\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of two secret-shared arrays.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(vec1.size())\n    def _(i):\n        sum.iadd(vec1[i] * vec2[i])\n    return sum\n", "response_1": "def inner_product(vec1, vec2):\n    sum = 0\n    for i in range(len(vec1)):\n        sum += vec1[i] * vec2[i]\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "more_distinct_nonnegative", "response_0": "def more_distinct_nonnegative(arr):\n    nonnegative_counter = cint(0)\n    negative_counter = cint(0)\n    n = len(arr)\n    for i in range(n):\n        unique = cint(1)\n        for j in range(i):\n            unique *= (arr[i] != arr[j])\n        is_nonnegative = arr[i] >= 0\n        nonnegative_counter += unique * is_nonnegative\n        negative_counter += unique * (1 - is_nonnegative)\n    return nonnegative_counter > negative_counter\n", "response_1": "def more_distinct_nonnegative(arr):\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    n = len(arr)\n    for i in range(n):\n        is_unique = sint(1)\n        for j in range(i):\n            eq = (arr[j] == arr[i])\n            is_unique = is_unique * (1 - eq)\n        is_nonneg = arr[i] >= 0\n        nonnegative_counter += is_unique * is_nonneg\n        negative_counter += is_unique * (1 - is_nonneg)\n    return nonnegative_counter > negative_counter\n", "model_name": "deepseek-r1"}
{"test_name": "flip_positives", "response_0": "def flip_positives(array):\n    for i in range(len(array)):\n        condition = array[i] > 0\n        multiplier = 1 - 2 * sint(condition)\n        array[i] = array[i] * multiplier\n    return array\n", "response_1": "def flip_positives(array):\n    for i in range(len(array)):\n        # Compute secure multiplier (-1 for positive, 1 otherwise)\n        multiplier = 1 - 2 * (array[i] > 0)\n        # Apply secure multiplier without branching\n        array[i] = array[i] * multiplier\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "divide_and_plus", "response_0": "def divide_and_plus(x):\n    # Scaling factor for fixed-point arithmetic\n    s = 2**20\n    # Scale the input\n    x_scaled = x * s\n    for _ in range(4):\n        # Integer division by 2\n        x_scaled = x_scaled / 2\n        # Add scaled value of 1\n        x_scaled += s\n    return x_scaled\n", "response_1": "def divide_and_plus(x):\n    for _ in range(4):\n        x = x / sfix(2)\n        x = x + sfix(1)\n    return x\n", "model_name": "deepseek-r1"}
{"test_name": "array_log2", "response_0": "def array_log2(arr):\n    for i in range(len(arr)):\n        arr[i] = arr[i].flog2()\n    return arr\n", "response_1": "def array_log2(arr):\n    \"\"\"Take logarithm with base two to all elements in the input array.\"\"\"\n    import math\n    ln2 = sfloat(math.log(2))\n    result = []\n    for x in arr:\n        result.append(x.ln() / ln2)\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "sum_to_ten", "response_0": "def sum_to_ten(array):\n    sum = sbitint(0)\n    done = sbitint(0)\n    for i in range(len(array)):\n        new_sum = sum + array[i]\n        sum = done.if_else(sum, new_sum)\n        done = done | (sum >= 10)\n    return sum\n", "response_1": "def sum_to_ten(array):\n    sum = sint(0)\n    active = sint(1)\n    for i in range(len(array)):\n        current = array[i] * active\n        sum += current\n        cond = sum >= 10\n        cond_sint = cond.if_else(sint(1), sint(0))\n        active = active * (sint(1) - cond_sint)\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    for i in range(len(arr)):\n        if i % 2:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "def choppy_plus_minus(arr):\n    for i in range(len(arr)):\n        if i % 2:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "min_element", "response_0": "def min_element(a):\n    current = a[0]\n    for item in a:\n        bit = current <= item\n        current = mux(bit, current, item)\n    return current\n", "response_1": "def min_element(a):\n    current = a[0]\n    for i in range(len(a)):\n        current = mux(current <= a[i], current, a[i])\n    return current\n", "model_name": "deepseek-r1"}
{"test_name": "soft_max", "response_0": "def soft_max(arr):\n    from mpc_math import fxp_exp, fxp_div\n    denominator = sfix(0)\n    for item in arr:\n        denominator += fxp_exp(item)\n    return [fxp_div(fxp_exp(x), denominator) for x in arr]\n", "response_1": "def soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array.\n    \"\"\"\n    denominator = sfix(0)\n    for item in arr:\n        denominator += exp_fx(item)\n    \n    brr = []\n    for item in arr:\n        brr.append(exp_fx(item) / denominator)\n    return brr\n", "model_name": "deepseek-r1"}
{"test_name": "count_reverse_pair_with_break", "response_0": "def count_reverse_pair_with_break(arr):\n    count = sint(0)\n    break_flag = sint(0)\n    n = len(arr)\n    for i in range(1, n):\n        is_active = break_flag == 0\n        current_break = is_active * (arr[i] > 10)\n        break_flag = break_flag + current_break - break_flag * current_break\n        process_inner = is_active * (1 - current_break)\n        for j in range(i):\n            count += process_inner * (arr[j] > arr[i])\n    return count\n", "response_1": "def count_reverse_pair_with_break(arr):\n    count = sint(0)\n    break_flag = sbit(0)\n    n = len(arr)\n    for i in range(1, n):\n        with if_(break_flag == 0):\n            current_break = arr[i] > 10\n            new_break = break_flag | current_break\n            break_flag.update(new_break)\n            with if_(current_break == 0):\n                for j in range(i):\n                    count += (arr[j] > arr[i]).if_else(sint(1), sint(0))\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "sum_unique", "response_0": "def sum_unique(arr):\n    sum_total = sint(0)\n    n = len(arr)\n    for i in range(n):\n        sum_duplicates = sint(0)\n        for j in range(n):\n            if j != i:\n                eq = arr[j] == arr[i]\n                sum_duplicates += eq\n        is_duplicate = sum_duplicates != 0\n        sum_total += arr[i] * (1 - is_duplicate)\n    return sum_total\n", "response_1": "def sum_unique(arr):\n    sum = sint(0)\n    n = len(arr)\n    for i in range(n):\n        sum_duplicates = sint(0)\n        for j in range(n):\n            sum_duplicates += (j != i) * (arr[j] == arr[i])\n        unique = sum_duplicates == 0\n        sum += arr[i] * unique\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "check_sum", "response_0": "def check_sum(array, target):\n    sum = sint(0)\n    for num in array:\n        sum += num\n    return sum == target\n", "response_1": "def check_sum(array, target):\n    sum = sint(0)\n    for num in array:\n        sum += num\n    return sum == target\n", "model_name": "deepseek-r1"}
{"test_name": "prod", "response_0": "def prod(array):\n    product = sint(1)\n    for num in array:\n        product *= num\n    return product\n", "response_1": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array. \n    \"\"\"\n    prod = sint(1)\n    for num in array:\n        prod = prod * num\n    return prod\n", "model_name": "deepseek-r1"}
{"test_name": "sum_till_negative", "response_0": "def sum_till_negative(array):\n    sum = sint(0)\n    flag = sint(1)\n    for i in range(len(array)):\n        current = array[i]\n        is_negative = current < 0\n        not_negative = 1 - is_negative\n        can_add = flag * not_negative\n        sum += current * can_add\n        flag = flag * not_negative\n    return sum\n", "response_1": "def sum_till_negative(array):\n    sum = sfix(0)\n    found_negative = sbit(0)\n    for element in array:\n        element_negative = element < 0\n        add_condition = (found_negative == 0) * (element_negative == 0)\n        sum += add_condition.if_else(element, sfix(0))\n        found_negative = found_negative + element_negative - found_negative * element_negative\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr):\n    sum = MemValue(0)\n    @for_range(len(arr))\n    def _(i):\n        # Replace the following condition with the actual predicate logic\n        condition = arr[i] > 0  # Example condition (modify as needed)\n        sum.iadd(condition)\n    return sum.read()\n", "response_1": "def count_satisfied(arr):\n    sum = sint(0)\n    for i in range(len(arr)):\n        # Replace the following line with your specific condition\n        condition = arr[i] > 0  # Example predicate check\n        sum += condition\n    return sum.reveal()\n", "model_name": "deepseek-r1"}
{"test_name": "standard_deviation", "response_0": "def standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    avg = sfloat(0)\n    for item in arr:\n        avg += item\n    avg = avg / len(arr)\n    \n    var = sfloat(0)\n    for item in arr:\n        diff = item - avg\n        var += diff * diff\n    var = var / len(arr)\n    \n    return var.sqrt()\n", "response_1": "def standard_deviation(arr):\n    # Compute average\n    sum_total = sfix(0)\n    for item in arr:\n        sum_total += item\n    average = sum_total / arr.size\n    \n    # Compute variance\n    variance_sum = sfix(0)\n    for item in arr:\n        diff = item - average\n        variance_sum += diff * diff\n    variance = variance_sum / arr.size\n    \n    # Return standard deviation\n    return variance.sqrt()\n", "model_name": "deepseek-r1"}
{"test_name": "dominate", "response_0": "def dominate(a, b):\n    all_dominate = 1\n    for i in range(len(a)):\n        all_dominate = all_dominate * (a[i] >= b[i])\n    return all_dominate\n", "response_1": "def dominate(a, b):\n    res = 1\n    for i in range(len(a)):\n        res = res * (a[i].greater_equal(b[i]))\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = brr[0].absolute()\n    for item in brr[1:]:\n        current_abs = item.absolute()\n        max_abs = (current_abs > max_abs).if_else(current_abs, max_abs)\n    \n    res = Array(len(brr), sfix)\n    @for_range(len(brr))\n    def _(i):\n        res[i] = brr[i] / max_abs\n    return res\n", "response_1": "def rescale(brr):\n    max_abs = sfix(0)\n    for item in brr:\n        abs_item = item.abs()\n        max_abs = max_abs.max(abs_item)\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "model_name": "deepseek-r1"}
{"test_name": "array_minus7", "response_0": "def array_minus7(arr):\n    res = Array(len(arr), arr.value_type)\n    for i in range(len(arr)):\n        res[i] = arr[i] - 7\n    return res\n", "response_1": "def array_minus7(arr):\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    sum = sfix(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum += arr1[i] * arr2[j]\n    return sum\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    sum = sint(0)\n    for i in range(arr1.size()):\n        for j in range(arr2.size()):\n            sum += arr1[i] * arr2[j]\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "longest_nondec_subseq", "response_0": "def longest_nondec_subseq(a):\n    n = len(a)\n    max_length = sint(0)\n    cur_length = sint(0)\n    for i in range(n):\n        if i == 0:\n            cur_length = sint(1)\n        else:\n            cond = a.get(i) >= a.get(i-1)\n            temp_max = (max_length >= cur_length).if_else(max_length, cur_length)\n            new_max = cond.if_else(max_length, temp_max)\n            new_cur = cond.if_else(cur_length + 1, sint(1))\n            max_length = new_max\n            cur_length = new_cur\n    max_length = (max_length >= cur_length).if_else(max_length, cur_length)\n    return max_length\n", "response_1": "def longest_nondec_subseq(a):\n    max_length = sint(0)\n    cur_length = sint(0)\n    for i in range(len(a)):\n        if i == 0:\n            cur_length = sint(1)\n        else:\n            cond = a[i] >= a[i-1]\n            new_cur = cond.if_else(cur_length + 1, sint(1))\n            temp_max = cond.if_else(max_length, (max_length >= cur_length).if_else(max_length, cur_length))\n            max_length = temp_max\n            cur_length = new_cur\n    max_length = (max_length >= cur_length).if_else(max_length, cur_length)\n    return max_length\n", "model_name": "deepseek-r1"}
{"test_name": "sum_but_skip_biggest", "response_0": "def sum_but_skip_biggest(array):\n    sum = sfix(0)\n    n = len(array)\n    biggest = array[0]\n    for i in range(n):\n        current = array[i]\n        condition = current >= biggest\n        sum += current * (1 - condition)\n        biggest = cond_swap(condition, biggest, current)\n    return sum\n\ndef cond_swap(condition, x, y):\n    return condition.if_else(y, x)\n", "response_1": "def sum_but_skip_biggest(array):\n    sum = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        current = array[i]\n        condition = current >= biggest\n        sum_increment = mpc.if_else(condition, sint(0), current)\n        sum += sum_increment\n        biggest = mpc.if_else(condition, current, biggest)\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "second_test", "response_0": "def second_test(arr):\n    count = sint(0)\n    for i in range(1, len(arr)):\n        comp = arr[0] < arr[i]\n        count += comp.if_else(sint(1), sint(0))\n    return count == 1\n", "response_1": "def second_test(arr):\n    count = sint(0)\n    for i in range(1, len(arr)):\n        count += sint(arr[0] < arr[i])\n    return sint(count == 1)\n", "model_name": "deepseek-r1"}
{"test_name": "Manhattan_distance", "response_0": "def Manhattan_distance(a, b):\n    ret = regint(0)\n    for i in range(len(a)):\n        d = a[i] - b[i]\n        abs_d = (d < 0).if_else(-d, d)\n        ret = ret + abs_d\n    return ret\n", "response_1": "def Manhattan_distance(a, b):\n    ret = 0\n    for i in range(a.size()):\n        ret = ret + sabs(a[i] - b[i])\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "deal_with_only_positive", "response_0": "from library import *\n\ndef deal_with_only_positive(array):\n    sum = sint(0)\n    sign = sint(1)\n    for i in range(len(array)):\n        element = array[i]\n        cond = element > 0\n        sum += cond * sign * element\n        sign = sign * (1 - 2 * cond)\n    return sum\n", "response_1": "def deal_with_only_positive(array):\n    sign = sint(1)\n    sum = sint(0)\n    for i in range(len(array)):\n        mask = array[i] > 0\n        sum = sum + sign * mask * array[i]\n        sign = sign * (sint(1) - sint(2) * mask)\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "compare_and_return", "response_0": "def compare_and_return(arr, brr):\n    ret = sint(-1)\n    found = sbit(0)\n    for i in range(len(arr)):\n        current_match = arr[i] == brr[i]\n        update_cond = current_match & ~found\n        ret = mux(update_cond, sint(i), ret)\n        found |= current_match\n    return ret\n", "response_1": "def compare_and_return(arr, brr):\n    n = len(arr)\n    running_or = sint(0)\n    sum_indices = sint(0)\n    for i in range(n):\n        current_match = sint(arr[i] == brr[i])\n        first_match = current_match * (sint(1) - running_or)\n        sum_indices += sint(i) * first_match\n        running_or = running_or + current_match - running_or * current_match\n    any_match = running_or != sint(0)\n    return any_match.if_else(sum_indices, sint(-1))\n", "model_name": "deepseek-r1"}
{"test_name": "sum_odd_positive", "response_0": "def sum_odd_positive(arr):\n    sum = sint(0)\n    for item in arr:\n        is_positive = item > 0\n        is_odd = (item % 2).equal(1)\n        sum += is_positive * is_odd * item\n    return sum\n", "response_1": "def sum_odd_positive(arr):\n    sum = sint(0)\n    for item in arr:\n        cond_p = sint(item > 0)\n        cond_o = item.mod2m(1)\n        sum += item * cond_p * cond_o\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "two_sum", "response_0": "def two_sum(arr, target):\n    \"\"\"\n    Determine if there exist two elements in the array (possibly the same) that sum to the target value.\n    \"\"\"\n    n = len(arr)\n    results = []\n    for i in range(n):\n        for j in range(n):\n            sum_ij = arr[i] + arr[j]\n            results.append(sum_ij == target)\n    return any(results)\n", "response_1": "def two_sum(arr, target):\n    found = sint(0)\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            sum = arr[i] + arr[j]\n            found = found | (sum == target)\n    return found\n", "model_name": "deepseek-r1"}
{"test_name": "seq_search", "response_0": "def seq_search(arr, target):\n    found_index = sfix(-1)\n    found_flag = sfix(0)\n    for i in range(len(arr)):\n        current_condition = (arr[i] == target).if_else(sfix(1), sfix(0))\n        effective_condition = current_condition * (sfix(1) - found_flag)\n        found_index = effective_condition * sfix(i) + (sfix(1) - effective_condition) * found_index\n        found_flag += effective_condition\n    return found_index\n", "response_1": "def seq_search(arr, target):\n    result = sint(-1)\n    n = len(arr)\n    for i in range(n):\n        current_match = arr[i] == target\n        not_found = (result == -1)\n        condition = current_match * not_found\n        result = condition.if_else(sint(i), result)\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "choppy_array", "response_0": "def choppy_array(arr):\n    n = len(arr)\n    flag = sint(0)\n    for i in range(n):\n        is_even = (i % 2) == 0\n        for j in range(n - i):\n            k = i + j\n            if is_even:\n                violation = arr[k] < arr[i]\n            else:\n                violation = arr[k] > arr[i]\n            flag = flag + violation - flag * violation\n    return flag == 0\n", "response_1": "def choppy_array(arr):\n    n = len(arr)\n    any_false = sint(0)\n    for i in range(n):\n        for j in range(n - i):\n            current = arr[i + j]\n            if i % 2 == 0:\n                cond = current < arr[i]\n            else:\n                cond = current > arr[i]\n            any_false = any_false | cond\n    res = 1 - any_false\n    return res.reveal()\n", "model_name": "deepseek-r1"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for i in range(arr.length):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "def array_process(arr):\n    \"\"\"\n    Process all elements in the input array with operations (modify as needed).\n    MP-SPDZ doesn't support passing functions as parameters, so operations must be inlined.\n    \"\"\"\n    for i in range(len(arr)):\n        # Example operation: square elements (replace with actual logic)\n        arr[i] = arr[i] * arr[i]\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "normalize", "response_0": "def normalize(vec):\n    \"\"\"\n    Normalize the vector using MP-SPDZ compatible operations.\n    \"\"\"\n    sum_squares = sfix(0)\n    for item in vec:\n        sum_squares += item * item  # Compute sum of squares using fixed-point arithmetic\n    base = sum_squares.sqrt()       # Secure square root operation\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base     # Element-wise division with fixed-point precision\n    return vec\n", "response_1": "def normalize(vec):\n    sum = sfix(0)\n    for item in vec:\n        sum += item * item\n    base = sum.sqrt()\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "model_name": "deepseek-r1"}
{"test_name": "impatient_merchant", "response_0": "def impatient_merchant(days):\n    can_buy = sbit(True)\n    net = sfix(0)\n    orig_price = sfix(0)\n    for i in range(len(days)):\n        current = days[i]\n        # Compute possible buy transaction\n        net_buy = net - current\n        orig_price_buy = current\n        can_buy_buy = sbit(False)\n        # Compute possible sell transaction\n        sell_cond = current > orig_price\n        net_sell = net + current * sell_cond\n        orig_price_sell = orig_price\n        can_buy_sell = sell_cond.if_else(sbit(True), sbit(False))\n        # Update state using MPC-aware conditional selection\n        net = can_buy.if_else(net_buy, net_sell)\n        orig_price = can_buy.if_else(orig_price_buy, orig_price_sell)\n        can_buy = can_buy.if_else(can_buy_buy, can_buy_sell)\n    return net\n", "response_1": "def impatient_merchant(days):\n    can_buy = sint(1)\n    net = sint(0)\n    orig_price = sint(0)\n    for day in days:\n        # Calculate both possible state transitions\n        buy_net = net - day\n        buy_orig = day\n        buy_can = sint(0)\n        \n        condition = day > orig_price\n        sell_net = net + condition * day\n        sell_orig = orig_price\n        sell_can = condition\n        \n        # Select between states using current can_buy flag\n        net = can_buy.if_else(buy_net, sell_net)\n        orig_price = can_buy.if_else(buy_orig, sell_orig)\n        can_buy = can_buy.if_else(buy_can, sell_can)\n    \n    return net\n", "model_name": "deepseek-r1"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    n = len(a)\n    temp = a[n]\n    for i in range(n-1):\n        a[n - i] = a[n - i - 1]\n    a[1] = temp\n    return a\n", "response_1": "def array_shift(a):\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1):\n        a[n - i - 1] = a[n - i - 2]\n    a[0] = temp\n    return a\n", "model_name": "deepseek-r1"}
{"test_name": "array_double", "response_0": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "def array_double(arr):\n    \"\"\"Double all elements in the secret integer array.\"\"\"\n    for i in range(arr.length):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "stop_at_zero", "response_0": "def stop_at_zero(array):\n    running = sint(1)\n    for i in range(len(array)):\n        is_zero = array[i].equal_zero()\n        should_stop = running * is_zero\n        increment = running * (1 - is_zero)\n        array[i] = array[i] + increment\n        running = running - should_stop\n    return array\n", "response_1": "def stop_at_zero(array):\n    should_process = sint(1)\n    for i in range(len(array)):\n        element = array[i]\n        not_zero = 1 - (element == 0)\n        increment = should_process * not_zero\n        array[i] += increment\n        should_process = should_process * not_zero\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = 1 - arr[i]\n    return arr\n", "response_1": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = 1 - arr[i]\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "array_process_then_clip", "response_0": "def array_process_then_clip(arr):\n    for i in range_(len(arr)):\n        val = arr[i]\n        # Apply your processing function here (e.g., val = val * 2)\n        # Example: double the value\n        val = val * 2\n        \n        # Clip upper bound\n        over = val > 10\n        val = over.if_else(sint(10), val)\n        # Clip lower bound\n        under = val < -10\n        val = under.if_else(sint(-10), val)\n        arr[i] = val\n    return arr\n", "response_1": "def array_process_then_clip(arr):\n    # Replace the next line with the actual function to apply\n    func = lambda x: x  # Placeholder - define your operation here\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = if_else(arr[i] > 10, 10, arr[i])\n        arr[i] = if_else(arr[i] < -10, -10, arr[i])\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "add_and_count_positive", "response_0": "def add_and_count_positive(array, k):\n    # Create a new array to store modified values\n    new_array = sintArray(len(array))\n    count = sint(0)\n    \n    # Iterate through each element in the input array\n    for i in range(len(array)):\n        # Add k to the element and store in new array\n        new_array[i] = array[i] + k\n        # Increment count if the result is positive (using secret integer comparison)\n        count += (new_array[i] > 0)\n    \n    # Return both the modified array and the count of positive values\n    return new_array, count\n", "response_1": "def add_and_count_positive(array, k):\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        count += sint(array[i] > 0)\n    return (array, count)\n", "model_name": "deepseek-r1"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    len_a = len(a)\n    len_b = len(b)\n    max_len = max(len_a, len_b)\n    min_len = min(len_a, len_b)\n    result = Array(max_len, sint)\n    \n    for i in range(min_len):\n        result[i] = a[i] - b[i]\n    \n    @if_public(len_a > len_b)\n    def _():\n        for i in range(min_len, max_len):\n            result[i] = a[i]\n    @else_\n    def _():\n        for i in range(min_len, max_len):\n            result[i] = -b[i]\n    \n    return result\n", "response_1": "def array_subtract(a, b):\n    len_a = a.size()\n    len_b = b.size()\n    if len_a > len_b:\n        max_len = len_a\n        result = a.value_type.Array(max_len)\n        for i in range(len_b):\n            result[i] = a[i] - b[i]\n        for i in range(len_b, max_len):\n            result[i] = a[i]\n    else:\n        max_len = len_b\n        result = b.value_type.Array(max_len)\n        for i in range(len_a):\n            result[i] = a[i] - b[i]\n        for i in range(len_a, max_len):\n            result[i] = -b[i]\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "lower_bound", "response_0": "def lower_bound(arr, x):\n    ret = sint(-1)\n    found = sbit(0)\n    best_distance = sint(0)\n    for i in range(len(arr)):\n        cond = arr[i] <= x\n        current_distance = x - arr[i]\n        is_closer = current_distance < best_distance\n        not_found = sbit(1) - found\n        effective_cond = cond * (not_found + found * is_closer)\n        found = found + cond - found * cond  # OR operation\n        ret = effective_cond.if_else(sint(i), ret)\n        best_distance = effective_cond.if_else(current_distance, best_distance)\n    return ret\n", "response_1": "def lower_bound(arr, x):\n    ret = sint(-1)\n    distance = sint(0)\n    found = sbit(0)\n    for i in range(len(arr)):\n        valid = arr[i] <= x\n        new_distance = x - arr[i]\n        not_found = sbit(1) - found\n        cond1 = valid * not_found\n        cond2 = valid * found * (new_distance < distance)\n        should_update = cond1 + cond2\n        ret = mux(should_update, sint(i), ret)\n        distance = mux(should_update, new_distance, distance)\n        found = mux(should_update, sbit(1), found)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "argmin", "response_0": "def argmin(a):\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        condition = a[i] < current\n        current = condition.if_else(a[i], current)\n        index = condition.if_else(sint(i), index)\n    return index\n", "response_1": "def argmin(a):\n    current = a[0]\n    index = sint(0)\n    for i in range(1, len(a)):\n        cond = a[i] < current\n        index = cond.mux(sint(i), index)\n        current = cond.mux(a[i], current)\n    return index\n", "model_name": "deepseek-r1"}
{"test_name": "independent_robbery", "response_0": "def independent_robbery(houses):\n    n = len(houses)\n    dp = sint.Array(n)\n    dp[0] = houses[0]\n    dp[1] = sint.if_else(houses[0] >= houses[1], houses[0], houses[1])\n    for i in range(2, n):\n        a = dp[i-2] + houses[i]\n        b = dp[i-1]\n        cmp = a >= b\n        dp[i] = cmp.if_else(a, b)\n    return dp[n-1]\n", "response_1": "def independent_robbery(houses):\n    n = len(houses)\n    dp = sint.Array(n)\n    dp[0] = houses[0]\n    dp[1] = sint.max(houses[0], houses[1])\n    for i in range(2, n):\n        dp[i] = sint.max(dp[i-1], dp[i-2] + houses[i])\n    return dp[n-1]\n", "model_name": "deepseek-r1"}
{"test_name": "sum_odd_and_odd", "response_0": "def sum_odd_and_odd(arr):\n    sum = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            sum += arr[j]\n    return sum\n", "response_1": "def sum_odd_and_odd(arr):\n    sum = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            sum += arr[j]\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "is_monotonous", "response_0": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    res = sint(1)  # Default to True for n <= 1\n    if n >= 2:\n        flag = sint(0)\n        d_prev = arr[1] - arr[0]\n        for i in range(1, n-1):\n            current_diff = arr[i+1] - arr[i]\n            product = current_diff * d_prev\n            condition = (product <= 0)\n            flag = flag | condition\n            d_prev = current_diff\n        res = (flag == 0)\n    return res\n", "response_1": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    flag = sbit(0)\n    d = sint(0)\n    for i in range(n - 1):\n        current_diff = arr[i + 1] - arr[i]\n        if i == 0:\n            d = current_diff\n        else:\n            product = current_diff * d\n            condition = product.leq(0)\n            flag = flag | condition\n            d = current_diff\n    return ~flag\n", "model_name": "deepseek-r1"}
{"test_name": "positive_count_negative_sum", "response_0": "def positive_count_negative_sum(arr):\n    count = sint(0)\n    sum = sint(0)\n    for item in arr:\n        count += (item > 0)\n        sum += item * (item < 0)\n    return count, sum\n", "response_1": "def positive_count_negative_sum(arr):\n    count = sint(0)\n    sum_neg = sint(0)\n    for item in arr:\n        count += (item > 0)\n        sum_neg += item * (item < 0)\n    return count.reveal(), sum_neg.reveal()\n", "model_name": "deepseek-r1"}
{"test_name": "sum_even", "response_0": "def sum_even(arr):\n    sum = sint(0)\n    for item in arr:\n        sum += item * (1 - (item % 2))\n    return sum\n", "response_1": "def sum_even(arr):\n    sum = sint(0)\n    for i in range(len(arr)):\n        is_even = (arr[i] % 2) == 0\n        sum += arr[i] * is_even\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector (sum of absolute values).\n    vec is an Array of secret values (sfix/sint)\n    \"\"\"\n    sum = sfix(0)  # Or sint(0) depending on type needed\n    for item in vec:\n        sum += sabs(item)  # MP-SPDZ's absolute value for secret values\n    return sum\n", "response_1": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the secret vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum += item.abs()\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "array_floor", "response_0": "def array_floor(arr):\n    \"\"\"\n    Apply floor function to all elements in the input array.\n    \"\"\"\n    ret = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        ret[i] = arr[i].floor()\n    return ret\n", "response_1": "def array_floor(arr):\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i].floor()\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "three_five", "response_0": "def three_five(arr):\n    has3 = sbit(False)\n    has5 = sbit(False)\n    for item in arr:\n        has3 = has3 | (item == 3)\n        has5 = has5 | (item == 5)\n    return (has3 & has5) | ((~has3) & (~has5))\n", "response_1": "def three_five(arr):\n    has3 = sint(0)\n    has5 = sint(0)\n    for item in arr:\n        eq3 = sint(item == 3)\n        eq5 = sint(item == 5)\n        has3 = 1 - (1 - has3) * (1 - eq3)\n        has5 = 1 - (1 - has5) * (1 - eq5)\n    both = has3 * has5\n    neither = (1 - has3) * (1 - has5)\n    return both + neither\n", "model_name": "deepseek-r1"}
{"test_name": "num_above_average", "response_0": "def num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value.\n    \"\"\"\n    sum = sfix(0)\n    n = len(arr)\n    for i in range(n):\n        sum += arr[i]\n    avg = sum / n\n    count = sint(0)\n    for i in range(n):\n        comp = arr[i] >= avg\n        count += comp.if_else(sint(1), sint(0))\n    return count.reveal()\n", "response_1": "def num_above_average(arr):\n    sum = sfix(0)\n    n = len(arr)\n    for i in range(n):\n        sum += arr[i]\n    avg = sum / n\n    count = sint(0)\n    for i in range(n):\n        c = arr[i] >= avg\n        count += sint(c)\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound, lower_bound):\n    res = []\n    for x in arr:\n        # Apply lower bound\n        temp = mux(x < lower_bound, lower_bound, x)\n        # Apply upper bound on the adjusted value\n        clipped = mux(temp > upper_bound, upper_bound, temp)\n        res.append(clipped)\n    return res\n", "response_1": "def clip(arr, upper_bound, lower_bound):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    for i in range(len(arr)):\n        x = arr[i]\n        # Apply lower bound\n        x = (x < lower_bound).if_else(lower_bound, x)\n        # Apply upper bound\n        x = (x > upper_bound).if_else(upper_bound, x)\n        arr[i] = x\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "def sum_with_certain_element_skipped(array):\n    sum = sint(0)\n    for element in array:\n        temp_sum = sum + element\n        condition = (temp_sum >= 5) * (temp_sum <= 10)\n        sum = sum + if_else(condition, sint(0), element)\n    return sum\n", "response_1": "def sum_with_certain_element_skipped(array):\n    sum = sint(0)\n    for element in array:\n        temp_sum = sum + element\n        in_range = (temp_sum >= 5) * (temp_sum <= 10)\n        sum += element * (1 - in_range)\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "sum_of_odd_and_even", "response_0": "def sum_of_odd_and_even(arr):\n    odd_sum = sfix(0)\n    even_sum = sfix(0)\n    for item in arr:\n        mod = item % 2\n        odd_sum += mod * item\n        even_sum += (1 - mod) * item\n    return odd_sum, even_sum\n", "response_1": "def sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        is_odd = item % 2\n        odd_sum += is_odd * item\n        even_sum += (1 - is_odd) * item\n    return (odd_sum, even_sum)\n", "model_name": "deepseek-r1"}
{"test_name": "distance", "response_0": "def distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between two secret-shared vectors.\n    \"\"\"\n    sum_squares = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        sum_squares += diff * diff\n    return sfix.sqrt(sum_squares)\n", "response_1": "def distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between two sfix vectors in MP-SPDZ\n    \"\"\"\n    sum_sq = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        sum_sq += diff * diff\n    return sum_sq.sqrt()\n", "model_name": "deepseek-r1"}
{"test_name": "num_occurrence", "response_0": "def num_occurrence(arr, target):\n    count = sint(0)\n    for item in arr:\n        count += sint(item == target)\n    return count\n", "response_1": "def num_occurrence(arr, target):\n    count = sint(0)\n    for item in arr:\n        count += (item == target)\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "palindrome", "response_0": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome using secret integers.\n    \"\"\"\n    flag = sint(1)  # True in secret integer form\n    n = len(arr)\n    for i in range(n):\n        flag = flag * (arr[i] == arr[n - 1 - i])\n    return flag\n", "response_1": "def palindrome(arr):\n    n = len(arr)\n    flag = sbit(1)\n    for i in range(n//2):\n        flag = flag & (arr[i] == arr[n-1 -i])\n    return flag\n", "model_name": "deepseek-r1"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    num = sint(0)\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            comparison = arr[i] > arr[j]\n            num += sint(comparison)\n    return num\n", "response_1": "def reverse_order_pair(arr):\n    num = sint(0)\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            num += (arr[i] > arr[j])\n    return num\n", "model_name": "deepseek-r1"}
{"test_name": "sum_of_cubes", "response_0": "def sum_of_cubes(arr):\n    \"\"\"Returns the sum of cubes of secret-shared elements in the array.\"\"\"\n    ret = sint(0)\n    for item in arr:\n        ret = ret + (item ** 3)\n    return ret\n", "response_1": "def sum_of_cubes(arr):\n    ret = sint(0)\n    for item in arr:\n        ret += item * item * item\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "max_element", "response_0": "def max_element(a):\n    current = a[0]\n    for i in range(1, len(a)):\n        item = a[i]\n        current = mux(current >= item, current, item)\n    return current\n", "response_1": "def max_element(a):\n    current = a[0]\n    for i in range(len(a)):\n        current = mux(current >= a[i], current, a[i])\n    return current\n", "model_name": "deepseek-r1"}
{"test_name": "array_if_else", "response_0": "def array_if_else(arr, predicator, if_func, else_func):\n    for i in range(len(arr)):\n        cond = predicator(arr[i])\n        true_val = if_func(arr[i])\n        false_val = else_func(arr[i])\n        arr[i] = cond.if_else(true_val, false_val)\n    return arr\n", "response_1": "def array_if_else(arr, predicator, if_func, else_func):\n    for i in range(len(arr)):\n        cond = predicator(arr[i])\n        true_val = if_func(arr[i])\n        false_val = else_func(arr[i])\n        arr[i] = cond.if_else(true_val, false_val)\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "inf_norm", "response_0": "def inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector using secure operations.\n    \"\"\"\n    sum = 0\n    for item in vec:\n        abs_item = sabs(item)\n        sum = mux(sum >= abs_item, sum, abs_item)\n    return sum\n", "response_1": "template<int v>\nsfix inf_norm(Array<sfix, v> vec) {\n    sfix max_val = sfix(0);\n    for (int i = 0; i < v; i++) {\n        sfix abs_item = vec[i].abs();\n        sfix condition = max_val >= abs_item;\n        max_val = mux(condition, max_val, abs_item);\n    }\n    return max_val;\n}\n", "model_name": "deepseek-r1"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] += 1\n    return arr\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    length = len(arr)\n    for i in range(length):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    count = sint(0)\n    for i in range(arr.size() - 1):\n        count += (arr[i] < arr[i+1])\n    return count\n", "response_1": "def count_rises(arr):\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        count += (arr[i] < arr[i + 1])\n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "skip_at_zero", "response_0": "def skip_at_zero(array):\n    for i in range(len(array)):\n        cond = array[i] != 0\n        array[i] = cond.if_else(array[i] + 1, array[i])\n    return array\n", "response_1": "def skip_at_zero(array):\n    for i in range(array.size()):\n        inc = (array[i] != 0) * 1\n        array[i] += inc\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "array_intersect", "response_0": "def array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    result = sint(0)\n    for i in range(len(p)):\n        for j in range(len(q)):\n            match = p[i] == q[j]\n            result = result + match - result * match\n    return result\n", "response_1": "def array_intersect(p, q):\n    found = sint(0)\n    for i in range_(len(p)):\n        for j in range_(len(q)):\n            eq = p[i] == q[j]\n            found = found + eq - found * eq\n    return found\n", "model_name": "deepseek-r1"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector using MP-SPDZ types.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum += item**2\n    return sum.sqrt()\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector using secure fixed-point arithmetic.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item * item  # Secure multiplication\n    return sum.sqrt()\n", "model_name": "deepseek-r1"}
{"test_name": "sum_between", "response_0": "def sum_between(arr, l, u):\n    sum = sfix(0)\n    for item in arr:\n        condition = (item >= l) * (item <= u)\n        sum += condition * item\n    return sum\n", "response_1": "def sum_between(arr, l, u):\n    sum = sint(0)\n    for item in arr:\n        cond1 = item >= l\n        cond2 = item <= u\n        sum += (cond1 * cond2) * item\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "largest_gap", "response_0": "def largest_gap(arr):\n    cur = sint(0)\n    for i in range(len(arr)-1):\n        diff = arr[i+1] - arr[i]\n        abs_diff = diff.abs()\n        cur = (abs_diff > cur).if_else(abs_diff, cur)\n    return cur\n", "response_1": "def largest_gap(arr):\n    cur = sint(0)\n    for i in range(len(arr) - 1):\n        diff = abs(arr[i+1] - arr[i])\n        larger = diff > cur\n        cur = larger.if_else(diff, cur)\n    return cur\n", "model_name": "deepseek-r1"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    # Compute minimum of a\n    amin = a[0]\n    for i in range(1, len(a)):\n        current = a[i]\n        cmp = current < amin\n        amin = cmp.if_else(current, amin)\n    \n    # Compute maximum of b\n    bmax = b[0]\n    for i in range(1, len(b)):\n        current = b[i]\n        cmp = current > bmax\n        bmax = cmp.if_else(current, bmax)\n    \n    # Return comparison result\n    return amin >= bmax\n", "response_1": "def totally_dominate(a, b):\n    amin = a.min()\n    bmax = b.max()\n    return amin >= bmax\n", "model_name": "deepseek-r1"}
{"test_name": "element_count", "response_0": "def element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the secret array.\n    All values are assumed to be secret integers (sint).\n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        # Secretly compare item to target and add 1/0 boolean result to counter\n        ret += (item == target)\n    return ret\n", "response_1": "def element_count(arr, target):\n    ret = sint(0)\n    for item in arr:\n        ret += (item == target)\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "is_subarray", "response_0": "def is_subarray(c, d):\n    lc = len(c)\n    ld = len(d)\n    if lc == 0:\n        return 1\n    if lc > ld:\n        return 0\n    max_i = ld - lc\n    result = sint(0)\n    for i in range(max_i + 1):\n        current_match = sint(1)\n        for j in range(lc):\n            current_match *= (d[i + j] == c[j])\n        result = result + current_match - result * current_match\n    return result\n", "response_1": "def is_subarray(c, d):\n    len_c = c.size()\n    len_d = d.size()\n    if len_c == 0:\n        return sbit(1)\n    if len_c > len_d:\n        return sbit(0)\n    result = MemValue(sbit(0))\n    @for_range(len_d)\n    def _(i):\n        valid_start = (i + len_c) <= len_d\n        match = MemValue(sbit(1))\n        @for_range(len_c)\n        def _(j):\n            eq = c[j] == d[i + j]\n            match.write(match.read() * eq)\n        current = sbit(valid_start) * match.read()\n        result.write(result.read() | current)\n    return result.read()\n", "model_name": "deepseek-r1"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    result = sint(0)\n    for item in arr:\n        is_match = (item == 5).bit_or(item == 7)\n        result = result.bit_or(is_match)\n    return result\n", "response_1": "def exists_5_or_7(arr):\n    sum = sint(0)\n    for item in arr:\n        sum += (item == 5) + (item == 7)\n    return sum > 0\n", "model_name": "deepseek-r1"}
{"test_name": "variance", "response_0": "def variance(arr):\n    n = len(arr)\n    sum_val = sfix(0)\n    for item in arr:\n        sum_val += item\n    average = sum_val / n\n    var_sum = sfix(0)\n    for item in arr:\n        diff = item - average\n        var_sum += diff * diff\n    return var_sum / n\n", "response_1": "def variance(arr):\n    \"\"\"\n    Return the variance of the array.\n    \"\"\"\n    average = sfix(0)\n    variance = sfix(0)\n    n = len(arr)\n    \n    # Calculate sum for average\n    sum = sfix(0)\n    for item in arr:\n        sum += item\n    average = sum / n\n    \n    # Calculate variance\n    for item in arr:\n        diff = item - average\n        variance += diff * diff  # (item - average) squared\n    variance = variance / n\n    \n    return variance\n", "model_name": "deepseek-r1"}
{"test_name": "is_ascending", "response_0": "def is_ascending(arr):\n    n = len(arr)\n    if n <= 1:\n        return sint(1)\n    any_fail = sint(0)\n    for i in range(n - 1):\n        any_fail = any_fail | (arr[i] >= arr[i + 1])\n    return 1 - any_fail\n", "response_1": "def is_ascending(arr):\n    res = sint(1)\n    for i in range(len(arr)-1):\n        res = res * (arr[i] < arr[i+1])\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "xor_all", "response_0": "def xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n", "response_1": "def xor_all(arr):\n    ret = arr[0]\n    for i in range(1, arr.size()):\n        ret = ret ^ arr[i]\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "upper_bound", "response_0": "def upper_bound(arr, x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = sfix(-1)\n    distance = sfix(0)\n    found = sbit(0)\n    for i in range(len(arr)):\n        current = arr[i]\n        is_candidate = current > x\n        new_distance = current - x\n        better_condition = (1 - found) + (new_distance < distance) - (1 - found) * (new_distance < distance)\n        update_condition = is_candidate * better_condition\n        ret = update_condition.if_else(sfix(i), ret)\n        distance = update_condition.if_else(new_distance, distance)\n        found = update_condition.if_else(sbit(1), found)\n    return ret\n", "response_1": "def upper_bound(arr, x):\n    max_val = 2**30 - 1\n    ret = sint(-1)\n    distance = sint(max_val)\n    found = sbit(0)\n    for i in range(len(arr)):\n        current = arr[i]\n        current_cond = current > x\n        new_distance = current - x\n        cond1 = found.negate()\n        cond2 = new_distance < distance\n        update_cond = current_cond & (cond1 | cond2)\n        new_ret = update_cond.if_else(sint(i), ret)\n        new_distance_val = update_cond.if_else(new_distance, distance)\n        new_found = found | current_cond\n        ret = new_ret\n        distance = new_distance_val\n        found = new_found\n    return ret\n", "model_name": "deepseek-r1"}
{"test_name": "array_process_then_sum", "response_0": "def array_process_then_sum(arr):\n    # Initialize sum with the same type as array elements\n    sum = 0 * arr[0]\n    for i in range(len(arr)):\n        # Replace with actual processing function (e.g., arr[i] * 2)\n        processed = arr[i]  # Default no-op; replace with real operation\n        arr[i] = processed\n        sum += processed\n    return sum\n", "response_1": "from sint import *\n\ndef main():\n    # Assuming array size and input are predefined or provided via input\n    n = 5\n    arr = Array(n, sint)\n    \n    # Initialize array with sample secret values (replace with actual input)\n    for i in range(n):\n        arr[i] = sint.get_input_from(i + 1)\n    \n    sum_result = sint(0)\n    \n    for i in range(n):\n        # Apply processing function (example: square each element)\n        processed_val = arr[i] * arr[i\n        arr[i] = processed_val\n        sum_result += processed_val\n    \n    # Output the revealed sum\n    print_ln(\"Processed sum: %s\", sum_result.reveal())\n", "model_name": "deepseek-r1"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the secret array.\n    \"\"\"\n    sum = sfloat(0)\n    length = arr.size\n    for i in range(length):\n        sum = sum + arr[i]\n    # Convert public length to clear float for division\n    ret = sum / cfloat(length)\n    return ret\n", "response_1": "def average(arr, length):\n    sum = sfix(0)\n    for i in range(length):\n        sum += arr[i]\n    return sum / length\n", "model_name": "deepseek-r1"}
{"test_name": "array_filter", "response_0": "# Filter to keep elements > 5\nfiltered = array_filter(arr, lambda x: x > 5)\n", "response_1": "def array_filter(arr):\n    # Assuming 'predicator' checks if element is non-zero (modify condition as needed)\n    for i in range(len(arr)):\n        condition = arr[i] != 0  # Replace with actual predicate condition\n        arr[i] = condition.if_else(arr[i], sint(0))\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "sum_up", "response_0": "def sum_up(array):\n    \"\"\"\n    The sum_up function translated to MP-SPDZ\n    \"\"\"\n    sum = sint(0)\n    for num in array:\n        sum = sum + num\n    return sum\n", "response_1": "def sum_up(array):\n    sum = sfix(0)\n    for num in array:\n        sum += num\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "negative_to_zero", "response_0": "def negative_to_zero(array):\n    for i in range(len(array)):\n        cond = array[i] < 0\n        array[i] = array[i] * (1 - cond)\n    return array\n", "response_1": "def negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(len(array)):\n        mask = array[i] >= 0\n        array[i] = array[i] * mask\n    return array\n", "model_name": "deepseek-r1"}
{"test_name": "sum_only_positive_to_ten", "response_0": "def sum_only_positive_to_ten(array):\n    sum = sfix(0)\n    n = len(array)\n    for i in range(n):\n        element = array[i]\n        cond1 = element > 0\n        cond2 = sum < 10\n        add = cond1 * cond2\n        sum += element * add\n    return sum\n", "response_1": "def sum_only_positive_to_ten(array):\n    sum = sint(0)\n    for i in range(len(array)):\n        is_positive = array[i] > 0\n        sum_less_10 = sum < 10\n        addable = is_positive & sum_less_10\n        addable_sint = sint(addable)\n        sum += array[i] * addable_sint\n    return sum\n", "model_name": "deepseek-r1"}
{"test_name": "bubble_sort", "response_0": "def bubble_sort(arr):\n    for i in range(len(arr)-1):\n        for j in range(1, len(arr) - i):\n            if arr[j] >= arr[j+1]:\n                temp = arr[j]\n                arr[j] = arr[j+1]\n                arr[j+1] = temp\n    return arr\n", "response_1": "def bubble_sort(arr):\n    n = len(arr)\n    for i in for_range(n - 1):\n        for j in for_range(n - 1 - i):\n            condition = arr[j] >= arr[j + 1]\n            a = arr[j]\n            b = arr[j + 1]\n            arr[j] = condition.if_else(b, a)\n            arr[j + 1] = condition.if_else(a, b)\n    return arr\n", "model_name": "deepseek-r1"}
