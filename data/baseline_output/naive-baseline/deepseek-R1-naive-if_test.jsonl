{"test_name": "sin_or_cos", "response_0": "def mpc_sin(x):\n    x_sq = x * x\n    x_cu = x_sq * x\n    x_5 = x_cu * x_sq\n    return x - x_cu / 6 + x_5 / 120\n\ndef mpc_cos(x):\n    x_sq = x * x\n    x_4 = x_sq * x_sq\n    return 1 - x_sq / 2 + x_4 / 24\n\ndef sin_or_cos(x):\n    is_non_negative = x >= 0\n    sin_val = mpc_sin(x)\n    cos_val = mpc_cos(x)\n    return if_else(is_non_negative, sin_val, cos_val)\n", "response_1": "def sin_or_cos(x):\n    condition = x >= 0\n    sin_val = sfix.sin(x)\n    cos_val = sfix.cos(x)\n    return condition.if_else(sin_val, cos_val)\n", "model_name": "deepseek-r1"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU using secure comparisons: returns input if negative, 0 otherwise\n    \"\"\"\n    return (input < 0).if_else(input, 0)\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return (input < 0).if_else(input, sfix(0))\n", "model_name": "deepseek-r1"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    return sabs(a - b) <= 1\n", "response_1": "def is_close(a, b):\n    \"\"\"\n    Return whether the absolute difference between two secret integers is at most 1.\n    \"\"\"\n    return (a - b).get_abs() <= 1\n", "model_name": "deepseek-r1"}
{"test_name": "hardswish", "response_0": "def hardswish(x):\n    return (x < -3).if_else(0, (x > 3).if_else(x, x * (x + 3) / 6))\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    return (x < sfix(-3)).if_else(\n        sfix(0),\n        (x > sfix(3)).if_else(\n            x,\n            x * (x + sfix(3)) / sfix(6)\n        )\n    )\n", "model_name": "deepseek-r1"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    bit_gt6 = x > 6\n    bit_lt_minus6 = x < -6\n    return bit_gt6.if_else(sint(6), bit_lt_minus6.if_else(sint(-6), x))\n", "response_1": "def clip_at_6(x):\n    temp = sint.if_else(x > 6, sint(6), x)\n    result = sint.if_else(temp < -6, sint(-6), temp)\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    return (x > 1).if_else(x,\n            (x < -1).if_else(x,\n                (x > 0).if_else(1,\n                    (x < 0).if_else(-1, 0)\n                )\n            )\n        )\n", "response_1": "from library import sfix\n\ndef piecewise_function(x):\n    cond1 = x > 1\n    cond2 = x < -1\n    cond3 = x > 0\n    cond4 = x < 0\n    return cond1.if_else(x, \n        cond2.if_else(x, \n            cond3.if_else(sfix(1), \n                cond4.if_else(sfix(-1), sfix(0))\n            )\n        )\n    )\n", "model_name": "deepseek-r1"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    # Step 1: Compare and swap a and b\n    cond1 = a >= b\n    a1 = cond1.if_else(b, a)\n    b1 = cond1.if_else(a, b)\n    \n    # Step 2: Compare and swap b1 and c\n    cond2 = b1 >= c\n    b2 = cond2.if_else(c, b1)\n    \n    # Step 3: Compare and swap a1 and b2\n    cond3 = a1 >= b2\n    b3 = cond3.if_else(a1, b2)\n    \n    return b3\n", "response_1": "def middle(a, b, c):\n    # Step 1: Compare a and b, swap if necessary\n    condition1 = a >= b\n    a1 = condition1.if_else(b, a)\n    b1 = condition1.if_else(a, b)\n    \n    # Step 2: Compare updated b with c, swap if necessary\n    condition2 = b1 >= c\n    b2 = condition2.if_else(c, b1)\n    \n    # Step 3: Compare updated a and updated b, swap if necessary\n    condition3 = a1 >= b2\n    b3 = condition3.if_else(a1, b2)\n    \n    return b3\n", "model_name": "deepseek-r1"}
{"test_name": "indicated_sin_or_cos", "response_0": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    Secure computation version that returns sin(x) if indicator is true (1),\n    otherwise returns cos(x). Works with secret-shared fixed-point values.\n    x: sfix - secret fixed-point input value\n    ind: sint - secret integer (0 or 1) indicating selection\n    Returns: sfix - selected trigonometric result\n    \"\"\"\n    return mux(ind, x.sin(), x.cos())\n", "response_1": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    Uses secure multiplexing to avoid branching on secret values.\n    \"\"\"\n    sin_val = taylor_sin(x)\n    cos_val = taylor_cos(x)\n    return ind.if_else(sin_val, cos_val)\n", "model_name": "deepseek-r1"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    return if_else(x >= 2, x - 2, x)\n", "response_1": "def minus2_if_else(x):\n    condition = x >= 2\n    return if_else(condition, x - 2, x)\n", "model_name": "deepseek-r1"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    \"\"\"\n    ReLU6 function using MPC-friendly operations\n    \"\"\"\n    return min(max(x, 0), 6)\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function for secret integers.\n    \"\"\"\n    # Compute maximum between x and 0 (ReLU)\n    relu = x.max(0)\n    # Compute minimum between result and 6 (cap at 6)\n    return relu.min(6)\n", "model_name": "deepseek-r1"}
{"test_name": "exp_slide", "response_0": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    return mux(x >= 0, sfix.pow_fx(x), x + 1)\n", "response_1": "def exp_slide(x):\n    condition = x >= 0\n    e_power = x.exp()\n    x_plus_1 = x + 1\n    return condition.if_else(e_power, x_plus_1)\n", "model_name": "deepseek-r1"}
{"test_name": "pass_or_not", "response_0": "def pass_or_not(score):\n    # Determine adjusted score based on the condition\n    adjusted_score = (score >= 60).if_else(score, sint(59))\n    # Determine pass/fail status as secret integer (1/0)\n    passed = (adjusted_score >= 60).if_else(sint(1), sint(0))\n    # Return both values as secret integers\n    return adjusted_score, passed\n", "response_1": "def pass_or_not(score):\n    adjusted_score = (score >= 60).if_else(score, sint(59))\n    passed = (adjusted_score >= 60)\n    return adjusted_score, passed\n", "model_name": "deepseek-r1"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    is_a_zero = a == 0\n    is_b_zero = b == 0\n    disc = b * b - 4 * a * c\n    disc_gt0 = disc > 0\n    disc_eq0 = disc == 0\n    result = is_a_zero * (1 - is_b_zero) + (1 - is_a_zero) * (2 * disc_gt0 + disc_eq0)\n    return result\n", "response_1": "def how_many_roots(a, b, c):\n    a_is_zero = a == 0\n    b_is_zero = b == 0\n    a_zero_case = 1 - b_is_zero\n    discriminant = b * b - 4 * a * c\n    d_gt_0 = discriminant > 0\n    d_eq_0 = discriminant == 0\n    non_zero_case = d_gt_0 * 2 + d_eq_0 * 1\n    return a_is_zero.if_else(a_zero_case, non_zero_case)\n", "model_name": "deepseek-r1"}
{"test_name": "elu", "response_0": "def elu(x):\n    # Determine if x is positive (secret integer bit)\n    condition = x > 0\n    # Convert secret bit to sfix for multiplication\n    condition_sfix = sfix(condition)\n    # Calculate both branches\n    positive_part = x * condition_sfix\n    negative_part = (x.exp() - 1) * (sfix(1) - condition_sfix)\n    # Combine results\n    return positive_part + negative_part\n", "response_1": "def elu(x):\n    \"\"\"ELU function for secret-shared values\"\"\"\n    from library import if_else\n    return if_else(x > 0, x, exp(x) - 1)\n", "model_name": "deepseek-r1"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function using secure comparisons\n    \"\"\"\n    return x * (x > 0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function using secure MPC operations\n    \"\"\"\n    return (x > 0).if_else(x, 0)\n", "model_name": "deepseek-r1"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha for secret-shared values.\n    \"\"\"\n    return (x > 0).if_else(x, x * alpha)\n", "response_1": "def leaky_relu(x, alpha):\n    # Compute the condition (x > 0) as secret bit\n    condition = x.greater_than(0)\n    # Return x if condition else x*alpha using secure selection\n    return if_else(condition, x, x * alpha)\n", "model_name": "deepseek-r1"}
{"test_name": "max", "response_0": "def max(a: sint, b: sint) -> sint:\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return mux(a >= b, a, b)\n", "response_1": "def max(a, b):\n    # Compute the comparison result as a secret integer (0 or 1)\n    c = a >= b\n    # Select between a and b using the comparison result\n    return c * a + (1 - c) * b\n", "model_name": "deepseek-r1"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    c1 = x > 1\n    c2 = x < -1\n    part1 = (x - 1) * c1\n    part2 = (-x - 1) * c2\n    return part1 + part2\n", "response_1": "def bowl_shape(x):\n    # Compute condition bits\n    b1 = x > 1\n    b2 = x < -1\n    \n    # Calculate each branch's contribution\n    part1 = b1 * (x - 1)\n    part2 = b2 * (-x - 1)\n    \n    # Sum contributions (mutually exclusive branches)\n    return part1 + part2\n", "model_name": "deepseek-r1"}
{"test_name": "rounded_kinetic_energy", "response_0": "from sfix import *\n\ndef rounded_kinetic_energy(m, v):\n    # Compute kinetic energy\n    k = (m * v * v) * 0.5\n    # Get integer part via floor\n    k_int = k.floor()\n    # Calculate fractional part\n    frac = k - k_int\n    # Determine if we need to round up\n    round_up = frac >= 0.5\n    # Apply rounding and return\n    return k_int + round_up.if_else(1, 0)\n", "response_1": "", "model_name": "deepseek-r1"}
{"test_name": "danger_test", "response_0": "def danger_test(origin, damage):\n    return (origin - damage <= 10).if_else(sint(1), sint(0))\n", "response_1": "def danger_test(origin, damage):\n    return origin - damage <= 10\n", "model_name": "deepseek-r1"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    return ind.if_else(x + y, x * y)\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"MP-SPDZ implementation of conditional sum/product using secure multiplexer\"\"\"\n    sum_result = x + y\n    product_result = x * y\n    return mux(ind, sum_result, product_result)\n", "model_name": "deepseek-r1"}
{"test_name": "median", "response_0": "from sorting import radix_sort\n\ndef median(arr):\n    n_elems = len(arr)\n    if n_elems == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    n_bits = 64  # Adjust based on input range\n    sorter = radix_sort(n_bits, n_elems)\n    sorter.sort(arr)\n    if n_elems % 2:\n        return arr[n_elems//2]\n    else:\n        mid = n_elems//2\n        sum_val = arr[mid] + arr[mid-1]\n        return sum_val / 2\n", "response_1": "def median(arr):\n    # Check if the array is empty\n    if len(arr) == 0:\n        crash(\"The length of the array is 0!\")\n    \n    # Secure sort for secret-shared values\n    arr.sort()\n    \n    n = len(arr)\n    mid = n // 2\n    \n    # Public condition check for even/odd length\n    if n % 2 == 1:\n        return arr[mid]\n    else:\n        # Secure average of two middle elements\n        return (arr[mid] + arr[mid-1]) * 0.5\n", "model_name": "deepseek-r1"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    sum = a + b\n    overflow = sum > 10\n    return overflow.if_else(10, sum)\n", "response_1": "def add_upto_10(a: sint, b: sint) -> sint:\n    sum = a + b\n    condition = sum > 10\n    return mux(condition, sint(10), sum)\n", "model_name": "deepseek-r1"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    # m is in tenths of a mile (secret integer)\n    c1 = m <= 50\n    c2 = (m > 50) * (m <= 100)\n    c3 = m > 100\n    fare1 = 500  # 5.00 dollars in cents\n    fare2 = 500 + 12 * (m - 50)  # 1.2 dollars/mile -> 12 cents per 0.1 mile\n    fare3 = 1100 + 15 * (m - 100)  # 1.5 dollars/mile -> 15 cents per 0.1 mile\n    total_fare = c1 * fare1 + c2 * fare2 + c3 * fare3\n    return total_fare\n", "response_1": "def taxi_fare(m):\n    # Compute the conditions for each fare segment\n    c1 = m <= 5.0\n    c2 = (m > 5.0) * (m <= 10.0)\n    c3 = m > 10.0\n\n    # Calculate fare components for each segment\n    term1 = sfix(5.0)\n    term2 = sfix(5.0) + (m - 5.0) * 1.2\n    term3 = sfix(11.0) + (m - 10.0) * 1.5\n\n    # Combine components based on conditions\n    return c1 * term1 + c2 * term2 + c3 * term3\n", "model_name": "deepseek-r1"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer using secure operations.\n    x: sfix input value\n    Returns: sfix rounded value\n    \"\"\"\n    x_int = x.floor()\n    fractional = x - x_int\n    condition = fractional < 0.5\n    return mux(condition, x_int, x_int + 1)\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    scaled = x.val\n    fractional = scaled % 1000000  # Assuming 6 decimal places for cfix\n    floor = scaled // 1000000\n    return cfix(floor + (fractional >= 500000))\n", "model_name": "deepseek-r1"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    # Convert GPA values to fixed-point representation (multiplied by 10)\n    bit1 = score >= 90\n    part1 = bit1 * 40  # 4.0 * 10\n\n    bit2 = (score >= 85) * (1 - bit1)\n    part2 = bit2 * 36  # 3.6 * 10\n\n    bit3 = (score >= 80) * (1 - bit1 - bit2)\n    part3 = bit3 * 33  # 3.3 * 10\n\n    bit4 = (score >= 75) * (1 - bit1 - bit2 - bit3)\n    part4 = bit4 * 30  # 3.0 * 10\n\n    bit5 = (score >= 70) * (1 - bit1 - bit2 - bit3 - bit4)\n    part5 = bit5 * 26  # 2.6 * 10\n\n    # Handle else case (score < 70)\n    sum_bits = bit1 + bit2 + bit3 + bit4 + bit5\n    part6 = (1 - sum_bits) * 23  # 2.3 * 10\n\n    total_gpa = part1 + part2 + part3 + part4 + part5 + part6\n    return total_gpa\n", "response_1": "def gpa_calculator(score):\n    # Convert conditions to sfix and multiply by GPA values\n    c1 = sfix(score >= 90)\n    c2 = sfix((score >= 85) * (score < 90))\n    c3 = sfix((score >= 80) * (score < 85))\n    c4 = sfix((score >= 75) * (score < 80))\n    c5 = sfix((score >= 70) * (score < 75))\n    c6 = sfix(score < 70)\n    \n    return c1 * 4.0 + c2 * 3.6 + c3 * 3.3 + c4 * 3.0 + c5 * 2.6 + c6 * 2.3\n", "model_name": "deepseek-r1"}
{"test_name": "sign", "response_0": "def sign(x):\n    return (x > 0) - (x < 0)\n", "response_1": "def sign(x):\n    return (x == 0).if_else(0, (x > 0).if_else(1, -1))\n", "model_name": "deepseek-r1"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    # Compute both possible results\n    sum_result = a + b\n    diff_result = a - b\n    # Use comparison and conditional selection\n    condition = a <= b\n    return if_else(condition, sum_result, diff_result)\n", "response_1": "def sum_or_difference(a, b):\n    return mux(a <= b, a + b, a - b)\n", "model_name": "deepseek-r1"}
{"test_name": "CNOT", "response_0": "", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"Secure implementation of CNOT gate using secret-shared bits.\"\"\"\n    return mux(control_bit, 1 - flip_bit, flip_bit)\n", "model_name": "deepseek-r1"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    # Compare y with 0 to get a secret boolean (sbit)\n    condition = y < 0\n    # Use if_else to select between y+1 or y based on condition\n    return if_else(condition, y + 1, y)\n", "response_1": "def negative_plus1(y):\n    return if_else(y < 0, y + 1, y)\n", "model_name": "deepseek-r1"}
{"test_name": "is_a_parallelogram", "response_0": "def is_a_parallelogram(a0, a1, b0, b1, c0, c1, d0, d1):\n    # Check for duplicate points\n    same_ab = (a0 == b0) * (a1 == b1)\n    same_ac = (a0 == c0) * (a1 == c1)\n    same_ad = (a0 == d0) * (a1 == d1)\n    same_bc = (b0 == c0) * (b1 == c1)\n    same_bd = (b0 == d0) * (b1 == d1)\n    same_cd = (c0 == d0) * (c1 == d1)\n    has_duplicates = same_ab + same_ac + same_ad + same_bc + same_bd + same_cd\n    has_duplicates = has_duplicates != 0\n\n    # Check parallelogram conditions\n    cond1_x = (a0 + b0) == (c0 + d0)\n    cond1_y = (a1 + b1) == (c1 + d1)\n    cond1 = cond1_x * cond1_y\n\n    cond2_x = (a0 + c0) == (b0 + d0)\n    cond2_y = (a1 + c1) == (b1 + d1)\n    cond2 = cond2_x * cond2_y\n\n    cond3_x = (a0 + d0) == (b0 + c0)\n    cond3_y = (a1 + d1) == (b1 + c1)\n    cond3 = cond3_x * cond3_y\n\n    cond_any = (cond1 + cond2 + cond3) != 0\n\n    # Final result\n    result = cond_any * (1 - has_duplicates)\n    return result\n", "response_1": "def is_a_parallelogram(a_x, a_y, b_x, b_y, c_x, c_y, d_x, d_y):\n    # Check for duplicate points\n    same_ab = (a_x == b_x) & (a_y == b_y)\n    same_ac = (a_x == c_x) & (a_y == c_y)\n    same_ad = (a_x == d_x) & (a_y == d_y)\n    same_bc = (b_x == c_x) & (b_y == c_y)\n    same_bd = (b_x == d_x) & (b_y == d_y)\n    same_cd = (c_x == d_x) & (c_y == d_y)\n    has_duplicates = same_ab | same_ac | same_ad | same_bc | same_bd | same_cd\n    \n    # Check midpoint conditions\n    cond1_x = (a_x + b_x) == (c_x + d_x)\n    cond1_y = (a_y + b_y) == (c_y + d_y)\n    condition1 = cond1_x & cond1_y\n    \n    cond2_x = (a_x + c_x) == (b_x + d_x)\n    cond2_y = (a_y + c_y) == (b_y + d_y)\n    condition2 = cond2_x & cond2_y\n    \n    cond3_x = (a_x + d_x) == (b_x + c_x)\n    cond3_y = (a_y + d_y) == (b_y + c_y)\n    condition3 = cond3_x & cond3_y\n    \n    mid_condition = condition1 | condition2 | condition3\n    \n    return (~has_duplicates) & mid_condition\n", "model_name": "deepseek-r1"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"Return the secure minimum of two secret values.\"\"\"\n    return smin(a, b)\n", "response_1": "def min(a, b):\n    \"\"\"Secure computation of minimum value between two sfix inputs\"\"\"\n    return (a <= b).if_else(a, b)\n", "model_name": "deepseek-r1"}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x: cint, y: cint) -> cint:\n    def legal(a: cint, b: cint) -> cint:\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n    \n    # Generate all 8 possible knight moves\n    moves = [\n        (x + 1, y + 2),\n        (x - 1, y + 2),\n        (x + 1, y - 2),\n        (x - 1, y - 2),\n        (x + 2, y + 1),\n        (x - 2, y + 1),\n        (x + 2, y - 1),\n        (x - 2, y - 1)\n    ]\n    \n    total = cint(0)\n    for dx, dy in moves:\n        total += legal(dx, dy)\n    \n    return total\n", "response_1": "def choice_of_the_knight(x, y):\n    # Define the eight possible knight moves as deltas\n    deltas = [\n        (1, 2), (-1, 2),\n        (1, -2), (-1, -2),\n        (2, 1), (-2, 1),\n        (2, -1), (-2, -1)\n    ]\n    \n    count = sint(0)\n    \n    for dx, dy in deltas:\n        a = x + dx\n        b = y + dy\n        # Check if position is within bounds using secret comparisons\n        valid_x = (a >= 0) & (a <= 7)\n        valid_y = (b >= 0) & (b <= 7)\n        count += sint(valid_x & valid_y)\n    \n    return count\n", "model_name": "deepseek-r1"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    sum_ab = a + b\n    diff_ab = a - b\n    condition = sum_ab > diff_ab\n    return condition.if_else(sum_ab, diff_ab)\n", "response_1": "def max_sum_different(a,b):\n    a_plus_b = a + b\n    a_minus_b = a - b\n    condition = a_plus_b > a_minus_b\n    return mux(condition, a_plus_b, a_minus_b)\n", "model_name": "deepseek-r1"}
