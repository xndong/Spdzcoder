{"test_name": "next_integer", "response_0": "def next_integer(t):\n    sint_part = t.trunc()\n    fractional_part = t - sint_part.to_sfix()\n    is_negative = t < 0\n    has_fraction = (fractional_part != 0)\n    adjustment = (is_negative & has_fraction).if_else(sint(1), sint(0))\n    floor_t = sint_part - adjustment\n    return floor_t + 1\n", "response_1": "", "model_name": "deepseek-r1"}
{"test_name": "father_and_son", "response_0": "def main():\n    # Read secret inputs from party 0\n    father_age = sint.get_input_from(0)\n    son_age = sint.get_input_from(0)\n    \n    # Calculate absolute difference using native sint operations\n    age_diff = father_age - 2 * son_age\n    absolute_diff = age_diff.abs()\n    \n    # Reveal and output the result\n    print_ln(\"Years difference: %s\", absolute_diff.reveal())\n", "response_1": "def father_and_son(father_age, son_age):\n    # Calculate the difference and take absolute value using .abs()\n    return (father_age - son_age * 2).abs()\n", "model_name": "deepseek-r1"}
{"test_name": "triangle_area", "response_0": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the area of the triangle.\n    \"\"\"\n    return side * height / 2\n", "response_1": "def triangle_area(side, height):\n    \"\"\"\n    Given secret-shared values for a triangle's side length and corresponding height,\n    computes the area using sfix type for secure fixed-point arithmetic.\n    \"\"\"\n    return side * height / 2.0\n", "model_name": "deepseek-r1"}
{"test_name": "sin_plus_cos", "response_0": "def sin_plus_cos(a):\n    \"\"\"Return sin(a)+cos(a) for sfix value a\"\"\"\n    return a.sin() + a.cos()\n", "response_1": "def sin_plus_cos(a):\n    \"\"\"\n    Return approximate sfix value of sin(a)+cos(a) using Taylor series expansion.\n    Note: Accurate for inputs near zero using 5th-order sin and 4th-order cos approximation.\n    \"\"\"\n    sin_a = a - (a*a*a)/sfix(6) + (a*a*a*a*a)/sfix(120)\n    cos_a = sfix(1) - (a*a)/sfix(2) + (a*a*a*a)/sfix(24)\n    return sin_a + cos_a\n", "model_name": "deepseek-r1"}
{"test_name": "sigmoid", "response_0": "def sigmoid(x):\n    \"\"\"\n    sigmoid function using fixed-point arithmetic\n    \"\"\"\n    return 1 / (sfix(1) + exp(-x))\n", "response_1": "def sigmoid(x):\n    \"\"\"sigmoid function for sfix type\"\"\"\n    return 1 / (1 + (-x).exp()\n", "model_name": "deepseek-r1"}
{"test_name": "self_exponent", "response_0": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return k ** k\n", "response_1": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    max_k = 20  # Adjust based on maximum expected k\n    result = sint(1)\n    for i in range(max_k):\n        cond = i < k\n        result = result * (cond * k + (1 - cond) * 1)\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "silu", "response_0": "def silu(x):\n    \"\"\"SiLU function in MP-SPDZ\"\"\"\n    import cmath\n    return x / (1 + cmath.exp(-x))\n", "response_1": "def silu(x):\n    \"\"\"\n    SiLU function in MP-SPDZ using sfix type\n    \"\"\"\n    return x / (sfix(1) + (-x).exp()\n", "model_name": "deepseek-r1"}
{"test_name": "Gaussian_bracket", "response_0": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the fractional part of x using secure computation.\n    \"\"\"\n    # Get integer part as secure integer\n    x_floor_sint = x.floor()\n    # Convert integer part back to sfix (already scaled)\n    x_floor = sfix(x_floor_sint, True)\n    # Calculate fractional part\n    return x - x_floor\n", "response_1": "def Gaussian_bracket(x):\n    t = x.trunc()\n    fractional = x - sfix(t)\n    is_negative = x < 0\n    has_fraction = fractional != 0\n    adjustment = is_negative * has_fraction\n    floor_x = t - sint(adjustment)\n    return x - sfix(floor_x)\n", "model_name": "deepseek-r1"}
{"test_name": "asin_and_square", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef asin_and_square(x):\n    # Taylor series approximation for arcsin(x) up to x^5 term\n    x_squared = x * x\n    x_cubed = x * x_squared\n    term1 = x_cubed * sfix(0.1666666667)  # 1/6\n    x_fifth = x_cubed * x_squared\n    term2 = x_fifth * sfix(0.075)         # 3/40\n    asin_approx = x + term1 + term2\n    \n    # Square the approximation\n    result = asin_approx * asin_approx\n    return result\n", "response_1": "from library import sfix\n\ndef asin_and_square(x):\n    # Compute arcsin via 3rd order Taylor approximation (x + x\u00b3/6 + 3x\u2075/40)\n    x_sq = x * x\n    x_cu = x * x_sq\n    x_qu = x_cu * x_sq\n    term1 = x_cu * sfix(0.16666666666666666)  # 1/6\n    term2 = x_qu * sfix(0.075)                # 3/40\n    asin_approx = x + term1 + term2\n    \n    # Square the result\n    return asin_approx.sqr()\n", "model_name": "deepseek-r1"}
{"test_name": "cylinder_surface", "response_0": "def cylinder_surface(r, h):\n    \"\"\"\n    Given secret fixed-point radius and height of a cylinder, return its surface area.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return 2 * pi * r * r + 2 * pi * r * h\n", "response_1": "def cylinder_surface(r, h):\n    # Calculate \u03c0 as a fixed-point value\n    pi = fixed(3.141592653589793)\n    # Compute surface area components using MP-SPDZ arithmetic\n    return 2 * pi * r * r + 2 * pi * r * h\n", "model_name": "deepseek-r1"}
{"test_name": "radian_to_degree", "response_0": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    return r / sfix(3.141592653589793) * 180\n", "response_1": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree using fixed-point arithmetic\n    \"\"\"\n    return r * sfix(57.29577951308232)  # 180/\u03c0 \u2248 57.29577951308232\n", "model_name": "deepseek-r1"}
{"test_name": "square_root", "response_0": "def square_root(a):\n    \"\"\"\n    return the square root of the input.\n    \"\"\"\n    return a.sqrt()\n", "response_1": "def square_root(a):\n    \"\"\"Return the square root of the secret-shared input value\"\"\"\n    return sqrt(a)\n", "model_name": "deepseek-r1"}
{"test_name": "cosine_theorem", "response_0": "def cosine_theorem(a,b,rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them (in radians),\n    use cosine theorem to compute the length of the third edge.\n    All parameters and return value are secret shared sfix type.\n    \"\"\"\n    return sfix.sqrt(a*a + b*b - 2*a*b*sfix.cos(rad))\n", "response_1": "from sfix import *\n\ndef cosine_theorem(a, b, rad):\n    # Calculate cosine using a Taylor series approximation up to x^6 term\n    x = rad\n    x_sq = x * x\n    x_four = x_sq * x_sq\n    x_six = x_four * x_sq\n    cos_rad = 1 - (x_sq / 2) + (x_four / 24) - (x_six / 720)\n    \n    # Compute the squared length of the third edge\n    c_squared = a * a + b * b - 2 * a * b * cos_rad\n    \n    # Calculate and return the square root of the result\n    return c_squared.sqrt()\n", "model_name": "deepseek-r1"}
{"test_name": "lights_states", "response_0": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return 2 ** num\n", "response_1": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    # In MP-SPDZ, use bit shift for efficient 2^num calculation\n    return 1 << num\n", "model_name": "deepseek-r1"}
{"test_name": "degree_to_radian", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nimport math\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    factor = sfix(math.pi) / 180\n    return d * factor\n", "response_1": "", "model_name": "deepseek-r1"}
{"test_name": "Fah_to_Cel", "response_0": "def Fah_to_Cel(F):\n    \"\"\"Convert secret Fahrenheit temperature to secret Celsius temperature.\"\"\"\n    return (F - sfloat(32)) / sfloat(1.8)\n", "response_1": "def Fah_to_Cel(F: sfix):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature using secret-shared fixed-point arithmetic.\n    \"\"\"\n    return (F - sfix(32)) / sfix(1.8)\n", "model_name": "deepseek-r1"}
{"test_name": "elliptic_area", "response_0": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area. \n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return pi * a * b\n", "response_1": "from Compiler import types\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic (as sfix values), \n    returns its area using secure fixed-point arithmetic.\n    \"\"\"\n    # Predefined \u03c0 constant in sfix format (3.141592653589793)\n    pi = types.sfix(3.141592653589793)\n    return pi * a * b\n", "model_name": "deepseek-r1"}
{"test_name": "floor", "response_0": "def floor(z):\n    \"\"\"\n    Return the maximum integer (sint) no bigger than the input (sfix).\n    \"\"\"\n    return z.floor()\n", "response_1": "from sfix import *\n\ndef floor(z):\n    truncated = z.trunc()\n    is_negative = z < 0\n    has_fraction = z != truncated\n    adjustment = is_negative * has_fraction * sfix(1)\n    return truncated - adjustment\n", "model_name": "deepseek-r1"}
{"test_name": "log_and_cube", "response_0": "def log_and_cube(x):\n    from mpc_math import log2_fx\n    log_val = log2_fx(x)\n    cubed = log_val * log_val * log_val\n    return cubed\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.types import sfix\nimport math\n\ndef log_and_cube(x):\n    \"\"\"Secure implementation of log2(x)\u00b3 using fixed-point arithmetic\"\"\"\n    ln_x = x.log()\n    ln_2 = sfix(math.log(2))\n    log2_x = ln_x / ln_2\n    return log2_x * log2_x * log2_x\n", "model_name": "deepseek-r1"}
{"test_name": "floor_and_square", "response_0": "def floor_and_square(z):\n    t = trunc(z, sfix.f, True)\n    t_sfix = sfix(t)\n    is_negative_fraction = z < t_sfix\n    adjusted_floor = t - is_negative_fraction.if_else(sint(1), sint(0))\n    scale = cint(2 ** sfix.f)\n    squared_scaled = adjusted_floor * adjusted_floor * scale\n    return sfix(squared_scaled)\n", "response_1": "def floor_and_square(z):\n    \"\"\"\n    Calculate floor of secret fixed-point input and return its square.\n    z: sfix (secret fixed-point value)\n    Returns: sint (secret integer squared result)\n    \"\"\"\n    floored = z.floor()\n    return floored * floored\n", "model_name": "deepseek-r1"}
{"test_name": "meters_to_feet", "response_0": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet using fixed-point arithmetic.\n    \"\"\"\n    return m * sfix(3.2808)\n", "response_1": "def meters_to_feet(m):\n    return m * sfix(3.2808)\n", "model_name": "deepseek-r1"}
{"test_name": "sphere_area", "response_0": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r (sfix type).\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return sfix(4) * pi * r * r\n", "response_1": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r in fixed-point arithmetic.\n    Assumes r is scaled by 1e6 (e.g., 2.5 is represented as 2500000).\n    \"\"\"\n    s = 10**6\n    pi = 3141593  # 3.141592653589793 * 1e6 rounded to integer\n    r_sq = r * r\n    return (4 * pi * r_sq) // (s * s)\n", "model_name": "deepseek-r1"}
{"test_name": "coarse_abs", "response_0": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    p = sint.get_precision()\n    x_abs = x.sabs()\n    scaling_factor = 10 ** p\n    return x_abs / scaling_factor\n", "response_1": "def coarse_abs(x):\n    \"\"\"Return the absolute value of x and truncate towards zero.\"\"\"\n    return x.abs().trunc()\n", "model_name": "deepseek-r1"}
{"test_name": "how_many_chickens", "response_0": "def how_many_chickens(sheads, slegs):\n    \"\"\"\n    Compute the number of chickens using secret-shared values for heads and legs.\n    \"\"\"\n    return sheads - ((slegs - sheads*2) // 2)\n", "response_1": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - ((legs - heads * 2) // 2)\n", "model_name": "deepseek-r1"}
{"test_name": "interest_calculator", "response_0": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    MPC compound interest calculation using explicit multiplication loop.\n    Assumes 'months' is a public integer, while 'capital' and 'ratio' are secret sfix values.\n    \"\"\"\n    result = sfix(1)\n    one = sfix(1)\n    for _ in range(months):\n        result = result * (one + ratio)\n    total_interest = (result - one) * capital\n    return total_interest\n", "response_1": "def interest_calculator(capital, ratio, months):\n    factor = 1 + ratio\n    compounded = factor ** months\n    interest = (compounded - 1) * capital\n    return interest\n", "model_name": "deepseek-r1"}
{"test_name": "circle_area", "response_0": "def circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius (sfix type).\n    \"\"\"\n    # Predefined \u03c0 in sfix (scaled integer representation)\n    pi = sfix(205887, use_magic=True)\n    return pi * r * r\n", "response_1": "def circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius (secret sfix type).\n    \"\"\"\n    return sfix.pi * r ** 2\n", "model_name": "deepseek-r1"}
{"test_name": "cube_and_square_root", "response_0": "def cube_and_square_root(x):\n    cubed = sfix.pow(x, 3)\n    return sfix.sqrt(cubed)\n", "response_1": "def cube_and_square_root(x):\n    cubed = x * x * x\n    return cubed.sqrt()\n", "model_name": "deepseek-r1"}
{"test_name": "round", "response_0": "def round(x):\n    x_trunc = sint.get_typed(x)\n    x_trunc_sfix = sfix(x_trunc)\n    is_negative = x < 0\n    has_fraction = x != x_trunc_sfix\n    floor_x = x_trunc - ( (is_negative & has_fraction).if_else(sint(1), sint(0)) )\n    fractional_part = x - sfix(floor_x)\n    should_round_up = fractional_part >= 0.5\n    rounded = floor_x + should_round_up.if_else(sint(1), sint(0))\n    return sfix(rounded)\n", "response_1": "def round(x):\n    # Compute the integer part truncated towards zero\n    x_int = x.get_int()\n    # Determine if x is negative and has a fractional part\n    is_negative = x < sfix(0)\n    has_fraction = x != sfix(x_int)\n    # Adjust x_floor to match math.floor behavior\n    adjustment = is_negative * has_fraction\n    x_floor = x_int - adjustment\n    # Calculate fractional part\n    fractional = x - sfix(x_floor)\n    # Check if fractional part is less than 0.5\n    condition = fractional < sfix(0.5)\n    # Select result based on condition\n    result = condition.if_else(x_floor, x_floor + 1)\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "cryptic_adjustment", "response_0": "def cryptic_adjustment(origin):\n    inner_sqrt = sfix.sqrt(origin)\n    temp = 10 * inner_sqrt\n    outer_sqrt = sfix.sqrt(temp)\n    return 10 * outer_sqrt\n", "response_1": "def cryptic_adjustment(origin):\n    temp1 = origin.sqrt()\n    temp2 = temp1 * 10\n    temp3 = temp2.sqrt()\n    return temp3 * 10\n", "model_name": "deepseek-r1"}
{"test_name": "specific_pow", "response_0": "def specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using MPC-friendly operations\n    \"\"\"\n    # x^2.5 = sqrt(x^5) since 2.5 = 5/2\n    # Compute x^5 through sequential multiplication\n    x_cubed = x * x * x\n    x_fifth = x_cubed * x * x\n    # Square root using MPC-native operation\n    return x_fifth.sqrt()\n", "response_1": "def specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    x_sq = x * x\n    sqrt_x = x.sqrt()\n    return x_sq * sqrt_x\n", "model_name": "deepseek-r1"}
{"test_name": "soft_plus", "response_0": "def soft_plus(x):\n    \"\"\"\n    Softplus function for sfix type\n    \"\"\"\n    return (sfix(1) + x.exp()).log()\n", "response_1": "def soft_plus(x):\n    \"\"\"Softplus function using MP-SPDZ fixed-point arithmetic\"\"\"\n    # Compute e^x using secure fixed-point exponent\n    # Add 1 and take natural logarithm\n    return (sfix(1) + x.exp()).log()\n", "model_name": "deepseek-r1"}
{"test_name": "ball_volume", "response_0": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    return (sfix(4) * sfix.pi() * r * r * r) / 3\n", "response_1": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return pi * r**3 * 4 / 3\n", "model_name": "deepseek-r1"}
{"test_name": "Heron", "response_0": "def Heron(a,b,c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its area with Heron's formula.\n    All inputs and outputs are in sfix type for secure computation.\n    \"\"\"\n    p = (a + b + c) / 2\n    product = p * (p - a) * (p - b) * (p - c)\n    return product.sqrt()\n", "response_1": "def Heron(a, b, c):\n    # Calculate semi-perimeter\n    p = (a + b + c) / 2\n    # Compute product under square root using Heron's formula\n    product = p * (p - a) * (p - b) * (p - c)\n    # Return square root of the product using sfix's built-in sqrt\n    return product.sqrt()\n", "model_name": "deepseek-r1"}
{"test_name": "next_perfect_square", "response_0": "def next_perfect_square(x):\n    low = sint(0)\n    high = x\n    for _ in range(64):\n        mid = (low + high) / 2\n        mid_sq = mid * mid\n        cmp = mid_sq <= x\n        new_low = cmp.if_else(mid + 1, low)\n        new_high = cmp.if_else(high, mid - 1)\n        low, high = new_low, new_high\n    return (high + 1) * (high + 1)\n", "response_1": "def next_perfect_square(x):\n    sqrt_x = sqrt(x)\n    next_root = sqrt_x + 1\n    return next_root * next_root\n", "model_name": "deepseek-r1"}
{"test_name": "pi_to_the_x", "response_0": "def pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x using secure fixed-point arithmetic.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return (x * pi.ln()).exp()\n", "response_1": "def pi_to_the_x(x):\n    \"\"\"Return the value of \u03c0^x in MP-SPDZ fixed-point arithmetic\"\"\"\n    pi = sfix(3.141592653589793)  # Define \u03c0 with sfix precision\n    return pi.pow(x)\n", "model_name": "deepseek-r1"}
{"test_name": "spring_rocket", "response_0": "def spring_rocket(height, m, k):\n    g = sfix(9.8)\n    numerator = 2 * m * g * height\n    value = numerator / k\n    res = value.sqrt()\n    return res\n", "response_1": "def spring_rocket(height, m, k):\n    g = sfix(9.8)\n    temp = (sfix(2) * m * g * height) / k\n    return temp.sqrt()\n", "model_name": "deepseek-r1"}
{"test_name": "cone_volume", "response_0": "def cone_volume(r, h):\n    \"\"\"\n    Given the secret radius and height, compute the volume of the cone.\n    \"\"\"\n    # Define \u03c0 with sfix fixed-point type\n    pi = sfix(3.141592653589793)\n    # Calculate volume using fixed-point arithmetic: (\u03c0 * r\u00b2 * h) / 3\n    return (pi * r * r * h) / 3\n", "response_1": "def cone_volume(r, h):\n    \"\"\"\n    Given the radius and height (sfix type), compute the volume of the cone.\n    \"\"\"\n    # Use fixed-point approximation of \u03c0 (3.141592653589793 in sfix)\n    pi = sfix(3.141592653589793)\n    return pi * r * r * h / 3\n", "model_name": "deepseek-r1"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) / 2\n", "response_1": "def how_many_rabbits(heads, legs):\n    return (legs - heads * 2) / 2\n", "model_name": "deepseek-r1"}
