{"test_name": "array_from_intrinsic_linspace", "response_0": "num = 10\nstart = sfix(0)\nend = sfix(99)\na = Array(num, sfix)\n\nfor i in range(num):\n    step = (end - start) * (sfix(i) / (num - 1))\n    a[i] = start + step\n", "response_1": "num = 10\nstart = 0\nend = 99\nstep = cfix(end - start) / (num - 1)\na = Array(num, cfix)\nfor i in range(num):\n    a[i] = cfix(start) + cfix(i) * step\n", "model_name": "deepseek-r1"}
{"test_name": "more_positive", "response_0": "def more_positive(arr):\n    count = 0\n    for x in arr:\n        count += (x > 0) - (x < 0)\n    return count > 0\n", "response_1": "def more_positive(arr):\n    count = sfix(0)\n    for x in arr:\n        count += (x > 0) - (x < 0)\n    return count > 0\n", "model_name": "deepseek-r1"}
{"test_name": "select", "response_0": "def select(ind, a, b):\n    res = sfloat.Array(len(a))\n    for i in range(len(a)):\n        res[i] = ind[i].if_else(a[i], b[i])\n    return res\n", "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from two sfix arrays based on a sint array ind (0 or 1).\n    Returns new sfix array where each element is a[i] if ind[i]=1, else b[i].\n    \"\"\"\n    return [ind[i] * a[i] + (1 - ind[i]) * b[i] for i in range(len(ind))]\n", "model_name": "deepseek-r1"}
{"test_name": "np_relu", "response_0": "from mpc_math import max\n\ndef relu(y):\n    return max(y, 0)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function on secret-shared values.\n    \"\"\"\n    return [ (x > 0) * x for x in y ]\n", "model_name": "deepseek-r1"}
{"test_name": "cost_matrix", "response_0": "def cost_matrix(profit_matrix):\n    # Find the maximum value in the profit matrix\n    max_val = profit_matrix[0][0]\n    for row in profit_matrix:\n        for val in row:\n            if val > max_val:\n                max_val = val\n    \n    # Create offset matrix filled with max_val\n    offset_matrix = []\n    for row in profit_matrix:\n        offset_row = []\n        for _ in row:\n            offset_row.append(max_val)\n        offset_matrix.append(offset_row)\n    \n    # Calculate cost matrix by subtracting original values from offset\n    cost_matrix = []\n    for i in range(len(profit_matrix)):\n        cost_row = []\n        for j in range(len(profit_matrix[i])):\n            cost = offset_matrix[i][j] - profit_matrix[i][j]\n            cost_row.append(cost)\n        cost_matrix.append(cost_row)\n    \n    return cost_matrix\n", "response_1": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    rows = len(profit_matrix)\n    cols = len(profit_matrix[0])\n    \n    # Find maximum value in profit matrix\n    max_val = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            current = profit_matrix[i][j]\n            if current > max_val:\n                max_val = current\n    \n    # Create cost matrix by subtracting each element from max_val\n    cost_matrix = Array(rows, regint)\n    for i in range(rows):\n        row = Array(cols, regint)\n        for j in range(cols):\n            row[j] = max_val - profit_matrix[i][j]\n        cost_matrix[i] = row\n    \n    return cost_matrix\n", "model_name": "deepseek-r1"}
{"test_name": "np_zeros", "response_0": "n = 10\na = Array(n, cint)\n@for_range(n)\ndef _(i):\n    a[i] = cint(0)\n", "response_1": "n = 10\na = Array(n, lambda _: sint(0))\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    rows = len(ndarray)\n    cols = len(ndarray[0])\n    result = [sint(0) for _ in range(cols)]\n    \n    for i in range(rows):\n        eq = sint(i) == row_index\n        for j in range(cols):\n            result[j] += eq * ndarray[i][j]\n    \n    return result\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    # Determine array dimensions\n    rows = ndarray.sizes[0]\n    cols = ndarray.sizes[1]\n    \n    # Initialize result array\n    result = sint.Array(cols)\n    \n    # Iterate through all possible rows\n    for i in range(rows):\n        # Create mask if current row matches index\n        mask = (i == row_index)\n        \n        # Select elements from matching row\n        for j in range(cols):\n            result[j] = mask * ndarray[i][j] + (1 - mask) * result[j]\n    \n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    return Array(n, lambda i: 0)\n", "response_1": "def zeros(n):\n    return [sint(0) for _ in range(n)]\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_slicing_stride", "response_0": "def array_concate(a, b):\n    # Collect even indices from first array\n    even_a = []\n    for i in range(0, len(a), 2):\n        even_a.append(a[i])\n    \n    # Collect odd indices from second array\n    odd_b = []\n    for i in range(1, len(b), 2):\n        odd_b.append(b[i])\n    \n    # Concatenate and return\n    return even_a + odd_b\n", "response_1": "def array_concate(a, b):\n    # Collect even indices from first array\n    even_a = []\n    for i in range(0, len(a), 2):\n        even_a.append(a[i])\n    \n    # Collect odd indices from second array\n    odd_b = []\n    for i in range(1, len(b), 2):\n        odd_b.append(b[i])\n    \n    # Concatenate and return as new array\n    return even_a + odd_b\n", "model_name": "deepseek-r1"}
{"test_name": "QR_decomposition", "response_0": "def QR_decomposition(mat):\n    # Transpose the matrix to work with columns\n    n = len(mat)\n    m = len(mat[0])\n    columns = [[mat[i][j] for i in range(n)] for j in range(m)]\n    \n    q_columns = []\n    for i in range(m):\n        # Copy the original column\n        v = [x for x in columns[i]]\n        \n        # Subtract projections from previous vectors\n        for j in range(i):\n            qj = q_columns[j]\n            # Compute inner product\n            inner_product = sfloat(0)\n            for k in range(n):\n                inner_product += v[k] * qj[k]\n            # Subtract projection\n            for k in range(n):\n                v[k] -= inner_product * qj[k]\n        \n        # Compute norm\n        norm_sq = sfloat(0)\n        for x in v:\n            norm_sq += x*x\n        norm = norm_sq.sqrt()\n        \n        # Normalize vector\n        q_i = [x / norm for x in v]\n        q_columns.append(q_i)\n    \n    # Transpose back to row-major format\n    return [[q_columns[j][i] for j in range(m)] for i in range(n)]\n", "response_1": "def QR_decomposition(mat):\n    # Get the number of rows and columns\n    rows = len(mat)\n    cols = len(mat[0])\n    \n    # Transpose the matrix to work with columns\n    col_matrix = [[mat[i][j] for i in range(rows)] for j in range(cols)]\n    q_columns = []\n    \n    for i in range(cols):\n        # Copy the original column\n        v = [col_matrix[i][j] for j in range(rows)]\n        \n        # Subtract projections from previous vectors\n        for j in range(i):\n            # Compute dot product\n            dot = sum(q_columns[j][k] * v[k] for k in range(rows))\n            # Subtract projection component\n            for k in range(rows):\n                v[k] -= dot * q_columns[j][k]\n        \n        # Normalize the vector\n        norm_squared = sum(v[k] * v[k] for k in range(rows))\n        norm = sfix.sqrt(norm_squared)\n        q_col = [v[k] / norm for k in range(rows)]\n        q_columns.append(q_col)\n    \n    # Transpose back to row-major format\n    return [[q_columns[j][i] for j in range(cols)] for i in range(rows)]\n", "model_name": "deepseek-r1"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    min_diff = abs(array[0] - value)\n    index = 0\n    for i in range(1, len(array)):\n        current_diff = abs(array[i] - value)\n        cmp = current_diff < min_diff\n        min_diff = cmp.if_else(current_diff, min_diff)\n        index = cmp.if_else(i, index)\n    return index\n", "response_1": "def find_nearest_index(array, value):\n    min_index = sint(0)\n    min_diff = (array[0] - value).abs()\n    for i in range(1, len(array)):\n        diff = (array[i] - value).abs()\n        smaller = diff < min_diff\n        min_diff = smaller.if_else(diff, min_diff)\n        min_index = smaller.if_else(i, min_index)\n    return min_index\n", "model_name": "deepseek-r1"}
{"test_name": "np_concat_simple_row", "response_0": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D lists along rows (axis 0)\n    \"\"\"\n    return ndarrayA + ndarrayB\n", "response_1": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate two 2-D arrays along rows (axis 0).\n    \"\"\"\n    return ndarrayA + ndarrayB\n", "model_name": "deepseek-r1"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    n = ndarray.size()\n    array = Array(n, ndarray.value_type)\n    for i in range(n):\n        array[i] = ndarray[i]\n    return array\n", "response_1": "def array_copy(array):\n    new_array = Array(array.size(), array.value_type)\n    for i in range(array.size()):\n        new_array[i] = array[i]\n    return new_array\n", "model_name": "deepseek-r1"}
{"test_name": "max_pooling", "response_0": "def max_pooling(x, stride):\n    # Determine input dimensions\n    batch_size = len(x)\n    height = len(x[0])\n    width = len(x[0][0])\n    \n    # Calculate output dimensions\n    out_height = height // stride\n    out_width = width // stride\n    \n    # Initialize output array\n    out = Array(batch_size, Array(out_height, Array(out_width, sint)))\n    \n    for b in range(batch_size):\n        for i_out in range(out_height):\n            for j_out in range(out_width):\n                # Calculate window starting position\n                i = i_out * stride\n                j = j_out * stride\n                \n                # Initialize current max with first element in window\n                current_max = x[b][i][j]\n                \n                # Iterate over all elements in pooling window\n                for di in range(stride):\n                    for dj in range(stride):\n                        val = x[b][i + di][j + dj]\n                        # Update maximum using secure comparison\n                        current_max = val.if_else(val > current_max, current_max)\n                \n                # Store result in output array\n                out[b][i_out][j_out] = current_max\n                \n    return out\n", "response_1": "def max_pooling(x, stride):\n    # Determine dimensions\n    batch_size = len(x)\n    H = len(x[0])\n    W = len(x[0][0])\n    H_out = H // stride\n    W_out = W // stride\n    \n    # Initialize output with secret zeros\n    out = [[[sint(0) for _ in range(W_out)] for _ in range(H_out)] for _ in range(batch_size)]\n    \n    for b in range(batch_size):\n        for i in range(0, H, stride):\n            for j in range(0, W, stride):\n                # Initialize current_max with first element of window\n                current_max = x[b][i][j]\n                # Compare with other elements in window\n                for di in range(stride):\n                    for dj in range(stride):\n                        if di == 0 and dj == 0:\n                            continue  # Skip first element\n                        val = x[b][i + di][j + dj]\n                        current_max = current_max.max(val)\n                # Store result in output\n                out[b][i // stride][j // stride] = current_max\n    return out\n", "model_name": "deepseek-r1"}
{"test_name": "array_reshape", "response_0": "a = [[cint(j) for j in range(i*5, (i+1)*5)] for i in range(3)]\n", "response_1": "a = [[i * 5 + j for j in range(5)] for i in range(3)]\n", "model_name": "deepseek-r1"}
{"test_name": "np_concat_simple_column", "response_0": "def array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ equivalent for column-wise concatenation of two 2D arrays\n    \"\"\"\n    array = []\n    for i in range(len(ndarrayA)):\n        array.append(ndarrayA[i] + ndarrayB[i])\n    return array\n", "response_1": "def array_simple_concate_column(ndarrayA, ndarrayB):\n    return [a + b for a, b in zip(ndarrayA, ndarrayB)]\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Iterate through each row and collect the element at column_index\n    return [row[column_index] for row in ndarray]\n", "response_1": "def array_dimensional_indexing(ndarray, column_index):\n    res = []\n    for row in ndarray:\n        res.append(row[column_index])\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    n = min(len(array), len(array[0]))\n    res = []\n    for i in range(n):\n        res.append(array[i][i])\n    return res\n", "response_1": "def diag(array):\n    n_rows = len(array)\n    if n_rows == 0:\n        return []\n    n_cols = len(array[0])\n    min_dim = min(n_rows, n_cols)\n    return [array[i][i] for i in range(min_dim)]\n", "model_name": "deepseek-r1"}
{"test_name": "np_concat_special", "response_0": "def array_special_concate(ndarrayA, ndarrayB):\n    # Create new array with same number of rows\n    array = []\n    # For each row in both arrays\n    for i in range(len(ndarrayA)):\n        row_a = ndarrayA[i]\n        row_b = ndarrayB[i]\n        \n        # Collect even columns from arrayA (0, 2, 4...)\n        even_columns = []\n        for j in range(0, len(row_a), 2):\n            even_columns.append(row_a[j])\n        \n        # Collect odd columns from arrayB (1, 3, 5...)\n        odd_columns = []\n        for j in range(1, len(row_b), 2):\n            odd_columns.append(row_b[j])\n        \n        # Concatenate and add to result\n        array.append(even_columns + odd_columns)\n    \n    return array\n", "response_1": "def array_special_concate(ndarrayA, ndarrayB):\n    result = []\n    for i in range(len(ndarrayA)):\n        row = []\n        # Collect even columns from first array\n        for j in range(0, len(ndarrayA[i]), 2):\n            row.append(ndarrayA[i][j])\n        # Collect odd columns from second array\n        for j in range(1, len(ndarrayB[i]), 2):\n            row.append(ndarrayB[i][j])\n        result.append(row)\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_arange", "response_0": "def arange(start, stop=None, step=1):\n    if stop is None:\n        stop = start\n        start = 0\n    \n    n = (stop - start + step - 1) // step\n    if n < 0:\n        n = 0\n    \n    return [start + i * step for i in range(n)]\n", "response_1": "def arange(start, stop, step):\n    # Determine if the original 'stop' was None using a sentinel value (-1)\n    # If stop is -1, adjust start and stop to replicate the Python behavior\n    actual_start = regint(0)\n    actual_stop = regint(0)\n    if_statement(stop == -1, 'public', 'public')\n    def true_block():\n        actual_start.set(0)\n        actual_stop.set(start)\n    def false_block():\n        actual_start.set(start)\n        actual_stop.set(stop)\n    if_statement_end()\n\n    arr = sint.Array(0)\n    current = actual_start\n    while current < actual_stop:\n        arr.append(current)\n        current += step\n    return arr\n", "model_name": "deepseek-r1"}
{"test_name": "np_eye_2", "response_0": "m = 3\nn = 5\na = Array(m, lambda i: Array(n, lambda j: sint(1) if i == j else sint(0)))\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef main():\n    m = 3\n    n = 5\n    # Initialize matrix with zeros\n    a = Matrix(m, n, cint)\n    # Set diagonal elements to 1\n    for i in range(m):\n        for j in range(n):\n            a[i][j] = cint(1 if i == j else 0)\n", "model_name": "deepseek-r1"}
{"test_name": "third_smallest", "response_0": "def third_smallest(arr):\n    n = len(arr)\n    # Create a copy of the array to avoid modifying the original\n    sorted_arr = Array(n, arr[0].type)\n    for i in range(n):\n        sorted_arr[i] = arr[i]\n    # Sort the copied array in ascending order\n    sorted_arr.sort()\n    # Return third element (index 2) from sorted array\n    return sorted_arr[2]\n", "response_1": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    sorted_arr = arr.copy()\n    sorted_arr.sort()\n    return sorted_arr[2]\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to securely index i-th row from 2-D secret arrays.\n    Inputs:\n    ndarray: list of list of sint (secret 2D array)\n    row_index: sint (secret index)\n    Returns: list of sint (selected row elements)\n    \"\"\"\n    if len(ndarray) == 0:\n        return []\n    \n    cols = len(ndarray[0])\n    result = [sint(0) for _ in range(cols)]\n    \n    for i, row in enumerate(ndarray):\n        eq = mpc.eq(row_index, i)\n        for j in range(cols):\n            result[j] += row[j] * eq\n    \n    return result\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to select i-th row from 2D secret-shared array.\n    \"\"\"\n    return ndarray[row_index]\n", "model_name": "deepseek-r1"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = cint.Array(n)\nfor i in range(n):\n    a[i] = i\n", "response_1": "n = 10\na = []  # Use list instead of numpy array\nfor i in range(n):\n    a.append(i)\n", "model_name": "deepseek-r1"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array_row = ndarray[row_index]\n    return array_row\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ equivalent of NumPy row indexing for 2D secret arrays.\n    Assumes ndarray is List[List[sfix/sint]] and row_index is public int.\n    \"\"\"\n    array_row = ndarray[row_index]\n    return array_row\n", "model_name": "deepseek-r1"}
{"test_name": "array_from_python_structure", "response_0": "a_l = [0,10,20,30,40]\na = Array.create_from(a_l)\n", "response_1": "a_l = [0,10,20,30,40]\na = sint.Array.create_from(a_l)\n", "model_name": "deepseek-r1"}
{"test_name": "np_reshape", "response_0": "def array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a 1D array into 2D m x n array.\n    \"\"\"\n    # Check if reshape is possible\n    assert(m * n == len(ndarray))\n    # Create new shape using list slicing\n    return [ndarray[i*n : (i+1)*n] for i in range(m)]\n", "response_1": "def array_reshape(ndarray, m, n):\n    reshaped = sint.Array(m, n)\n    for i in range(m):\n        for j in range(n):\n            reshaped[i][j] = ndarray[i * n + j]\n    return reshaped\n", "model_name": "deepseek-r1"}
{"test_name": "np_ones", "response_0": "n = 10\na = Array(n, cint)\nfor i in range(n):\n    a[i] = 1\n", "response_1": "n = 10\na = sint.Array(n, sint(1))\n", "model_name": "deepseek-r1"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    \"\"\"Set the ones in the array into zeros using secure operations.\"\"\"\n    return [((yi == 1).if_else(0, yi)) for yi in y]\n", "response_1": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    for i in range(len(y)):\n        bit = y[i] == 1\n        y[i] = bit.if_else(sint(0), y[i])\n    return y\n", "model_name": "deepseek-r1"}
{"test_name": "np_eye", "response_0": "n = 10\na = Array(n, lambda i: Array(n, lambda j: 1 if i == j else 0))\n", "response_1": "n = 10\na = Array(n, lambda i: Array(n, lambda j: cint(1) if i == j else cint(0)))\n", "model_name": "deepseek-r1"}
{"test_name": "np_diag", "response_0": "a_l = [1,3,5,2,4,6]\nn = len(a_l)\na = [[cint(0) for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    a[i][i] = cint(a_l[i])\n", "response_1": "a_l = [1,3,5,2,4,6]\nn = len(a_l)\na = Matrix(n, n)\nfor i in range(n):\n    a[i][i] = a_l[i]\n", "model_name": "deepseek-r1"}
{"test_name": "np_advanced_integer_indexing", "response_0": "def integer_array_indexing(array, indices):\n    ret_array = sint.Array(len(indices))\n    for i in range(len(indices)):\n        current_idx = indices[i]\n        element = sint(0)\n        for j in range(len(array)):\n            mask = (j == current_idx)\n            element += array[j] * mask\n        ret_array[i] = element\n    return ret_array\n", "response_1": "def integer_array_indexing(array, indices):\n    ret_array = []\n    for index in indices:\n        ret_array.append(array[index])\n    return ret_array\n", "model_name": "deepseek-r1"}
