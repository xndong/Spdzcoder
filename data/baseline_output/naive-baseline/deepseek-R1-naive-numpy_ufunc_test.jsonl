{"test_name": "cross_entropy_loss", "response_0": "def cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss for secret-shared values.\n    \"\"\"\n    res = sfix(0)\n    for yi in y:\n        res += yi * log_fx(yi)\n    return -res\n", "response_1": "from Compiler import math\n\ndef cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss for secret-shared values.\n    \"\"\"\n    sum = 0\n    for yi in y:\n        sum += yi * math.log(yi)\n    return -sum\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_square_sqrt", "response_0": "from Compiler import floatingpoint\nfrom Compiler.types import sfix\nfrom Compiler.library import print_ln, for_range\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation using MPC operations.\"\"\"\n    # Calculate the mean of the array\n    total = sum(array)\n    n = len(array)\n    mean = total / n\n    \n    # Calculate deviations from the mean\n    deviations = [x - mean for x in array]\n    \n    # Square all deviations\n    squared_deviations = [x*x for x in deviations]\n    \n    # Calculate mean of squared deviations\n    mean_squares = sum(squared_deviations) / n\n    \n    # Take square root to get RMSD\n    rmsd = floatingpoint.sqrt(mean_squares)\n    \n    return rmsd\n", "response_1": "def compute_RMSD(array):\n    \"\"\"This function calculate the root mean square deviation.\"\"\"\n    # Calculate mean\n    sum_total = sfix(0)\n    for x in array:\n        sum_total += x\n    mean = sum_total / len(array)\n    \n    # Calculate squared deviations\n    squared_deviations = sfix.Array(len(array))\n    for i in range(len(array)):\n        deviation = array[i] - mean\n        squared_deviations[i] = deviation * deviation\n    \n    # Calculate mean of squared deviations\n    sum_squares = sfix(0)\n    for x in squared_deviations:\n        sum_squares += x\n    mean_squares = sum_squares / len(array)\n    \n    # Calculate square root\n    rmsd = util.sqrt(mean_squares)\n    return rmsd\n", "model_name": "deepseek-r1"}
{"test_name": "logsumexp", "response_0": "def logsumexp(log_probs):\n    _max = log_probs[0]\n    for i in range(1, len(log_probs)):\n        _max = _max.max(log_probs[i])\n    \n    ds = []\n    for x in log_probs:\n        ds.append(x - _max)\n    \n    exp_sum = sfix(0)\n    for d in ds:\n        exp_sum += d.exp()\n    \n    return _max + exp_sum.log()\n", "response_1": "from util import sum\ndef logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp for secret floating-point inputs\n    \"\"\"\n    n = log_probs.size\n    # Compute maximum value\n    _max = util.max(log_probs, n)\n    # Subtract max and exponentiate\n    ds = Array(n, sfix)\n    for i in range(n):\n        ds[i] = log_probs[i] - _max\n    # Sum exponentials and take log\n    exp_sum = sum(d.exp() for d in ds)\n    # Add back the maximum\n    return _max + exp_sum.log()\n", "model_name": "deepseek-r1"}
{"test_name": "binary_cross_entropy_loss", "response_0": "def binary_cross_entropy(y_hat, y):\n    # Adjust y_hat to prevent log(0) using MPC-friendly scaling\n    epsilon = sfix(0.001)\n    n = len(y_hat)\n    log2_base = sfix(math.log(2))\n    \n    total = sfix(0)\n    for i in range(n):\n        # Scale y_hat to [epsilon, 1-epsilon]\n        adjusted = y_hat[i] * (1 - 2*epsilon) + epsilon\n        \n        # Compute log2(adjusted) using natural logarithm conversion\n        log_term = adjusted.log() / log2_base\n        \n        # Compute log2(1 - adjusted)\n        log_1minus = (1 - adjusted).log() / log2_base\n        \n        # Calculate cross-entropy component\n        term = y[i] * log_term + (1 - y[i]) * log_1minus\n        total += term\n    \n    # Compute negative mean of the loss components\n    return -total / n\n", "response_1": "def binary_cross_entropy(y_hat, y):\n    \"\"\"Compute binary cross-entropy loss with secret sharing\"\"\"\n    \n    # Clip y_hat to prevent log(0)\n    @for_range(len(y_hat))\n    def _(i):\n        lower = y_hat[i] < 0.001\n        y_hat[i] = lower.if_else(sfix(0.001), y_hat[i])\n        upper = y_hat[i] > 0.999\n        y_hat[i] = upper.if_else(sfix(0.999), y_hat[i])\n\n    # Compute log terms using approximation\n    log_y_hat = log2_approx(y_hat)\n    log_1y = log2_approx(1 - y_hat)\n    \n    # Element-wise loss calculation\n    loss_terms = y * log_y_hat + (1 - y) * log_1y\n    \n    # Aggregate and normalize\n    return -sfix.mean(loss_terms)\n\ndef log2_approx(x):\n    \"\"\"Piecewise linear approximation of log2 for [0.001, 0.999]\"\"\"\n    # Coefficients for linear approximation segments\n    m = sfix(-4.0)  # Example slope\n    b = sfix(2.0)    # Example intercept\n    return m * (x - 0.5) + b  # Center around mid-point\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_less_equal", "response_0": "def compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates element-wise comparison (arrayA <= arrayB) for secret values.\"\"\"\n    less_eq = []\n    for a, b in zip(arrayA, arrayB):\n        less_eq.append(a <= b)\n    return less_eq\n", "response_1": "def compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates element-wise less than or equal for secret arrays.\"\"\"\n    return [a <= b for a, b in zip(arrayA, arrayB)]\n", "model_name": "deepseek-r1"}
{"test_name": "RMS_prop_step", "response_0": "def RMS_prop_step(grads, layers):\n    alpha = cfix(0.5)\n    beta = cfix(1.0)\n    s = [[sfix(0) for _ in grad] for grad in grads]\n    \n    for i in range(len(grads)):\n        for j in range(len(grads[i])):\n            s[i][j] = beta * s[i][j] + (1 - beta) * grads[i][j] * grads[i][j]\n            adjusted_grad = alpha * (grads[i][j] / s[i][j].sqrt())\n            layers[i][j] += adjusted_grad\n            \n    return layers\n", "response_1": "def RMS_prop_step(grads, layers):\n    alpha = sfix(0.5)\n    beta = sfix(1.0)\n    s = []\n    for grad in grads:\n        s.append(Array(len(grad), sfix))\n        for j in range(len(grad)):\n            s[-1][j] = sfix(0)\n    \n    for i in range(len(layers)):\n        grad = grads[i]\n        layer = layers[i]\n        s_i = s[i]\n        for j in range(len(grad)):\n            # Update squared gradient accumulator\n            s_i[j] = beta * s_i[j] + (1 - beta) * (grad[j] * grad[j])\n            # Compute adaptive learning rate adjustment\n            adjusted_grad = alpha * (grad[j] / sqrt(s_i[j]))\n            # Update layer parameters\n            layer[j] += adjusted_grad\n    \n    return layers\n", "model_name": "deepseek-r1"}
{"test_name": "entropy", "response_0": "def entropy(y):\n    # Determine the unique elements in y\n    unique = []\n    for elem in y:\n        found = False\n        for u in unique:\n            if u == elem:\n                found = True\n                break\n        if not found:\n            unique.append(elem)\n    \n    n = len(y)\n    sum_ = sfix(0)\n    \n    # Calculate entropy components for each unique value\n    for val in unique:\n        count = 0\n        for elem in y:\n            count += (elem == val)\n        p = sfix(count) / sfix(n)\n        sum_ += -p * p.log2()\n    \n    return sum_\n", "response_1": "def entropy(y):\n    # Compute entropy of array y\n    n = len(y)\n    # Build unique list\n    unique = []\n    for elem in y:\n        found = False\n        for u in unique:\n            if u == elem:\n                found = True\n                break\n        if not found:\n            unique.append(elem)\n    sum_ = 0\n    for i in unique:\n        count = 0\n        for elem in y:\n            count += (elem == i)\n        p = count / n\n        sum_ += - (p * p.log2())\n    return sum_\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_exp", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sfix, SecretArray\n\ndef compute_softmax(arr):\n    \"\"\"Computes softmax values for a SecretArray using MP-SPDZ.\"\"\"\n    n = arr.size()\n    exp = SecretArray(n, sfix)\n    \n    # Compute exponentials\n    @for_range(n)\n    def _(i):\n        exp[i] = sfix.exp(arr[i])\n    \n    # Sum exponentials\n    summation = sfix(0)\n    @for_range(n)\n    def _(i):\n        summation.iadd(exp[i])\n    \n    # Compute softmax\n    softmax = SecretArray(n, sfix)\n    @for_range(n)\n    def _(i):\n        softmax[i] = exp[i] / summation\n    \n    return softmax\n", "response_1": "from compiler import *\nfrom typing import List\n\ndef compute_softmax(array: List[sfix]) -> List[sfix]:\n    \"\"\"Computes softmax values for a list of secret-shared sfix values.\"\"\"\n    # Compute element-wise exponentiation\n    exp_array = [x.exp() for x in array]\n    \n    # Compute sum of exponents using explicit accumulation\n    sum_exp = sfix(0)\n    for e in exp_array:\n        sum_exp += e\n    \n    # Compute softmax by dividing each exponent by the sum\n    return [e / sum_exp for e in exp_array]\n", "model_name": "deepseek-r1"}
{"test_name": "tanh", "response_0": "class Tanh:\n\n    def fn(self, z):\n        \"\"\"Compute tanh(z) for secret-shared z using built-in sfix.tanh().\"\"\"\n        return z.tanh()\n    \n    def grad(self, x):\n        \"\"\"Compute derivative 1 - tanh\u00b2(x) using secure operations.\"\"\"\n        tanh_x = self.fn(x)\n        return 1 - (tanh_x * tanh_x)\n", "response_1": "class Tanh:\n    def fn(self, z):\n        two_z = z * sfix(2)\n        exp_two_z = two_z.exp()\n        return (exp_two_z - 1) / (exp_two_z + 1)\n    \n    def grad(self, x):\n        tanh_x = self.fn(x)\n        return 1 - (tanh_x * tanh_x)\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_tan", "response_0": "from sfix import sfix\n\ndef sin(x):\n    x2 = x * x\n    x3 = x * x2\n    x5 = x3 * x2\n    x7 = x5 * x2\n    return x - x3/6 + x5/120 - x7/5040\n\ndef cos(x):\n    x2 = x * x\n    x4 = x2 * x2\n    x6 = x4 * x2\n    return 1 - x2/2 + x4/24 - x6/720\n\ndef compute_tan(array):\n    return [sin(x) / cos(x) for x in array]\n", "response_1": "def taylor_sin(x):\n    # Approximate sin(x) using Taylor series up to x^5\n    x_sq = x * x\n    x_cu = x_sq * x\n    x_5th = x_cu * x_sq\n    return x - x_cu * sfix(0.1666666667) + x_5th * sfix(0.0083333333)\n\ndef taylor_cos(x):\n    # Approximate cos(x) using Taylor series up to x^4\n    x_sq = x * x\n    x_4th = x_sq * x_sq\n    return sfix(1) - x_sq * sfix(0.5) + x_4th * sfix(0.0416666667)\n\ndef compute_tan(array):\n    \"\"\"This function calculates tangent using secure approximations\"\"\"\n    n = len(array)\n    result = Array(n, sfix)\n    for i in range(n):\n        x = array[i]\n        sin_val = taylor_sin(x)\n        cos_val = taylor_cos(x)\n        result[i] = sin_val / cos_val\n    return result\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_greater", "response_0": "def compute_greater(arrayA, arrayB):\n    n = len(arrayA)\n    res = Array(n, sint)\n    for i in range(n):\n        res[i] = arrayA[i] > arrayB[i]\n    return res\n", "response_1": "def compute_greater(arrayA, arrayB):\n    \"\"\"Returns an array where each element is 1 if arrayA[i] > arrayB[i], else 0\"\"\"\n    return [a > b for a, b in zip(arrayA, arrayB)]\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_maximum", "response_0": "def compute_maximum(arrayA, arrayB):\n    max_ones = []\n    for a, b in zip(arrayA, arrayB):\n        max_ones.append(a.max(b))\n    return max_ones\n", "response_1": "def compute_maximum(arrayA, arrayB):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    max_values = []  # Use list instead of numpy array\n    for i in range(len(arrayA)):\n        # Compare elements and select maximum using MPC-safe comparison\n        max_val = (arrayA[i] > arrayB[i]).if_else(arrayA[i], arrayB[i])\n        max_values.append(max_val)\n    return max_values\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_log2", "response_0": "from mpc_math import ln_fx\nfrom sfix import sfix\nfrom library import Array\nimport math\n\ndef compute_log2(array):\n    \"\"\"This function calculate base-2 logarithm of x in the input array.\"\"\"\n    ln2 = sfix(math.log(2))\n    n = len(array)\n    result = Array(n, sfix)\n    for i in range(n):\n        result[i] = ln_fx(array[i]) / ln2\n    return result\n", "response_1": "from util import if_else\nfrom Compiler import floatingpoint\n\ndef compute_log2(array):\n    \"\"\"This function calculates base-2 logarithm of x in the input array.\"\"\"\n    log2_values = Array(len(array), sfix)\n    ln2_inv = sfix(1.44269504089)  # Precomputed 1/ln(2) for conversion\n    for i in range(len(array)):\n        # Compute natural logarithm and convert to log2\n        log_x = sfix.log(array[i])\n        log2_values[i] = log_x * ln2_inv\n    return log2_values\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_absolute", "response_0": "def obtain_absolute(array):\n    \"\"\"This function computes the absolute values in an MP-SPDZ array.\"\"\"\n    size = len(array)\n    result = Array(size, sint)\n    for i in range(size):\n        result[i] = array[i].get_abs()\n    return result\n", "response_1": "def obtain_absolute(array):\n    \"\"\"This function computes the absolute values in an MP-SPDZ array.\"\"\"\n    return sint.Array([x.abs() for x in array])\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_arctan", "response_0": "from math import Lib\nfrom types import sfix\n\ndef compute_arctan(array):\n    \"\"\"This function calculates trigonometric inverse tangent element-wise on secret-shared fixed-point arrays.\"\"\"\n    arctan_res = []\n    for element in array:\n        arctan_res.append(element.atan())\n    return arctan_res\n", "response_1": "from math import pi\nfrom sfloat import sgf\nsfix = sgf\n\ndef compute_arctan(array):\n    \"\"\"This function calculates trigonometric inverse tangent, element-wise using MPC approximations.\"\"\"\n    arctan_res = []\n    for x in array:\n        # Check if x is zero\n        is_zero = (x == 0)\n        \n        # Compute sign and absolute value\n        sign = (x > 0) - (x < 0)  # Returns 1, 0, or -1 in MPC\n        abs_x = x * sign\n        \n        # Range reduction logic\n        needs_inversion = (abs_x > 1.0)\n        reciprocal = needs_inversion.if_else(1.0 / abs_x, abs_x)\n        \n        # Taylor series approximation for arctan (5 terms)\n        x_term = reciprocal\n        x_sq = x_term * x_term\n        x_cu = x_term * x_sq\n        x_5th = x_cu * x_sq\n        x_7th = x_5th * x_sq\n        x_9th = x_7th * x_sq\n        \n        approx = x_term - x_cu/3.0 + x_5th/5.0 - x_7th/7.0 + x_9th/9.0\n        \n        # Apply range reduction adjustment\n        adjusted = needs_inversion.if_else(sfix(pi/2) - approx, approx)\n        \n        # Restore original sign\n        signed_result = adjusted * sign\n        \n        # Handle zero case\n        final_result = is_zero.if_else(sfix(0), signed_result)\n        \n        arctan_res.append(final_result)\n    return arctan_res\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_log", "response_0": "from floatingpoint import fplog\nfrom types import sfloat\n\ndef compute_log(array):\n    \"\"\"This function calculates natural logarithm for all p in the input array.\"\"\"\n    nlog = Array(len(array), sfloat)\n    for i in range(len(array)):\n        nlog[i] = fplog(array[i])\n    return nlog\n", "response_1": "def compute_log(array):\n    \"\"\"This function calculates natural logarithm for all p in the input array.\"\"\"\n    nlog = []\n    for p in array:\n        nlog.append(p.log_fx())\n    return nlog\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_not_equal", "response_0": "def compute_not_equal(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is not equal to arrayB.\"\"\"\n    neq = []\n    for a, b in zip(arrayA, arrayB):\n        neq.append(a != b)\n    return neq\n", "response_1": "def compute_not_equal(arrayA, arrayB):\n    neq = sint.Array(len(arrayA))\n    for i in range(len(arrayA)):\n        neq[i] = arrayA[i] != arrayB[i]\n    return neq\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_equal", "response_0": "def compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates element-wise equality comparison between two arrays of secret integers\"\"\"\n    # Initialize an empty list to store comparison results\n    eq = []\n    # Iterate through corresponding elements of both arrays\n    for a, b in zip(arrayA, arrayB):\n        # Compare secret integers and store result (1 if equal, 0 otherwise)\n        eq.append(a == b)\n    return eq\n", "response_1": "def compute_equal(arrayA, arrayB):\n    \"\"\"Returns a list where each element is 1 (True) if arrayA[i] == arrayB[i], 0 otherwise\"\"\"\n    return [x == y for x, y in zip(arrayA, arrayB)]\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_true_divide", "response_0": "def true_divide(arrayA, arrayB):\n    size = len(arrayA)\n    result = Array(size, sfix)\n    for i in range(size):\n        result[i] = arrayA[i] / arrayB[i]\n    return result\n", "response_1": "def true_divide(arrayA, arrayB):\n    \"\"\"Element-wise true division between two secret-shared 1-D arrays.\"\"\"\n    return Array(len(arrayA), [arrayA[i] / arrayB[i] for i in range(len(arrayA))])\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_greater_equal", "response_0": "def compute_greater_equal(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is greater than or equal to arrayB.\"\"\"\n    if len(arrayA) != len(arrayB):\n        raise ValueError(\"Arrays must be of the same length\")\n    return [a >= b for a, b in zip(arrayA, arrayB)]\n", "response_1": "def compute_greater_equal(arrayA, arrayB):\n    greater_eq = []\n    for i in range(len(arrayA)):\n        greater_eq.append(arrayA[i] >= arrayB[i])\n    return greater_eq\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_negative", "response_0": "def negative(arrayA):\n    size = arrayA.size()\n    new_array = Array(size, sint)\n    for i in range(size):\n        new_array[i] = -arrayA[i]\n    return new_array\n", "response_1": "def negative(arrayA):\n    return [-x for x in arrayA]\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_power", "response_0": "from sint import sint\ndef power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    # Assuming arrayB contains public integers (cint) and arrayA contains secret integers (sint)\n    return [x ** y for x, y in zip(arrayA, arrayB)]\n", "response_1": "def power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    res = Array(len(arrayA), sint)\n    for i in range(len(arrayA)):\n        res[i] = arrayA[i] ** arrayB[i]\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_exp2", "response_0": "from util import Array\n\ndef compute_exp2(array):\n    \"\"\"This function calculates 2^p for all p in the input array (public integers).\"\"\"\n    n = len(array)\n    exp = Array(n, cint)\n    for i in range(n):\n        exp[i] = two_power_p(array[i])\n    return exp\n", "response_1": "def compute_exp2(array):\n    exp = Array(len(array), sfix)\n    @for_range(len(array))\n    def _(i):\n        exp[i] = sfix.pow2(array[i])\n    return exp\n", "model_name": "deepseek-r1"}
{"test_name": "cross_entropy_loss_class", "response_0": "class CrossEntropy:\n    def loss(self, y, y_pred):\n        cross_entropy = sfix(0)\n        for i in range(len(y)):\n            cross_entropy += y[i] * y_pred[i].log2()\n        return -cross_entropy\n    \n    def grad(self, y, y_pred):\n        n = len(y)\n        grad = []\n        for i in range(n):\n            grad_i = (y_pred[i] - y[i]) / n\n            grad.append(grad_i)\n        return grad\n", "response_1": "def cross_entropy_loss(y, y_pred):\n    \"\"\"\n    Secure computation of cross-entropy loss\n    y: Array[sfix] (ground truth)\n    y_pred: Array[sfix] (predictions)\n    Returns sfix representing -sum(y * log2(y_pred))\n    \"\"\"\n    total = sfix(0)\n    for i in range(len(y)):\n        total += y[i] * y_pred[i].log2()\n    return -total\n\ndef cross_entropy_grad(y, y_pred):\n    \"\"\"\n    Secure computation of gradient for cross-entropy loss\n    y: Array[sfix] (ground truth)\n    y_pred: Array[sfix] (predictions)\n    Returns Array[sfix] of (y_pred - y)/len(y)\n    \"\"\"\n    n = len(y)\n    return [(y_pred[i] - y[i])/n for i in range(n)]\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_arccos", "response_0": "def compute_arccos(array):\n    \"\"\"Calculate inverse cosine element-wise on an Array of sfix values.\"\"\"\n    arccos_res = Array(len(array))\n    for i in range(len(array)):\n        arccos_res[i] = array[i].acos()\n    return arccos_res\n", "response_1": "from math import pi\nfrom library import sfix, Array, sqrt\n\ndef arctan_approximation(y):\n    # Handle y >= 0 approximation using identity for y > 1\n    is_less_eq_1 = y <= 1\n    z = is_less_eq_1.if_else(y, 1/y)\n    # Simple polynomial approximation for arctan(z)\n    arctan_z = z - z**3/3 + z**5/5 - z**7/7  # Improve with more terms\n    result = is_less_eq_1.if_else(arctan_z, sfix(pi/2) - arctan_z)\n    return result\n\ndef compute_arccos(array):\n    arccos_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        x = array[i]\n        # Handle special cases\n        is_neg_one = x == -1\n        is_pos_one = x == 1\n        is_zero = x == 0\n        is_neg = x < 0\n        \n        # Special case results\n        special_res = is_neg_one * sfix(pi) + is_pos_one * sfix(0) + is_zero * sfix(pi/2)\n        \n        # General case calculation\n        x_abs = x * (1 - 2 * is_neg)\n        x_sq = x_abs * x_abs\n        y_numerator = sqrt(sfix(1) - x_sq)\n        y = y_numerator / x_abs\n        arccos_abs = arctan_approximation(y)\n        \n        # Combine negative handling\n        final_res = (sfix(pi) - arccos_abs) * is_neg + arccos_abs * (1 - is_neg)\n        \n        # Select final result\n        arccos_res[i] = special_res + final_res * (1 - is_neg_one - is_pos_one - is_zero)\n    return arccos_res\n", "model_name": "deepseek-r1"}
{"test_name": "r2_score", "response_0": "def r2_score(y_hat, y_test):\n    # Compute mean of y_test\n    n = len(y_test)\n    sum_y = sfix(0)\n    for y in y_test:\n        sum_y += y\n    mean_y = sum_y / n\n\n    # Compute total sum of squares (TSS)\n    tss = sfix(0)\n    for y in y_test:\n        diff = y - mean_y\n        tss += diff * diff\n\n    # Compute residual sum of squares (RSS)\n    rss = sfix(0)\n    for y, yh in zip(y_test, y_hat):\n        diff = y - yh\n        rss += diff * diff\n\n    # Calculate and return R\u00b2 score\n    return 1 - (rss / tss)\n", "response_1": "def r2_score(y_hat, y_test):\n    # Compute mean of y_test\n    sum_y_test = sfix(0)\n    n = len(y_test)\n    for i in range(n):\n        sum_y_test += y_test[i]\n    mean_y = sum_y_test / n\n\n    # Compute total sum of squares\n    total_sum_squares = sfix(0)\n    for i in range(n):\n        diff = y_test[i] - mean_y\n        total_sum_squares += diff * diff\n\n    # Compute residual sum of squares\n    residual_sum_squares = sfix(0)\n    for i in range(n):\n        diff = y_test[i] - y_hat[i]\n        residual_sum_squares += diff * diff\n\n    # Compute R\u00b2 score\n    r_squared = 1 - (residual_sum_squares / total_sum_squares)\n    return r_squared\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_arcsin", "response_0": "def compute_arcsin(array):\n    \"\"\"This function calculates trigonometric inverse sine element-wise using MPC-friendly polynomial approximation.\"\"\"\n    result = []\n    for x in array:\n        x_sq = x * x\n        x_cu = x_sq * x\n        x_5th = x_cu * x_sq\n        # Approximation: arcsin(x) \u2248 x + (1/6)x\u00b3 + (3/40)x\u2075\n        arcsin_x = x + x_cu * sfix(0.1666666667) + x_5th * sfix(0.075)\n        result.append(arcsin_x)\n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_arcsin(array):\n    \"\"\"This function calculates trigonometric inverse sine element-wise using a polynomial approximation.\"\"\"\n    arcsin_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        x = array[i]\n        # Using 5th order Taylor series approximation: x + x\u00b3/6 + 3x\u2075/40\n        x_sq = x * x\n        x_cu = x_sq * x\n        term3 = x_cu * sfix(1.0/6.0)\n        x_5th = x_cu * x_sq\n        term5 = x_5th * sfix(3.0/40.0)\n        arcsin_res[i] = x + term3 + term5\n    return arcsin_res\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_true_divide2", "response_0": "def true_divide(arrayA, arrayB):\n    \"\"\"true divide between two MP-SPDZ 1-d arrays.\"\"\"\n    res = Array(arrayA.size(), sfix)\n    for i in range(arrayA.size()):\n        res[i] = arrayA[i] / arrayB[i]\n    return res\n", "response_1": "def true_divide(arrayA, arrayB):\n    \"\"\"Element-wise division of two secret 1D arrays using sfix\"\"\"\n    res = []\n    for a, b in zip(arrayA, arrayB):\n        res.append(a / b)\n    return res\n", "model_name": "deepseek-r1"}
{"test_name": "square_error_loss", "response_0": "def squre_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss for MPC.\n    Assumes y and y_pred are lists of sfix values.\n    \"\"\"\n    sum_sq = sfix(0)\n    for i in range(len(y)):\n        diff = y_pred[i] - y[i]\n        sum_sq += diff * diff\n    return sum_sq * 0.5\n", "response_1": "def squre_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss for secret-shared values.\n    \"\"\"\n    sum_squared = 0\n    for a, b in zip(y_pred, y):\n        diff = a - b\n        sum_squared += diff * diff\n    return sum_squared * 0.5\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_less", "response_0": "from library import Array\n\ndef compute_less(arrayA, arrayB):\n    \"\"\"Element-wise comparison of two secret integer arrays (arrayA < arrayB).\"\"\"\n    n = len(arrayA)\n    res = Array(n, sbit)\n    for i in range(n):\n        res[i] = arrayA[i] < arrayB[i]\n    return res\n", "response_1": "def compute_less(arrayA, arrayB):\n    \"\"\"Element-wise comparison of arrayA < arrayB using secret integers.\"\"\"\n    return [a < b for a, b in zip(arrayA, arrayB)]\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_cos", "response_0": "from library import Array, math\n\ndef compute_cosine(array):\n    \"\"\"This function calculates trigonometric cosine element-wise.\"\"\"\n    n = len(array)\n    res = Array(n, sfix)\n    for i in range(n):\n        res[i] = math.cos(array[i])\n    return res\n", "response_1": "def compute_cosine(array):\n    \"\"\"This function calculates trigonometric cosine element-wise using a Taylor series approximation.\"\"\"\n    cos_res = []\n    for x in array:\n        x_squared = x * x\n        term = x_squared / 2\n        cos_x = 1 - term  # First two terms\n        \n        term = term * x_squared / (3 * 4)  # x^4/24\n        cos_x += term\n        \n        term = term * x_squared / (5 * 6)  # x^6/720\n        cos_x -= term\n        \n        term = term * x_squared / (7 * 8)  # x^8/40320\n        cos_x += term\n        \n        term = term * x_squared / (9 * 10)  # x^10/3628800\n        cos_x -= term\n        \n        cos_res.append(cos_x)\n    return cos_res\n", "model_name": "deepseek-r1"}
{"test_name": "np_ufunc_sin", "response_0": "def compute_sine(array):\n    \"\"\"Compute sine using Taylor series approximation up to x^7 term.\"\"\"\n    result = []\n    for x in array:\n        x_sq = x * x\n        x_cu = x_sq * x\n        term3 = x_cu * sfix(0.1666666667)  # 1/6\n        x_5 = x_cu * x_sq\n        term5 = x_5 * sfix(0.0083333333)  # 1/120\n        x_7 = x_5 * x_sq\n        term7 = x_7 * sfix(0.0001984127)  # 1/5040\n        sin_x = x - term3 + term5 - term7\n        result.append(sin_x)\n    return result\n", "response_1": "def compute_sine(array):\n    \"\"\"This function calculates trigonometric sine, element-wise.\"\"\"\n    sin_res = [x.sin() for x in array]\n    return sin_res\n", "model_name": "deepseek-r1"}
{"test_name": "update_weights", "response_0": "def update_weights(m, A, X, Y):\n    n = len(X[0])\n    dw = [sfix(0) for _ in range(n)]\n    for j in range(n):\n        for i in range(m):\n            dw[j] += X[i][j] * (A[i] - Y[i])\n        dw[j] = dw[j] * (1.0 / m)\n    return dw\n", "response_1": "def update_weights(m, A, X, Y):\n    A_minus_Y = A - Y\n    dot_product = X.dot(A_minus_Y)\n    dw = (1.0 / m) * dot_product\n    return dw\n", "model_name": "deepseek-r1"}
{"test_name": "toy_layer", "response_0": "from library import *\n\ndef sigmoid(x):\n    # Third-order Taylor approximation around 0 for sigmoid function\n    return sfix(0.5) + (x * sfix(0.25)) - (x**3 * sfix(1/48))\n\ndef matrix_mult_vec(matrix, vec):\n    rows = len(matrix)\n    cols = len(matrix[0]) if rows > 0 else 0\n    result = Array(cols, sfix)\n    for j in range(cols):\n        sum = sfix(0)\n        for i in range(rows):\n            sum += vec[i] * matrix[i][j]\n        result[j] = sum\n    return result\n\ndef vector_add(vec1, vec2):\n    return [vec1[i] + vec2[i] for i in range(len(vec1))]\n\ndef toy_layer(input_data, weights, biases):\n    # First layer processing\n    layer1_input = vector_add(matrix_mult_vec(weights[0], input_data), biases[0])\n    layer1_output = [sigmoid(x) for x in layer1_input]\n    \n    # Second layer processing\n    layer2_input = vector_add(matrix_mult_vec(weights[1], layer1_output), biases[1])\n    layer2_output = [sigmoid(x) for x in layer2_input]\n    \n    return layer2_output\n", "response_1": "# Secure sigmoid approximation using piecewise polynomial\ndef sigmoid(x):\n    # Cubic approximation for better accuracy\n    a = sfix(0.5)\n    b = sfix(0.15)\n    c = sfix(-0.0015)\n    return a + x * b + x**3 * c\n\n# Secure matrix multiplication\ndef secure_matrix_mult(A, B):\n    n = len(A)\n    m = len(A[0]) if n > 0 else 0\n    p = len(B[0]) if m > 0 else 0\n    result = [[sfix(0) for _ in range(p)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(p):\n            sum = sfix(0)\n            for k in range(m):\n                sum += A[i][k] * B[k][j]\n            result[i][j] = sum\n    return result\n\n# Secure matrix-vector addition\ndef secure_add_bias(matrix, bias):\n    n = len(matrix)\n    p = len(matrix[0]) if n > 0 else 0\n    result = [[sfix(0) for _ in range(p)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(p):\n            result[i][j] = matrix[i][j] + bias[j]\n    return result\n\n# Secure activation application\ndef secure_apply_activation(matrix):\n    n = len(matrix)\n    p = len(matrix[0]) if n > 0 else 0\n    result = [[sfix(0) for _ in range(p)] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(p):\n            result[i][j] = sigmoid(matrix[i][j])\n    return result\n\n# Complete secure layer computation\ndef secure_toy_layer(input_data, weights, biases):\n    # First layer processing\n    l1_input = secure_matrix_mult(input_data, weights[0])\n    l1_input = secure_add_bias(l1_input, biases[0])\n    l1_output = secure_apply_activation(l1_input)\n    \n    # Second layer processing\n    l2_input = secure_matrix_mult(l1_output, weights[1])\n    l2_input = secure_add_bias(l2_input, biases[1])\n    l2_output = secure_apply_activation(l2_input)\n    \n    return l2_output\n", "model_name": "deepseek-r1"}
