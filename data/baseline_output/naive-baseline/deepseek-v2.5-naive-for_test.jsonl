{"test_name": "multiply_first_five", "response_0": "def multiply_first_five(array: sint):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sint(1)\n    for i in range(len(array)):\n        prod = prod * array[i]\n        if i >= 4:\n            break\n    return prod\n", "response_1": "", "model_name": "deepseek-v2.5"}
{"test_name": "second_largest", "response_0": "fromCompiler import *\n\ndef mp_second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array using MP-SPDZ syntax.\n    \"\"\"\n    # Initialize the largest and second largest elements\n    largest = arr[0] if arr[0] >= arr[1] else arr[1]\n    second = arr[1] if arr[0] >= arr[1] else arr[0]\n\n    # Iterate through the array to find the second largest element\n    for i in range(len(arr)):\n        if i > 1:\n            if arr[i] >= largest:\n                second = largest\n                largest = arr[i]\n            else:\n                if arr[i] >= second:\n                    second = arr[i]\n\n    return second\n\n# Example usage in MP-SPDZ\n# arr = [sint(x) for x in [4, 2, 7, 1, 9, 3]]\n# result = mp_second_largest(arr)\n# print_ln(\"Second largest element: %s\", result.reveal())\n", "response_1": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array. \n    \"\"\"\n    largest = arr[0] if arr[0] >= arr[1] else arr[1]\n    second = arr[1] if arr[0] >= arr[1] else arr[0]\n    \n    for i in range(2, len(arr)):\n        if arr[i] >= largest:\n            second = largest\n            largest = arr[i]\n        elif arr[i] >= second:\n            second = arr[i]\n    \n    return second\n\n# MP-SPDZ program\nfrom Compiler import types\n\ndef second_largest_mpspdz(arr: types.Array):\n    \"\"\"\n    Return the second largest element in the array using MP-SPDZ.\n    \"\"\"\n    largest = arr[0] if arr[0] >= arr[1] else arr[1]\n    second = arr[1] if arr[0] >= arr[1] else arr[0]\n    \n    for i in range(2, len(arr)):\n        cond1 = arr[i] >= largest\n        cond2 = arr[i] >= second\n        \n        second = cond1.if_else(largest, second)\n        largest = cond1.if_else(arr[i], largest)\n        second = cond2.if_else(arr[i], second)\n    \n    return second\n", "model_name": "deepseek-v2.5"}
{"test_name": "partial_sum", "response_0": "c\nvoid partial_sum(int n, sint* arr) {\n    /*\n    Compute the partial sum of the array with secret-shared integers.\n    */\n    sint partial = 0;\n    for (int i = 0; i < n; i++) {\n        partial = partial + arr[i];\n        arr[i] = partial;\n    }\n}\n", "response_1": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    for i in range(1, n):\n        arr[i] = arr[i] + arr[i - 1]\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_adjacent_product", "response_0": "#include <iostream>\n#include <vector>\n\nint max_adjacent_product(const std::vector<int>& arr) {\n    int n = arr.size();\n    int cur = arr[0] * arr[1];\n    for (int i = 1; i < n-1; ++i) {\n        int temp = arr[i] * arr[i+1];\n        if (temp > cur) {\n            cur = temp;\n        }\n    }\n    return cur;\n}\n\nint main() {\n    std::vector<int> arr = {/* Initialize your array here */};\n    int result = max_adjacent_product(arr);\n    std::cout << \"Max adjacent product: \" << result << std::endl;\n    return 0;\n}\n", "response_1": "def max_adjacent_product(arr):\n    n = len(arr)\n    cur = arr[0] * arr[1]\n    for i in range(1, n-1):\n        candidate = arr[i] * arr[i+1]\n        cur = max(cur, candidate)\n    return cur\n", "model_name": "deepseek-v2.5"}
{"test_name": "argmax", "response_0": "def argmax(a):\n    \"\"\"\n    Return the index of the max value of an array.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = cint(0)\n\n    for i in range(1, n):\n        cond = current >= a[i]\n        index = cond.if_else(index, i)\n        current = cond.if_else(current, a[i])\n\n    return index\n", "response_1": "def argmax(a):\n    \"\"\"\n    Return the index of the max value of an array.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = sfix(0)\n\n    for i in range(1, n):\n        cond = current >= a[i]\n        index = cond * index + (1 - cond) * sfix(i)\n        current = cond * current + (1 - cond) * a[i]\n\n    return index\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_distinct", "response_0": "from Compiler import types\n\ndef count_distinct(arr: types.Array):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = types.sint(0)\n    for i in range(len(arr)):\n        unique = types.sint(1)\n        for j in range(i):\n            unique = unique & (arr[j] != arr[i])\n        counter = counter + unique\n    return counter\n", "response_1": "from Compiler import types\n\ndef count_distinct(arr: types.Array):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = types.sint(0)\n    n = len(arr)\n    \n    for i in range(n):\n        unique = types.sint(1)  # Assume the element is unique\n        for j in range(i):\n            # Compare arr[j] and arr[i] securely\n            unique = unique * (arr[j] != arr[i])\n        \n        # Increment counter if the element is unique\n        counter = counter + unique\n    \n    return counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sint(0)  # Initialize ret as a secret integer\n    for item in arr:\n        ret = ret + item  # Use addition to simulate the OR operation\n    return ret.reveal() > 0  # Reveal the result and check if it's greater than 0\n", "response_1": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sfix(0)  # Initialize ret as a fixed-point number with value 0\n    for item in arr:\n        ret = ret + item  # Use addition to simulate logical OR\n    return ret > 0  # Return True if ret is greater than 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "range", "response_0": "from Compiler import mpc_math\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = mpc_math.max(arr)\n    min_value = mpc_math.min(arr)\n    return max_value - min_value\n", "response_1": "from Compiler import mpc_math\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    \n    for item in arr[1:]:\n        max_value = mpc_math.max(max_value, item)\n        min_value = mpc_math.min(min_value, item)\n    \n    return max_value - min_value\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_larger_than_5", "response_0": "from Compiler import types\n\ndef count_larger_than_5(arr: types.Array):\n    \"\"\"\n    Count the number of elements in the given array larger than 5.\n    \"\"\"\n    counter = types.sint(0)  # Initialize counter as a secret integer\n    for i in range(len(arr)):\n        if arr[i] > 5:\n            counter = counter + 1\n    return counter\n", "response_1": "def count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5. \n    \"\"\"\n    counter = sint(0)\n    for item in arr:\n        if_statement = item > 5\n        counter = counter + if_statement\n    return counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_dominator", "response_0": "#include <mpc.h>\n\ntemplate <typename T>\nbool exists_dominator(const vector<T>& arr) {\n    T max = 0;\n    T sum = 0;\n\n    for (size_t i = 0; i < arr.size(); ++i) {\n        T abs_item = abs(arr[i]);\n        max = max(max, abs_item);\n        sum = sum + abs_item;\n    }\n\n    return 2 * max > sum;\n}\n", "response_1": "def exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = 0\n    sum = 0\n    for item in arr:\n        max = smax(max, abs(item))\n        sum = sum + abs(item)\n    return 2 * max > sum\n\n# MP-SPDZ program\n\n# Input: arr is an array of secret shared integers\n# Output: A secret shared boolean indicating whether a dominator exists\n\ndef exists_dominator_mpspdz(arr):\n    n = len(arr)\n    max = sint(0)\n    sum = sint(0)\n\n    for i in range(n):\n        item = arr[i]\n        max = smax(max, abs(item))\n        sum = sum + abs(item)\n\n    return 2 * max > sum\n\n# Example usage in MP-SPDZ\n# arr = [sint(x) for x in [1, -2, 3, -4, 5]]\n# result = exists_dominator_mpspdz(arr)\n# print_ln(\"Dominator exists: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "greedy_picker", "response_0": "from Compiler import mpc_math\n\ndef greedy_picker(items, captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    for item in items:\n        if_statement = item <= captivity\n        captivity = if_statement.if_else(captivity - item, captivity)\n        num = if_statement.if_else(num + 1, num)\n    return num\n", "response_1": "def greedy_picker(items: Array[Int], captivity: Int) -> Int:\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    for item in items:\n        if_statement = item <= captivity\n        captivity = if_statement.if_else(captivity - item, captivity)\n        num = if_statement.if_else(num + 1, num)\n    return num\n", "model_name": "deepseek-v2.5"}
{"test_name": "scalar_add_array", "response_0": "from Compiler import mpc_math\n\ndef scalar_add_array(s: sint, l: list):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result. \n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Define the scalar and the array\n    s = sint(5)  # Example scalar\n    l = [sint(1), sint(2), sint(3)]  # Example array\n\n    # Call the function\n    result = scalar_add_array(s, l)\n\n    # Print the result\n    print_ln(\"The result is: %s\", result.reveal())\n", "response_1": "def scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n\n# MP-SPDZ equivalent\ndef scalar_add_array_mpspdz(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    for i in range(len(l)):\n        s = s + l[i]\n    return s\n\n# Example usage in MP-SPDZ\ns = sint(5)  # Example scalar, can be secret-shared\nl = [sint(1), sint(2), sint(3)]  # Example array, can be secret-shared\nresult = scalar_add_array_mpspdz(s, l)\nprint_ln(\"Result: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_equidistant_seq", "response_0": "#include <iostream>\n#include <vector>\n\nbool is_equidistant_seq(const std::vector<int>& arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    int d = arr[1] - arr[0];\n    for (int i = 1; i < n - 1; ++i) {\n        if (arr[i + 1] - arr[i] != d) {\n            return false;\n        }\n    }\n    return true;\n}\n", "response_1": "def is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence. \n    If the array has length 1 or 0, return True.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return sint(1)\n\n    d = arr[1] - arr[0]\n    for i in range(2, n):\n        if arr[i] - arr[i-1] != d:\n            return sint(0)\n    return sint(1)\n\n# Example usage in MP-SPDZ\n# arr = [sint(x) for x in [1, 3, 5, 7]]\n# result = is_equidistant_seq(arr)\n# print_ln(\"Is equidistant sequence: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product", "response_0": "from Compiler import mpc_math\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays in MP-SPDZ.\n    \"\"\"\n    # Ensure the vectors are of the same length\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    \n    # Initialize the sum as a secure fixed-point number\n    sum = mpc_math.sfix(0)\n    \n    # Compute the inner product\n    for i in range(len(vec1)):\n        sum += vec1[i] * vec2[i]\n    \n    return sum\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret-shared arrays.\n    \"\"\"\n    n = len(vec1)\n    sum = sfix(0)  # Initialize sum as a secret-shared fixed-point number\n    for i in range(n):\n        sum += vec1[i] * vec2[i]  # Perform secret-shared multiplication and addition\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "more_distinct_nonnegative", "response_0": "def more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    n = len(arr)\n    nonnegative_counter = sfix(0)\n    negative_counter = sfix(0)\n    \n    for i in range(n):\n        unique = sfix(1)\n        for j in range(i):\n            unique = unique & (arr[j] != arr[i])\n        \n        nonnegative_counter = nonnegative_counter + (unique & (arr[i] >= 0))\n        negative_counter = negative_counter + (unique & (arr[i] < 0))\n    \n    return nonnegative_counter > negative_counter\n", "response_1": "def more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    n = len(arr)\n    nonnegative_counter = sfix(0)\n    negative_counter = sfix(0)\n\n    for i in range(n):\n        unique = sfix(1)\n        for j in range(i):\n            unique = unique & (arr[j] != arr[i])\n        if_statement = unique.if_else(1, 0)\n        nonnegative_counter = nonnegative_counter + if_statement * (arr[i] >= 0)\n        negative_counter = negative_counter + if_statement * (arr[i] < 0)\n\n    return nonnegative_counter > negative_counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "flip_positives", "response_0": "def flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        if_statement = array[i] > 0\n        array[i] = if_statement.if_else(-array[i], array[i])\n    return array\n", "response_1": "c\nvoid flip_positives(int64_t* array, int64_t n) {\n    for (int i = 0; i < n; i++) {\n        if (array[i] <= 0) {\n            continue;\n        }\n        array[i] = -array[i];\n    }\n}\n", "model_name": "deepseek-v2.5"}
{"test_name": "divide_and_plus", "response_0": "def divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Assuming x is a secret integer or fixed-point number\n    x = sint(10)  # Example input, you can replace 10 with any other value\n    result = divide_and_plus(x)\n    print_ln(\"Result: %s\", result.reveal())\n", "response_1": "def divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n\n# Example usage in MP-SPDZ\nx = sfix(10)  # Example input, sfix is a fixed-point number in MP-SPDZ\nresult = divide_and_plus(x)\nprint_ln(\"Result: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_log2", "response_0": "from Compiler import floatingpoint\nfrom Compiler import mpc_math\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    # Approximate log2 using a polynomial approximation or series expansion\n    def log2_approx(x):\n        # Example: Using a simple Taylor series expansion around 1\n        # log2(x) = ln(x) / ln(2)\n        ln_x = floatingpoint.ln(x)\n        ln_2 = floatingpoint.ln(floatingpoint.sfloat(2))\n        return ln_x / ln_2\n\n    # Apply log2 to each element in the array\n    for i in range(len(arr)):\n        arr[i] = log2_approx(arr[i])\n    \n    return arr\n", "response_1": "from mamba import log2\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = log2(arr[i])\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_to_ten", "response_0": "def sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sfloat(0)  # Initialize sum as a secret floating-point number\n    for i in range(len(array)):\n        sum += array[i]\n        if_then(sum >= 10, lambda: break)\n    return sum\n", "response_1": "def sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        sum += array[i]\n        if_then(sum >= 10)\n        break_loop()\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n\n# Example usage in MP-SPDZ\ndef main():\n    arr = Array(10, sint)  # Create an array of 10 secret integers\n    arr = choppy_plus_minus(arr)\n    # Output the modified array\n    for i in range(len(arr)):\n        print_ln(\"%s\", arr[i].reveal())\n", "response_1": "#include \"array.h\"\n#include \"math.h\"\n\nvoid choppy_plus_minus(Array<sint> &arr) {\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if (i % 2) {\n            arr[i] = arr[i] + 1;\n        } else {\n            arr[i] = arr[i] - 1;\n        }\n    }\n}\n\nprogram choppy_program {\n    Array<sint> arr = {1, 2, 3, 4, 5};\n    choppy_plus_minus(arr);\n    // Output the modified array\n    for (int i = 0; i < arr.size(); i++) {\n        print_float(arr[i]);\n    }\n}\n", "model_name": "deepseek-v2.5"}
{"test_name": "min_element", "response_0": "def min_element(a):\n    \"\"\"\n    Return the minimum value of an array.\n    \"\"\"\n    current = a[0]\n    for i in range(len(a)):\n        current = current if current <= a[i] else a[i]\n    \n    return current\n\n# Example usage in MP-SPDZ\n# Assuming 'a' is an array of integers\na = Array(10, sint)  # Example array of size 10 with secret integers\n# Initialize 'a' with some values (not shown here)\nresult = min_element(a)\nprint_ln(\"The minimum element is: %s\", result)\n", "response_1": "def min_element(a):\n    \"\"\"\n    Return the minimum value of an array.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    for i in range(1, n):\n        current = current.if_else(current <= a[i], a[i])\n    \n    return current\n", "model_name": "deepseek-v2.5"}
{"test_name": "soft_max", "response_0": "def soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array.\n    \"\"\"\n    from Compiler import mpc_math\n\n    # Initialize the denominator\n    denominator = sfix(0)\n\n    # Compute the sum of exp(item) for each item in arr\n    for item in arr:\n        denominator += mpc_math.exp(item)\n\n    # Compute the soft-max values\n    brr = arr.copy()\n    for i in range(len(arr)):\n        brr[i] = mpc_math.exp(arr[i]) / denominator\n\n    return brr\n", "response_1": "def soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    from math import e\n    from Compiler import mpc_math\n\n    # Calculate the denominator\n    denominator = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        denominator[i] = mpc_math.exp(arr[i])\n    denominator_sum = denominator.sum()\n\n    # Calculate the softmax values\n    brr = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        brr[i] = mpc_math.exp(arr[i]) / denominator_sum\n\n    return brr\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_reverse_pair_with_break", "response_0": "def count_reverse_pair_with_break(arr: regint):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    \"\"\"\n    n = len(arr)\n    count = regint(0)\n    for i in range(1, n):\n        if arr[i] > 10:\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count += 1\n    return count\n", "response_1": "def count_reverse_pair_with_break(arr):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    \"\"\"\n    count = sfix(0)\n    n = len(arr)\n    for i in range(1, n):\n        if arr[i] > sfix(10):\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count += sfix(1)\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_unique", "response_0": "def sum_unique(arr):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    n = len(arr)\n    sum = sfix(0)\n\n    for i in range(n):\n        unique = sfix(1)\n        for j in range(n):\n            if j != i:\n                unique = unique * (arr[i] != arr[j])\n        sum = sum + unique * arr[i]\n\n    return sum\n", "response_1": "def sum_unique(arr):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    n = len(arr)\n    sum = sint(0)\n\n    for i in range(n):\n        unique = True\n        for j in range(n):\n            if arr[j] == arr[i] and j != i:\n                unique = False\n                break\n        if unique:\n            sum = sum + arr[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "check_sum", "response_0": "# Example usage in MP-SPDZ\nfrom Compiler import mpc_math\n\n# Assuming array and target are already defined as secret-shared values\nresult = check_sum(array, target)\n", "response_1": "def check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = sint(0)\n    for num in array:\n        sum = sum + num\n    return sum == target\n", "model_name": "deepseek-v2.5"}
{"test_name": "prod", "response_0": "def prod(const vector<int>& array) {\n    int prod = 1;\n    for (int i = 0; i < array.size(); i++) {\n        prod = prod * array[i];\n    }\n    return prod;\n}\n", "response_1": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    prod = sfix(1)  # Initialize the product with 1, using secure fixed-point numbers\n    for i in range(len(array)):\n        prod = prod * array[i]  # Secure multiplication\n    return prod\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_till_negative", "response_0": "def sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        if array[i].reveal() < 0:\n            break\n        sum += array[i]\n    return sum\n", "response_1": "def sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i].less_than(0):\n            break\n        sum += array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    sum = sfix(0)  # Initialize sum as a fixed-point number\n    for i in range(len(arr)):\n        if predicator(arr[i]):\n            sum = sum + sfix(1)  # Increment sum by 1\n    return sum\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    sum = sfix(0)  # Initialize sum as a fixed-point number\n    for i in range(len(arr)):\n        if predicator(arr[i]):\n            sum = sum + sfix(1)  # Increment sum by 1\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "standard_deviation", "response_0": "def standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    n = len(arr)\n    average = sfix.Array(n).sum() / sfix(n)\n    variance = sfix(0)\n    for i in range(n):\n        variance += (arr[i] - average) ** 2 / sfix(n)\n    return variance.sqrt()\n", "response_1": "def standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array.\n    \"\"\"\n    n = len(arr)\n    average = sfix.Array(n).clear_()\n    variance = sfix.Array(n).clear_()\n    \n    # Calculate the average\n    for i in range(n):\n        average[0] = average[0] + arr[i] / n\n    \n    # Calculate the variance\n    for i in range(n):\n        variance[0] = variance[0] + (arr[i] - average[0]) ** 2 / n\n    \n    # Return the square root of the variance\n    return variance[0].sqrt()\n", "model_name": "deepseek-v2.5"}
{"test_name": "dominate", "response_0": "def dominate(a, b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    n = len(a)\n    ret = sint(1)  # Initialize ret as a secret integer with value 1 (True)\n    for i in range(n):\n        ret = ret * (sint.geq(a[i], b[i]))  # Check if a[i] >= b[i] and update ret\n    return ret\n", "response_1": "def dominate(a, b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    n = len(a)\n    ret = sint(1)  # Initialize ret as a secret integer with value 1 (True)\n    for i in range(n):\n        ret = ret * (a[i] >= b[i])  # Securely compare and multiply the result\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = sfloat(0)\n    for item in brr:\n        max_abs = max_abs.max(abs(item))\n    \n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    \n    return brr\n", "response_1": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    n = len(brr)\n    max_abs = sfloat.load_int(0)\n\n    # Find the maximum absolute value\n    for i in range(n):\n        item = brr[i]\n        abs_item = sfloat.abs(item)\n        max_abs = sfloat.max(max_abs, abs_item)\n\n    # Rescale the array\n    for i in range(n):\n        brr[i] = brr[i] / max_abs\n\n    return brr\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_minus7", "response_0": "def array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] - cint(7)\n    return arr\n", "response_1": "def array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] - cint(7)\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    n = len(arr1)\n    m = len(arr2)\n    sum = sint(0)\n\n    for i in range(n):\n        for j in range(m):\n            sum = sum + arr1[i] * arr2[j]\n\n    return sum\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum = sum + arr1[i] * arr2[j]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "longest_nondec_subseq", "response_0": "def longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    max_length = sfix(0)\n    cur_length = sfix(0)\n\n    for i in range(len(a)):\n        if i == 0:\n            cur_length = sfix(1)\n            continue\n        if a[i] >= a[i - 1]:\n            cur_length = cur_length + sfix(1)\n        else:\n            max_length = max(max_length, cur_length)\n            cur_length = sfix(1)\n\n    max_length = max(max_length, cur_length)\n    return max_length\n", "response_1": "def longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    n = len(a)\n    max_length = sint(0)\n    cur_length = sint(0)\n\n    for i in range(n):\n        if i == 0:\n            cur_length = sint(1)\n        else:\n            cond = a[i] >= a[i - 1]\n            cur_length = cur_length + 1 if cond else sint(1)\n            max_length = max_length if max_length >= cur_length else cur_length\n\n    max_length = max_length if max_length >= cur_length else cur_length\n    return max_length\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_but_skip_biggest", "response_0": "def sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        if array[i] >= biggest:\n            biggest = array[i]\n        else:\n            sum += array[i]\n    return sum\n", "response_1": "def sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = sfix(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        if array[i] >= biggest:\n            biggest = array[i]\n            continue\n        sum += array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "second_test", "response_0": "def second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    for i in range(1, len(arr)):\n        if arr[0] < arr[i]:\n            count = count + 1\n    return count == 1\n", "response_1": "def second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sfix(0)  # Initialize count as a secret fixed-point number\n    for i in range(1, len(arr)):\n        # Secure comparison of arr[0] and arr[i]\n        comparison = arr[0] < arr[i]\n        # Increment count if the comparison is true\n        count = count + comparison\n    \n    # Check if count is equal to 1\n    result = count == 1\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "Manhattan_distance", "response_0": "def Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    n = len(a)\n    ret = sfix(0)  # Initialize the result as a fixed-point number\n    for i in range(n):\n        ret += abs(a[i] - b[i])\n    return ret\n", "response_1": "def Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    ret = sfix(0)  # Initialize the result as a fixed-point number\n    for i in range(len(a)):\n        diff = a[i] - b[i]  # Compute the difference between corresponding elements\n        abs_diff = abs(diff)  # Compute the absolute value of the difference\n        ret = ret + abs_diff  # Accumulate the result\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "deal_with_only_positive", "response_0": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sfix(1)\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        sum = sum + sign * array[i]\n        sign = (-1) * sign\n    return sum\n", "response_1": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sfix(1)\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i] <= sfix(0):\n            continue\n        sum = sum + sign * array[i]\n        sign = (-1) * sign\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "compare_and_return", "response_0": "def compare_and_return(arr: sint, brr: sint):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    n = len(arr)\n    ret = sint(-1)\n    for i in range(n):\n        if_((arr[i] == brr[i]), lambda: ret.assign(i))\n        if_(ret != -1, lambda: break())\n    return ret\n", "response_1": "from Compiler import types\n\ndef compare_and_return(arr: types.Array, brr: types.Array) -> types.sint:\n    n = len(arr)\n    ret = types.sint(-1)\n    for i in range(n):\n        if arr[i] == brr[i]:\n            ret = types.sint(i)\n            break\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_odd_positive", "response_0": "def sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr)):\n        item = arr[i]\n        if item % 2 == 1 and item > 0:\n            sum = sum + item\n    return sum\n", "response_1": "def sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for item in arr:\n        # Check if item is odd and positive\n        if item % 2 == 1 and item > 0:\n            sum = sum + item\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_sum", "response_0": "from Compiler import types\n\n# Assuming arr and target are secret-shared values\narr = types.Array(10, types.sint)  # Example array of size 10\ntarget = types.sint()  # Example target value\n\n# Call the two_sum function\nresult = two_sum(arr, target)\n\n# Output the result (if needed)\nprint_ln(\"Result: %s\", result.reveal())\n", "response_1": "from Compiler import mpc_math\n\ndef two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            # Compute the sum of arr[i] and arr[j]\n            sum_ij = arr[i] + arr[j]\n            # Compare the sum with the target\n            if_cond = sum_ij == target\n            # If the condition is met, return True\n            if if_cond.reveal():\n                return True\n    return False\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Example array and target\n    arr = [sint(1), sint(2), sint(3), sint(4)]\n    target = sint(5)\n    \n    # Call the function\n    result = two_sum(arr, target)\n    \n    # Reveal the result\n    print_ln(\"Result: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "seq_search", "response_0": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the secret-shared array for the secret-shared target.\n    Return the secret-shared index of the target, return secret-shared -1 if target not found.\n    The array is guaranteed to have all different elements.\n    \"\"\"\n    n = len(arr)\n    found = sfix(-1)\n    for i in range(n):\n        # Compare the current element with the target\n        is_equal = arr[i] == target\n        # If equal, update the found index\n        found = sint.if_else(is_equal, i, found)\n    return found\n", "response_1": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    n = len(arr)\n    found = sint(0)\n    index = sint(-1)\n\n    for i in range(n):\n        # Check if the current element is equal to the target\n        is_equal = arr[i] == target\n        # If found, update the index and set found to 1\n        index = is_equal.if_else(i, index)\n        found = found | is_equal\n\n    # If not found, return -1\n    return found.if_else(index, -1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_array", "response_0": "def choppy_array(arr: Array):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i):\n            if i % 2 == 1:\n                if arr[i + j] > arr[i]:\n                    return False\n            else:\n                if arr[i + j] < arr[i]:\n                    return False\n    return True\n", "response_1": "from Compiler import types\n\ndef choppy_array(arr: types.Array):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i):\n            if i % 2 == 1:\n                if arr[i + j] > arr[i]:\n                    return types.sfix(0)\n            else:\n                if arr[i + j] < arr[i]:\n                    return types.sfix(0)\n    return types.sfix(1)\n\n# Example usage in MP-SPDZ program\narr = types.Array(5, types.sfix)  # Example array with 5 elements\n# Initialize arr with some values\n# arr[0] = ...\n# arr[1] = ...\n# arr[2] = ...\n# arr[3] = ...\n# arr[4] = ...\n\nresult = choppy_array(arr)\nprint_ln(\"Is choppy array: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n\n# Example usage in MP-SPDZ\n# Assuming arr is a list of sint (secret integers) and func is a function that operates on sint\n\n# Define the function to be applied to each element\ndef square(x):\n    return x * x\n\n# Create an array of secret integers\narr = [sint(1), sint(2), sint(3)]\n\n# Process the array with the square function\nprocessed_arr = array_process(arr, square)\n\n# Output the processed array\nprint_ln(\"Processed array: %s\", [processed_arr[i].reveal() for i in range(len(processed_arr))])\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n\n# Example usage in MP-SPDZ\n# arr = Array(10, sint)  # Example array of 10 secret integers\n# func = lambda x: x * x  # Example function to square the elements\n# result = array_process(arr, func)\n", "model_name": "deepseek-v2.5"}
{"test_name": "normalize", "response_0": "from Compiler import mpc_math\nfrom Compiler import types\n\ndef normalize(vec):\n    \"\"\"\n    Normalize the vector in a secure multi-party computation context.\n    \"\"\"\n    sum = types.sfix(0)\n    for item in vec:\n        sum = sum + item**2\n    base = mpc_math.sqrt(sum)\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "response_1": "fromCompiler import *\n\ndef normalize(vec):\n    \"\"\"\n    Normalize the vector in an MP-SPDZ secure manner.\n    \"\"\"\n    # Compute the sum of squares\n    sum_squares = sfix(0)\n    for item in vec:\n        sum_squares += item**2\n    \n    # Compute the square root of the sum of squares\n    base = sum_squares.sqrt()\n    \n    # Normalize each element in the vector\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    \n    return vec\n", "model_name": "deepseek-v2.5"}
{"test_name": "impatient_merchant", "response_0": "def impatient_merchant(days):\n    can_buy = sbit()\n    net = sint(0)\n    orig_price = sint(0)\n\n    for i in range(len(days)):\n        if can_buy.reveal():\n            net -= days[i]\n            orig_price = days[i]\n            can_buy = sbit(0)\n        else:\n            if (days[i] > orig_price).reveal():\n                net += days[i]\n                can_buy = sbit(1)\n\n    return net.reveal()\n", "response_1": "def impatient_merchant(days):\n    \"\"\"\n    MP-SPDZ version of the impatient merchant problem.\n    \"\"\"\n    can_buy = sint(1)  # Initialize can_buy as a secret integer with value 1 (True)\n    net = sint(0)  # Initialize net as a secret integer with value 0\n    orig_price = sint(0)  # Initialize orig_price as a secret integer with value 0\n\n    @for_range(len(days))\n    def _(i):\n        nonlocal can_buy, net, orig_price\n        buy_condition = can_buy == 1\n        net = net - buy_condition * days[i]\n        orig_price = buy_condition * days[i] + (1 - buy_condition) * orig_price\n        can_buy = (1 - buy_condition) * can_buy + (days[i] > orig_price)\n\n    return net\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1, 0, -1):\n        a[i] = a[i-1]\n    a[0] = temp\n    return a\n", "response_1": "def array_shift(a):\n    n = a.size\n    temp = a[n-1]\n    for i in range(n-1, 0, -1):\n        a[i] = a[i-1]\n    a[0] = temp\n    return a\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_double", "response_0": "def array_double(arr: Array<sint>):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming arr is a list of sint (secret integers)\n    arr = [sint(1), sint(2), sint(3)]\n    arr = array_double(arr)\n    # Output the result\n    for i in range(len(arr)):\n        print_ln(\"%s\", arr[i].reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "stop_at_zero", "response_0": "def stop_at_zero(array: sint):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        # Check if the current element is 0\n        if_statement = array[i] == 0\n        if if_statement.if_else(lambda: True, lambda: False):\n            break\n        # Add 1 to the current element\n        array[i] = array[i] + 1\n    return array\n", "response_1": "def stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        if array[i] == 0:\n            break\n        array[i] = array[i] + 1\n    return array\n\n# MP-SPDZ program\n\n# Assuming 'array' is a list of integers and is already defined\nn = len(array)\n\nfor i in range(n):\n    if array[i] == cint(0):\n        break\n    array[i] = array[i] + cint(1)\n\n# The modified array is now stored in 'array'\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i].bit_not()\n    return arr\n", "response_1": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = 1 - arr[i]\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_then_clip", "response_0": "def array_process_then_clip(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome into the range [-10, 10]\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = smax(arr[i], -10)  # Clipping to -10\n        arr[i] = smin(arr[i], 10)   # Clipping to 10\n    return arr\n", "response_1": "def array_process_then_clip(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome into the range [-10, 10]\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = cint(arr[i])  # Ensure the result is an integer\n        arr[i] = max(arr[i], -10)\n        arr[i] = min(arr[i], 10)\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "add_and_count_positive", "response_0": "def add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array.\n    Return both the output array and the count.\n    \"\"\"\n    n = len(array)\n    output_array = sint.Array(n)\n    count = sint(0)\n\n    for i in range(n):\n        output_array[i] = array[i] + k\n        count = count + (output_array[i] > 0)\n\n    return output_array, count\n", "response_1": "def add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    n = len(array)\n    count = sfix(0)\n    for i in range(n):\n        array[i] = array[i] + k\n        if array[i] > sfix(0):\n            count = count + sfix(1)\n    return array, count\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    max_len = max(n, m)\n    \n    # Initialize the result array with zeros\n    ret = sfix.Array(max_len)\n    \n    # Subtract elementwise\n    for i in range(max_len):\n        if i < n and i < m:\n            ret[i] = a[i] - b[i]\n        elif i < n:\n            ret[i] = a[i]\n        else:\n            ret[i] = -b[i]\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    \n    if len_a > len_b:\n        ret = sfix.Array(len_a)\n        for i in range(len_b):\n            ret[i] = a[i] - b[i]\n        for i in range(len_a - len_b):\n            ret[len_b + i] = a[len_b + i]\n    else:\n        ret = sfix.Array(len_b)\n        for i in range(len_a):\n            ret[i] = a[i] - b[i]\n        for i in range(len_b - len_a):\n            ret[len_a + i] = -b[len_a + i]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "lower_bound", "response_0": "from Compiler import mpc_math\n\ndef lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = mpc_math.infty()\n    found = False\n\n    for i in range(n):\n        cond1 = arr[i] <= x\n        cond2 = (not found) | ((x - arr[i]) < distance)\n        cond = cond1 & cond2\n\n        ret = cond.if_else(i, ret)\n        distance = cond.if_else(x - arr[i], distance)\n        found = found | cond1\n\n    return ret\n", "response_1": "def lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = -1\n    distance = x + 1  # Initialize distance to a value greater than any possible distance\n    found = False\n\n    for i in range(len(arr)):\n        cond = arr[i] <= x\n        new_distance = x - arr[i]\n        update_cond = cond & (~found | (new_distance < distance))\n        ret = update_cond.if_else(i, ret)\n        distance = update_cond.if_else(new_distance, distance)\n        found = found | cond\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "argmin", "response_0": "def argmin(a):\n    \"\"\"\n    Return the index of the minimum value of an array.\n    \"\"\"\n    n = len(a)\n    current_index = sint(0)\n    current_value = a[0]\n\n    for i in range(1, n):\n        # Compare current_value and a[i]\n        is_smaller = current_value < a[i]\n        # Update current_value and current_index\n        current_value = is_smaller.if_else(current_value, a[i])\n        current_index = is_smaller.if_else(current_index, sint(i))\n\n    return current_index\n", "response_1": "from Compiler import mpc_math\n\ndef argmin(a):\n    \"\"\"\n    Return the index of the minimum value of a secret-shared array.\n    \"\"\"\n    n = len(a)\n    current_min = a[0]\n    index = sint(0)\n\n    for i in range(1, n):\n        # Compare the current minimum with the next element\n        is_smaller = current_min <= a[i]\n        # Update the current minimum\n        current_min = mpc_math.if_else(is_smaller, current_min, a[i])\n        # Update the index\n        index = mpc_math.if_else(is_smaller, index, sint(i))\n\n    return index\n", "model_name": "deepseek-v2.5"}
{"test_name": "independent_robbery", "response_0": "def independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem in MP-SPDZ.\n    \"\"\"\n    n = len(houses)\n    dp = sfix.Array(n)\n    dp[0] = houses[0]\n    dp[1] = houses[1] if houses[1] >= houses[0] else houses[0]\n    \n    for i in range(2, n):\n        dp[i] = dp[i-2] + houses[i] if dp[i-2] + houses[i] >= dp[i-1] else dp[i-1]\n    \n    return dp[n-1]\n", "response_1": "def independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem in MP-SPDZ.\n    \"\"\"\n    n = len(houses)\n    dp = sfix.Array(n)\n    dp[0] = houses[0]\n    dp[1] = max(houses[1], dp[0])\n    for i in range(2, n):\n        dp[i] = max(dp[i-2] + houses[i], dp[i-1])\n    return dp[n-1]\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_odd_and_odd", "response_0": "def sum_odd_and_odd(arr: Array):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    sum = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            sum += arr[j]\n    return sum\n", "response_1": "def sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    n = len(arr)\n    sum = sint(0)\n    for i in range(1, n, 2):\n        for j in range(1, i, 2):\n            sum += arr[j]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_monotonous", "response_0": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    d = cint(0)\n    for i in range(n-1):\n        if i > 0 and (arr[i+1] - arr[i]) * d <= 0:\n            return cint(0)\n        d = arr[i+1] - arr[i]\n    return cint(1)\n\n# Example usage in MP-SPDZ\narr = Array(5, sint)  # Example array of 5 secret integers\n# Initialize arr with some values (not shown here)\nresult = is_monotonous(arr)\nprint_ln(\"The array is monotonous: %s\", result.reveal())\n", "response_1": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    d = sint(0)\n    result = sbool(True)\n\n    for i in range(n-1):\n        diff = arr[i+1] - arr[i]\n        if i > 0:\n            cond = (diff * d) <= 0\n            result = result & (not cond)\n        d = diff\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler import mpc_math\n\ndef positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sfix(0)\n    sum = sfix(0)\n    for item in arr:\n        if item > sfix(0):\n            count = count + sfix(1)\n        if item < sfix(0):\n            sum = sum + item\n    return count, sum\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Assuming arr is a list of secure fixed-point numbers\n    arr = [sfix(2.5), sfix(-1.3), sfix(3.0), sfix(-2.7)]\n    count, sum = positive_count_negative_sum(arr)\n    print_ln(\"Count of positive elements: %s\", count.reveal())\n    print_ln(\"Sum of negative elements: %s\", sum.reveal())\n", "response_1": "def positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint(0)\n    sum = sint(0)\n    for item in arr:\n        if_statement = item > 0\n        count = count + if_statement\n        if_statement = item < 0\n        sum = sum + item * if_statement\n    return count, sum\n\n# Example usage in MP-SPDZ\narr = sfix.Array(10)  # Assuming an array of fixed-point numbers\n# Initialize arr with some values\n# arr = [sfix(x) for x in [1, -2, 3, -4, 5, -6, 7, -8, 9, -10]]\ncount, sum = positive_count_negative_sum(arr)\nprint_ln(\"Count of positive elements: %s\", count.reveal())\nprint_ln(\"Sum of negative elements: %s\", sum.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_even", "response_0": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sfix(0)  # Initialize sum to 0 with fixed-point precision\n    for i in range(len(arr)):\n        item = arr[i]\n        if item % 2 == 0:\n            sum = sum + item\n    return sum\n\n# Example usage in MP-SPDZ\narr = [sfix(1), sfix(2), sfix(3), sfix(4)]\nresult = sum_even(arr)\nprint_ln(\"Sum of even numbers: %s\", result.reveal())\n", "response_1": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        if arr[i].reveal() % 2 == 0:\n            sum = sum + arr[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + abs(item)\n    return sum\n", "response_1": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sint(0)\n    for item in vec:\n        sum = sum + abs(item)\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_floor", "response_0": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    \"\"\"\n    ret = [sfix(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        ret[i] = arr[i].floor()\n    return ret\n", "response_1": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i].floor()\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "three_five", "response_0": "def three_five(arr):\n    \"\"\"\n    If the input array contains both/neither 3 and/or 5, return True,\n    otherwise return False.\n    \"\"\"\n    has3 = sbit()  # Initialize a secret bit for has3\n    has5 = sbit()  # Initialize a secret bit for has5\n\n    for item in arr:\n        has3 = has3 | (item == 3)\n        has5 = has5 | (item == 5)\n\n    return (has3 & has5) | ((~has3) & (~has5))\n", "response_1": "def three_five(arr: regint):\n    \"\"\"\n    If the input array contains both/neither 3 and/or 5, return True, \n    otherwise return False. \n    \"\"\"\n    has3 = sint(0)\n    has5 = sint(0)\n    for i in range(len(arr)):\n        has3 = has3 | (arr[i] == 3)\n        has5 = has5 | (arr[i] == 5)\n    return (has3 & has5) | ((~has3) & (~has5))\n", "model_name": "deepseek-v2.5"}
{"test_name": "num_above_average", "response_0": "def num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    sum = sfix(0)\n    count = sfix(0)\n    n = len(arr)\n    \n    for i in range(n):\n        sum = sum + arr[i]\n    \n    avg = sum / sfix(n)\n    \n    for item in arr:\n        if_statement = item >= avg\n        count = count + if_statement\n    \n    return count\n", "response_1": "def num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    n = len(arr)\n    sum = sint(0)\n    count = sint(0)\n\n    # Calculate the sum of the array\n    for i in range(n):\n        sum = sum + arr[i]\n\n    # Calculate the average\n    avg = sum / n\n\n    # Count elements larger than or equal to the average\n    for item in arr:\n        if_statement = item >= avg\n        count = count + if_statement.if_else(1, 0)\n\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = max(lower_bound, min(arr[i], upper_bound))\n    return arr\n", "response_1": "def clip(arr: Array, upper_bound: sfix, lower_bound: sfix) -> Array:\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = max(min(arr[i], upper_bound), lower_bound)\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "def sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for i in range(len(array)):\n        # Check if adding the current element keeps the sum within [5, 10]\n        if_condition = (sum + array[i] >= 5) & (sum + array[i] <= 10)\n        # Skip the current element if the condition is met\n        sum = sum + array[i] * (1 - if_condition)\n    return sum\n", "response_1": "def sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        temp_sum = sum + array[i]\n        if_condition = (temp_sum >= 5) * (temp_sum <= 10)\n        sum = sum + array[i] * (1 - if_condition)\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_of_odd_and_even", "response_0": "def sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers.\n    \"\"\"\n    odd_sum = sint(0)  # Initialize odd_sum as a secret integer\n    even_sum = sint(0)  # Initialize even_sum as a secret integer\n\n    for item in arr:\n        # Check if the item is odd\n        if item.reveal() % 2 == 1:\n            odd_sum = odd_sum + item\n        else:\n            even_sum = even_sum + item\n\n    return odd_sum, even_sum\n\n# Example usage in an MP-SPDZ program\n# arr = [sint(1), sint(2), sint(3), sint(4)]\n# odd_sum, even_sum = sum_of_odd_and_even(arr)\n# print_ln(\"Odd sum: %s, Even sum: %s\", odd_sum.reveal(), even_sum.reveal())\n", "response_1": "def sum_of_odd_and_even(arr: regint):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers. \n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for i in range(len(arr)):\n        item = sint(arr[i])\n        if item.reveal() % 2:\n            odd_sum = odd_sum + item\n        else:\n            even_sum = even_sum + item\n    return odd_sum, even_sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "distance", "response_0": "def distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        sum = sum + (vec1[i] - vec2[i]) ** 2\n    return sqrt(sum)\n", "response_1": "def distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors in MP-SPDZ.\n    \"\"\"\n    sum = sfloat(0)\n    for i in range(len(vec1)):\n        sum = sum + (vec1[i] - vec2[i]) ** 2\n    return sqrt(sum)\n", "model_name": "deepseek-v2.5"}
{"test_name": "num_occurrence", "response_0": "def num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sint(0)  # Initialize count as a secret integer\n    for item in arr:\n        # Check if item is equal to target using secure comparison\n        count = count + (item == target)\n    return count\n", "response_1": "def num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sint(0)  # Initialize count as a secret integer\n    for item in arr:\n        if item == target:\n            count = count + 1\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "palindrome", "response_0": "#include <iostream>\n#include <vector>\n\ntemplate <typename T>\nbool palindrome(const std::vector<T>& arr) {\n    bool flag = true;\n    size_t n = arr.size();\n    for (size_t i = 0; i < n; ++i) {\n        flag = flag & (arr[i] == arr[n - 1 - i]);\n    }\n    return flag;\n}\n", "response_1": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    n = len(arr)\n    flag = sint(1)  # Initialize flag as a secret integer with value 1\n\n    for i in range(n):\n        flag = flag & (arr[i] == arr[n - 1 - i])\n\n    return flag\n", "model_name": "deepseek-v2.5"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    num = sfix(0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                num = num + 1\n    return num\n", "response_1": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array. \n    \"\"\"\n    n = len(arr)\n    num = sint(0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            cond = arr[i] > arr[j]\n            num = num + cond\n    return num\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_of_cubes", "response_0": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        ret = ret + item**3\n    return ret\n", "response_1": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sint(0)  # Initialize ret as a secret integer\n    for item in arr:\n        ret = ret + item**3\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_element", "response_0": "from Compiler import mpc_math\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array in MP-SPDZ.\n    \"\"\"\n    current = a[0]\n    for i in range(len(a)):\n        current = mpc_math.max(current, a[i])\n    \n    return current\n", "response_1": "def max_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    for i in range(1, len(a)):\n        current = smax(current, a[i])\n    \n    return current\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_if_else", "response_0": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    for i in range(len(arr)):\n        # Use secure comparison and conditional assignment\n        cond = predicator(arr[i])\n        arr[i] = cond.if_else(if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "response_1": "template <typename T, typename Predicator, typename IfFunc, typename ElseFunc>\nvoid array_if_else(T* arr, int size, Predicator predicator, IfFunc if_func, ElseFunc else_func) {\n    for (int i = 0; i < size; i++) {\n        if (predicator(arr[i])) {\n            arr[i] = if_func(arr[i]);\n        } else {\n            arr[i] = else_func(arr[i]);\n        }\n    }\n}\n", "model_name": "deepseek-v2.5"}
{"test_name": "inf_norm", "response_0": "def inf_norm(Array<sint, 1> vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    sint sum = 0;\n    for (int i = 0; i < vec.size(); i++) {\n        sum = max(sum, abs(vec[i]));\n    }\n    return sum;\n", "response_1": "def inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    max_val = sfix(0)\n    for item in vec:\n        max_val = max(max_val, abs(item))\n    return max_val\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] + 1\n    return arr\n\n# Example usage in MP-SPDZ\nn = 5\narr = Array(n, sint)\narr.input_from(0)  # Assuming the array is input from party 0\n\n# Call the function\nresult = array_inc(arr)\n\n# Output the result\nfor i in range(n):\n    print_ln(\"Result[%s] = %s\", i, result[i].reveal())\n", "response_1": "from Compiler import types\n\ndef array_inc_mpspdz(arr):\n    \"\"\"\n    Increment all elements in the input array by 1 in MP-SPDZ\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] + 1\n    return arr\n\n# Example usage in MP-SPDZ\ndef main():\n    # Define an array of secret integers\n    arr = Array(10, sint)\n    # Initialize the array with some values (for demonstration purposes)\n    for i in range(10):\n        arr[i] = sint(i)\n    \n    # Call the function to increment the array\n    result = array_inc_mpspdz(arr)\n    \n    # Output the result (for demonstration purposes)\n    for i in range(10):\n        print_ln(\"Element %s: %s\", i, result[i].reveal())\n\nmain()\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises", "response_0": "# count_rises.mpc\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n    for i in range(n - 1):\n        if arr[i] < arr[i + 1]:\n            count = count + 1\n    return count\n\n# Example usage in MP-SPDZ\n# arr = [sint(x) for x in [1, 2, 3, 2, 4]]\n# result = count_rises(arr)\n# print_ln(\"Number of rises: %s\", result.reveal())\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sfix(0)  # Initialize count as a secure fixed-point number\n    for i in range(len(arr) - 1):\n        if arr[i] < arr[i + 1]:\n            count = count + 1\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "skip_at_zero", "response_0": "#include <iostream>\n#include <vector>\n\nstd::vector<int> skip_at_zero(std::vector<int>& array) {\n    for (int i = 0; i < array.size(); ++i) {\n        if (array[i] == 0) {\n            continue;\n        }\n        array[i] += 1;\n    }\n    return array;\n}\n", "response_1": "def skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        cond = array[i] == 0\n        array[i] = array[i] + cond.if_else(0, 1)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_intersect", "response_0": "from Compiler import types\n\ndef array_intersect(p: types.Array, q: types.Array) -> types.sint:\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    n = len(p)\n    m = len(q)\n    \n    result = types.sint(0)\n    \n    for i in range(n):\n        for j in range(m):\n            result = result | (p[i] == q[j])\n            if result == 1:\n                break\n        if result == 1:\n            break\n    \n    return result\n", "response_1": "fromCompiler import *\n\ndef array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element.\n    \"\"\"\n    n = len(p)\n    m = len(q)\n    result = sbit()\n\n    for i in range(n):\n        for j in range(m):\n            result = result | (p[i] == q[j])\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item**2\n    return sqrt(sum)\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item**2\n    return sqrt(sum)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_between", "response_0": "def sum_between(arr: Array, l: sfix, u: sfix):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr)):\n        if l <= arr[i] <= u:\n            sum = sum + arr[i]\n    return sum\n", "response_1": "def sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sfix(0)\n    for item in arr:\n        if_statement = item >= l\n        if_statement &= item <= u\n        sum = sum + if_statement.if_else(item, sfix(0))\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "largest_gap", "response_0": "def largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = sfix(0)\n    for i in range(len(arr)-1):\n        if abs(arr[i+1] - arr[i]) > cur:\n            cur = abs(arr[i+1] - arr[i])\n    return cur\n", "response_1": "def largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = sint(0)  # Initialize the current largest gap as a secret integer\n    for i in range(len(arr)-1):\n        gap = abs(arr[i+1] - arr[i])  # Compute the gap between consecutive elements\n        cur = max(cur, gap)  # Update the current largest gap\n    return cur\n", "model_name": "deepseek-v2.5"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    n = len(a)\n    m = len(b)\n\n    # Initialize secret-shared minimum of a and maximum of b\n    amin = a[0]\n    bmax = b[0]\n\n    # Compute the minimum of array a\n    for i in range(1, n):\n        amin = amin.max(a[i])\n\n    # Compute the maximum of array b\n    for i in range(1, m):\n        bmax = bmax.min(b[i])\n\n    # Compare the minimum of a with the maximum of b\n    return amin.geq(bmax)\n", "response_1": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    \n    for i in range(len(a)):\n        amin = amin.max(a[i])\n    \n    for i in range(len(b)):\n        bmax = bmax.min(b[i])\n    \n    return amin >= bmax\n", "model_name": "deepseek-v2.5"}
{"test_name": "element_count", "response_0": "def element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    ret = sfix(0)\n    for item in arr:\n        if item == target:\n            ret = ret + sfix(1)\n    return ret\n", "response_1": "def element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    ret = sint(0)  # Initialize ret as a secret integer\n    for item in arr:\n        if item == target:\n            ret = ret + 1\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_subarray", "response_0": "def is_subarray(c: Array, d: Array) -> Regint:\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    for i in range(len(d)):\n        if len(c) <= len(d) - i:\n            flag = Regint(1)\n            for j in range(len(c)):\n                flag = flag & (d[i + j] == c[j])\n            if flag.reveal():\n                return Regint(1)\n    return Regint(0)\n", "response_1": "def is_subarray(c, d):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    n = len(d)\n    m = len(c)\n    for (int i = 0; i < n; i++) {\n        if (m <= n - i) {\n            flag = true;\n            for (int j = 0; j < m; j++) {\n                flag = flag and (d[i + j] == c[j]);\n            }\n            if (flag) {\n                return true;\n            }\n        }\n    }\n    return false;\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler import mpc_math\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the secret-shared array contains 5 or 7.\n    \"\"\"\n    for item in arr:\n        # Compare the secret-shared item with 5 and 7\n        is_5 = item == 5\n        is_7 = item == 7\n        # Combine the results using OR\n        if is_5 | is_7:\n            return True\n    return False\n", "response_1": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7 in an MP-SPDZ program.\n    \"\"\"\n    for item in arr:\n        # Compare item with 5 and 7\n        is_5 = item == cint(5)\n        is_7 = item == cint(7)\n        \n        # Combine the results using OR operation\n        found = is_5 | is_7\n        \n        # If any item is 5 or 7, return True\n        if_then(found, return_true())\n    \n    # If no item is 5 or 7, return False\n    return_false()\n\n# Example usage in an MP-SPDZ program\n# arr = Array of secret-shared integers\n# result = exists_5_or_7(arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "variance", "response_0": "fromCompiler import *\n\ndef variance(arr):\n    \"\"\"\n    Return the variance of the array. \n    \"\"\"\n    n = len(arr)\n    average = sfloat()\n    variance = sfloat()\n\n    # Calculate the average\n    for item in arr:\n        average += item / sfloat(n)\n\n    # Calculate the variance\n    for item in arr:\n        variance += (item - average) ** 2 / sfloat(n)\n\n    return variance\n\n# Example usage\narr = [sfloat(x) for x in [1, 2, 3, 4, 5]]\nprint_ln(\"Variance: %s\", variance(arr).reveal())\n", "response_1": "from Compiler import mpc_math\n\ndef variance(arr):\n    \"\"\"\n    Return the variance of the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    average = mpc_math.sum(arr) / n\n    variance = mpc_math.sum([(x - average) ** 2 for x in arr]) / n\n    return variance\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_ascending", "response_0": "def is_ascending(arr):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    n = len(arr)\n    if n == 1:\n        return True\n\n    for i in range(n-1):\n        if arr[i] >= arr[i+1]:\n            return False\n    return True\n\n# MP-SPDZ equivalent\n\ndef is_ascending_mpspdz(arr):\n    n = len(arr)\n    if_then(n == 1, return_true())\n\n    for i in range(n-1):\n        if_then(arr[i] >= arr[i+1], return_false())\n    return_true()\n", "response_1": "from Compiler import types\n\ndef is_ascending(arr: types.Array):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    n = len(arr)\n    if n == 1:\n        return types.sint(1)  # Return True if the array length is 1\n    \n    for i in range(n - 1):\n        # Compare arr[i] and arr[i+1] securely\n        comparison = arr[i] < arr[i + 1]\n        if types.reveal(comparison) == 0:\n            return types.sint(0)  # Return False if not strictly ascending\n    \n    return types.sint(1)  # Return True if all elements are strictly ascending\n", "model_name": "deepseek-v2.5"}
{"test_name": "xor_all", "response_0": "def xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n\n# Example usage in MP-SPDZ\n# Assuming `arr` is a list of `sint` values\narr = [sint(0), sint(1), sint(0), sint(1)]\nresult = xor_all(arr)\nprint_ln(\"The XOR of all elements is: %s\", result.reveal())\n", "response_1": "def xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming arr is a list of sint (secret integers)\n    arr = [sint(0), sint(1), sint(0), sint(1)]\n    result = xor_all(arr)\n    print_ln(\"The result of XOR all elements is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "upper_bound", "response_0": "def upper_bound(arr, x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = 0\n    found = False\n\n    for i in range(n):\n        cond = arr[i] > x\n        cond_not_found = not_found | (arr[i] - x < distance)\n        ret = cond * (cond_not_found * i + (1 - cond_not_found) * ret) + (1 - cond) * ret\n        distance = cond * (cond_not_found * (arr[i] - x) + (1 - cond_not_found) * distance) + (1 - cond) * distance\n        found = cond | found\n\n    return ret\n", "response_1": "def upper_bound(arr, x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = Array(n, sint)\n    found = sbool(False)\n\n    for i in range(n):\n        cond = arr[i] > x\n        distance[i] = cond * (arr[i] - x)\n        ret = cond * i + (1 - cond) * ret\n        found = cond + (1 - cond) * found\n\n    min_distance = sfloat(1e9)  # A large number to initialize\n    min_index = -1\n\n    for i in range(n):\n        cond = distance[i] < min_distance\n        min_distance = cond * distance[i] + (1 - cond) * min_distance\n        min_index = cond * i + (1 - cond) * min_index\n\n    return min_index if found else -1\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_then_sum", "response_0": "def array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    n = len(arr)\n    sum = sfix(0)\n    for i in range(n):\n        arr[i] = func(arr[i])\n        sum = sum + arr[i]\n    return sum\n", "response_1": "def array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        sum = sum + arr[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    length = len(arr)  # Get the length of the array\n    for i in range(length):\n        sum = sum + arr[i]  # Accumulate the sum\n    ret = sum / length  # Compute the average\n    return ret\n", "response_1": "from Compiler import types\n\ndef main():\n    # Example array of secret integers\n    arr = [types.sint(1), types.sint(2), types.sint(3), types.sint(4)]\n    \n    # Compute the average\n    avg = average(arr)\n    \n    # Output the result\n    print_ln(\"The average is: %s\", avg.reveal())\n\nif __name__ == \"__main__\":\n    main()\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_filter", "response_0": "def array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * predicator(arr[i])\n    return arr\n", "response_1": "void array_filter(int n, int arr[], int (*predicator)(int)) {\n    /*\n    For each element in the input array, \n    if the predicator returns True, then preserve the element, \n    otherwise set the element to 0. \n    */\n    for (int i = 0; i < n; i++) {\n        arr[i] = predicator(arr[i]) ? arr[i] : 0;\n    }\n}\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_up", "response_0": "def sum_up(array):\n    \"\"\"\n    The sum_up function in MP-SPDZ\n    \"\"\"\n    sum = array[0]\n    for i in range(1, len(array)):\n        sum = sum + array[i]\n    return sum\n", "response_1": "def sum_up(array):\n    \"\"\"\n    The sum_up function in MP-SPDZ\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for i in range(len(array)):\n        sum = sum + array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_to_zero", "response_0": "def negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the secure array to zero\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        # Check if the element is negative\n        if_statement = array[i] < 0\n        # Set the element to zero if it is negative\n        array[i] = if_statement.if_else(0, array[i])\n    return array\n", "response_1": "from Compiler import types\n\ndef negative_to_zero(array: types.Array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(len(array)):\n        # Check if the element is negative\n        is_negative = array[i] < 0\n        # Set the element to zero if it is negative\n        array[i] = is_negative.if_else(0, array[i])\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_only_positive_to_ten", "response_0": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        if sum >= 10:\n            break\n        sum = sum + array[i]\n    return sum\n", "response_1": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    n = len(array)\n    for i in range(n):\n        if_statement = array[i] > 0\n        sum = if_statement.if_else(sum + array[i], sum)\n        if_break = sum >= 10\n        if if_break:\n            break\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "bubble_sort", "response_0": "void bubble_sort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - 1 - i; j++) {\n            if (arr[j] >= arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n", "response_1": "def bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array. \n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            # Use secure comparison and swapping\n            if arr[j] >= arr[j + 1]:\n                temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n    return arr\n", "model_name": "deepseek-v2.5"}
