{"test_name": "sin_or_cos", "response_0": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    if_else(x >= 0, lambda: sin(x), lambda: cos(x))\n", "response_1": "from Compiler import types\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    if x >= 0:\n        return types.sin(x)\n    return types.cos(x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    condition = input < 0\n    return condition.if_else(input, 0)\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    # Perform the comparison to check if input is less than 0\n    is_negative = input < 0\n    \n    # Use the comparison result to select the appropriate value\n    result = is_negative * input + (1 - is_negative) * 0\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_close", "response_0": "a = sint()\nb = sint()\n", "response_1": "def is_close(a, b):\n    difference = a - b\n    abs_difference = max(difference, -difference)\n    return abs_difference <= 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "hardswish", "response_0": "from Compiler import types\n\ndef hardswish(x):\n    \"\"\"\n    Hardswish function implemented in MP-SPDZ.\n    \"\"\"\n    zero = types.sint(0)\n    three = types.sint(3)\n    neg_three = types.sint(-3)\n\n    # Compute the conditions\n    cond1 = x < neg_three\n    cond2 = x > three\n    cond3 = ~(cond1 | cond2)\n\n    # Compute the results for each condition\n    result1 = zero\n    result2 = x\n    result3 = x * (x + three) / types.sint(6)\n\n    # Combine the results using multiplexing\n    return cond1.if_else(result1, cond2.if_else(result2, result3))\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function for secret-shared values.\n    \"\"\"\n    # Define constants\n    const_neg_3 = sfloat.load_sint(-3)\n    const_3 = sfloat.load_sint(3)\n    const_6 = sfloat.load_sint(6)\n\n    # Compute the conditions\n    less_than_neg_3 = x < const_neg_3\n    greater_than_3 = x > const_3\n    between_neg_3_and_3 = 1 - less_than_neg_3 - greater_than_3\n\n    # Compute the result\n    result = (less_than_neg_3 * 0) + \\\n             (greater_than_3 * x) + \\\n             (between_neg_3_and_3 * (x * (x + const_3) / const_6))\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    six = sfix(6)\n    minus_six = sfix(-6)\n    \n    if_statement = x > six\n    x = if_statement.if_else(six, x)\n    \n    if_statement = x < minus_six\n    x = if_statement.if_else(minus_six, x)\n    \n    return x\n", "response_1": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    # Use the max function to ensure the value does not exceed 6\n    clipped_high = x.max(6)\n    # Use the min function to ensure the value does not go below -6\n    clipped_low = clipped_high.min(-6)\n    return clipped_low\n", "model_name": "deepseek-v2.5"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function implemented in MP-SPDZ.\n    \"\"\"\n    ret = sfix(0)\n    ret = sfix.if_else(x > sfix(1), x, ret)\n    ret = sfix.if_else(x < sfix(-1), x, ret)\n    ret = sfix.if_else(x > sfix(0), sfix(1), ret)\n    ret = sfix.if_else(x < sfix(0), sfix(-1), ret)\n    return ret\n", "response_1": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function.\n    \"\"\"\n    if_x_greater_than_1 = x > 1\n    if_x_less_than_minus_1 = x < -1\n    if_x_greater_than_0 = x > 0\n    if_x_less_than_0 = x < 0\n\n    ret = if_x_greater_than_1.if_else(x, \n              if_x_less_than_minus_1.if_else(x, \n                  if_x_greater_than_0.if_else(1, \n                      if_x_less_than_0.if_else(-1, 0))))\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    if_statement(a >= b, lambda: (a, b) := (b, a))\n    if_statement(b >= c, lambda: (b, c) := (c, b))\n    if_statement(a >= b, lambda: (a, b) := (b, a))\n    return b\n", "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    if_a_ge_b = a >= b\n    a, b = if_a_ge_b * (b, a) + (1 - if_a_ge_b) * (a, b)\n\n    if_b_ge_c = b >= c\n    b, c = if_b_ge_c * (c, b) + (1 - if_b_ge_c) * (b, c)\n\n    if_a_ge_b = a >= b\n    a, b = if_a_ge_b * (b, a) + (1 - if_a_ge_b) * (a, b)\n\n    return b\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicated_sin_or_cos", "response_0": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Assuming x and ind are secret shared inputs\n    sin_val = sin(x)\n    cos_val = cos(x)\n    return if_else(ind, sin_val, cos_val)\n", "response_1": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    import mpc_math  # Import MP-SPDZ specific math functions\n\n    # Use a conditional to determine whether to compute sine or cosine\n    result = mpc_math.if_else(ind, mpc_math.sin(x), mpc_math.cos(x))\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    # Compute x-2\n    y = x - 2\n    \n    # Check if y is no less than 0\n    condition = y.geq(0)\n    \n    # Return y if condition is true, otherwise return x\n    return y.if_else(x, condition)\n", "response_1": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    x_minus_2 = x - 2\n    condition = x_minus_2 >= 0\n    return sfix.if_else(condition, x_minus_2, x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    \"\"\"\n    ReLU6 function implemented in MP-SPDZ.\n    \"\"\"\n    # Check if x < 0\n    less_than_zero = x < 0\n    # Check if x > 6\n    greater_than_six = x > 6\n    \n    # Return 0 if x < 0, 6 if x > 6, else return x\n    return (less_than_zero * 0) + ((1 - less_than_zero) * ((greater_than_six * 6) + ((1 - greater_than_six) * x)))\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    # Initialize the result with 0\n    result = cint(0)\n\n    # Check if x is less than 0\n    less_than_zero = x < 0\n    result = result.if_else(0, x)\n\n    # Check if x is greater than 6\n    greater_than_six = x > 6\n    result = result.if_else(6, x)\n\n    # Return the result\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "exp_slide", "response_0": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    import math\n    from Compiler import types\n\n    # Assuming x is a secure float or integer\n    if_condition = x >= 0\n\n    # Secure conditional assignment\n    result = types.if_else(if_condition, math.exp(x), x + 1)\n\n    return result\n", "response_1": "from Compiler import types\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    if_condition = x >= 0\n    result = types.sint.if_else(if_condition, types.sint.exp(x), x + 1)\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "pass_or_not", "response_0": "fromCompiler import *\n\ndef pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Convert score to a secret-shared integer\n    score = sint(score)\n\n    # Create a secret-shared constant for 60 and 59\n    sixty = sint(60)\n    fifty_nine = sint(59)\n\n    # Compute the condition for passing\n    passed_condition = score >= sixty\n\n    # Compute the new score based on the condition\n    new_score = score.if_else(score, fifty_nine)\n\n    # Compute the passed flag based on the condition\n    passed = passed_condition.if_else(sint(1), sint(0))\n\n    # Return the new score and the passed flag\n    return new_score, passed\n", "response_1": "def pass_or_not(score: sint):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Check if the score is greater than or equal to 60\n    passed = score >= 60\n\n    # If the score is less than 60, set it to 59\n    score = score.if_else(score, 59)\n\n    # Return the modified score and the pass status\n    return score, passed\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return cint(0)\n        else:\n            return cint(1)\n    discriminant = b**2 - 4 * a * c\n    if discriminant > 0:\n        return cint(2)\n    elif discriminant == 0:\n        return cint(1)\n    else:\n        return cint(0)\n", "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if_statement = sfix(0)\n    if_else_statement = sfix(0)\n    else_statement = sfix(0)\n\n    # Check if a is zero\n    if_a_zero = a == sfix(0)\n    if_a_zero.if_else(\n        # If a is zero, check if b is zero\n        (b == sfix(0)).if_else(\n            # If b is zero, return 0\n            sfix(0),\n            # Else, return 1\n            sfix(1)\n        ),\n        # Else, proceed with the quadratic formula\n        (b**sfix(2) - sfix(4) * a * c > sfix(0)).if_else(\n            # If discriminant is positive, return 2\n            sfix(2),\n            # Else, check if discriminant is zero\n            (b**sfix(2) - sfix(4) * a * c == sfix(0)).if_else(\n                # If discriminant is zero, return 1\n                sfix(1),\n                # Else, return 0\n                sfix(0)\n            )\n        )\n    )\n\n    return if_a_zero\n", "model_name": "deepseek-v2.5"}
{"test_name": "elu", "response_0": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    if_statement = x > 0\n    positive_part = if_statement * x\n    negative_part = (1 - if_statement) * (~(~(x)))\n    return positive_part + negative_part\n", "response_1": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    import math\n    from Compiler import mpc_math\n\n    # Secure comparison: if x > 0\n    cond = x > 0\n\n    # Compute the ELU function\n    result = cond.if_else(x, mpc_math.pow(math.e, x) - 1)\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function for secret shared values in MP-SPDZ\n    \"\"\"\n    # Create a secret shared value for 0\n    zero = sfix(0)\n    \n    # Compute the condition x > 0\n    condition = x > zero\n    \n    # Use the condition to select x or 0\n    result = condition.if_else(x, zero)\n    \n    return result\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function in MP-SPDZ\n    \"\"\"\n    return x * (x > 0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    return x.if_else(x, x * alpha)\n", "response_1": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    return x.if_else(x, x * alpha)\n", "model_name": "deepseek-v2.5"}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    cond1 = x > 1\n    cond2 = x < -1\n    \n    result = cond1.if_else(x - 1, cond2.if_else(-x - 1, 0))\n    \n    return result\n", "response_1": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Define the conditionals\n    cond1 = x > 1\n    cond2 = x < -1\n    \n    # Compute the results based on the conditions\n    result1 = x - 1\n    result2 = -x - 1\n    result3 = 0\n    \n    # Use the select function to choose the correct result\n    result = cond1.if_else(result1, cond2.if_else(result2, result3))\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "rounded_kinetic_energy", "response_0": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    # Scale the values to avoid floating-point operations\n    scale = 1000  # Adjust the scale as needed for precision\n    m_scaled = m * scale\n    v_scaled = v * scale\n\n    # Compute the kinetic energy\n    k_scaled = (m_scaled * v_scaled * v_scaled) // (2 * scale * scale)\n\n    # Round to the nearest integer\n    k_int = k_scaled // scale\n    remainder = k_scaled % scale\n\n    # Check if the remainder is >= 0.5 in scaled terms\n    half_scale = scale // 2\n    rounded_k_int = k_int + (remainder >= half_scale)\n\n    return rounded_k_int\n", "response_1": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    # Compute the kinetic energy\n    k = m * v**2 / 2\n    \n    # Convert to integer (floor)\n    k_int = k.floor()\n    \n    # Check if the fractional part is less than 0.5\n    fractional_part = k - k_int\n    is_less_than_half = fractional_part < 0.5\n    \n    # Return the rounded value\n    return k_int + is_less_than_half.if_else(0, 1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "danger_test", "response_0": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    return health_left <= 10\n\n# Example usage in MP-SPDZ\norigin = sfix(100)  # Example initial health\ndamage = sfix(95)   # Example damage received\n\n# Perform the danger test\nis_dangerous = danger_test(origin, damage)\n\n# Output the result\nprint_ln(\"The situation is dangerous: %s\", is_dangerous.reveal())\n", "response_1": "from Compiler import types\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    return health_left <= 10\n\n# Define the main function for MP-SPDZ\ndef main():\n    # Define the inputs as secure integers\n    origin = types.sint()\n    damage = types.sint()\n\n    # Input the values from the parties\n    print_ln(\"Enter the Dragon Warrior's initial health:\")\n    origin.input()\n    print_ln(\"Enter the damage received:\")\n    damage.input()\n\n    # Call the danger_test function\n    is_dangerous = danger_test(origin, damage)\n\n    # Output the result\n    print_ln(\"Is the situation dangerous? %s\", is_dangerous.reveal())\n\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    # Assuming x, y, and ind are secret-shared values\n    sum_result = x + y\n    prod_result = x * y\n    \n    # Use a conditional statement to select the result based on ind\n    result = ind.if_else(sum_result, prod_result)\n    \n    return result\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    # Assuming x, y, and ind are all secret-shared values\n    # ind is a boolean indicator (0 or 1)\n    result = ind * (x + y) + (1 - ind) * (x * y)\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "median", "response_0": "from Compiler import mpc_math\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array\n    sorted_arr = mpc_math.sort(arr)\n    \n    # Calculate the median\n    n = len(sorted_arr)\n    if n % 2 == 1:\n        ret = sorted_arr[n // 2]\n    else:\n        ret = (sorted_arr[n // 2] + sorted_arr[n // 2 - 1]) / 2\n    \n    return ret\n", "response_1": "from Compiler import mpc_math\n\ndef median(arr):\n    \"\"\"\n    Return the median of the secret-shared array. \n    Check first whether the array is empty\n    \"\"\"\n    n = len(arr)\n    if_statement = n == 0\n    if_statement.if_else(\n        lambda: raise_(ValueError(\"The length of the array is 0!\")),\n        lambda: None\n    )\n    \n    # Sort the array (this is a placeholder for a proper sorting algorithm)\n    sorted_arr = mpc_math.sort(arr)\n    \n    ret = sfloat.Array(n)\n    odd = n % 2\n    odd.if_else(\n        lambda: ret.assign(sorted_arr[n // 2]),\n        lambda: ret.assign((sorted_arr[n // 2] + sorted_arr[n // 2 - 1]) / 2)\n    )\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    return (sum_ab > 10).if_else(10, sum_ab)\n", "response_1": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    clipped_sum = smax(sum_ab, 10)\n    return clipped_sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    # Base fare\n    base_fare = 5\n    \n    # Check if miles are less than or equal to 5\n    if_m_le_5 = m <= 5\n    fare_le_5 = base_fare * if_m_le_5\n    \n    # Check if miles are between 5 and 10\n    if_5_le_m_le_10 = (m > 5) * (m <= 10)\n    fare_5_to_10 = (base_fare + 1.2 * (m - 5)) * if_5_le_m_le_10\n    \n    # Check if miles are greater than 10\n    if_m_gt_10 = m > 10\n    fare_gt_10 = (11 + 1.5 * (m - 10)) * if_m_gt_10\n    \n    # Combine all conditions\n    total_fare = fare_le_5 + fare_5_to_10 + fare_gt_10\n    \n    return total_fare\n", "response_1": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    if m <= 5:\n        return cint(5)\n    elif m <= 10:\n        return cint(5) + cfloat(1.2) * (m - cint(5))\n    else:\n        return cint(11) + cfloat(1.5) * (m - cint(10))\n\n# Example usage in MP-SPDZ\n# m = cint(7)  # Example input\n# print_ln(\"%s\", taxi_fare(m).reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = x.floor()\n    return x_int + (x - x_int >= 0.5)\n", "response_1": "def round_spdz(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = sfix.floor(x)\n    return x_int if (x - x_int) < sfix(0.5) else x_int + sfix(1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    if_statement = (score >= 90)\n    gpa = if_statement.if_else(4.0, 0)\n    \n    if_statement = (score >= 85)\n    gpa = if_statement.if_else(3.6, gpa)\n    \n    if_statement = (score >= 80)\n    gpa = if_statement.if_else(3.3, gpa)\n    \n    if_statement = (score >= 75)\n    gpa = if_statement.if_else(3.0, gpa)\n    \n    if_statement = (score >= 70)\n    gpa = if_statement.if_else(2.6, gpa)\n    \n    gpa = if_statement.if_else(2.3, gpa)\n    \n    return gpa\n", "response_1": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    if_else(score >= 90, lambda: 4.0,\n        if_else(score >= 85, lambda: 3.6,\n            if_else(score >= 80, lambda: 3.3,\n                if_else(score >= 75, lambda: 3.0,\n                    if_else(score >= 70, lambda: 2.6,\n                        lambda: 2.3)))))\n", "model_name": "deepseek-v2.5"}
{"test_name": "sign", "response_0": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    neg_one = sint(-1)\n\n    is_zero = x == zero\n    is_positive = x > zero\n    is_negative = x < zero\n\n    return is_zero * zero + is_positive * one + is_negative * neg_one\n", "response_1": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    neg_one = sint(-1)\n\n    is_zero = x == zero\n    is_positive = x > zero\n\n    return is_zero.if_else(zero, is_positive.if_else(one, neg_one))\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    # Compare a and b\n    comparison = a <= b\n    # Use the comparison result to choose between sum and difference\n    result = comparison.if_else(a + b, a - b)\n    return result\n", "response_1": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    # Compare a and b\n    cmp = a <= b\n    \n    # Use the comparison result to select the result\n    result = cmp.if_else(a + b, a - b)\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ.\n    \"\"\"\n    # Secure XOR operation to flip the bit if control_bit is True\n    return control_bit ^ (control_bit & flip_bit)\n", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ operations.\n    \"\"\"\n    # In MP-SPDZ, we use secure integer operations. We assume control_bit and flip_bit are secret-shared integers.\n    # The control_bit is either 0 or 1, and the flip_bit is also either 0 or 1.\n    \n    # Compute the result of the CNOT gate\n    result = control_bit * (1 - flip_bit) + (1 - control_bit) * flip_bit\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_plus1", "response_0": "template <typename T>\nT negative_plus1(const T& y) {\n    /*\n    Return y+1 if y is negative, otherwise return y\n    */\n    if (y < 0) {\n        return y + 1;\n    } else {\n        return y;\n    }\n}\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Check if y is negative\n    is_negative = y < 0\n    \n    # Use a conditional assignment to return y+1 if y is negative, otherwise return y\n    result = is_negative.if_else(y + 1, y)\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_a_parallelogram", "response_0": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return cint(0)\n\n    condition1 = (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1])\n\n    return cint(1) if condition1 or condition2 or condition3 else cint(0)\n", "response_1": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices,\n    return whether the four vertices can form a parallelogram.\n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] & x[1] == y[1]\n    \n    # Check if any two vertices are the same\n    if_same = same(a, b) | same(a, c) | same(a, d) | same(b, c) | same(b, d) | same(c, d)\n    if if_same:\n        return false\n    \n    # Check the parallelogram conditions\n    condition1 = (a[0] + b[0] == c[0] + d[0]) & (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) & (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) & (a[1] + d[1] == b[1] + c[1])\n    \n    return condition1 | condition2 | condition3\n\n# Example usage in MP-SPDZ\n# a = [sint(x) for x in input_array()]\n# b = [sint(x) for x in input_array()]\n# c = [sint(x) for x in input_array()]\n# d = [sint(x) for x in input_array()]\n# result = is_a_parallelogram(a, b, c, d)\n# print_ln(\"Is a parallelogram: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a < b & a | b\n", "response_1": "def secure_min(a, b):\n    \"\"\"\n    Return the minimum value of the two secure inputs.\n    \"\"\"\n    return a if a <= b else b\n\n# Example usage with secure inputs\na = sint(10)  # Example secure input\nb = sint(20)  # Example secure input\nresult = secure_min(a, b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x: sint, y: sint):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sint(0)\n\n    def legal(a: sint, b: sint):\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    counter = counter + 1 if legal(x + 1, y + 2) else counter\n    counter = counter + 1 if legal(x - 1, y + 2) else counter\n    counter = counter + 1 if legal(x + 1, y - 2) else counter\n    counter = counter + 1 if legal(x - 1, y - 2) else counter\n    counter = counter + 1 if legal(x + 2, y + 1) else counter\n    counter = counter + 1 if legal(x - 2, y + 1) else counter\n    counter = counter + 1 if legal(x + 2, y - 1) else counter\n    counter = counter + 1 if legal(x - 2, y - 1) else counter\n\n    return counter\n", "response_1": "def choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sfix(0)\n\n    def legal(a, b):\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n\n    return counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_sum_difference", "response_0": "#include <mpc.h>\n\ntemplate <typename T>\nT max_sum_different(const T& a, const T& b) {\n    T sum = a + b;\n    T diff = a - b;\n    T result;\n\n    if (sum > diff) {\n        result = sum;\n    } else {\n        result = diff;\n    }\n\n    return result;\n}\n", "response_1": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    max_val = (sum_ab > diff_ab).if_else(sum_ab, diff_ab)\n    return max_val\n", "model_name": "deepseek-v2.5"}
