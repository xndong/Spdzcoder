{"test_name": "next_integer", "response_0": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return t.floor_to_int() + 1\n", "response_1": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return t.floor_op() + 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "father_and_son", "response_0": "def father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    # Calculate the difference between father's age and twice the son's age\n    age_difference = father_age - 2 * son_age\n    # Return the absolute value of the difference\n    return abs(age_difference)\n\n# Example usage in MP-SPDZ\ndef main():\n    # Define the input as secret integers\n    father_age = sint(35)  # Example value\n    son_age = sint(10)      # Example value\n    \n    # Call the function\n    result = father_and_son(father_age, son_age)\n    \n    # Output the result\n    print_ln(\"The age difference is: %s\", result.reveal())\n", "response_1": "from Compiler import types\n\ndef father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    # Calculate the difference between father's age and twice the son's age\n    age_difference = father_age - (son_age * 2)\n    \n    # Return the absolute value of the difference\n    return abs(age_difference)\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Define the input types\n    father_age = types.sint()\n    son_age = types.sint()\n    \n    # Input the values (these would be provided securely in a real MP-SPDZ program)\n    father_age = sint.get_input_from(0)\n    son_age = sint.get_input_from(1)\n    \n    # Call the function\n    result = father_and_son(father_age, son_age)\n    \n    # Output the result\n    print_ln(\"The age difference is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "triangle_area", "response_0": "def triangle_area(side: sfix, height: sfix) -> sfix:\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the size of the triangle.\n    \"\"\"\n    return side * height / 2\n", "response_1": "from Compiler import types\n\n# Assuming side and height are secret-shared values\nside = types.sint()\nheight = types.sint()\n\n# Compute the area of the triangle\narea = triangle_area(side, height)\n\n# Output the result\nprint_ln(\"The area of the triangle is: %s\", area.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "sin_plus_cos", "response_0": "def sin_plus_cos(a):\n    \"\"\"\n    Return sin(a)+cos(a)\n    \"\"\"\n    # Assuming 'a' is a secret shared value\n    return (sint.sin(a) + sint.cos(a))\n", "response_1": "def sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    return sin(a) + cos(a)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sigmoid", "response_0": "def sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    return 1 / (1 + exp(-x))\n", "response_1": "def sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    # MP-SPDZ does not have math.pow or math.e, so we use the provided operations\n    e_to_minus_x = exp(-x)  # MP-SPDZ provides an exp function\n    return 1 / (1 + e_to_minus_x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "self_exponent", "response_0": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return k ** k\n", "response_1": "from Compiler import types\n\ndef self_exponent(k: types.sfix):\n    \"\"\"\n    Return the self-exponent k^k using fixed-point arithmetic.\n    \"\"\"\n    return k ** k\n", "model_name": "deepseek-v2.5"}
{"test_name": "silu", "response_0": "from Compiler import mpc_math\n\ndef silu(x):\n    \"\"\"\n    SiLU function for MP-SPDZ\n    \"\"\"\n    return x / (1 + mpc_math.pow(mpc_math.e, -x))\n", "response_1": "def silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    return x / (1 + exp(-x))\n", "model_name": "deepseek-v2.5"}
{"test_name": "Gaussian_bracket", "response_0": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = sint.floor(x)\n    return x - x_int\n", "response_1": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = sfloat.floor(x)\n    return x - x_int\n", "model_name": "deepseek-v2.5"}
{"test_name": "asin_and_square", "response_0": "def asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome. \n    \"\"\"\n    from Compiler import mpc_math\n    return mpc_math.pow(mpc_math.asin(x), 2)\n", "response_1": "def asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome. \n    \"\"\"\n    return (asin(x))**2\n", "model_name": "deepseek-v2.5"}
{"test_name": "cylinder_surface", "response_0": "def cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area. \n    \"\"\"\n    # MP-SPDZ does not have a built-in math module, so we use the predefined constant 'pi'\n    pi = 3.141592653589793\n    \n    # Compute the surface area of the cylinder\n    surface_area = 2 * pi * r**2 + 2 * pi * r * h\n    \n    return surface_area\n", "response_1": "def cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area. \n    \"\"\"\n    pi = 3.141592653589793  # Approximate value of pi\n    return 2 * pi * r**2 + 2 * pi * r * h\n", "model_name": "deepseek-v2.5"}
{"test_name": "radian_to_degree", "response_0": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    pi = 3.141592653589793\n    return r * (180 / pi)\n", "response_1": "fromCompiler import *\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    # Use the predefined constant pi in MP-SPDZ\n    return r / const_pi() * 180\n\n# Example usage in an MP-SPDZ program\nif __name__ == \"__main__\":\n    # Assuming r is a secure float or integer\n    r = sint()  # or sfloat() depending on the type\n    result = radian_to_degree(r)\n    # Output the result (this is just an example, actual output depends on the protocol)\n    print_ln(\"Result: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "square_root", "response_0": "def square_root(a):\n    \"\"\"\n    return the square root of the input. \n    \"\"\"\n    return a.sqrt()\n", "response_1": "def square_root(a):\n    \"\"\"\n    return the square root of the input. \n    \"\"\"\n    return regint(a).sqrt()\n", "model_name": "deepseek-v2.5"}
{"test_name": "cosine_theorem", "response_0": "fromCompiler import *\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    # Compute the square of a and b\n    a_sq = a**2\n    b_sq = b**2\n    \n    # Compute the cosine of the angle\n    cos_rad = cos(rad)\n    \n    # Compute the product of a, b, and cos(rad)\n    ab_cos = a * b * cos_rad\n    \n    # Compute the final result using the cosine theorem\n    result = sqrt(a_sq + b_sq - 2 * ab_cos)\n    \n    return result\n", "response_1": "def cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    from Compiler import mpc_math\n    return mpc_math.sqrt(a**2 + b**2 - 2 * a * b * mpc_math.cos(rad))\n", "model_name": "deepseek-v2.5"}
{"test_name": "lights_states", "response_0": "from math import exp2\n\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    num_clear = cint(num)\n    return exp2(num_clear)\n", "response_1": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return pow2(num)\n\n# Example usage in MP-SPDZ\n# num = sint.get_input_from(0)  # Assuming the number is provided by party 0\n# result = lights_states(num)\n# print_ln(\"The total number of possible states is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "degree_to_radian", "response_0": "# Define the constant pi\npi = 3.14159265358979323846\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    return d * pi / 180\n", "response_1": "def degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    # MP-SPDZ does not have an import statement like Python.\n    # We assume that the necessary constants (like pi) are available.\n    return d / 180 * const_pi()\n", "model_name": "deepseek-v2.5"}
{"test_name": "Fah_to_Cel", "response_0": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - sfix(32)) / sfix(1.8)\n", "response_1": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    # Assuming F is a fixed-point number in MP-SPDZ\n    return (F - 32) / 1.8\n\n# Example usage in MP-SPDZ\n# F = sfix(100)  # Example input in Fahrenheit\n# C = Fah_to_Cel(F)\n# print_ln(\"Celsius temperature: %s\", C.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "elliptic_area", "response_0": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area. \n    \"\"\"\n    # Define pi as a constant\n    pi = 3.141592653589793\n    \n    # Perform the secure multiplication\n    area = sfloat.mul(pi, sfloat.mul(a, b))\n    \n    return area\n", "response_1": "def elliptic_area(a: sfix, b: sfix):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area. \n    \"\"\"\n    from Compiler import mpc_math\n    return mpc_math.pi() * a * b\n", "model_name": "deepseek-v2.5"}
{"test_name": "floor", "response_0": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    import math\n    if isinstance(z, sint):\n        return sint.conv(math.floor(z.reveal()))\n    elif isinstance(z, cint):\n        return cint(math.floor(z))\n    else:\n        raise TypeError(\"Unsupported type for floor function\")\n", "response_1": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Assuming z is of type sfix (secret fixed-point number)\n    # Convert z to an integer by truncating the fractional part\n    return z.truncate(0)\n\n# Example usage in MP-SPDZ\n# z = sfix(3.7)\n# result = floor(z)\n# print_ln(\"Floor of %s is %s\", z, result)\n", "model_name": "deepseek-v2.5"}
{"test_name": "log_and_cube", "response_0": "from Compiler import mpc_math\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    # Compute base-2 logarithm using MP-SPDZ's math library\n    log_result = mpc_math.log2(x)\n    \n    # Compute the cube of the log result\n    cube_result = log_result * log_result * log_result\n    \n    return cube_result\n", "response_1": "def log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    # Assuming x is a secret floating-point number\n    log_base_2 = sfloat.log2(x)\n    cube = log_base_2 ** 3\n    return cube\n", "model_name": "deepseek-v2.5"}
{"test_name": "floor_and_square", "response_0": "def floor_and_square(z: sfix):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    # Calculate the floor of the fixed-point number\n    floor_z = floor_fix(z)\n    \n    # Return the square of the floor\n    return floor_z * floor_z\n", "response_1": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    # Assuming z is an MP-SPDZ floating-point number\n    floored_z = z.floor()\n    return floored_z ** 2\n", "model_name": "deepseek-v2.5"}
{"test_name": "meters_to_feet", "response_0": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    # Define the conversion factor as a fixed-point number\n    conversion_factor = 3.2808\n    \n    # Perform the fixed-point multiplication\n    return m * conversion_factor\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Input in meters (as a fixed-point number)\n    m = sfix(1.0)  # Example input: 1.0 meter\n    \n    # Convert meters to feet\n    feet = meters_to_feet(m)\n    \n    # Output the result\n    print_ln(\"%.6f meters is %.6f feet.\", m, feet)\n", "response_1": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * 3.2808\n\n# Example usage in MP-SPDZ\n# Assume 'm' is a shared secret input\nm = sfix.get_input_from(0)  # Example input from party 0\nresult = meters_to_feet(m)\nprint_ln(\"The length in feet is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "sphere_area", "response_0": "from Compiler import math\n\ndef sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    return 4 * math.pi * r**2\n", "response_1": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    # Define pi as a fixed-point number\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the area of the sphere\n    return 4 * pi * r * r\n", "model_name": "deepseek-v2.5"}
{"test_name": "coarse_abs", "response_0": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    # Compute the absolute value of x\n    abs_x = x.abs()\n    \n    # Round the absolute value to zero using floor\n    rounded_abs_x = abs_x.floor()\n    \n    return rounded_abs_x\n", "response_1": "from Compiler import instructions\nfrom Compiler import types\n\n@instructions.function_block\ndef coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = abs(x)\n    return types.math.floor(abs_x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_chickens", "response_0": "from Compiler import types\n\ndef how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - (legs - heads * 2) // 2\n\n# Example usage in MP-SPDZ\nheads = types.cint(35)  # Example value for heads\nlegs = types.cint(94)    # Example value for legs\n\nresult = how_many_chickens(heads, legs)\nprint_ln(\"Number of chickens: %s\", result.reveal())\n", "response_1": "heads = sint(10)  # Example input for heads\nlegs = sint(32)   # Example input for legs\n\nresult = how_many_chickens(heads, legs)\nprint_ln(\"Number of chickens: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "interest_calculator", "response_0": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get. \n    \"\"\"\n    # In MP-SPDZ, we use the `pow` function for exponentiation\n    return (pow(1 + ratio, months) - 1) * capital\n\n# Example usage in MP-SPDZ\n# capital = sfix(1000)  # Example initial capital\n# ratio = sfix(0.05)    # Example interest ratio\n# months = sfix(12)     # Example number of months\n# interest = interest_calculator(capital, ratio, months)\n# print_ln(\"Interest: %s\", interest.reveal())\n", "response_1": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get. \n    \"\"\"\n    import math\n    # In MP-SPDZ, we use the `sint` or `sfix` type for secret integers or fixed-point numbers\n    capital = sfix(capital)\n    ratio = sfix(ratio)\n    months = sint(months)\n    \n    # Calculate (1 + ratio) ** months\n    compounded_ratio = (1 + ratio) ** months\n    \n    # Calculate the interest\n    interest = (compounded_ratio - 1) * capital\n    \n    return interest\n", "model_name": "deepseek-v2.5"}
{"test_name": "circle_area", "response_0": "def circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    from Compiler import types\n    pi = types.sfix(3.141592653589793)  # Approximate value of pi\n    return pi * r * r\n", "response_1": "from math import pi\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    return pi * r**2\n\n# Example usage in MP-SPDZ\nr = sfloat.get_input_from(0)  # Assuming the radius is provided as input from party 0\narea = circle_area(r)\nprint_ln(\"The area of the circle is: %s\", area.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "cube_and_square_root", "response_0": "def cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    # Compute the cube of x\n    cube = x ** 3\n    # Compute the square root of the cube\n    square_root = cint(cube).sqrt()\n    return square_root\n", "response_1": "def cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    # Assuming x is a fixed-point number\n    cube = x ** 3\n    result = sqrt(cube)\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = x.floor()\n    return x_int + ((x - x_int) >= 0.5).if_else(1, 0)\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = sgf2n(x).floor()\n    return x_int if (x - x_int) < sgf2n(0.5) else x_int + 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "cryptic_adjustment", "response_0": "fromCompiler import *\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor want to adjust the pessimistic score of his students mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    return 10 * cint(10 * sqrt(origin))\n\n# Example usage in MP-SPDZ\norigin = cint(16)  # Example input\nadjusted_score = cryptic_adjustment(origin)\nprint_ln(\"Adjusted score: %s\", adjusted_score.reveal())\n", "response_1": "from Compiler import instructions\nfrom Compiler import types\n\n@instructions.private_compile\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor want to adjust the pessimistic score of his students mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    return 10 * sqrt(10 * sqrt(origin))\n\n# Example usage (this part is for demonstration and should be run in an MP-SPDZ program context)\n# origin = types.sfloat(some_value)\n# adjusted_score = cryptic_adjustment(origin)\n# print_ln(\"Adjusted score: %s\", adjusted_score.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "specific_pow", "response_0": "def specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    # Define the precision for fixed-point arithmetic\n    k = 20  # Number of bits for fractional part\n    scale = 2**k\n\n    # Convert x to fixed-point representation\n    x_fp = x * scale\n\n    # Compute x^2.5 using fixed-point arithmetic\n    x_sq = (x_fp * x_fp) // scale  # x^2\n    x_sqrt = int(math.isqrt((x_fp * scale) // scale))  # Approximate sqrt(x)\n    x_pow = (x_sq * x_sqrt) // scale  # x^(2.5)\n\n    return x_pow\n", "response_1": "def specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    # Define the precision for fixed-point arithmetic\n    k = 20  # Number of bits for fractional part\n\n    # Convert x to a fixed-point number\n    x_fp = x.if_else(x << k, 0)\n\n    # Compute x^2\n    x_squared = (x_fp * x_fp) >> k\n\n    # Compute x^0.5 (square root)\n    x_sqrt = sqrt(x_fp, k)\n\n    # Compute x^2.5 = x^2 * x^0.5\n    result = (x_squared * x_sqrt) >> k\n\n    return result\n\n# Example usage in MP-SPDZ\nx = sfix.get_input_from(0)\nresult = specific_pow(x)\nprint_ln(\"Result: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "soft_plus", "response_0": "def soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    return log(1 + exp(x))\n", "response_1": "def soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    return sfix.log(1 + sfix.exp(x))\n", "model_name": "deepseek-v2.5"}
{"test_name": "ball_volume", "response_0": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    # MP-SPDZ provides a constant for pi\n    pi = regint(3141592653589793) / regint(1000000000000000)\n    # Calculate the volume using MP-SPDZ operations\n    volume = pi * r**3 * 4 / 3\n    return volume\n", "response_1": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    PI = 3.141592653589793\n    return PI * r**3 * 4 / 3\n", "model_name": "deepseek-v2.5"}
{"test_name": "Heron", "response_0": "from Compiler import types\n\ndef Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    area_squared = p * (p - a) * (p - b) * (p - c)\n    return area_squared.sqrt()\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    a = types.sint(5)  # Replace with actual input\n    b = types.sint(5)  # Replace with actual input\n    c = types.sint(5)  # Replace with actual input\n    result = Heron(a, b, c)\n    print_ln(\"The area of the triangle is: %s\", result.reveal())\n", "response_1": "def Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    return sqrt(p * (p - a) * (p - b) * (p - c))\n", "model_name": "deepseek-v2.5"}
{"test_name": "next_perfect_square", "response_0": "def next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    sqrt_x = sfloat.sqrt(x)\n    floor_sqrt_x = sfloat.floor(sqrt_x)\n    next_sqrt = floor_sqrt_x + 1\n    return next_sqrt * next_sqrt\n", "response_1": "def next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    # Compute the integer square root of x\n    sqrt_x = cint(x).sqrt()\n    \n    # Increment the square root by 1\n    next_sqrt = sqrt_x + 1\n    \n    # Return the square of the incremented square root\n    return next_sqrt * next_sqrt\n\n# Example usage in MP-SPDZ\nx = cint(15)  # Example input\nresult = next_perfect_square(x)\nprint_ln(\"The next perfect square is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "pi_to_the_x", "response_0": "def pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    from Compiler import mpc_math\n    return mpc_math.pow(mpc_math.pi, x)\n", "response_1": "def pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x using fixed-point arithmetic.\n    \"\"\"\n    # Define the value of pi in fixed-point representation\n    pi = sfix(3.141592653589793)\n    \n    # Compute pi^x using the pow function in MP-SPDZ\n    result = pi ** x\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "spring_rocket", "response_0": "from compiler import *\nfrom library import *\n\ndef spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = sfloat(9.8)\n    return sqrt(2 * m * g * height / k)\n", "response_1": "def spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = 9.8\n    return sqrt(2 * m * g * height / k)\n\n# Example usage in MP-SPDZ\n# height = sfix(10.0)\n# m = sfix(5.0)\n# k = sfix(100.0)\n# result = spring_rocket(height, m, k)\n# print_ln(\"The minimum length the spring should be compressed is: %s\", result)\n", "model_name": "deepseek-v2.5"}
{"test_name": "cone_volume", "response_0": "def cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    from Compiler import math\n    return math.pi * r * r * h / 3\n", "response_1": "from Compiler import types\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = types.cfloat(3.141592653589793)  # Using a constant for pi\n    return pi * r * r * h / 3\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * cint(2)) / cint(2)\n", "response_1": "from Compiler import types\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) / 2\n\n# Example usage in MP-SPDZ\nheads = types.sint.get_input_from(0)\nlegs = types.sint.get_input_from(1)\nrabbits = how_many_rabbits(heads, legs)\nprint_ln(\"Number of rabbits: %s\", rabbits.reveal())\n", "model_name": "deepseek-v2.5"}
