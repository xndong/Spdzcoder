{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler import mpc_math\n\nstart = 0\nend = 99\nnum = 10\n\n# Calculate the step size\nstep = (end - start) / (num - 1)\n\n# Initialize the array\na = [start + i * step for i in range(num)]\n\n# Print the array (for debugging purposes)\nprint_ln(\"Array a: %s\", a)\n", "response_1": "from Compiler import mpc_math\n\n# Define the start, end, and number of points\nstart = 0\nend = 99\nnum = 10\n\n# Calculate the step size\nstep = (end - start) / (num - 1)\n\n# Initialize the array\na = [start + i * step for i in range(num)]\n\n# Convert the list to an MP-SPDZ array (if needed)\na = Array(num, sint).assign(a)\n\n# Print the array (for debugging purposes)\nprint_ln(\"Array a: %s\", a.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "more_positive", "response_0": "fromCompiler import *\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    # Initialize the count\n    count = sint(0)\n    \n    # Iterate over the array and count the positive numbers\n    for num in arr:\n        # Check if the number is positive\n        if num > 0:\n            count += 1\n        elif num < 0:\n            count -= 1\n    \n    # Return whether the count is positive\n    return count > 0\n\n# Example usage in an MP-SPDZ program\nif __name__ == \"__main__\":\n    # Example array\n    arr = Array(5, sint)\n    arr[0] = sint(1)\n    arr[1] = sint(-2)\n    arr[2] = sint(3)\n    arr[3] = sint(-4)\n    arr[4] = sint(5)\n    \n    # Call the function\n    result = more_positive(arr)\n    \n    # Output the result\n    print_ln(\"More positive numbers: %s\", result.reveal())\n", "response_1": "from Compiler import mpc_math\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    count = sint(0)\n    for x in arr:\n        count += (x > 0)\n    return count > (len(arr) // 2)\n", "model_name": "deepseek-v2.5"}
{"test_name": "select", "response_0": "from Compiler import mpc_math\n\ndef select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are secret-shared float data.\n    \"\"\"\n    return mpc_math.if_else(ind, a, b)\n", "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are secret-shared float data.\n    \"\"\"\n    return sfix.if_else(ind, a, b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function in MP-SPDZ.\n    \"\"\"\n    return y.maximum(0)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function for a secret fixed-point number.\n    \"\"\"\n    return y.max(0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "cost_matrix", "response_0": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix in MP-SPDZ.\n    \"\"\"\n    from Compiler import mpc_math\n\n    # Get the shape of the profit matrix\n    matrix_shape = profit_matrix.shape\n\n    # Find the maximum value in the profit matrix\n    max_value = mpc_math.max(profit_matrix)\n\n    # Create an offset matrix with the same shape and filled with the max value\n    offset_matrix = sfix.Array(matrix_shape[0], matrix_shape[1])\n    offset_matrix.assign_all(max_value)\n\n    # Compute the cost matrix\n    cost_matrix = offset_matrix - profit_matrix\n\n    return cost_matrix\n", "response_1": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix in MP-SPDZ.\n    \"\"\"\n    # Assuming profit_matrix is a matrix of type sfix or sint\n    matrix_shape = profit_matrix.shape()\n    \n    # Compute the maximum value in the profit matrix\n    max_value = profit_matrix.max()\n    \n    # Create an offset matrix filled with the maximum value\n    offset_matrix = sfix.Matrix(matrix_shape[0], matrix_shape[1])\n    offset_matrix.assign_all(max_value)\n    \n    # Compute the cost matrix by subtracting the profit matrix from the offset matrix\n    cost_matrix = offset_matrix - profit_matrix\n    \n    return cost_matrix\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_zeros", "response_0": "n = 10\na = sfix.Array(n)\nfor i in range(n):\n    a[i] = sfix(0)\n", "response_1": "n = 10\na = [sint(0) for _ in range(n)]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array in MP-SPDZ\n    array = ndarray[row_index]\n    return array\n", "response_1": "from Compiler import mpc_math\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    return [sint(0)] * n\n", "response_1": "def zeros(n):\n    return [sint()] * n\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_slicing_stride", "response_0": "def array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    # Collect even index elements from the first array\n    viewA = [ndarrayA[i] for i in range(0, len(ndarrayA), 2)]\n    \n    # Collect odd index elements from the second array\n    viewB = [ndarrayB[i] for i in range(1, len(ndarrayB), 2)]\n    \n    # Concatenate the two lists\n    array = viewA + viewB\n    \n    return array\n", "response_1": "def array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    # Collect even index elements from the first array\n    viewA = ndarrayA[::2]\n    \n    # Collect odd index elements from the second array\n    viewB = ndarrayB[1::2]\n    \n    # Concatenate the two views\n    array = viewA.concat(viewB)\n    \n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "QR_decomposition", "response_0": "def QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    from mp_spdz import Matrix, dot, transpose\n\n    # Assuming mat is a Matrix object in MP-SPDZ\n    n, m = mat.shape\n    Q = Matrix(n, m)\n    R = Matrix(m, m)\n\n    # Initialize Q with the input matrix\n    Q = mat.copy()\n\n    for i in range(m):\n        # Compute R[i, i] as the norm of the i-th column of Q\n        R[i, i] = Q[:, i].norm()\n\n        # Normalize the i-th column of Q\n        Q[:, i] = Q[:, i] / R[i, i]\n\n        # Update the rest of the columns\n        for j in range(i + 1, m):\n            R[i, j] = dot(transpose(Q[:, i]), Q[:, j])\n            Q[:, j] = Q[:, j] - Q[:, i] * R[i, j]\n\n    return Q\n", "response_1": "from Compiler import mpc_math\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    # Assuming mat is a 2D list or array of MP-SPDZ secure types\n    n_rows = len(mat)\n    n_cols = len(mat[0]) if n_rows > 0 else 0\n\n    # Initialize Q and R matrices\n    Q = [[sfix(0) for _ in range(n_cols)] for _ in range(n_rows)]\n    R = [[sfix(0) for _ in range(n_cols)] for _ in range(n_cols)]\n\n    # Perform Gram-Schmidt process to compute Q and R\n    for j in range(n_cols):\n        v = [mat[i][j] for i in range(n_rows)]\n        for k in range(j):\n            R[k][j] = sum(Q[i][k] * mat[i][j] for i in range(n_rows))\n            v = [v[i] - R[k][j] * Q[i][k] for i in range(n_rows)]\n        R[j][j] = mpc_math.sqrt(sum(v[i] * v[i] for i in range(n_rows)))\n        for i in range(n_rows):\n            Q[i][j] = v[i] / R[j][j]\n\n    return Q\n", "model_name": "deepseek-v2.5"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    # Calculate the absolute difference between each element in the array and the value\n    differences = [abs(x - value) for x in array]\n    \n    # Find the index of the minimum difference\n    idx = min_index(differences)\n    \n    return idx\n", "response_1": "# Example usage in an MP-SPDZ program\nfrom Compiler import types\n\n# Assuming array and value are of secure types\narray = types.Array(10, types.sfix)\nvalue = types.sfix(5.0)\n\n# Populate the array with some values\nfor i in range(10):\n    array[i] = types.sfix(i)\n\n# Find the nearest index\nnearest_index = find_nearest_index(array, value)\n\n# Output the result (after opening the secret value)\nprint_ln(\"Nearest index: %s\", nearest_index.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_simple_row", "response_0": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type sfix or sint\n    # Get the number of rows and columns of the input arrays\n    rowsA = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    rowsB = len(ndarrayB)\n    colsB = len(ndarrayB[0])\n\n    # Check if the number of columns is the same\n    if colsA != colsB:\n        raise ValueError(\"The number of columns in the input arrays must be the same.\")\n\n    # Initialize the result array with the combined number of rows\n    result = [[sfix(0) for _ in range(colsA)] for _ in range(rowsA + rowsB)]\n\n    # Copy elements from ndarrayA\n    for i in range(rowsA):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n\n    # Copy elements from ndarrayB\n    for i in range(rowsB):\n        for j in range(colsB):\n            result[rowsA + i][j] = ndarrayB[i][j]\n\n    return result\n", "response_1": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are 2-D arrays of type sint\n    # Concatenate the arrays along axis 0\n    array = ndarrayA.concatenate_rows(ndarrayB)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    array = Array(len(ndarray), sint)\n    array.assign(ndarray)\n    return array\n", "response_1": "from Compiler import mpc_math\n\ndef array_copy(ndarray):\n    array = ndarray.copy()\n    return array\n\n# Example usage\n@for_range(10)\ndef _(i):\n    input_array = sfix.Array(10)  # Example input array of 10 elements\n    copied_array = array_copy(input_array)\n    # Further operations with copied_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_pooling", "response_0": "# MP-SPDZ program\nfrom Compiler import mpc_math\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling on secret-shared data.\n    \"\"\"\n    # Ensure x is a secret shared array\n    assert isinstance(x, list) and all(isinstance(xi, mpc_math.sfix) for xi in x), \"Input must be a secret-shared array\"\n    \n    batch_size = len(x)\n    input_height = len(x[0])\n    input_width = len(x[0][0])\n    \n    output_height = input_height // stride\n    output_width = input_width // stride\n    \n    # Initialize the output array\n    out = [[[mpc_math.sfix(0) for _ in range(output_width)] for _ in range(output_height)] for _ in range(batch_size)]\n    \n    for b in range(batch_size):\n        for i in range(0, input_height, stride):\n            for j in range(0, input_width, stride):\n                # Extract the pooling window\n                window = [x[b][i + di][j + dj] for di in range(stride) for dj in range(stride)]\n                # Compute the max of the window\n                out[b][i // stride][j // stride] = mpc_math.max(window)\n    \n    return out\n", "response_1": "# MP-SPDZ program for max pooling\n\n# Define the max_pooling function\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    \"\"\"\n    # Calculate the output shape\n    out_shape = (x.shape[0], x.shape[1] / stride, x.shape[2] / stride)\n    out = sfix.Matrix(out_shape[0], out_shape[1])\n    \n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                # Extract the sub-matrix\n                sub_matrix = x[b, i:i+stride, j:j+stride]\n                # Compute the max of the sub-matrix\n                max_val = sub_matrix.max()\n                # Assign the max value to the output\n                out[b, i / stride, j / stride] = max_val\n    \n    return out\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_reshape", "response_0": "from Compiler import mpc_math\n\n# Define the shape of the array\nrows = 3\ncols = 5\n\n# Create an array of size 15 (3x5) with values from 0 to 14\na = mpc_math.matrix(rows, cols, range(15))\n\n# Print the array\nprint_ln('Array a:')\nfor i in range(rows):\n    print_ln(' '.join(str(a[i][j]) for j in range(cols)))\n", "response_1": "from Compiler import types\n\n# Define the array\na = types.Array(3, 5, types. sint)\n\n# Fill the array with values from 0 to 14\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = types.sint(i * 5 + j)\n\n# The array 'a' is now a 3x5 array with values from 0 to 14\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_simple_column", "response_0": "from Compiler import mpc_math\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are already defined as MP-SPDZ arrays\n    # and have the same number of rows\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n    \n    # Initialize the result array with the correct dimensions\n    result = [[0] * (colsA + colsB) for _ in range(rows)]\n    \n    # Copy elements from ndarrayA\n    for i in range(rows):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from ndarrayB\n    for i in range(rows):\n        for j in range(colsB):\n            result[i][j + colsA] = ndarrayB[i][j]\n    \n    return result\n", "response_1": "def array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of the same shape\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n    \n    # Initialize the result array with the appropriate shape\n    result = [[0] * (colsA + colsB) for _ in range(rows)]\n    \n    # Copy elements from ndarrayA\n    for i in range(rows):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from ndarrayB\n    for i in range(rows):\n        for j in range(colsB):\n            result[i][j + colsA] = ndarrayB[i][j]\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array in MP-SPDZ\n    # MP-SPDZ uses `sint` or `sfix` for secret integers or fixed-point numbers\n    # Here we assume `sint` for simplicity\n    rows = len(ndarray)\n    cols = len(ndarray[0])\n    \n    # Initialize an array to store the result\n    result = [sint() for _ in range(rows)]\n    \n    # Extract the i-th column\n    for i in range(rows):\n        result[i] = ndarray[i][column_index]\n    \n    return result\n", "response_1": "fromCompiler import *\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array of type sint (secret-shared integers)\n    rows, cols = len(ndarray), len(ndarray[0])\n    \n    # Initialize an array to store the column\n    column = [sint() for _ in range(rows)]\n    \n    # Extract the i-th column\n    for i in range(rows):\n        column[i] = ndarray[i][column_index]\n    \n    return column\n\n# Example usage (this part would be part of the main MP-SPDZ program)\n# ndarray = [[sint(1), sint(2), sint(3)], [sint(4), sint(5), sint(6)]]\n# column_index = sint(1)\n# result = array_dimensional_indexing(ndarray, column_index)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    diag = [array[i][i] for i in range(min(len(array), len(array[0])))]\n    return diag\n", "response_1": "def diag(array):\n    # Assuming 'array' is a 2D list or array in MP-SPDZ\n    diag_elements = []\n    for i in range(min(len(array), len(array[0]))):\n        diag_elements.append(array[i][i])\n    return diag_elements\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_special", "response_0": "from Compiler import types\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    Collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Get the shape of the input arrays\n    rows, colsA = ndarrayA.shape\n    rows, colsB = ndarrayB.shape\n\n    # Collect all the even columns from the first array\n    viewA = ndarrayA[:, ::2]\n\n    # Collect all the odd columns from the second array\n    viewB = ndarrayB[:, 1::2]\n\n    # Concatenate the two views along axis 1\n    array = types.Matrix.concatenate(viewA, viewB, axis=1)\n\n    return array\n", "response_1": "from Compiler import types\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1. \n    Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Get the shape of the input arrays\n    rowsA, colsA = ndarrayA.sizes\n    rowsB, colsB = ndarrayB.sizes\n\n    # Ensure that the number of rows in both arrays is the same\n    assert rowsA == rowsB, \"Number of rows in both arrays must be the same\"\n\n    # Collect all the even columns from the first array\n    even_cols_A = [ndarrayA[:, i] for i in range(0, colsA, 2)]\n\n    # Collect all the odd columns from the second array\n    odd_cols_B = [ndarrayB[:, i] for i in range(1, colsB, 2)]\n\n    # Concatenate the even columns from the first array and the odd columns from the second array\n    result_cols = even_cols_A + odd_cols_B\n\n    # Create a new array with the concatenated columns\n    result = types.Matrix(rowsA, len(result_cols), result_cols[0].value_type)\n    for i, col in enumerate(result_cols):\n        result[:, i] = col\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_arange", "response_0": "def arange(start, stop, step):\n    \"\"\"\n    Create a 1-D array in MP-SPDZ with elements from start to stop (exclusive) with a given step.\n    \"\"\"\n    if regint(stop) == regint(None):\n        stop = start\n        start = 0\n\n    # Calculate the number of elements in the array\n    num_elements = (stop - start + step - 1) // step\n\n    # Initialize an array with the calculated number of elements\n    array = Array(num_elements, sint)\n\n    # Fill the array with values from start to stop with the given step\n    for i in range(num_elements):\n        array[i] = start + i * step\n\n    return array\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-d array using MP-SPDZ's secure types.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    array = []\n    current = sint(start)\n    while current < stop:\n        array.append(current)\n        current += step\n\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_eye_2", "response_0": "from Compiler import types\n\n# Define the dimensions\nm = 3\nn = 5\n\n# Create a 2-dimensional array filled with zeros\na = types.Array(m, n, types.sint)\n\n# Set the diagonal elements to one\nfor i in range(min(m, n)):\n    a[i][i] = 1\n\n# Print the array (optional, for debugging purposes)\nfor i in range(m):\n    for j in range(n):\n        print_ln(\"%s \", a[i][j].reveal())\n", "response_1": "from Compiler import types\n\n# Define the dimensions of the array\nm = 3\nn = 5\n\n# Create a 2-dimensional array filled with 0s\na = types.Matrix(m, n, types.sint)\n\n# Set the diagonal elements to 1\nfor i in range(min(m, n)):\n    a[i][i] = 1\n\n# Output the array\nfor i in range(m):\n    for j in range(n):\n        print_ln('%s', a[i][j].reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "third_smallest", "response_0": "from Compiler import mpc_math\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Ensure the array has at least 3 elements\n    if len(arr) < 3:\n        raise ValueError(\"Array must contain at least 3 elements\")\n    \n    # Sort the array securely\n    sorted_arr = mpc_math.sort(arr)\n    \n    # Return the third smallest element\n    return sorted_arr[2]\n", "response_1": "from Compiler import mpc_math\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Sort the array using MP-SPDZ's secure sorting function\n    sorted_arr = mpc_math.sort(arr)\n    \n    # Return the third smallest element\n    return sorted_arr[2]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array in MP-SPDZ\n    rows = len(ndarray)\n    cols = len(ndarray[0])\n    \n    # Initialize an array to store the result\n    result = Array(cols, sint)\n    \n    # Extract the i-th row\n    for j in range(cols):\n        result[j] = ndarray[row_index][j]\n    \n    return result\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array in MP-SPDZ\n    rows = len(ndarray)\n    cols = len(ndarray[0])\n    \n    # Initialize an empty array to store the result\n    result = Array(cols, sint)\n    \n    # Extract the i-th row\n    for j in range(cols):\n        result[j] = ndarray[row_index][j]\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = sint.Array(n)\nfor i in range(n):\n    a[i] = sint(i)\n", "response_1": "n = 10\na = [sint(i) for i in range(n)]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array in MP-SPDZ\n    # and row_index is a public integer\n    array = ndarray[row_index]\n    return array\n", "response_1": "from Compiler import mpc_math\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D sarray and row_index is a sint\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler import types\n\n# Define a list of integers\na_l = [0, 10, 20, 30, 40]\n\n# Convert the list to an MP-SPDZ array\na = types.Array(5, types. sint).create_from(a_l)\n", "response_1": "from Compiler import mpc_math\n\n# Create a list of integers\na_l = [0, 10, 20, 30, 40]\n\n# Convert the list to an MP-SPDZ array\na = Array(len(a_l), sint)\na.assign(a_l)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_reshape", "response_0": "def array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape an array.\n    \"\"\"\n    array = ndarray.reshape(m, n)\n    return array\n", "response_1": "fromCompiler import sint, sarray\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a secret-shared array.\n    \"\"\"\n    array = sarray(ndarray)\n    reshaped_array = array.reshape(m, n)\n    return reshaped_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ones", "response_0": "n = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = sint(1)\n", "response_1": "n = 10\na = sfix.Array(n)\nfor i in range(n):\n    a[i] = sfix(1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    y = y.set_element(1, 0)\n    return y\n", "response_1": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    # Assuming y is a list of integers or a numpy-like array in MP-SPDZ\n    # We need to iterate over the array and set the elements equal to 1 to 0\n    for i in range(len(y)):\n        y[i] = y[i].if_else(0, y[i])\n    return y\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_eye", "response_0": "n = 10\na = sfix.Matrix(n, n)\nfor i in range(n):\n    a[i][i] = 1\n", "response_1": "n = 10\na = sfix.Matrix(n, n)\nfor i in range(n):\n    a[i][i] = 1.0\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_diag", "response_0": "from Compiler import mpc_math\n\n# Define the list of diagonal elements\na_l = [1, 3, 5, 2, 4, 6]\n\n# Determine the size of the square matrix\nn = len(a_l)\n\n# Initialize an empty square matrix\na = [[0 for _ in range(n)] for _ in range(n)]\n\n# Fill the diagonal elements\nfor i in range(n):\n    a[i][i] = a_l[i]\n\n# Now `a` is the diagonal matrix\n", "response_1": "fromCompiler import Array, Matrix\n\n# Define the diagonal elements\na_l = Array(6, sint)\na_l[0] = sint(1)\na_l[1] = sint(3)\na_l[2] = sint(5)\na_l[3] = sint(2)\na_l[4] = sint(4)\na_l[5] = sint(6)\n\n# Create a 6x6 matrix and set the diagonal elements\na = Matrix(6, 6, sint)\nfor i in range(6):\n    a[i][i] = a_l[i]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_advanced_integer_indexing", "response_0": "def integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an array from an integer array in MP-SPDZ.\n    \"\"\"\n    # Convert indices to an MP-SPDZ array\n    indices = Array(len(indices), sint)\n    for i in range(len(indices)):\n        indices[i] = sint(indices[i])\n    \n    # Initialize the return array\n    ret_array = Array(len(indices), sint)\n    \n    # Perform the indexing\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    \n    return ret_array\n", "response_1": "def integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an MP-SPDZ array from an integer array.\n    \"\"\"\n    # Assuming array and indices are both lists of integers\n    ret_array = Array(len(indices), sint)\n    \n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    \n    return ret_array\n", "model_name": "deepseek-v2.5"}
