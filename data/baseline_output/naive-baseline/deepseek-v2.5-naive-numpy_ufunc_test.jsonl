{"test_name": "cross_entropy_loss", "response_0": "def cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss securely using MP-SPDZ.\n    \"\"\"\n    import mpc_math  # MP-SPDZ math functions\n    import mpc_numpy as np  # MP-SPDZ numpy-like functions\n\n    # Securely compute the element-wise logarithm of y\n    log_y = np.log(y)\n    \n    # Securely compute the element-wise product of y and log_y\n    product = y * log_y\n    \n    # Securely compute the sum of all elements in the product\n    total_sum = -np.sum(product)\n    \n    return total_sum\n", "response_1": "from Compiler import mpc_math\n\ndef cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss in MP-SPDZ.\n    \"\"\"\n    # Assuming y is a secure array of floats\n    log_y = mpc_math.log(y)\n    product = y * log_y\n    return -mpc_math.sum(product)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_square_sqrt", "response_0": "fromCompiler import *\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Compute the mean of the array\n    mean = array.sum() / len(array)\n    \n    # Compute the deviation from the mean\n    deviation = array - mean\n    \n    # Compute the square of the deviations\n    square = deviation.square()\n    \n    # Compute the mean of the squared deviations\n    square_mean = square.sum() / len(array)\n    \n    # Compute the square root of the mean of the squared deviations\n    rmsd = square_mean.sqrt()\n    \n    return rmsd\n", "response_1": "def compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Assuming array is a list of sfix values\n    n = len(array)\n    \n    # Compute the mean\n    sum_array = sfix(0)\n    for i in range(n):\n        sum_array = sum_array + array[i]\n    mean = sum_array / sfix(n)\n    \n    # Compute the deviation and square it\n    square = []\n    for i in range(n):\n        deviation = array[i] - mean\n        square.append(deviation * deviation)\n    \n    # Compute the mean of the squared deviations\n    sum_square = sfix(0)\n    for i in range(n):\n        sum_square = sum_square + square[i]\n    square_mean = sum_square / sfix(n)\n    \n    # Compute the RMSD\n    rmsd = square_mean.sqrt()\n    \n    return rmsd\n", "model_name": "deepseek-v2.5"}
{"test_name": "logsumexp", "response_0": "fromCompiler import *\n\ndef logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp in MP-SPDZ\n    \"\"\"\n    _max = sint.max(log_probs)\n    ds = [x - _max for x in log_probs]\n    exp_sum = sint(0)\n    for x in ds:\n        exp_sum += sint.exp(x)\n    return _max + sint.log(exp_sum)\n", "response_1": "def logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp\n    \"\"\"\n    # Assuming log_probs is a list of sfloat values\n    _max = log_probs[0]\n    for log_prob in log_probs[1:]:\n        _max = _max.max(log_prob)\n    \n    ds = [log_prob - _max for log_prob in log_probs]\n    exp_sum = sum([d.exp() for d in ds])\n    return _max + exp_sum.log()\n", "model_name": "deepseek-v2.5"}
{"test_name": "binary_cross_entropy_loss", "response_0": "from Compiler import mpc_math\nfrom Compiler import types\n\ndef binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss in MP-SPDZ.\n    \"\"\"\n    # Ensure y_hat is within the range (0, 1)\n    y_hat = types.sfix(y_hat)\n    y = types.sfix(y)\n    \n    # Adjust y_hat to avoid log(0) and log(1)\n    y_hat = y_hat.where(y_hat == 0, types.sfix(0.001))\n    y_hat = y_hat.where(y_hat == 1, types.sfix(1 - 0.001))\n    \n    # Compute the binary cross-entropy loss\n    loss = -types.sfix.avg(y * mpc_math.log2(y_hat) + (1 - y) * mpc_math.log2(1 - y_hat))\n    \n    return loss\n", "response_1": "fromCompiler import *\n\ndef binary_cross_entropy(y_hat: sfix, y: sfix):\n    \"\"\"\n    Compute the binary cross-entropy loss in MP-SPDZ.\n    \"\"\"\n    # Avoiding zero and one by setting a small epsilon\n    epsilon = sfix(0.001)\n    y_hat_adjusted = y_hat + (sfix(1) - y_hat) * (y_hat == sfix(0)) * epsilon\n    y_hat_adjusted = y_hat_adjusted - (y_hat_adjusted == sfix(1)) * epsilon\n\n    # Compute the binary cross-entropy loss\n    loss = -mean(y * log2(y_hat_adjusted) + (sfix(1) - y) * log2(sfix(1) - y_hat_adjusted))\n    return loss\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_less_equal", "response_0": "def compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is less than or equal to arrayB.\"\"\"\n    less_eq = [a <= b for a, b in zip(arrayA, arrayB)]\n    return less_eq\n", "response_1": "from Compiler import mpc_math\n\ndef compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is less than or equal to arrayB.\"\"\"\n    # Ensure both arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must have the same length\"\n    \n    # Initialize an empty list to store the comparison results\n    less_eq = []\n    \n    # Perform element-wise comparison\n    for a, b in zip(arrayA, arrayB):\n        # Use secure comparison to determine if a <= b\n        result = mpc_math.less_equal(a, b)\n        less_eq.append(result)\n    \n    return less_eq\n", "model_name": "deepseek-v2.5"}
{"test_name": "RMS_prop_step", "response_0": "fromCompiler import *\n\ndef RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step in MP-SPDZ.\n    \"\"\"\n    alpha = sfloat(0.5)\n    beta = sfloat(1.0)\n    s = [sfloat.Array(len(grad)) for grad in grads]\n    for i, (grad, layer) in enumerate(zip(grads, layers)):\n        s[i] = beta * s[i] + (sfloat(1.0) - beta) * grad.square()\n        grad = alpha * (grad / s[i].sqrt())\n        layer += grad\n    return layers\n", "response_1": "fromCompiler import *\n\ndef RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step.\n    \"\"\"\n    alpha = sfloat(0.5)\n    beta = sfloat(1.0)\n    s = [sint.Array(grad.length) for grad in grads]\n    for i, (grad, layer) in enumerate(zip(grads, layers)):\n        s[i] = beta * s[i] + (1 - beta) * grad**2\n        grad = alpha * (grad / sqrt(s[i]))\n        layer = layer + grad\n    return layers\n", "model_name": "deepseek-v2.5"}
{"test_name": "entropy", "response_0": "from math import log2\n\ndef entropy(y):\n    \"\"\"\n    Compute the entropy of the given array in MP-SPDZ\n    \"\"\"\n    n = len(y)\n    sum_ = 0\n    unique_values = set(y)\n    \n    for i in unique_values:\n        v = sum(1 for x in y if x == i)\n        p = v / n\n        sum_ += -p * log2(p)\n    \n    return sum_\n", "response_1": "def entropy(y):\n    \"\"\"\n    Compute the entropy of the given array in MP-SPDZ\n    \"\"\"\n    n = len(y)\n    sum_ = sfix(0)\n\n    # Convert the input to a list of secret fixed-point numbers\n    y_sfix = [sfix(yi) for yi in y]\n\n    # Find unique values in y\n    unique_values = list(set(y_sfix))\n\n    for i in unique_values:\n        v = sfix(0)\n        for yi in y_sfix:\n            v += (yi == i)\n        p = v / sfix(n)\n        sum_ += -p * log2(p)\n\n    return sum_\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_exp", "response_0": "def compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D array.\"\"\"\n    # Compute the exponential of each element in the array\n    exp_array = [regint(x).exp() for x in array]\n    \n    # Compute the sum of the exponential values\n    summation = regint(0)\n    for exp_val in exp_array:\n        summation = summation + exp_val\n    \n    # Compute the softmax values\n    softmax = [exp_val / summation for exp_val in exp_array]\n    \n    return softmax\n", "response_1": "from Compiler import mpc_math\n\ndef compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D array.\"\"\"\n    # Compute the exponential of each element in the array\n    exp = [mpc_math.exp(x) for x in array]\n    \n    # Compute the summation of the exponential values\n    summation = mpc_math.sum(exp)\n    \n    # Compute the softmax values\n    softmax = [x / summation for x in exp]\n    \n    return softmax\n", "model_name": "deepseek-v2.5"}
{"test_name": "tanh", "response_0": "class Tanh():\n\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        return sfix.tanh(z)\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        tanh_x = sfix.tanh(x)\n        return 1 - tanh_x * tanh_x\n", "response_1": "from Compiler import mpc_math\n\nclass Tanh():\n\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        return mpc_math.tanh(z)\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        tanh_x = mpc_math.tanh(x)\n        return 1 - tanh_x * tanh_x\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_tan", "response_0": "from Compiler import mpc_math\n\ndef compute_tan(array):\n    \"\"\"This function calculates the trigonometric tangent, element-wise.\"\"\"\n    tan_res = mpc_math.tan(array)\n    return tan_res\n", "response_1": "from Compiler import mpc_math\n\ndef compute_tan(array):\n    \"\"\"This function calculates trigonometric tangent, element-wise in a secure manner.\"\"\"\n    tan_res = [mpc_math.tan(x) for x in array]\n    return tan_res\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_greater", "response_0": "def compute_greater(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than arrayB.\"\"\"\n    n = len(arrayA)\n    greater_res = [None] * n\n    for i in range(n):\n        greater_res[i] = arrayA[i] > arrayB[i]\n    return greater_res\n", "response_1": "fromCompiler import Array, sint\n\ndef compute_greater(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than arrayB.\"\"\"\n    n = len(arrayA)\n    greater_res = Array(n, sint)\n    \n    for i in range(n):\n        greater_res[i] = arrayA[i] > arrayB[i]\n    \n    return greater_res\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_maximum", "response_0": "from Compiler import mpc_math\n\ndef compute_maximum(arrayA, arrayB):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    max_ones = [mpc_math.max(a, b) for a, b in zip(arrayA, arrayB)]\n    return max_ones\n", "response_1": "fromCompiler import *\n\ndef compute_maximum(arrayA, arrayB):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    max_ones = Array(len(arrayA), sfix)\n    for i in range(len(arrayA)):\n        max_ones[i] = max(arrayA[i], arrayB[i])\n    return max_ones\n\n# Example usage in an MP-SPDZ program\ndef main():\n    n = 5\n    arrayA = Array(n, sfix)\n    arrayB = Array(n, sfix)\n    \n    # Initialize arrays with some values (this should be done securely in a real scenario)\n    for i in range(n):\n        arrayA[i] = sfix(i + 1)\n        arrayB[i] = sfix(n - i)\n    \n    max_ones = compute_maximum(arrayA, arrayB)\n    \n    # Print the result (for debugging purposes)\n    for i in range(n):\n        print_ln(\"Max at index %s: %s\", i, max_ones[i].reveal())\n\nmain()\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_log2", "response_0": "from Compiler import mpc_math\n\ndef compute_log2(array):\n    \"\"\"This function calculates the base-2 logarithm of elements in the input array.\"\"\"\n    log2 = [mpc_math.log2(x) for x in array]\n    return log2\n", "response_1": "from Compiler import mpc_math\n\ndef compute_log2(array):\n    \"\"\"This function calculates the base-2 logarithm of the input array.\"\"\"\n    log2 = mpc_math.log2(array)\n    return log2\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_absolute", "response_0": "fromCompiler import array\n\ndef obtain_absolute(array):\n    \"\"\"This function computes the absolute values in a MP-SPDZ array.\"\"\"\n    result = array.abs()\n    return result\n", "response_1": "def obtain_absolute(array):\n    \"\"\"This function computes the absolute values in a MP-SPDZ array.\"\"\"\n    array = [abs(x) for x in array]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_arctan", "response_0": "from Compiler import mpc_math\n\ndef compute_arctan(array):\n    \"\"\"This function calculates the trigonometric inverse tangent, element-wise.\"\"\"\n    arctan_res = [mpc_math.atan(element) for element in array]\n    return arctan_res\n", "response_1": "from Compiler import types\n\ndef compute_arctan(array: types.Array):\n    \"\"\"This function calculates the trigonometric inverse tangent, element-wise.\"\"\"\n    arctan_res = array.arctan()\n    return arctan_res\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_log", "response_0": "from Compiler import types\n\ndef compute_log(array: types.Array):\n    \"\"\"This function calculates the natural logarithm for all elements in the input array.\"\"\"\n    nlog = array.get_vector().log()\n    return nlog\n", "response_1": "from Compiler import mpc_math\n\ndef compute_log(array):\n    \"\"\"This function calculates natural logarithm for all elements in the input array.\"\"\"\n    nlog = [mpc_math.log(x) for x in array]\n    return nlog\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_not_equal", "response_0": "from Compiler import mpc_math\n\ndef compute_not_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is not equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of integers or floats\n    neq = []\n    for a, b in zip(arrayA, arrayB):\n        # Perform element-wise comparison\n        neq_element = mpc_math.not_equal(a, b)\n        neq.append(neq_element)\n    return neq\n", "response_1": "def compute_not_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is not equal to arrayB.\"\"\"\n    neq = arrayA != arrayB\n    return neq\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_equal", "response_0": "fromCompiler import *\n\ndef compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is equal to arrayB.\"\"\"\n    eq = Array(len(arrayA), sfix)\n    for i in range(len(arrayA)):\n        eq[i] = (arrayA[i] == arrayB[i])\n    return eq\n\n# Example usage in an MP-SPDZ program\n# Assuming arrayA and arrayB are already defined as arrays of sfix\n# result = compute_equal(arrayA, arrayB)\n", "response_1": "def compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is equal to arrayB.\"\"\"\n    n = len(arrayA)\n    eq = [sint(0)] * n  # Initialize an array of size n with secret integers\n    for i in range(n):\n        eq[i] = arrayA[i] == arrayB[i]\n    return eq\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_true_divide", "response_0": "def true_divide(arrayA, arrayB):\n    \"\"\"true divide between two lists of sfix values.\"\"\"\n    if len(arrayA) != len(arrayB):\n        raise ValueError(\"Arrays must be of the same length\")\n    \n    result = []\n    for a, b in zip(arrayA, arrayB):\n        if b == 0:\n            raise ValueError(\"Division by zero\")\n        result.append(a / b)\n    \n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"true divide between two 1-d arrays in MP-SPDZ.\"\"\"\n    array = mpc_math.sdiv(arrayA, arrayB)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_greater_equal", "response_0": "from Compiler import mpc_math\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than or equal to arrayB.\"\"\"\n    greater_eq = mpc_math.geq_vector(arrayA, arrayB)\n    return greater_eq\n", "response_1": "fromCompiler import *\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is greater than or equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of integers or fixed-point numbers\n    # and that they have the same length\n    n = len(arrayA)\n    greater_eq = [None] * n\n    \n    for i in range(n):\n        greater_eq[i] = arrayA[i] >= arrayB[i]\n    \n    return greater_eq\n\n# Example usage (this part would be part of the main MP-SPDZ program)\n# arrayA = sfix.Array(n)  # Assuming sfix is used for fixed-point numbers\n# arrayB = sfix.Array(n)\n# result = compute_greater_equal(arrayA, arrayB)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_negative", "response_0": "from Compiler import types\n\ndef negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    array = -arrayA\n    return array\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming arrayA is a list of MP-SPDZ integers or floats\n    arrayA = types.Array(5, types.sint)  # Example: an array of 5 secret integers\n    arrayA.assign([1, 2, 3, 4, 5])  # Assigning values to the array\n    \n    # Call the negative function\n    result = negative(arrayA)\n    \n    # Print the result (in a real MP-SPDZ program, you might need to use a secure output mechanism)\n    print_ln('Result: %s', result.reveal())\n", "response_1": "def negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    # Assuming arrayA is a list of MP-SPDZ secure types (e.g., sfix, sfloat, sint)\n    array = [ -x for x in arrayA ]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_power", "response_0": "from Compiler import mpc_math\n\ndef power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    # Ensure that the arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must have the same length\"\n    \n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the arrays and compute the power element-wise\n    for x, y in zip(arrayA, arrayB):\n        result.append(mpc_math.pow(x, y))\n    \n    return result\n", "response_1": "def power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    n = len(arrayA)\n    result = Array(n, sfix)\n    for i in range(n):\n        result[i] = arrayA[i] ** arrayB[i]\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_exp2", "response_0": "from Compiler import types\n\ndef compute_exp2(array):\n    \"\"\"This function calculates 2**p for all p in the input array securely.\"\"\"\n    exp = [types.sint(2) ** p for p in array]\n    return exp\n", "response_1": "def compute_exp2(array):\n    \"\"\"This function calculates 2**p for all p in the input array.\"\"\"\n    exp = [sfix.pow2(p) for p in array]\n    return exp\n", "model_name": "deepseek-v2.5"}
{"test_name": "cross_entropy_loss_class", "response_0": "from Compiler import types\n\nclass CrossEntropy:\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss.\n        \"\"\"\n        cross_entropy = -(types.sint.dot(y, types.sint.log2(y_pred)))\n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross entropy loss\n        \"\"\"\n        n = len(y)\n        grad = y_pred - y\n        grad = grad / types.sint(n)\n        return grad\n", "response_1": "fromCompiler import *\n\nclass CrossEntropy():\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss.\n        \"\"\"\n        cross_entropy = -sum(y * sfix.log2(y_pred))\n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross entropy loss\n        \"\"\"\n        n = len(y)\n        grad = y_pred - y\n        grad /= sfix(n)\n        return grad\n\n# Example usage (to be executed in MP-SPDZ environment)\n# y = sfix.Array(10)  # Example input\n# y_pred = sfix.Array(10)  # Example input\n# ce = CrossEntropy()\n# loss = ce.loss(y, y_pred)\n# gradient = ce.grad(y, y_pred)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_arccos", "response_0": "fromCompiler import *\n\ndef compute_arccos(array):\n    \"\"\"This function calculates trigonometric inverse cosine, element-wise.\"\"\"\n    arccos_res = [sint.arccos(x) for x in array]\n    return arccos_res\n", "response_1": "from Compiler import types\n\ndef compute_arccos(array):\n    \"\"\"This function calculates trigonometric inverse cosine, element-wise.\"\"\"\n    arccos_res = [types.sint.arccos(x) for x in array]\n    return arccos_res\n", "model_name": "deepseek-v2.5"}
{"test_name": "r2_score", "response_0": "fromCompiler import *\n\ndef r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score in MP-SPDZ.\n    \"\"\"\n    # Compute the mean of y_test\n    mean_y_test = sfloat.Array(len(y_test)).sum() / len(y_test)\n    \n    # Compute the total sum of squares\n    total_sum_squares = sfloat.Array(len(y_test)).clear_()\n    for i in range(len(y_test)):\n        total_sum_squares += (y_test[i] - mean_y_test) ** 2\n    \n    # Compute the residual sum of squares\n    residual_sum_squares = sfloat.Array(len(y_test)).clear_()\n    for i in range(len(y_test)):\n        residual_sum_squares += (y_test[i] - y_hat[i]) ** 2\n    \n    # Compute the R2 score\n    r2 = 1 - residual_sum_squares / total_sum_squares\n    \n    return r2\n", "response_1": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score in MP-SPDZ.\n    \"\"\"\n    # Compute the mean of y_test\n    mean_y_test = sfloat.sum(y_test) / len(y_test)\n    \n    # Compute total sum of squares\n    total_sum_squares = sfloat.sum((y_test - mean_y_test) ** 2)\n    \n    # Compute residual sum of squares\n    residual_sum_squares = sfloat.sum((y_test - y_hat) ** 2)\n    \n    # Compute the r2 score\n    return 1 - residual_sum_squares / total_sum_squares\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_arcsin", "response_0": "fromCompiler import *\n\ndef compute_arcsin(array):\n    \"\"\"This function calculates trigonometric inverse sine, element-wise.\"\"\"\n    arcsin_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        arcsin_res[i] = sfix.asin(array[i])\n    return arcsin_res\n", "response_1": "fromCompiler import *\n\ndef compute_arcsin(array):\n    \"\"\"This function calculates the trigonometric inverse sine, element-wise.\"\"\"\n    arcsin_res = [sint.arccos(x) for x in array]\n    return arcsin_res\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_true_divide2", "response_0": "fromCompiler import *\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"true divide between two MP-SPDZ 1-d arrays.\"\"\"\n    res = [a / b for a, b in zip(arrayA, arrayB)]\n    return res\n\n# Example usage\nif __name__ == \"__main__\":\n    # Input arrays (these would be secret-shared in a real MP-SPDZ program)\n    arrayA = sfix.Array(5)  # Example: 5 elements\n    arrayB = sfix.Array(5)  # Example: 5 elements\n\n    # Fill arrays with some values (this would be done by the parties in a real scenario)\n    for i in range(5):\n        arrayA[i] = sfix(i + 1)  # Example values: 1, 2, 3, 4, 5\n        arrayB[i] = sfix(i + 2)  # Example values: 2, 3, 4, 5, 6\n\n    # Perform the true division\n    result = true_divide(arrayA, arrayB)\n\n    # Output the result (this would be done securely in a real MP-SPDZ program)\n    for i in range(5):\n        print_ln(\"Result[%s] = %s\", i, result[i].reveal())\n", "response_1": "from Compiler import types\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"true divide between two MP-SPDZ 1-d arrays.\"\"\"\n    n = len(arrayA)\n    res = [types.sfix(0) for _ in range(n)]\n    for i in range(n):\n        res[i] = arrayA[i] / arrayB[i]\n    return res\n", "model_name": "deepseek-v2.5"}
{"test_name": "square_error_loss", "response_0": "def square_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss in MP-SPDZ.\n    \"\"\"\n    diff = y_pred - y\n    norm_squared = sum(diff * diff)\n    return 0.5 * norm_squared\n", "response_1": "def square_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    error = y_pred - y\n    squared_error = error * error\n    return 0.5 * sum(squared_error)\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_less", "response_0": "fromCompiler import *\n\ndef compute_less(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is less than arrayB.\"\"\"\n    less_res = sint.Array(len(arrayA))\n    for i in range(len(arrayA)):\n        less_res[i] = arrayA[i] < arrayB[i]\n    return less_res\n", "response_1": "from Compiler import mpc_math\n\ndef compute_less(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is less than arrayB.\"\"\"\n    less_res = [mpc_math.lt(a, b) for a, b in zip(arrayA, arrayB)]\n    return less_res\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_cos", "response_0": "from Compiler import mpc_math\n\ndef compute_cosine(array):\n    \"\"\"This function calculates trigonometric cosine, element-wise.\"\"\"\n    cos_res = mpc_math.cos(array)\n    return cos_res\n", "response_1": "def compute_cosine(array):\n    \"\"\"This function calculates trigonometric cosine, element-wise.\"\"\"\n    cos_res = [None] * len(array)\n    for i in range(len(array)):\n        cos_res[i] = cosd(array[i])  # Using cosd for fixed-point arithmetic\n    return cos_res\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ufunc_sin", "response_0": "from compiler.mainsim import sin\n\ndef compute_sine(array):\n    \"\"\"This function calculates trigonometric sine, element-wise.\"\"\"\n    sin_res = sin(array)\n    return sin_res\n", "response_1": "from Compiler import mpc_math\n\ndef compute_sine(array):\n    \"\"\"This function calculates trigonometric sine, element-wise.\"\"\"\n    sin_res = [mpc_math.sin(x) for x in array]\n    return sin_res\n", "model_name": "deepseek-v2.5"}
{"test_name": "update_weights", "response_0": "def update_weights(m, A, X, Y):\n    \"\"\"\n    Update the weights and return the difference.\n    \"\"\"\n    from Compiler import mpc_math\n    from Compiler import mpc_operations\n\n    # Compute the dot product securely\n    dot_product = mpc_operations.dot(X, (A - Y))\n    \n    # Compute the division securely\n    dw = mpc_math.div(dot_product, m)\n    \n    return dw\n", "response_1": "def update_weights(m, A, X, Y):\n    \"\"\"\n    Update the weights and return the difference.\n    \"\"\"\n    # Assuming m is a public integer and A, X, Y are secret-shared matrices\n    # Compute the dot product of X and (A - Y)\n    diff = A - Y\n    dw = (1 / m) * sfix.dot(X, diff)\n    return dw\n", "model_name": "deepseek-v2.5"}
{"test_name": "toy_layer", "response_0": "from Compiler import types\nfrom Compiler.library import *\n\ndef sigmoid(x):\n    return 1 / (1 + exp(-x))\n\ndef toy_layer(input_data, weights, biases):\n    layer1_input = input_data.dot(weights[0]) + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    layer2_input = layer1_output.dot(weights[1]) + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    return layer2_output\n", "response_1": "from Compiler import mpc_math\nfrom Compiler import types\n\ndef sigmoid(x):\n    return 1 / (1 + mpc_math.exp(-x))\n\ndef toy_layer(input_data, weights, biases):\n    # Assuming input_data, weights, and biases are of type sfix (fixed-point secure type)\n    layer1_input = types.sfix.dot(input_data, weights[0]) + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    layer2_input = types.sfix.dot(layer1_output, weights[1]) + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    return layer2_output\n", "model_name": "deepseek-v2.5"}
