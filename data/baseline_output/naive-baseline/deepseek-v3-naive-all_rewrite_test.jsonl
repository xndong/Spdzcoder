{"test_name": "move_to_end", "response_0": "from Compiler import types\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array excluding the element at the given index\n    array = types.Array(len(arr) - 1, arr.value_type)\n    @for_range(len(arr))\n    def _(i):\n        if i < index:\n            array[i] = arr[i]\n        elif i > index:\n            array[i - 1] = arr[i]\n    \n    # Append the element at the given index to the end of the new array\n    array.append(arr[index])\n    \n    return array\n", "response_1": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array without the element at the given index\n    array = Array(len(arr) - 1, arr.value_type)\n    for i in range(index):\n        array[i] = arr[i]\n    for i in range(index + 1, len(arr)):\n        array[i - 1] = arr[i]\n    \n    # Append the element to the end\n    array.append(arr[index])\n    \n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        raise ValueError(\"Array must have at least two elements\")\n\n    # Initialize the top two elements\n    top1 = arr[0]\n    top2 = arr[1]\n\n    # Iterate through the array to find the top two elements\n    for i in range(2, n):\n        # Check if the current element is greater than top1 or top2\n        if arr[i] > top1 or arr[i] > top2:\n            # If top1 is smaller than top2, replace top1\n            if top1 < top2:\n                top1 = arr[i]\n            # Otherwise, replace top2\n            else:\n                top2 = arr[i]\n\n    # Return the smaller of the two top elements, which is the second largest\n    return mux(top1 < top2, top1, top2)\n", "response_1": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    # Initialize the first two elements as the largest and second largest\n    largest = arr[0]\n    second_largest = arr[1]\n\n    # Iterate through the array starting from the third element\n    for i in range(2, len(arr)):\n        # Check if the current element is greater than the largest or second largest\n        is_greater_than_largest = arr[i] > largest\n        is_greater_than_second = arr[i] > second_largest\n\n        # Update the largest and second largest elements if necessary\n        largest = if_else(is_greater_than_largest, arr[i], largest)\n        second_largest = if_else(is_greater_than_largest, largest, \n                                 if_else(is_greater_than_second, arr[i], second_largest))\n\n    # Return the second largest element\n    return second_largest\n", "model_name": "deepseek-v3"}
{"test_name": "exists_true", "response_0": "from util import if_else\nfrom Compiler.types import sint, Array\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    arr: Array of sint (secret-shared integers)\n    \"\"\"\n    # Initialize the result to False (0)\n    result = sint(0)\n    \n    # Iterate over each element in the array\n    for x in arr:\n        # Use if_else to update the result if x is True (1)\n        result = if_else(x, sint(1), result)\n    \n    return result\n", "response_1": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = False\n    for val in arr:\n        ret = ret or val\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), sgf2n)  # Assuming sgf2n type for the array elements\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), sgf2n)\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays in an MPC context.\n    \"\"\"\n    # Multiply corresponding elements of vec1 and vec2\n    product = [x * y for x, y in zip(vec1, vec2)]\n    \n    # Sum the elements of the product list\n    summation = sum(product)\n    \n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    # Ensure the vectors are of the same length\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    \n    # Initialize the result as a secret integer\n    result = sfix(0)\n    \n    # Compute the inner product securely\n    for i in range(len(vec1)):\n        result += vec1[i] * vec2[i]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    array = Array(n, sgf2n)\n    for i in range(n):\n        array[i] = a[(i-1) % n]\n    return array\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    array = Array(n, a.s_type)\n    for i in range(n):\n        array[i] = a[(i-1)%n]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sbool)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "count_rises_2", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    count = 0\n    for i in range(n - 1):\n        flag = arr[i] < arr[i + 1]\n        count += flag\n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    count = sfix(0)\n    \n    for i in range(n - 1):\n        flag = arr[i] < arr[i + 1]\n        count += flag\n        \n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    result = Array(len(arr), sint)\n    for i in range(len(arr)):\n        if i % 2 == 1:\n            result[i] = arr[i] + 1\n        else:\n            result[i] = arr[i] - 1\n    return result\n", "response_1": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    if_else(a == 0,\n            if_else(b == 0, 0, 1),\n            if_else(b * b - 4 * a * c > 0, 2,\n                    if_else(b * b - 4 * a * c == 0, 1, 0)))\n", "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    else:\n        discriminant = b * b - 4 * a * c\n        if discriminant > 0:\n            return 2\n        elif discriminant == 0:\n            return 1\n        else:\n            return 0\n", "model_name": "deepseek-v3"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize a sum variable\n    summmation = sfix(0)\n    \n    # Iterate over each element in the array\n    for e in arr:\n        # Apply the predicator and convert the result to a secret-shared bit\n        flag = predicator(e).if_else(sfix(1), sfix(0))\n        # Accumulate the result\n        summmation += flag\n    \n    # Return the final sum\n    return summmation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize a list to store the flags\n    flag = Array(len(arr), sint)\n    \n    # Iterate over the array and apply the predicator\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    \n    # Sum the flags to get the count of elements that satisfy the predicator\n    summmation = sint(0)\n    for i in range(len(arr)):\n        summmation += flag[i]\n    \n    return summmation\n", "model_name": "deepseek-v3"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler import types\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    # Ensure both arrays are of the same length\n    assert len(arr1) == len(arr2), \"Arrays must be of the same length\"\n    \n    # Initialize the sum as a secret integer\n    total_sum = types.sint(0)\n    \n    # Iterate over the elements of the arrays\n    for i in range(len(arr1)):\n        # Multiply the corresponding elements and add to the total sum\n        total_sum += arr1[i] * arr2[i]\n    \n    return total_sum\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    ret = sfix.Array(len(arr1))\n    for i in range(len(arr1)):\n        ret[i] = arr1[i] * arr2[i]\n    return sum(ret)\n", "model_name": "deepseek-v3"}
{"test_name": "array_round", "response_0": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] + 0.5\n        ret[i] = sint(ret[i])  # Truncate to integer\n    return ret\n", "response_1": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = sint.round(arr[i])\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater_eq", "response_0": "from util import if_else\nfrom Compiler.types import Array, sfix\n\ndef array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        ret[i] = if_else(arr[i] >= brr[i], sfix(1), sfix(0))\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = Array(len(arr), sint)  # Initialize an array of secret integers with the same length as arr\n    for i in range(len(arr)):\n        ret[i] = (arr[i] >= brr[i]).if_else(sint(1), sint(0))  # Set ret[i] to 1 if arr[i] >= brr[i], else 0\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] < 0)\n    return ret\n", "response_1": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] < 0)\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = abs(len_a - len_b)\n    \n    # Determine which array is shorter and pad it with zeros\n    if len_a < len_b:\n        pad = b[-pad_length:]\n        pad = [-e for e in pad]\n    elif len_a > len_b:\n        pad = a[-pad_length:]\n    else:\n        pad = []\n    \n    # Perform elementwise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n    \n    # Append the padding\n    ret += pad\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = abs(len_a - len_b)\n    \n    # Determine which array is shorter and pad it with zeros\n    if len_a < len_b:\n        pad = [sint(0)] * pad_length\n        a = a + pad\n    elif len_a > len_b:\n        pad = [sint(0)] * pad_length\n        b = b + pad\n    \n    # Perform element-wise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    result = Array(len(arr), sfix)  # Initialize an array to store the results\n    for i in range(len(arr)):\n        result[i] = func(arr[i])  # Apply the function to each element\n    return result\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    # Initialize an empty array to store the results\n    result = Array(len(arr), sgf2n)\n\n    # Iterate over each element in the input array\n    for i in range(len(arr)):\n        # Apply the function to the current element and store the result\n        result[i] = func(arr[i])\n\n    # Return the processed array\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted = Array(n, sgf2n)\n    shifted[0] = a[n-1]\n    for i in range(1, n):\n        shifted[i] = a[i-1]\n    return shifted\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    # Get the last element of the array\n    last_element = a[-1]\n    \n    # Create a new array by concatenating the last element with the rest of the array\n    shifted_array = Array(len(a), a[0].clear_type())\n    shifted_array[0] = last_element\n    for i in range(1, len(a)):\n        shifted_array[i] = a[i-1]\n    \n    return shifted_array\n", "model_name": "deepseek-v3"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = Array(len(a), sfix)\n    for i in range(len(a)):\n        ret_array[i] = a[i].greater_than(b[i]).if_else(a[i], b[i])\n    return ret_array\n", "response_1": "from util import if_else\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = Array(len(a), sint)\n    for i in range(len(a)):\n        ret_array[i] = if_else(a[i] > b[i], a[i], b[i])\n    return ret_array\n", "model_name": "deepseek-v3"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    max_len = max(len_a, len_b)\n    \n    # Pad the shorter array with 0s\n    if len_a < max_len:\n        a = a + [sfix(0.0)] * (max_len - len_a)\n    elif len_b < max_len:\n        b = b + [sfix(0.0)] * (max_len - len_b)\n    \n    # Subtract the arrays elementwise\n    ret = [a[i] - b[i] for i in range(max_len)]\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    max_len = max(len_a, len_b)\n    \n    # Pad the shorter array with 0s\n    a_padded = a + [sfix(0.0)] * (max_len - len_a)\n    b_padded = b + [sfix(0.0)] * (max_len - len_b)\n    \n    # Subtract element-wise\n    ret = [x - y for x, y in zip(a_padded, b_padded)]\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    :param c: Array of secret-shared values\n    :return: Array of secret-shared values, which is the input array concatenated with itself\n    \"\"\"\n    return c + c\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c + c\n", "model_name": "deepseek-v3"}
{"test_name": "zeros", "response_0": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = Array(num, sint)\n    for i in range(num):\n        array[i] = sint(0)\n    return array\n", "response_1": "def zeros(num):\n    \"\"\"\n    Return a list of zeros with length num.\n    \"\"\"\n    return [sint(0) for _ in range(num)]\n", "model_name": "deepseek-v3"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x):\n        # Securely compute the clipped value\n        is_upper = x >= upper_bound\n        is_lower = x <= lower_bound\n        return if_else(is_upper, upper_bound, if_else(is_lower, lower_bound, x))\n\n    # Apply the helper function to each element in the array\n    clipped_arr = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        clipped_arr[i] = helper_func(arr[i])\n\n    return clipped_arr\n", "response_1": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x):\n        # Compare x with upper_bound and lower_bound\n        is_upper = x >= upper_bound\n        is_lower = x <= lower_bound\n        \n        # Select the appropriate value based on the comparisons\n        clipped_value = s_if_else(is_upper, upper_bound, s_if_else(is_lower, lower_bound, x))\n        return clipped_value\n\n    # Apply the helper function to each element in the array\n    clipped_arr = Array(len(arr), sint)\n    for i in range(len(arr)):\n        clipped_arr[i] = helper_func(arr[i])\n    \n    return clipped_arr\n", "model_name": "deepseek-v3"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize the sum to 0\n    summmation = 0\n    \n    # Iterate over the array\n    for i in range(len(arr)):\n        # Apply the predicator to the current element\n        flag = predicator(arr[i])\n        \n        # Add the result to the sum\n        summmation += flag\n    \n    return summmation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    # Apply the predicator to each element in the array\n    flag = arr.map(predicator)\n    \n    # Sum the results to count the number of satisfied elements\n    summation = sum(flag)\n    \n    return summation\n", "model_name": "deepseek-v3"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler import types\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    count = types.sint(0)\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compare arr[i] with arr[j] securely\n            comp = arr[i] > arr[j]\n            # Increment the count if arr[i] > arr[j]\n            count += comp\n    \n    return count\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array securely.\n    \"\"\"\n    count = types.sint(0)\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i, n):\n            count += if_else(arr[i] > arr[j], 1, 0)\n    \n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    result = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        result[i] = arr[i] + 1\n    return result\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    result = Array(n, sint)\n    for i in range(n):\n        result[i] = arr[i] + 1\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)  # Initialize count as a secret integer\n    n = len(arr)\n    for i in range(n - 1):\n        count += if_else(arr[i] < arr[i + 1], sint(1), sint(0))\n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)\n    n = len(arr)\n    for i in range(n - 1):\n        count += (arr[i] < arr[i + 1])\n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "array_process_2", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    # Apply the function to each element in the array\n    processed_arr = Array(len(arr))\n    for i in range(len(arr)):\n        processed_arr[i] = func(arr[i])\n    return processed_arr\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    result = Array(len(arr), type(arr[0]))\n    for i in range(len(arr)):\n        result[i] = func(arr[i])\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "two_norm", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Square each element in the vector\n    squared_vec = [x * x for x in vec]\n    \n    # Sum the squared elements\n    sum_squared = sum(squared_vec)\n    \n    # Compute the square root of the sum\n    norm = sqrt(sum_squared)\n    \n    return norm\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Square each element in the vector\n    squared_vec = [item * item for item in vec]\n    \n    # Sum the squared elements\n    sum_squared = sum(squared_vec)\n    \n    # Compute the square root of the sum\n    norm = sqrt(sum_squared)\n    \n    return norm\n", "model_name": "deepseek-v3"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Initialize amin with the first element of a\n    amin = a[0]\n    # Iterate through the rest of a to find the minimum value\n    for i in range(1, len(a)):\n        amin = if_else(a[i] < amin, a[i], amin)\n    \n    # Initialize bmax with the first element of b\n    bmax = b[0]\n    # Iterate through the rest of b to find the maximum value\n    for i in range(1, len(b)):\n        bmax = if_else(b[i] > bmax, b[i], bmax)\n    \n    # Return whether amin is greater than or equal to bmax\n    return amin >= bmax\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Compute the minimum value in array a\n    amin = min(a)\n    \n    # Compute the maximum value in array b\n    bmax = max(b)\n    \n    # Compare amin and bmax\n    return if_else(amin >= bmax, types.sint(1), types.sint(0))\n", "model_name": "deepseek-v3"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays securely.\n    \"\"\"\n    summation = sfix(0)  # Initialize summation with a secure fixed-point value\n    for x, y in zip(vec1, vec2):\n        summation += x * y  # Securely multiply and add to the summation\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    summation = sfix(0)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "model_name": "deepseek-v3"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), a.value_type)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = sint.Array(len(arr))\n    for i in range(len(arr)):\n        flag[i] = (arr[i] == 5) + (arr[i] == 7)\n    return sum(flag) > 0\n", "response_1": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = (arr[i] == 5) + (arr[i] == 7)\n    result = sint(0)\n    for i in range(len(arr)):\n        result = result + flag[i]\n    return result > 0\n", "model_name": "deepseek-v3"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array to store the result\n    ret = Array(len(arr) - 1, arr.value_type)\n    \n    # Copy elements before the index\n    for i in range(index):\n        ret[i] = arr[i]\n    \n    # Copy elements after the index\n    for i in range(index + 1, len(arr)):\n        ret[i - 1] = arr[i]\n    \n    return ret\n", "response_1": "from Compiler.types import Array, cint\n\ndef remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    # Determine the length of the original array\n    length = arr.length()\n    \n    # Create a new array with one less element\n    ret = Array(length - 1, cint)\n    \n    # Copy elements before the index\n    @for_range(index)\n    def _(i):\n        ret[i] = arr[i]\n    \n    # Copy elements after the index\n    @for_range(index + 1, length)\n    def _(i):\n        ret[i - 1] = arr[i]\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = sum(arr)\n    length = len(arr)\n    ret = summmation / length\n    return ret\n", "response_1": "def average(arr):\n    \"\"\"\n    Compute the average value of the secret-shared array.\n    \"\"\"\n    summmation = sum(arr)\n    length = len(arr)\n    ret = summmation / length\n    return ret\n", "model_name": "deepseek-v3"}
