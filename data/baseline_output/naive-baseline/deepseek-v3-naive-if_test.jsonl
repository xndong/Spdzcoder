{"test_name": "sin_or_cos", "response_0": "from math import sin, cos\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    return if_else(x >= 0, sin(x), cos(x))\n", "response_1": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    from math import sin, cos\n    if x >= 0:\n        return sin(x)\n    else:\n        return cos(x)\n", "model_name": "deepseek-v3"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return input * (input < 0)\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return if_else(input < 0, input, 0)\n", "model_name": "deepseek-v3"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    diff = a - b\n    abs_diff = diff * (diff > 0) - diff * (diff < 0)\n    return abs_diff <= 1\n", "response_1": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    diff = a - b\n    abs_diff = if_else(diff < 0, -diff, diff)\n    return abs_diff <= 1\n", "model_name": "deepseek-v3"}
{"test_name": "hardswish", "response_0": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    condition1 = x < -3\n    condition2 = x > 3\n    result = condition1.if_else(0, condition2.if_else(x, x * (x + 3) / 6))\n    return result\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function in MP-SPDZ.\n    \"\"\"\n    if x < -3:\n        return 0\n    elif x > 3:\n        return x\n    else:\n        return x * (x + 3) / 6\n", "model_name": "deepseek-v3"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    result = x\n    if_gt_6 = x > 6\n    result = if_else(if_gt_6, 6, result)\n    if_lt_minus_6 = x < -6\n    result = if_else(if_lt_minus_6, -6, result)\n    return result\n", "response_1": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    result = x\n    @if_ (x > 6)\n    def _():\n        result.update(6)\n    @if_ (x < -6)\n    def _():\n        result.update(-6)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "piecewise_function", "response_0": "program piecewise_function\n    # Input: secret integer x\n    # Output: secret integer ret\n    s_int x\n    s_int ret\n\n    # Initialize ret to 0\n    ret = 0\n\n    # Check if x > 1\n    s_int cond1 = x > 1\n    ret = cond1 * x + (1 - cond1) * ret\n\n    # Check if x < -1\n    s_int cond2 = x < -1\n    ret = cond2 * x + (1 - cond2) * ret\n\n    # Check if x > 0\n    s_int cond3 = x > 0\n    ret = cond3 * 1 + (1 - cond3) * ret\n\n    # Check if x < 0\n    s_int cond4 = x < 0\n    ret = cond4 * -1 + (1 - cond4) * ret\n\n    # Output the result\n    output(ret)\nend\n", "response_1": "from Compiler.library import if_, while_loop\nfrom Compiler.types import sfix, cint\n\ndef piecewise_function(x):\n    \"\"\"\n    A piecewise function in MP-SPDZ.\n    \"\"\"\n    ret = sfix(0)\n    \n    # Check conditions in order\n    condition1 = x > sfix(1)\n    condition2 = x < sfix(-1)\n    condition3 = x > sfix(0)\n    condition4 = x < sfix(0)\n    \n    # Assign values based on conditions\n    ret = if_(condition1, x, ret)\n    ret = if_(condition2, x, ret)\n    ret = if_(condition3, sfix(1), ret)\n    ret = if_(condition4, sfix(-1), ret)\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    if a >= b:\n        temp = a\n        a = b\n        b = temp\n    if b >= c:\n        temp = b\n        b = c\n        c = temp\n    if a >= b:\n        temp = a\n        a = b\n        b = temp\n    return b\n", "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # Swap a and b if a >= b\n    temp = a\n    a = b\n    b = temp\n    \n    # Swap b and c if b >= c\n    temp = b\n    b = c\n    c = temp\n    \n    # Swap a and b if a >= b\n    temp = a\n    a = b\n    b = temp\n    \n    return b\n", "model_name": "deepseek-v3"}
{"test_name": "indicated_sin_or_cos", "response_0": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Assuming x is a secret shared value and ind is a secret shared boolean\n    # Using the mpc_math library for trigonometric functions\n    from mpc_math import sin, cos\n    \n    # Conditional selection based on the indicator\n    result = ind * sin(x) + (1 - ind) * cos(x)\n    return result\n", "response_1": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Since MP-SPDZ does not have a math library, we need to implement sine and cosine\n    # using approximations or other methods. Here, we assume that sin and cos functions\n    # are available or implemented elsewhere in the code.\n    \n    # Assuming sin and cos are predefined or implemented elsewhere\n    sin_value = sin(x)\n    cos_value = cos(x)\n    \n    # Use a conditional to return the appropriate value\n    result = if_else(ind, sin_value, cos_value)\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    result = x - 2\n    condition = result >= 0\n    return if_else(condition, result, x)\n", "response_1": "from util import if_else\n\ndef minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    x_minus_2 = x - 2\n    condition = x_minus_2 >= 0\n    return if_else(condition, x_minus_2, x)\n", "model_name": "deepseek-v3"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    return (x < 0).if_else(0, (x > 6).if_else(6, x))\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    return (x < 0).if_else(0, (x > 6).if_else(6, x))\n", "model_name": "deepseek-v3"}
{"test_name": "exp_slide", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    # Check if x is nonnegative\n    is_nonnegative = x >= 0\n\n    # Compute e^x if x is nonnegative\n    exp_x = exp(x) * is_nonnegative\n\n    # Compute x + 1 if x is negative\n    x_plus_1 = (x + 1) * (1 - is_nonnegative)\n\n    # Return the result based on the condition\n    return exp_x + x_plus_1\n\ndef exp(x):\n    \"\"\"\n    Compute e^x using a Taylor series approximation.\n    \"\"\"\n    result = sfix(1.0)\n    term = sfix(1.0)\n    for i in range(1, 10):  # Adjust the range for better precision\n        term = term * x / i\n        result = result + term\n    return result\n", "response_1": "from Compiler.library import if_else\nfrom Compiler.types import sfix, cint\nfrom Compiler.util import exp\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    # Convert x to sfix if it's not already\n    x = sfix(x)\n    \n    # Check if x is nonnegative\n    is_nonnegative = x >= 0\n    \n    # Compute e^x\n    exp_x = exp(x)\n    \n    # Compute x + 1\n    x_plus_1 = x + 1\n    \n    # Use if_else to choose between exp_x and x_plus_1 based on is_nonnegative\n    result = if_else(is_nonnegative, exp_x, x_plus_1)\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "pass_or_not", "response_0": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    passed = (score >= 60)\n    score = if_else(passed, score, 59)\n    return score, passed\n", "response_1": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    passed = score >= 60\n    score = if_else(passed, score, 59)\n    return score, passed\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    # Check if a is zero\n    a_is_zero = (a == 0)\n    \n    # Check if b is zero\n    b_is_zero = (b == 0)\n    \n    # If a is zero, handle the linear case\n    if_linear = a_is_zero * (1 - b_is_zero)\n    \n    # Calculate the discriminant\n    discriminant = b * b - 4 * a * c\n    \n    # Determine the number of roots based on the discriminant\n    discriminant_positive = (discriminant > 0)\n    discriminant_zero = (discriminant == 0)\n    \n    # If a is not zero, handle the quadratic case\n    if_quadratic = (1 - a_is_zero) * (discriminant_positive * 2 + discriminant_zero * 1)\n    \n    # Combine the results from the linear and quadratic cases\n    num_roots = if_linear * 1 + if_quadratic\n    \n    return num_roots\n", "response_1": "# MP-SPDZ program to determine the number of roots of a quadratic equation\nfrom Compiler import types\n\ndef how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b, and c of a quadratic function, \n    return the number of its roots.\n    a, b, and c can be zero, but they will not all be zero.\n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    discriminant = b**2 - 4*a*c\n    if discriminant > 0:\n        return 2\n    elif discriminant == 0:\n        return 1\n    else:\n        return 0\n", "model_name": "deepseek-v3"}
{"test_name": "elu", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef elu(x):\n    \"\"\"\n    ELU function for secret-shared values\n    \"\"\"\n    e = sfix(math.e)\n    zero = sfix(0)\n    one = sfix(1)\n    \n    # Compute the condition x > 0\n    condition = x > zero\n    \n    # Compute the ELU function\n    result = cond_swap(condition, x, e ** x - one)\n    \n    return result\n", "response_1": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    if x > 0:\n        return x\n    else:\n        return exp(x) - 1\n", "model_name": "deepseek-v3"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return if_else(x > 0, x, 0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function in MP-SPDZ\n    \"\"\"\n    # Compare x with 0 to determine if it's greater than 0\n    cmp_result = x > 0\n    \n    # Use the comparison result to select between x and 0\n    result = cmp_result.if_else(x, 0)\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    # Compare x with 0 to determine if it's positive\n    is_positive = x > 0\n    \n    # Use the comparison result to select between x and x * alpha\n    result = is_positive.if_else(x, x * alpha)\n    \n    return result\n", "response_1": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    # Compute the condition x > 0\n    condition = x > 0\n    \n    # If condition is true, return x, otherwise return x * alpha\n    result = condition.if_else(x, x * alpha)\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.if_else(a >= b, b)\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    c = a >= b\n    return c.if_else(a, b)\n", "model_name": "deepseek-v3"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Compare x with 1 and -1\n    gt_one = x > 1\n    lt_minus_one = x < -1\n\n    # Compute the possible results\n    result_gt = x - 1\n    result_lt = -x - 1\n    result_else = 0\n\n    # Select the appropriate result based on the conditions\n    result = gt_one.if_else(result_gt, lt_minus_one.if_else(result_lt, result_else))\n\n    return result\n", "response_1": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    if_gt = x > 1\n    if_lt = x < -1\n    result = if_gt * (x - 1) + if_lt * (-x - 1) + (1 - if_gt - if_lt) * 0\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "rounded_kinetic_energy", "response_0": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    # Compute kinetic energy: k = m * v^2 / 2\n    k = m * v * v / 2\n    \n    # Get the integer part of k\n    k_int = k.floor()\n    \n    # Determine if the fractional part is greater than or equal to 0.5\n    fractional_part = k - k_int\n    rounding_condition = fractional_part >= 0.5\n    \n    # Return the rounded value\n    return k_int + rounding_condition\n", "response_1": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    # Compute kinetic energy: k = m * v^2 / 2\n    k = m * v * v / 2\n\n    # Extract the integer part of k\n    k_int = k.floor()\n\n    # Compute the fractional part\n    fractional_part = k - k_int\n\n    # Round to the nearest integer\n    if fractional_part < 0.5:\n        return k_int\n    else:\n        return k_int + 1\n", "model_name": "deepseek-v3"}
{"test_name": "danger_test", "response_0": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    return health_left <= 10\n", "response_1": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    is_dangerous = health_left <= 10\n    return is_dangerous\n", "model_name": "deepseek-v3"}
{"test_name": "indicated_sum_or_multiply", "response_0": "from Compiler.library import if_else\n\ndef indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs,\n    otherwise return the product of the inputs.\n    \"\"\"\n    return if_else(ind, x + y, x * y)\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    sum_result = x + y\n    product_result = x * y\n    result = ind.if_else(sum_result, product_result)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "median", "response_0": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array\n    sorted_arr = Array(n, sfix)\n    for i in range(n):\n        sorted_arr[i] = arr[i]\n    sorted_arr.sort()\n    \n    ret = sfix(0)\n    if n % 2 == 1:\n        ret = sorted_arr[n // 2]\n    else:\n        ret = (sorted_arr[n // 2] + sorted_arr[n // 2 - 1]) / 2\n    return ret\n", "response_1": "def median(arr):\n    \"\"\"\n    Return the median of the array.\n    Check first whether the array is empty.\n    \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array\n    sorted_arr = sorted(arr)\n    \n    # Calculate the median\n    if len(sorted_arr) % 2 == 1:\n        ret = sorted_arr[len(sorted_arr) // 2]\n    else:\n        ret = (sorted_arr[len(sorted_arr) // 2] + sorted_arr[len(sorted_arr) // 2 - 1]) / 2\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum = a + b\n    condition = sum > 10\n    result = condition.if_else(10, sum)\n    return result\n", "response_1": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum = a + b\n    result = if_else(sum > 10, 10, sum)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers.\n    The rule is the following:\n    Base fare: 5, which can cover the first 5 miles.\n    The part in [5,10] is charged with 1.2 dollars per mile.\n    The part in [10,+INF] is charged with 1.5 dollars per mile.\n    \"\"\"\n    base_fare = 5\n    rate_5_10 = 1.2\n    rate_10_inf = 1.5\n\n    if m <= 5:\n        return base_fare\n    elif m <= 10:\n        return base_fare + rate_5_10 * (m - 5)\n    else:\n        return base_fare + rate_5_10 * 5 + rate_10_inf * (m - 10)\n", "response_1": "from Compiler.library import *\n\ndef taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers.\n    The rule is the following:\n    Base fare: 5, which can cover the first 5 miles.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile.\n    \"\"\"\n    base_fare = 5\n    rate1 = 1.2\n    rate2 = 1.5\n    \n    # Compute the fare based on the distance\n    if_then(m <= 5)\n    fare = base_fare\n    else_if(m <= 10)\n    fare = base_fare + rate1 * (m - 5)\n    else_()\n    fare = base_fare + rate1 * 5 + rate2 * (m - 10)\n    end_if()\n    \n    return fare\n", "model_name": "deepseek-v3"}
{"test_name": "round", "response_0": "from Compiler.types import sint, sfix\nfrom Compiler.library import if_else\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x.floor()\n    remainder = x - x_int\n    return if_else(remainder < 0.5, x_int, x_int + 1)\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x // 1  # Equivalent to math.floor(x)\n    fractional_part = x - x_int\n    if fractional_part < 0.5:\n        return x_int\n    else:\n        return x_int + 1\n", "model_name": "deepseek-v3"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    # Assuming score is a secret integer in the range [0, 100]\n    if score >= 90:\n        return 4.0\n    elif score >= 85:\n        return 3.6\n    elif score >= 80:\n        return 3.3\n    elif score >= 75:\n        return 3.0\n    elif score >= 70:\n        return 2.6\n    else:\n        return 2.3\n", "response_1": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score.\n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    gpa = sfix(0.0)\n    if score >= 90:\n        gpa = sfix(4.0)\n    elif score >= 85:\n        gpa = sfix(3.6)\n    elif score >= 80:\n        gpa = sfix(3.3)\n    elif score >= 75:\n        gpa = sfix(3.0)\n    elif score >= 70:\n        gpa = sfix(2.6)\n    else:\n        gpa = sfix(2.3)\n    return gpa\n", "model_name": "deepseek-v3"}
{"test_name": "sign", "response_0": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = x == 0\n    positive = x > 0\n    negative = x < 0\n    \n    result = zero.if_else(0, positive.if_else(1, -1))\n    return result\n", "response_1": "from Compiler.types import sbit, sbitint, sbitintvec\nfrom Compiler.library import if_else\n\ndef sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sbitint(0)\n    one = sbitint(1)\n    minus_one = sbitint(-1)\n    \n    is_zero = x == zero\n    is_positive = x > zero\n    \n    return if_else(is_zero, zero, if_else(is_positive, one, minus_one))\n", "model_name": "deepseek-v3"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input,\n    return their sum, otherwise return their difference.\n    \"\"\"\n    condition = a <= b\n    result = if_else(condition, a + b, a - b)\n    return result\n", "response_1": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    condition = a <= b\n    result = condition.if_else(a + b, a - b)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    return flip_bit.if_else(1 - flip_bit, control_bit)\n", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using secret-shared values.\n    \"\"\"\n    # If control_bit is 1, flip the flip_bit; otherwise, keep it the same.\n    return (1 - flip_bit) * control_bit + flip_bit * (1 - control_bit)\n", "model_name": "deepseek-v3"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Check if y is negative\n    is_negative = y < 0\n    \n    # If y is negative, return y + 1, otherwise return y\n    result = is_negative.if_else(y + 1, y)\n    \n    return result\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Check if y is negative\n    is_negative = y < 0\n    \n    # Compute y + 1 if y is negative, otherwise keep y\n    result = is_negative * (y + 1) + (1 - is_negative) * y\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "is_a_parallelogram", "response_0": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram.\n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    # Check if any two points are the same\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n    \n    # Check the parallelogram conditions\n    condition1 = (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1])\n    \n    return condition1 or condition2 or condition3\n", "response_1": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    # Check if any two points are the same\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n    \n    # Check the parallelogram conditions\n    condition1 = (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1])\n    \n    return condition1 or condition2 or condition3\n", "model_name": "deepseek-v3"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    # Compare a and b\n    cmp = a <= b\n    \n    # Use the comparison result to select the minimum value\n    result = cmp.if_else(a, b)\n    \n    return result\n", "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a * (a <= b) + b * (b < a)\n", "model_name": "deepseek-v3"}
{"test_name": "choice_of_the_knight", "response_0": "def legal(a, b):\n    return (0 <= a) * (a <= 7) * (0 <= b) * (b <= 7)\n\ndef choice_of_the_knight(x, y):\n    counter = 0\n    counter = counter + legal(x + 1, y + 2)\n    counter = counter + legal(x - 1, y + 2)\n    counter = counter + legal(x + 1, y - 2)\n    counter = counter + legal(x - 1, y - 2)\n    counter = counter + legal(x + 2, y + 1)\n    counter = counter + legal(x - 2, y + 1)\n    counter = counter + legal(x + 2, y - 1)\n    counter = counter + legal(x - 2, y - 1)\n    return counter\n", "response_1": "def legal(a, b):\n    return (0 <= a <= 7) * (0 <= b <= 7)\n\ndef choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = 0\n    counter += legal(x+1, y+2)\n    counter += legal(x-1, y+2)\n    counter += legal(x+1, y-2)\n    counter += legal(x-1, y-2)\n    counter += legal(x+2, y+1)\n    counter += legal(x-2, y+1)\n    counter += legal(x+2, y-1)\n    counter += legal(x-2, y-1)\n    return counter\n", "model_name": "deepseek-v3"}
{"test_name": "max_sum_difference", "response_0": "from Compiler.types import sint\n\ndef max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_result = a + b\n    diff_result = a - b\n    \n    # Compare sum_result and diff_result\n    comparison = sum_result > diff_result\n    \n    # Use the comparison result to select the maximum value\n    max_value = comparison.if_else(sum_result, diff_result)\n    \n    return max_value\n", "response_1": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    max_value = sum_ab.greater_than(diff_ab).if_else(sum_ab, diff_ab)\n    return max_value\n", "model_name": "deepseek-v3"}
