{"test_name": "next_integer", "response_0": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return t.floor() + 1\n", "response_1": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    # In MP-SPDZ, we can directly add 1 to the input value\n    # since the framework handles integer arithmetic securely.\n    return t + 1\n", "model_name": "deepseek-v3"}
{"test_name": "father_and_son", "response_0": "def father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    result = abs(father_age - son_age * 2)\n    return result\n", "response_1": "def father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    return abs(father_age - son_age * 2)\n", "model_name": "deepseek-v3"}
{"test_name": "triangle_area", "response_0": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the area of the triangle.\n    \"\"\"\n    area = side * height\n    area = area / 2\n    return area\n", "response_1": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the size of the triangle.\n    \"\"\"\n    return (side * height) / 2\n", "model_name": "deepseek-v3"}
{"test_name": "sin_plus_cos", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a) using polynomial approximation.\n    \"\"\"\n    # Polynomial coefficients for sin(x) approximation around 0\n    sin_coeff = [0, 1, 0, -1/6, 0, 1/120]\n    \n    # Polynomial coefficients for cos(x) approximation around 0\n    cos_coeff = [1, 0, -1/2, 0, 1/24, 0]\n    \n    # Calculate sin(a) using polynomial approximation\n    sin_a = sum(c * (a ** i) for i, c in enumerate(sin_coeff))\n    \n    # Calculate cos(a) using polynomial approximation\n    cos_a = sum(c * (a ** i) for i, c in enumerate(cos_coeff))\n    \n    # Return sin(a) + cos(a)\n    return sin_a + cos_a\n", "response_1": "def sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a) using polynomial approximation.\n    \"\"\"\n    # Polynomial approximation for sin(x) and cos(x) around 0\n    # sin(x) \u2248 x - x^3/6 + x^5/120\n    # cos(x) \u2248 1 - x^2/2 + x^4/24\n    \n    a_squared = a * a\n    a_cubed = a * a_squared\n    a_quartic = a_squared * a_squared\n    a_quintic = a_cubed * a_squared\n    \n    sin_a = a - a_cubed / 6 + a_quintic / 120\n    cos_a = 1 - a_squared / 2 + a_quartic / 24\n    \n    return sin_a + cos_a\n", "model_name": "deepseek-v3"}
{"test_name": "sigmoid", "response_0": "from fixedpt import *\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function using fixed-point arithmetic\n    \"\"\"\n    # e^(-x) using fixed-point arithmetic\n    e_neg_x = exp_fx(-x)\n    \n    # 1 + e^(-x)\n    denominator = 1 + e_neg_x\n    \n    # 1 / (1 + e^(-x))\n    return 1 / denominator\n", "response_1": "def sigmoid(x):\n    \"\"\"\n    sigmoid function using fixed-point arithmetic\n    \"\"\"\n    # Constants\n    one = sfix(1)\n    e = sfix(2.718281828459045)  # Approximation of e\n    \n    # Compute e^(-x)\n    neg_x = -x\n    exp_neg_x = e ** neg_x\n    \n    # Compute 1 + e^(-x)\n    denominator = one + exp_neg_x\n    \n    # Compute 1 / (1 + e^(-x))\n    result = one / denominator\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "self_exponent", "response_0": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    result = 1\n    for _ in range(k):\n        result *= k\n    return result\n", "response_1": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return k ** k\n", "model_name": "deepseek-v3"}
{"test_name": "silu", "response_0": "def silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    # Compute e^(-x) using the exp function in MP-SPDZ\n    exp_neg_x = exp(-x)\n    \n    # Compute the SiLU function: x / (1 + e^(-x))\n    return x / (1 + exp_neg_x)\n", "response_1": "def silu(x):\n    \"\"\"\n    SiLU function in MP-SPDZ\n    \"\"\"\n    e = 2.718281828459045\n    return x / (1 + e ** (-x))\n", "model_name": "deepseek-v3"}
{"test_name": "Gaussian_bracket", "response_0": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = x // 1  # Equivalent to math.floor(x) for positive x\n    return x - x_int\n", "response_1": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = x // 1  # Equivalent to math.floor(x) for positive x\n    return x - x_int\n", "model_name": "deepseek-v3"}
{"test_name": "asin_and_square", "response_0": "from Compiler import mpc_math\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    # Approximate arcsin using a polynomial or other method\n    asin_x = mpc_math.asin(x)\n    \n    # Compute the square of the result\n    result = mpc_math.sqr(asin_x)\n    \n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    # Assuming x is a secret-shared value\n    # Approximate asin(x) using a polynomial approximation or other method\n    # Here, we use a placeholder for the approximation\n    asin_x = asin_approx(x)\n    \n    # Square the result\n    result = asin_x * asin_x\n    \n    return result\n\ndef asin_approx(x):\n    \"\"\"\n    Placeholder for arcsin approximation.\n    In practice, this would be replaced with a polynomial or other approximation.\n    \"\"\"\n    # This is a placeholder and should be replaced with an actual approximation\n    return x  # Replace with actual approximation\n", "model_name": "deepseek-v3"}
{"test_name": "cylinder_surface", "response_0": "def cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    pi = 3.141592653589793  # Approximate value of pi\n    return 2 * pi * r * r + 2 * pi * r * h\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    pi = 3.141592653589793\n    term1 = 2 * pi * r * r\n    term2 = 2 * pi * r * h\n    return term1 + term2\n", "model_name": "deepseek-v3"}
{"test_name": "radian_to_degree", "response_0": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    # Define pi as a fixed-point constant\n    pi = sfix(3.14159265358979323846)\n    \n    # Perform the conversion\n    return r / pi * sfix(180)\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree using fixed-point arithmetic\n    \"\"\"\n    # Define the fixed-point precision factor\n    precision_factor = 1000  # Adjust based on required precision\n\n    # Convert pi to fixed-point representation\n    pi_fixed = int(3.141592653589793 * precision_factor)\n\n    # Convert the input radian value to fixed-point\n    r_fixed = r * precision_factor\n\n    # Perform the conversion: (r / pi) * 180\n    result_fixed = (r_fixed * 180 * precision_factor) // pi_fixed\n\n    # Convert the result back to the original scale\n    return result_fixed / precision_factor\n", "model_name": "deepseek-v3"}
{"test_name": "square_root", "response_0": "def square_root(a):\n    \"\"\"\n    Compute the square root of a using the Babylonian method.\n    \"\"\"\n    if a == 0:\n        return 0\n    x = a\n    y = (x + 1) // 2\n    while y < x:\n        x = y\n        y = (x + a // x) // 2\n    return x\n", "response_1": "def square_root(a):\n    \"\"\"\n    Approximate the square root of the input using the Babylonian method.\n    \"\"\"\n    if a == 0:\n        return 0\n    x = a / 2\n    for _ in range(10):  # Adjust the number of iterations for better precision\n        x = (x + a / x) / 2\n    return x\n", "model_name": "deepseek-v3"}
{"test_name": "cosine_theorem", "response_0": "from Compiler.library import sqrt, cos\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    return sqrt(a**2 + b**2 - 2 * a * b * cos(rad))\n", "response_1": "from Compiler.library import sqrt, cos\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them,\n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    a_squared = a * a\n    b_squared = b * b\n    two_a_b = 2 * a * b\n    cos_rad = cos(rad)\n    return sqrt(a_squared + b_squared - two_a_b * cos_rad)\n", "model_name": "deepseek-v3"}
{"test_name": "lights_states", "response_0": "# Function to compute the total number of possible states for the lights\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    return 2 ** num\n", "response_1": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return 2 ** num\n", "model_name": "deepseek-v3"}
{"test_name": "degree_to_radian", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    # Define pi as a fixed-point number (scaled by 2^20)\n    pi = sfix(3.141592653589793 * (1 << 20))\n    \n    # Convert degree to radian using fixed-point arithmetic\n    radian = (d * pi) / (sfix(180 * (1 << 20)))\n    \n    return radian\n", "response_1": "def degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    pi = 3.14159265358979323846\n    return d * pi / 180\n", "model_name": "deepseek-v3"}
{"test_name": "Fah_to_Cel", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature using fixed-point arithmetic.\n    \"\"\"\n    # Assuming F is a fixed-point number\n    # Convert 1.8 to fixed-point representation (e.g., 1.8 * 2^16)\n    factor = sfix(1.8 * (1 << 16))\n    \n    # Perform the conversion using fixed-point arithmetic\n    result = (F - sfix(32 * (1 << 16))) / factor\n    \n    return result\n", "response_1": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - 32) / 1.8\n", "model_name": "deepseek-v3"}
{"test_name": "elliptic_area", "response_0": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    pi = 3.141592653589793\n    return pi * a * b\n", "response_1": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    # Define pi as a fixed-point constant\n    pi = sfix(3.14159265358979323846)\n    \n    # Calculate the area using fixed-point arithmetic\n    area = pi * a * b\n    \n    return area\n", "model_name": "deepseek-v3"}
{"test_name": "floor", "response_0": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Convert the floating-point number to an integer by truncating the decimal part\n    return z.reveal().to_int()\n", "response_1": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Convert the input to a fixed-point number (if not already)\n    z_fixed = sfix(z)\n    \n    # Truncate the fractional part to get the floor value\n    floor_value = z_fixed.floor()\n    \n    return floor_value\n", "model_name": "deepseek-v3"}
{"test_name": "log_and_cube", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    # Constants for log2 approximation\n    log2_e = sfix(1.4426950408889634)\n    \n    # Compute natural logarithm using the approximation ln(x) = log2(x) / log2(e)\n    ln_x = log2(x) / log2_e\n    \n    # Compute log2(x) = ln(x) * log2(e)\n    log2_x = ln_x * log2_e\n    \n    # Cube the result\n    result = log2_x * log2_x * log2_x\n    \n    return result\n\ndef log2(x):\n    \"\"\"\n    Approximate log2(x) using the Newton-Raphson method\n    \"\"\"\n    # Initial guess\n    y = sfix(0.0)\n    \n    # Number of iterations for convergence\n    iterations = 10\n    \n    for _ in range(iterations):\n        y = y + (x - exp2(y)) / (exp2(y) * ln2())\n    \n    return y\n\ndef exp2(y):\n    \"\"\"\n    Compute 2^y using the approximation exp2(y) = exp(y * ln(2))\n    \"\"\"\n    ln2 = sfix(0.6931471805599453)\n    return exp(y * ln2)\n\ndef ln2():\n    \"\"\"\n    Return the natural logarithm of 2\n    \"\"\"\n    return sfix(0.6931471805599453)\n", "response_1": "from math import log, pow\n\ndef log_and_cube(x):\n    \"\"\"\n    Take log (with base-2) to the input, then compute the cube of the outcome.\n    \"\"\"\n    # Compute the natural logarithm\n    ln_x = log(x)\n    \n    # Convert to base-2 logarithm using the change of base formula\n    log2_x = ln_x / log(2)\n    \n    # Compute the cube of the base-2 logarithm\n    result = pow(log2_x, 3)\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "floor_and_square", "response_0": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input.\n    Then return the square of the previous outcome.\n    \"\"\"\n    floored = z // 1  # Equivalent to math.floor(z) for integer division\n    return floored * floored  # Return the square of the floored value\n", "response_1": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input.\n    Then return the square of the previous outcome.\n    \"\"\"\n    # In MP-SPDZ, we can use integer division to simulate floor\n    floored_z = z // 1\n    # Return the square of the floored value\n    return floored_z * floored_z\n", "model_name": "deepseek-v3"}
{"test_name": "meters_to_feet", "response_0": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    conversion_factor = sfix(3.2808)\n    return m * conversion_factor\n", "response_1": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * 3.2808\n", "model_name": "deepseek-v3"}
{"test_name": "sphere_area", "response_0": "from Compiler import types\n\ndef sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    pi = types.sfix(3.14159265358979323846)\n    return types.sfix(4) * pi * r * r\n", "response_1": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    pi = 3.141592653589793\n    return 4 * pi * r * r\n", "model_name": "deepseek-v3"}
{"test_name": "coarse_abs", "response_0": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = x if x >= 0 else -x\n    return abs_x // 1\n", "response_1": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = x * (x >= 0) - x * (x < 0)\n    return abs_x // 1\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_chickens", "response_0": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem securely.\n    \"\"\"\n    # Calculate the number of chickens using the formula: heads - (legs - heads * 2) // 2\n    chickens = heads - (legs - heads * 2) // 2\n    return chickens\n", "response_1": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    # Calculate the number of chickens\n    chickens = heads - (legs - heads * 2) // 2\n    return chickens\n", "model_name": "deepseek-v3"}
{"test_name": "interest_calculator", "response_0": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get.\n    \"\"\"\n    # Calculate (1 + ratio) ^ months using a loop\n    result = 1 + ratio\n    for i in range(1, months):\n        result = result * (1 + ratio)\n    \n    # Calculate the final interest\n    interest = (result - 1) * capital\n    return interest\n", "response_1": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get. \n    \"\"\"\n    # Calculate (1 + ratio)^months\n    one_plus_ratio = 1 + ratio\n    result = 1\n    for _ in range(months):\n        result = result * one_plus_ratio\n    \n    # Calculate (result - 1) * capital\n    interest = (result - 1) * capital\n    return interest\n", "model_name": "deepseek-v3"}
{"test_name": "circle_area", "response_0": "def circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    # Approximate value of pi using fixed-point arithmetic\n    pi = 3.14159265358979323846 * 2**16  # Fixed-point representation of pi\n    \n    # Calculate r^2\n    r_squared = r * r\n    \n    # Calculate the area: pi * r^2\n    area = (pi * r_squared) // (2**16)  # Adjust for fixed-point arithmetic\n    \n    return area\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import sfloat\nfrom Compiler import mathlib\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = sfloat(mathlib.pi())\n    return pi * r * r\n", "model_name": "deepseek-v3"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    # Compute x^3\n    x_cubed = x ** 3\n    \n    # Compute the square root of x^3\n    sqrt_x_cubed = sqrt(x_cubed)\n    \n    return sqrt_x_cubed\n", "response_1": "from util import if_else\nfrom math import sqrt\n\ndef cube_and_square_root(x):\n    \"\"\"\n    Take cube to the input, then compute the square root of the outcome.\n    \"\"\"\n    x_cubed = x * x * x\n    result = sqrt(x_cubed)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x.floor()\n    diff = x - x_int\n    return x_int + (diff >= 0.5)\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    # Extract the integer part of x\n    x_int = x < 0 ? x - (x % 1) : x - (x % 1)\n    \n    # Calculate the fractional part\n    fractional = x - x_int\n    \n    # Determine whether to round up or down\n    return x_int + (fractional >= 0.5)\n", "model_name": "deepseek-v3"}
{"test_name": "cryptic_adjustment", "response_0": "def cryptic_adjustment(origin):\n    \"\"\"\n    The professor wants to adjust the pessimistic score of his students' mid-term exam.\n    The adjustment formula is 10 * sqrt(10 * sqrt(origin))\n    \"\"\"\n    # Compute the inner square root: sqrt(origin)\n    inner_sqrt = sqrt(origin)\n    \n    # Compute the product: 10 * sqrt(origin)\n    inner_product = 10 * inner_sqrt\n    \n    # Compute the outer square root: sqrt(10 * sqrt(origin))\n    outer_sqrt = sqrt(inner_product)\n    \n    # Compute the final result: 10 * sqrt(10 * sqrt(origin))\n    result = 10 * outer_sqrt\n    \n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor want to adjust the pessimistic score of his students mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    # Compute the inner square root: sqrt(origin)\n    inner_sqrt = sqrt(origin)\n    \n    # Compute the outer square root: sqrt(10 * inner_sqrt)\n    outer_sqrt = sqrt(10 * inner_sqrt)\n    \n    # Multiply by 10 to get the final result\n    result = 10 * outer_sqrt\n    \n    return result\n\ndef sqrt(x):\n    \"\"\"\n    A simple implementation of square root using fixed-point arithmetic.\n    This is a placeholder and should be replaced with a more accurate method if needed.\n    \"\"\"\n    return x ** 0.5\n", "model_name": "deepseek-v3"}
{"test_name": "specific_pow", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    # Convert x to a fixed-point number\n    x_fixed = sfix(x)\n    \n    # Compute x^2\n    x_squared = x_fixed * x_fixed\n    \n    # Compute sqrt(x) using the square root function\n    sqrt_x = x_fixed.sqrt()\n    \n    # Compute x^(2.5) = x^2 * sqrt(x)\n    result = x_squared * sqrt_x\n    \n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    # Convert x to a fixed-point number\n    x_fixed = sfix(x)\n    \n    # Compute x^2\n    x_squared = x_fixed * x_fixed\n    \n    # Compute sqrt(x) using the built-in sqrt function\n    x_sqrt = sfix.sqrt(x_fixed)\n    \n    # Compute x^2.5 = x^2 * sqrt(x)\n    result = x_squared * x_sqrt\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "soft_plus", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef soft_plus(x):\n    \"\"\"\n    Softplus function in MP-SPDZ\n    \"\"\"\n    e_x = sfix.exp(x)\n    one_plus_e_x = sfix(1) + e_x\n    result = sfix.log(one_plus_e_x)\n    return result\n", "response_1": "def soft_plus(x):\n    \"\"\"\n    Softplus function in MP-SPDZ\n    \"\"\"\n    e_x = exp(x)  # Compute e^x\n    one_plus_e_x = 1 + e_x  # Compute 1 + e^x\n    log_result = log(one_plus_e_x)  # Compute log(1 + e^x)\n    return log_result\n", "model_name": "deepseek-v3"}
{"test_name": "ball_volume", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    # Define pi as a fixed-point number (3.141592653589793)\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the volume using fixed-point arithmetic\n    volume = pi * r * r * r * sfix(4) / sfix(3)\n    \n    return volume\n", "response_1": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    # Approximate value of \u03c0\n    pi = sfix(3.14159265358979323846)\n    # Calculate the volume using the formula (4/3) * \u03c0 * r^3\n    volume = pi * r * r * r * sfix(4) / sfix(3)\n    return volume\n", "model_name": "deepseek-v3"}
{"test_name": "Heron", "response_0": "def Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    s = p * (p - a) * (p - b) * (p - c)\n    return s.sqrt()\n", "response_1": "def Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    # Calculate the semi-perimeter\n    p = (a + b + c) / 2\n\n    # Calculate the area using Heron's formula\n    area = p * (p - a) * (p - b) * (p - c)\n    area_sqrt = area.sqrt()\n\n    return area_sqrt\n", "model_name": "deepseek-v3"}
{"test_name": "next_perfect_square", "response_0": "def next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x.\n    The input x is guaranteed to be a positive integer.\n    \"\"\"\n    # Initialize the square root candidate\n    sqrt_candidate = 0\n    \n    # Find the integer part of the square root of x\n    while sqrt_candidate * sqrt_candidate <= x:\n        sqrt_candidate += 1\n    \n    # The next perfect square is (sqrt_candidate)^2\n    return sqrt_candidate * sqrt_candidate\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x.\n    The input x is guaranteed to be a positive integer.\n    \"\"\"\n    # Compute the square root of x\n    sqrt_x = x.sqrt()\n\n    # Floor the square root and add 1\n    next_int = sqrt_x.floor() + 1\n\n    # Square the result to get the next perfect square\n    next_square = next_int * next_int\n\n    return next_square\n", "model_name": "deepseek-v3"}
{"test_name": "pi_to_the_x", "response_0": "def pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    # Define the value of pi\n    pi = 3.14159265358979323846\n    \n    # Perform the exponentiation\n    result = pi ** x\n    \n    return result\n", "response_1": "def pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    # Define the value of pi\n    pi = 3.14159265358979323846\n    \n    # Initialize the result to 1\n    result = 1\n    \n    # Multiply result by pi 'x' times\n    for _ in range(x):\n        result = result * pi\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "spring_rocket", "response_0": "from util import math\nfrom util import types\n\ndef spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = 9.8\n    result = math.sqrt(2 * m * g * height / k)\n    return result\n", "response_1": "# Define the function in MP-SPDZ\ndef spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = sfix(9.8)  # Define g as a fixed-point number\n    height = sfix(height)  # Convert height to fixed-point\n    m = sfix(m)  # Convert mass to fixed-point\n    k = sfix(k)  # Convert stiffness coefficient to fixed-point\n    \n    # Calculate the result using fixed-point arithmetic\n    result = (2 * m * g * height / k).sqrt()\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "cone_volume", "response_0": "def cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    # Define pi as a constant\n    pi = 3.141592653589793\n    \n    # Compute the volume of the cone\n    volume = pi * r * r * h / 3\n    \n    return volume\n", "response_1": "def cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = 3.14159265358979323846  # Approximation of pi\n    return (pi * r * r * h) / 3\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "response_1": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "model_name": "deepseek-v3"}
