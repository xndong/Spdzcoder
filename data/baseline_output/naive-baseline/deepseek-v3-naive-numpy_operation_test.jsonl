{"test_name": "array_from_intrinsic_linspace", "response_0": "program linspace\n    # Define the constants\n    start = 0\n    end = 99\n    num = 10\n\n    # Calculate the step size\n    step = (end - start) / (num - 1)\n\n    # Initialize an array to store the linspace values\n    a = Array(num, sint)\n\n    # Fill the array with the linspace values\n    for i in range(num):\n        a[i] = start + i * step\n\n    # Output the array (optional)\n    for i in range(num):\n        print_ln(\"%s\", a[i].reveal())\nend\n", "response_1": "program linspace\n    # Define the start, end, and number of points\n    start = 0\n    end = 99\n    num = 10\n\n    # Calculate the step size\n    step = (end - start) / (num - 1)\n\n    # Initialize an array to store the result\n    a = Array(num, sint)\n\n    # Generate the linearly spaced values\n    for i in range(num):\n        a[i] = start + i * step\n\n    # Output the array (optional)\n    for i in range(num):\n        print_ln(\"%s\", a[i].reveal())\nend\n", "model_name": "deepseek-v3"}
{"test_name": "more_positive", "response_0": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    count = 0\n    for x in arr:\n        # Check if x is positive\n        is_positive = x > 0\n        # Increment count if x is positive\n        count += is_positive\n    # Return whether count is greater than half the length of the array\n    return count > len(arr) / 2\n", "response_1": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    # Initialize count of positive numbers\n    count = sfix(0)\n    \n    # Iterate over the array\n    for i in range(len(arr)):\n        # Check if the element is positive\n        if arr[i] > 0:\n            count += 1\n        else:\n            count += 0\n    \n    # Return whether the count of positive numbers is greater than 0\n    return count > 0\n", "model_name": "deepseek-v3"}
{"test_name": "select", "response_0": "from Compiler import types\n\ndef select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays based on the indicator array.\n    The array elements are float data (secret-shared fixed-point).\n    \"\"\"\n    # Ensure that ind, a, and b are arrays of the same length\n    assert len(ind) == len(a) == len(b), \"Arrays must be of the same length\"\n    \n    # Initialize the result array\n    result = types.Array(len(a), types.sfix)\n    \n    # Perform the selection\n    for i in range(len(ind)):\n        result[i] = ind[i].if_else(a[i], b[i])\n    \n    return result\n", "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays based on the indicator array.\n    The array elements are assumed to be secret-shared floats.\n    \"\"\"\n    # Initialize an empty array to store the result\n    result = Array(len(a), sfloat)\n\n    # Iterate over the elements and select based on the indicator\n    for i in range(len(a)):\n        result[i] = sfloat.if_else(ind[i], a[i], b[i])\n\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return sgf2n.max(y, 0)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return y * (y > 0)\n", "model_name": "deepseek-v3"}
{"test_name": "cost_matrix", "response_0": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    # Determine the shape of the matrix\n    rows = len(profit_matrix)\n    cols = len(profit_matrix[0]) if rows > 0 else 0\n\n    # Find the maximum value in the profit matrix\n    max_val = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if profit_matrix[i][j] > max_val:\n                max_val = profit_matrix[i][j]\n\n    # Create the offset matrix filled with the maximum value\n    offset_matrix = [[max_val for _ in range(cols)] for _ in range(rows)]\n\n    # Compute the cost matrix by subtracting the profit matrix from the offset matrix\n    cost_matrix = [[offset_matrix[i][j] - profit_matrix[i][j] for j in range(cols)] for i in range(rows)]\n\n    return cost_matrix\n", "response_1": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    # Determine the shape of the profit matrix\n    rows = len(profit_matrix)\n    cols = len(profit_matrix[0])\n\n    # Find the maximum value in the profit matrix\n    max_val = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            max_val = max(max_val, profit_matrix[i][j])\n\n    # Create the offset matrix filled with the maximum value\n    offset_matrix = [[max_val for _ in range(cols)] for _ in range(rows)]\n\n    # Compute the cost matrix\n    cost_matrix = [[offset_matrix[i][j] - profit_matrix[i][j] for j in range(cols)] for i in range(rows)]\n\n    return cost_matrix\n", "model_name": "deepseek-v3"}
{"test_name": "np_zeros", "response_0": "n = 10\na = Array(n, sint)\n\nfor i in range(n):\n    a[i] = sint(0)\n", "response_1": "n = 10\na = Array(n, sint)  # Create an array of size n with default values (0 for sint)\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler import types\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array in MP-SPDZ\n    array = ndarray[row_index]\n    return array\n", "response_1": "from Compiler.library import Matrix\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a Matrix and row_index is a secret integer\n    array = ndarray[row_index][:]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    return [sint(0) for _ in range(n)]\n", "response_1": "def zeros(n):\n    return Array(n, 0)\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_slicing_stride", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. \n    Collect all the even index elements from the first array and \n    collect all the odd index elements from the second array.\n    \"\"\"\n    # Determine the size of the resulting array\n    sizeA = len(ndarrayA) // 2\n    sizeB = len(ndarrayB) // 2\n    total_size = sizeA + sizeB\n    \n    # Create the resulting array\n    result = types.Array(total_size, types.sint)\n    \n    # Collect even index elements from ndarrayA\n    idx = 0\n    for i in range(len(ndarrayA)):\n        if_else(i % 2 == 0, lambda: result.assign(idx, ndarrayA[i]), lambda: None)\n        idx = idx + (i % 2 == 0)\n    \n    # Collect odd index elements from ndarrayB\n    for i in range(len(ndarrayB)):\n        if_else(i % 2 == 1, lambda: result.assign(idx, ndarrayB[i]), lambda: None)\n        idx = idx + (i % 2 == 1)\n    \n    return result\n", "response_1": "def array_concate(arrayA, arrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. \n    Collect all the even index elements from the first array and \n    collect all the odd index elements from the second array.\n    \"\"\"\n    # Initialize empty arrays to store the selected elements\n    viewA = []\n    viewB = []\n    \n    # Collect even index elements from arrayA\n    for i in range(len(arrayA)):\n        if i % 2 == 0:\n            viewA.append(arrayA[i])\n    \n    # Collect odd index elements from arrayB\n    for i in range(len(arrayB)):\n        if i % 2 == 1:\n            viewB.append(arrayB[i])\n    \n    # Concatenate the two arrays\n    result = viewA + viewB\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "QR_decomposition", "response_0": "from Compiler import types\nfrom Compiler.library import print_ln, for_range\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Perform QR decomposition on the input matrix using the Gram-Schmidt process.\n    Returns the Q matrix.\n    \"\"\"\n    n = len(mat)\n    Q = [[types.sfix(0) for _ in range(n)] for _ in range(n)]\n    R = [[types.sfix(0) for _ in range(n)] for _ in range(n)]\n\n    for j in range(n):\n        v = [mat[i][j] for i in range(n)]\n        for k in range(j):\n            R[k][j] = sum(Q[i][k] * mat[i][j] for i in range(n))\n            v = [v[i] - Q[i][k] * R[k][j] for i in range(n)]\n        R[j][j] = (sum(v[i] * v[i] for i in range(n))) ** 0.5\n        for i in range(n):\n            Q[i][j] = v[i] / R[j][j]\n\n    return Q\n\n# Example usage (not part of the code)\n# mat = [[types.sfix(1), types.sfix(2)], [types.sfix(3), types.sfix(4)]]\n# Q = QR_decomposition(mat)\n# print_ln(\"Q matrix: %s\", Q)\n", "response_1": "from util import Matrix, Array\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix using the Gram-Schmidt process.\n    \"\"\"\n    n, m = mat.sizes\n    Q = Matrix(n, m)\n    R = Matrix(m, m)\n    \n    for j in range(m):\n        v = mat.get_column(j)\n        for i in range(j):\n            R[i][j] = Q.get_column(i).dot(v)\n            v = v - Q.get_column(i) * R[i][j]\n        R[j][j] = v.norm()\n        Q.set_column(j, v / R[j][j])\n    \n    return Q\n", "model_name": "deepseek-v3"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of the nearest value in an array to the given value.\n    \"\"\"\n    min_diff = abs(array[0] - value)\n    min_index = 0\n    \n    for i in range(1, len(array)):\n        diff = abs(array[i] - value)\n        if diff < min_diff:\n            min_diff = diff\n            min_index = i\n    \n    return min_index\n", "response_1": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    # Compute the absolute difference between each element in the array and the value\n    differences = [abs(a - value) for a in array]\n    \n    # Find the minimum difference\n    min_diff = min(differences)\n    \n    # Find the index of the minimum difference\n    idx = differences.index(min_diff)\n    \n    return idx\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_simple_row", "response_0": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Get the number of rows and columns in the first array\n    rowsA = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    \n    # Get the number of rows in the second array\n    rowsB = len(ndarrayB)\n    \n    # Initialize the result array with the combined number of rows\n    result = Array(rowsA + rowsB, sfix)\n    \n    # Copy elements from the first array\n    for i in range(rowsA):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from the second array\n    for i in range(rowsB):\n        for j in range(colsA):\n            result[rowsA + i][j] = ndarrayB[i][j]\n    \n    return result\n", "response_1": "from Compiler import types\n\ndef array_simple_concate_rows(arrayA, arrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Get the number of rows and columns in arrayA\n    rowsA, colsA = arrayA.shape\n    # Get the number of rows and columns in arrayB\n    rowsB, colsB = arrayB.shape\n    \n    # Ensure that both arrays have the same number of columns\n    assert colsA == colsB, \"Arrays must have the same number of columns\"\n    \n    # Create a new array with the combined number of rows\n    result = types.Array(rowsA + rowsB, colsA, arrayA.value_type)\n    \n    # Copy elements from arrayA to the result\n    for i in range(rowsA):\n        for j in range(colsA):\n            result[i][j] = arrayA[i][j]\n    \n    # Copy elements from arrayB to the result\n    for i in range(rowsB):\n        for j in range(colsB):\n            result[rowsA + i][j] = arrayB[i][j]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    # Create a new array with the same size as the input array\n    array = Array(len(ndarray), ndarray[0].type)\n    \n    # Copy each element from the input array to the new array\n    for i in range(len(ndarray)):\n        array[i] = ndarray[i]\n    \n    return array\n", "response_1": "def array_copy(ndarray):\n    array = Array(len(ndarray), sint)\n    for i in range(len(ndarray)):\n        array[i] = ndarray[i]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "max_pooling", "response_0": "from util import if_else\nfrom Compiler.types import Array, sfix, sint\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    x: Array of shape (batch_size, height, width)\n    stride: Integer representing the stride\n    \"\"\"\n    batch_size, height, width = x.sizes\n    out_height = height // stride\n    out_width = width // stride\n    \n    # Initialize the output array\n    out = Array(batch_size, out_height, out_width, sfix)\n    \n    for b in range(batch_size):\n        for i in range(0, height, stride):\n            for j in range(0, width, stride):\n                # Extract the window\n                window = x[b][i:i+stride][j:j+stride]\n                # Compute the maximum value in the window\n                max_val = window[0][0]\n                for wi in range(stride):\n                    for wj in range(stride):\n                        max_val = if_else(window[wi][wj] > max_val, window[wi][wj], max_val)\n                # Store the maximum value in the output array\n                out[b][i // stride][j // stride] = max_val\n    \n    return out\n", "response_1": "from Compiler import types\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling in MP-SPDZ.\n    \"\"\"\n    # Determine the output shape\n    out_shape = [x.shape[0], x.shape[1] // stride, x.shape[2] // stride]\n    \n    # Initialize the output array\n    out = types.Array(out_shape, types.sint)\n    \n    # Iterate over the input array\n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                # Extract the current window\n                window = x[b, i:i+stride, j:j+stride]\n                \n                # Compute the maximum value in the window\n                max_val = types.sint(0)\n                for k in range(window.shape[0]):\n                    for l in range(window.shape[1]):\n                        max_val = max(max_val, window[k, l])\n                \n                # Store the maximum value in the output array\n                out[b, i // stride, j // stride] = max_val\n    \n    return out\n", "model_name": "deepseek-v3"}
{"test_name": "array_reshape", "response_0": "from Compiler.library import Array, sfix\n\n# Create a 1D array with values from 0 to 14\na_flat = Array(15, sfix)\nfor i in range(15):\n    a_flat[i] = sfix(i)\n\n# Reshape the 1D array into a 3x5 2D array\na = Array(3, lambda: Array(5, sfix))\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = a_flat[i * 5 + j]\n", "response_1": "a = [[0, 1, 2, 3, 4],\n     [5, 6, 7, 8, 9],\n     [10, 11, 12, 13, 14]]\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_simple_column", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Get the dimensions of the input arrays\n    rows_A, cols_A = ndarrayA.shape\n    rows_B, cols_B = ndarrayB.shape\n    \n    # Ensure both arrays have the same number of rows\n    assert rows_A == rows_B, \"Arrays must have the same number of rows to concatenate along axis 1\"\n    \n    # Create a new array to hold the concatenated result\n    result = types.Array(rows_A, cols_A + cols_B, types.sint)\n    \n    # Fill the result array with elements from ndarrayA and ndarrayB\n    for i in range(rows_A):\n        for j in range(cols_A):\n            result[i][j] = ndarrayA[i][j]\n        for j in range(cols_B):\n            result[i][cols_A + j] = ndarrayB[i][j]\n    \n    return result\n", "response_1": "from Compiler import types\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type Array or Matrix\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n    \n    # Create a new array to hold the concatenated result\n    result = types.Array(rows, types.Array(colsA + colsB, types.sint))\n    \n    for i in range(rows):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n        for j in range(colsB):\n            result[i][colsA + j] = ndarrayB[i][j]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "# MP-SPDZ program to index i-th column from 2-D arrays\nprogram.array_dimensional_indexing = \\\n    lambda ndarray, column_index: [row[column_index] for row in ndarray]\n", "response_1": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    array = []\n    for row in ndarray:\n        array.append(row[column_index])\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    # Assuming array is a list of lists (2D array)\n    n = len(array)\n    diag_elements = Array(n, sint)  # Create an array to store the diagonal elements\n\n    for i in range(n):\n        diag_elements[i] = array[i][i]  # Extract the diagonal element\n\n    return diag_elements\n", "response_1": "def diag(array):\n    # Assuming array is a 2D list of sfix values\n    n = len(array)\n    diagonal = Array(n, sfix)\n    \n    for i in range(n):\n        diagonal[i] = array[i][i]\n    \n    return diagonal\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_special", "response_0": "program array_special_concate\n\n# Function to concatenate even columns from arrayA and odd columns from arrayB\ndef array_special_concate(arrayA, arrayB):\n    # Get the number of rows and columns in the arrays\n    rows = len(arrayA)\n    colsA = len(arrayA[0])\n    colsB = len(arrayB[0])\n    \n    # Initialize the result array\n    result = Array(rows, colsA // 2 + colsB // 2)\n    \n    # Collect even columns from arrayA\n    for i in range(rows):\n        for j in range(0, colsA, 2):\n            result[i][j // 2] = arrayA[i][j]\n    \n    # Collect odd columns from arrayB\n    for i in range(rows):\n        for j in range(1, colsB, 2):\n            result[i][colsA // 2 + j // 2] = arrayB[i][j]\n    \n    return result\n\n# Example usage (not part of the MP-SPDZ code)\n# arrayA = [[1, 2, 3], [4, 5, 6]]\n# arrayB = [[7, 8, 9], [10, 11, 12]]\n# result = array_special_concate(arrayA, arrayB)\n", "response_1": "def array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    Collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Get the dimensions of the input arrays\n    rowsA = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    rowsB = len(ndarrayB)\n    colsB = len(ndarrayB[0])\n\n    # Initialize the result array\n    result = Array(rowsA, sfix)\n\n    # Collect even columns from ndarrayA\n    for i in range(rowsA):\n        for j in range(0, colsA, 2):\n            result[i].append(ndarrayA[i][j])\n\n    # Collect odd columns from ndarrayB\n    for i in range(rowsB):\n        for j in range(1, colsB, 2):\n            result[i].append(ndarrayB[i][j])\n\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_arange", "response_0": "# MP-SPDZ does not have a direct equivalent to numpy.arange, so we implement it manually\ndef arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-d array similar to numpy.arange in MP-SPDZ.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Calculate the number of elements in the array\n    num_elements = (stop - start) // step\n\n    # Initialize an empty array\n    array = []\n\n    # Fill the array with values from start to stop with the given step\n    current = start\n    for _ in range(num_elements):\n        array.append(current)\n        current += step\n\n    return array\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-dimensional array similar to numpy.arange\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Calculate the number of elements in the array\n    n_elements = (stop - start) // step\n\n    # Initialize an empty array\n    array = Array(n_elements, sint)\n\n    # Fill the array with values\n    for i in range(n_elements):\n        array[i] = start + i * step\n\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_eye_2", "response_0": "m = 3\nn = 5\na = Array(m, Array(n, sint))\n\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sint(1)\n        else:\n            a[i][j] = sint(0)\n", "response_1": "# Define the dimensions of the matrix\nm = 3\nn = 5\n\n# Initialize a 2D array with zeros\na = Array(m, Array(n, sint(0)))\n\n# Set the diagonal elements to 1\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sint(1)\n\n# The array 'a' now contains a diagonal matrix with ones on the diagonal\n", "model_name": "deepseek-v3"}
{"test_name": "third_smallest", "response_0": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Sort the array using a simple bubble sort algorithm\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    # Return the third element (index 2) from the sorted array\n    return arr[2]\n", "response_1": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Sort the array manually\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    # Return the third smallest element\n    return arr[2]\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from a 2-D array represented as a list of lists.\n    \"\"\"\n    # Assuming ndarray is a list of lists (2-D array)\n    array = ndarray[row_index]\n    return array\n", "response_1": "from util import if_else\nfrom Compiler.types import Matrix\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a Matrix and row_index is a secret integer\n    rows, cols = ndarray.sizes()\n    result = Array(cols, sfix)\n    \n    for i in range(cols):\n        result[i] = ndarray[row_index][i]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = Array(n, sint)\n\nfor i in range(n):\n    a[i] = sint(i)\n", "response_1": "n = 10\na = Array(n, sint)\n\nfor i in range(n):\n    a[i] = sint(i)\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assume ndarray is a list of lists (2-D array)\n    # row_index is the index of the row to retrieve\n    array = ndarray[row_index]\n    return array\n", "response_1": "from Compiler import types\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a list of lists (2-D array)\n    # and row_index is an integer index\n    array_row = ndarray[row_index]\n    return array_row\n", "model_name": "deepseek-v3"}
{"test_name": "array_from_python_structure", "response_0": "# Define the length of the array\nn = 5\n\n# Create an array with the specified length\na = Array(n, sfix)\n\n# Initialize the array with the values from the Python list\na[0] = sfix(0)\na[1] = sfix(10)\na[2] = sfix(20)\na[3] = sfix(30)\na[4] = sfix(40)\n", "response_1": "from Compiler import types\n\n# Define the length of the array\nlength = 5\n\n# Create an array with the specified length\na = types.Array(length, types.sint)\n\n# Initialize the array with the given values\na[0] = 0\na[1] = 10\na[2] = 20\na[3] = 30\na[4] = 40\n", "model_name": "deepseek-v3"}
{"test_name": "np_reshape", "response_0": "program array_reshape:\n\n# Define the input array and dimensions\narray = Array(10, sint)  # Assuming a 1D array of size 10\nm = 2  # Number of rows\nn = 5  # Number of columns\n\n# Reshape the array into a 2D matrix\nreshaped_array = Array(m, Array(n, sint))\n\nfor i in range(m):\n    for j in range(n):\n        reshaped_array[i][j] = array[i * n + j]\n\n# Output the reshaped array\nprint_ln('Reshaped array: %s', reshaped_array)\n", "response_1": "def array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape an array.\n    \"\"\"\n    reshaped_array = Array(m, n, sint)\n    for i in range(m):\n        for j in range(n):\n            idx = i * n + j\n            reshaped_array[i][j] = ndarray[idx]\n    return reshaped_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ones", "response_0": "n = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = sint(1)\n", "response_1": "n = 10\na = Array(n, sint)\n@for_range(n)\ndef _(i):\n    a[i] = sint(1)\n", "model_name": "deepseek-v3"}
{"test_name": "set_one_to_zero", "response_0": "from Compiler.types import Array, sint\n\ndef set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    for i in range(len(y)):\n        y[i] = y[i].if_else(0, y[i] == 1)\n    return y\n", "response_1": "", "model_name": "deepseek-v3"}
{"test_name": "np_eye", "response_0": "n = 10\na = Array(n, n)\n\n@for_range(n)\ndef _(i):\n    @for_range(n)\n    def _(j):\n        if i == j:\n            a[i][j] = 1\n        else:\n            a[i][j] = 0\n", "response_1": "n = 10\na = Array(n, Array(n, sint))\n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sint(1)\n        else:\n            a[i][j] = sint(0)\n", "model_name": "deepseek-v3"}
{"test_name": "np_diag", "response_0": "# Define the list of values\na_l = [sint(1), sint(3), sint(5), sint(2), sint(4), sint(6)]\n\n# Define the size of the matrix\nn = len(a_l)\n\n# Initialize the matrix with zeros\na = [[sint(0) for _ in range(n)] for _ in range(n)]\n\n# Fill the diagonal with the values from a_l\nfor i in range(n):\n    a[i][i] = a_l[i]\n", "response_1": "# Define the list a_l\na_l = Array(6, sint)\na_l[0] = sint(1)\na_l[1] = sint(3)\na_l[2] = sint(5)\na_l[3] = sint(2)\na_l[4] = sint(4)\na_l[5] = sint(6)\n\n# Initialize a 6x6 matrix with zeros\na = Array(6, 6, sint)\n\n# Set the diagonal elements of the matrix\nfor i in range(6):\n    a[i][i] = a_l[i]\n", "model_name": "deepseek-v3"}
{"test_name": "np_advanced_integer_indexing", "response_0": "def integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an array from an integer array in MP-SPDZ.\n    \"\"\"\n    ret_array = Array(len(indices), array.value_type)\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    return ret_array\n", "response_1": "def integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an array from an integer array in MP-SPDZ.\n    \"\"\"\n    # Assuming array is an Array and indices is a list of integers\n    ret_array = Array(len(indices), sfix)  # Create an array to store the result\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]  # Index the array using the indices\n    return ret_array\n", "model_name": "deepseek-v3"}
