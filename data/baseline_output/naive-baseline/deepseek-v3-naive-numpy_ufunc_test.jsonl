{"test_name": "cross_entropy_loss", "response_0": "# Define the cross_entropy function\ndef cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss.\n    \"\"\"\n    # Initialize the result to 0\n    result = sfix(0)\n    \n    # Iterate over each element in y\n    for i in range(len(y)):\n        # Compute log(y[i]) using a numerical approximation\n        log_y = log_approx(y[i])\n        \n        # Multiply y[i] by log(y[i])\n        term = y[i] * log_y\n        \n        # Accumulate the result\n        result = result - term\n    \n    return result\n\n# Define a numerical approximation for the logarithm function\ndef log_approx(x):\n    \"\"\"\n    Numerical approximation of the natural logarithm.\n    \"\"\"\n    # Use a Taylor series approximation or another method\n    # This is a placeholder and should be replaced with a proper implementation\n    return x - sfix(1)  # Simplified approximation for demonstration\n", "response_1": "def cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss.\n    \"\"\"\n    # Initialize the loss to 0\n    loss = sfix(0)\n    \n    # Iterate over each element in the input array\n    for i in range(len(y)):\n        # Compute the log of the current element\n        log_y = log(y[i])\n        \n        # Multiply the element by its log and accumulate the result\n        loss -= y[i] * log_y\n    \n    return loss\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_square_sqrt", "response_0": "def compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Calculate the mean of the array\n    mean = sum(array) / len(array)\n    \n    # Calculate the deviation from the mean\n    deviation = array - mean\n    \n    # Square the deviations\n    square = deviation * deviation\n    \n    # Calculate the mean of the squared deviations\n    square_mean = sum(square) / len(square)\n    \n    # Calculate the square root of the mean of squared deviations\n    rmsd = sqrt(square_mean)\n    \n    return rmsd\n", "response_1": "from Compiler import types\nfrom Compiler import util\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation in MP-SPDZ.\"\"\"\n    # Calculate the mean of the array\n    mean = types.sfix.sum(array) / len(array)\n    \n    # Calculate the deviation from the mean\n    deviation = array - mean\n    \n    # Square the deviations\n    square = deviation * deviation\n    \n    # Calculate the mean of the squared deviations\n    square_mean = types.sfix.sum(square) / len(square)\n    \n    # Calculate the square root of the mean of squared deviations\n    rmsd = types.sfix.sqrt(square_mean)\n    \n    return rmsd\n", "model_name": "deepseek-v3"}
{"test_name": "logsumexp", "response_0": "def logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp in MP-SPDZ\n    \"\"\"\n    # Find the maximum value in the log_probs array\n    _max = log_probs.max()\n    \n    # Subtract the maximum value from each element in log_probs\n    ds = log_probs - _max\n    \n    # Compute the sum of the exponentials of the differences\n    exp_sum = ds.exp().sum()\n    \n    # Return the logsumexp result\n    return _max + exp_sum.log()\n", "response_1": "from Compiler import types\nfrom Compiler import library\nfrom Compiler import instructions\n\ndef logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp in MP-SPDZ\n    \"\"\"\n    # Find the maximum value in log_probs\n    _max = types.sint.max(log_probs)\n    \n    # Subtract the maximum value from each element in log_probs\n    ds = log_probs - _max\n    \n    # Compute the exponential of each element in ds\n    exp_ds = types.sint.exp(ds)\n    \n    # Sum the exponentials\n    exp_sum = types.sint.sum(exp_ds)\n    \n    # Compute the natural logarithm of the sum\n    log_exp_sum = types.sint.log(exp_sum)\n    \n    # Return the result\n    return _max + log_exp_sum\n", "model_name": "deepseek-v3"}
{"test_name": "binary_cross_entropy_loss", "response_0": "def binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss securely.\n    \"\"\"\n    # Replace 0 and 1 in y_hat with 0.001 and 0.999 respectively to avoid log(0)\n    y_hat = y_hat * (1 - (y_hat == 0)) + 0.001 * (y_hat == 0)\n    y_hat = y_hat * (1 - (y_hat == 1)) + 0.999 * (y_hat == 1)\n\n    # Compute the binary cross-entropy loss\n    loss_part1 = y * log2(y_hat)\n    loss_part2 = (1 - y) * log2(1 - y_hat)\n    loss = -mean(loss_part1 + loss_part2)\n\n    return loss\n", "response_1": "def binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss in MP-SPDZ.\n    \"\"\"\n    # Replace 0 and 1 in y_hat with 0.001 and 0.999 respectively to avoid log(0)\n    y_hat = y_hat * (1 - (y_hat == 0)) + 0.001 * (y_hat == 0)\n    y_hat = y_hat * (1 - (y_hat == 1)) + 0.999 * (y_hat == 1)\n    \n    # Compute the logarithms using the MPC-compatible log2 function\n    log_y_hat = log2(y_hat)\n    log_1_minus_y_hat = log2(1 - y_hat)\n    \n    # Compute the binary cross-entropy loss\n    loss = -((y * log_y_hat) + ((1 - y) * log_1_minus_y_hat))\n    \n    # Return the mean of the loss\n    return mean(loss)\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_less_equal", "response_0": "from util import if_else\nfrom Compiler.types import sint\n\ndef compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is less than or equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of sint (secret-shared integers)\n    less_eq = []\n    for a, b in zip(arrayA, arrayB):\n        # If a <= b, return 1 (True), else 0 (False)\n        result = if_else(a <= b, sint(1), sint(0))\n        less_eq.append(result)\n    return less_eq\n", "response_1": "def compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is less than or equal to arrayB.\"\"\"\n    less_eq = [sint(0)] * len(arrayA)\n    for i in range(len(arrayA)):\n        less_eq[i] = arrayA[i] <= arrayB[i]\n    return less_eq\n", "model_name": "deepseek-v3"}
{"test_name": "RMS_prop_step", "response_0": "def RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step.\n    \"\"\"\n    alpha = sfix(0.5)\n    beta = sfix(1.0)\n    s = Array(len(grads), sfix)\n    \n    for i in range(len(grads)):\n        grad = grads[i]\n        layer = layers[i]\n        s[i] = beta * s[i] + (1 - beta) * grad * grad\n        grad = alpha * (grad / (s[i].sqrt()))\n        layers[i] = layer + grad\n    \n    return layers\n", "response_1": "from Compiler import types\n\ndef RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step in MP-SPDZ.\n    \"\"\"\n    alpha = types.sfix(0.5)\n    beta = types.sfix(1.0)\n    s = [types.sfix.zeros_like(grad) for grad in grads]\n    \n    for i, (grad, layer) in enumerate(zip(grads, layers)):\n        s[i] = beta * s[i] + (1 - beta) * grad * grad\n        grad = alpha * (grad / (s[i].sqrt()))\n        layer = layer + grad\n    \n    return layers\n", "model_name": "deepseek-v3"}
{"test_name": "entropy", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef entropy(y):\n    \"\"\"\n    Compute the entropy of the given array\n    \"\"\"\n    n = len(y)\n    unique_values = types.Array.create_from(y).unique()\n    sum_ = types.sfloat(0.0)\n    \n    for i in unique_values:\n        v = types.sfloat(0.0)\n        for j in range(n):\n            v += if_else(y[j] == i, types.sfloat(1.0), types.sfloat(0.0))\n        p = v / types.sfloat(n)\n        sum_ += -p * p.log2()\n    \n    return sum_\n", "response_1": "def entropy(y):\n    \"\"\"\n    Compute the entropy of the given array\n    \"\"\"\n    n = len(y)\n    sum_ = 0\n    unique_elements = []\n    \n    # Find unique elements in y\n    for i in y:\n        if i not in unique_elements:\n            unique_elements.append(i)\n    \n    for i in unique_elements:\n        count = 0\n        for j in y:\n            if j == i:\n                count += 1\n        prob = count / n\n        sum_ += -(prob * log2(prob))\n    \n    return sum_\n\ndef log2(x):\n    \"\"\"\n    Compute the base-2 logarithm of x\n    \"\"\"\n    return log(x) / log(2)\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_exp", "response_0": "def compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D array.\"\"\"\n    # Compute the exponential of each element in the array\n    exp = [sfix.exp(x) for x in array]\n    \n    # Compute the sum of the exponentials\n    summation = sfix(0)\n    for e in exp:\n        summation += e\n    \n    # Compute the softmax values\n    softmax = [e / summation for e in exp]\n    \n    return softmax\n", "response_1": "def compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D array of secret-shared values.\"\"\"\n    # Compute the exponent of each element in the array\n    exp_array = [exp(x) for x in array]\n    \n    # Compute the sum of the exponentiated values\n    summation = sum(exp_array)\n    \n    # Compute the softmax values by dividing each exponentiated value by the summation\n    softmax = [x / summation for x in exp_array]\n    \n    return softmax\n", "model_name": "deepseek-v3"}
{"test_name": "tanh", "response_0": "class Tanh:\n\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        # Using the approximation tanh(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\n        # For simplicity, we use a 3rd-order approximation\n        z_squared = z * z\n        z_cubed = z * z_squared\n        return z - z_cubed / 3\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        # The derivative of tanh(x) is 1 - tanh(x)^2\n        tanh_x = self.fn(x)\n        return 1 - tanh_x * tanh_x\n", "response_1": "class Tanh:\n\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        return sfix.tanh(z)\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        tanh_x = sfix.tanh(x)\n        return 1 - tanh_x * tanh_x\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_tan", "response_0": "# Define the tangent function using Taylor series approximation\ndef compute_tan(x):\n    # Taylor series approximation for tan(x) around 0\n    # tan(x) \u2248 x + (x^3)/3 + (2x^5)/15 + (17x^7)/315 + ...\n    x_sq = x * x\n    x_cu = x * x_sq\n    x_5 = x_cu * x_sq\n    x_7 = x_5 * x_sq\n    \n    tan_x = x + (x_cu / 3) + (2 * x_5 / 15) + (17 * x_7 / 315)\n    return tan_x\n\n# Example usage with an array (assuming the array is a list of sfix values)\ndef compute_tan_array(array):\n    tan_res = [compute_tan(x) for x in array]\n    return tan_res\n", "response_1": "# Define the function to compute the tangent of an array\ndef compute_tan(array):\n    \"\"\"This function calculates the trigonometric tangent, element-wise.\"\"\"\n    # Initialize an empty list to store the results\n    tan_res = []\n    \n    # Iterate over each element in the array\n    for x in array:\n        # Approximate tan(x) using the Taylor series (first 3 terms)\n        tan_x = x + (x ** 3) / 3 + (2 * x ** 5) / 15\n        # Append the result to the list\n        tan_res.append(tan_x)\n    \n    # Return the list of tangent values\n    return tan_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_greater", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef compute_greater(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e., whether arrayA is greater than arrayB.\n    Both arrayA and arrayB are assumed to be of the same length and of type Array or similar.\n    \"\"\"\n    # Ensure both arrays are of the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must be of the same length\"\n    \n    # Initialize an array to store the result\n    greater_res = types.Array(len(arrayA), types.sint)\n    \n    # Perform element-wise comparison\n    for i in range(len(arrayA)):\n        greater_res[i] = if_else(arrayA[i] > arrayB[i], 1, 0)\n    \n    return greater_res\n", "response_1": "def compute_greater(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than arrayB.\"\"\"\n    # Initialize an empty array to store the result\n    greater_res = Array(len(arrayA), sint)\n    \n    # Perform element-wise comparison\n    for i in range(len(arrayA)):\n        greater_res[i] = arrayA[i] > arrayB[i]\n    \n    return greater_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_maximum", "response_0": "def compute_maximum(arrayA, arrayB):\n    \"\"\"\n    Element-wise maximum of array elements.\n    :param arrayA: First array of secret-shared integers.\n    :param arrayB: Second array of secret-shared integers.\n    :return: Array of secret-shared integers representing the element-wise maximum.\n    \"\"\"\n    max_ones = Array(len(arrayA), sint)\n    for i in range(len(arrayA)):\n        max_ones[i] = sint.max(arrayA[i], arrayB[i])\n    return max_ones\n", "response_1": "def compute_maximum(arrayA, arrayB):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    # Initialize an empty list to store the maximum values\n    max_ones = []\n    \n    # Iterate over the elements of the arrays\n    for a, b in zip(arrayA, arrayB):\n        # Compute the maximum of the two elements\n        max_val = a.greater_than(b, a, b)\n        # Append the maximum value to the list\n        max_ones.append(max_val)\n    \n    return max_ones\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_log2", "response_0": "# MP-SPDZ code for computing base-2 logarithm\n\ndef compute_log2(x):\n    \"\"\"\n    Approximate the base-2 logarithm of x using a simple numerical method.\n    This is a basic implementation and may not be highly accurate.\n    \"\"\"\n    # Initialize the result\n    result = 0\n    # If x is less than 1, we handle it separately\n    if x < 1:\n        while x < 1:\n            x *= 2\n            result -= 1\n    # If x is greater than or equal to 1, we handle it normally\n    while x >= 2:\n        x /= 2\n        result += 1\n    return result\n\ndef compute_log2_array(array):\n    \"\"\"\n    Compute the base-2 logarithm for each element in the array.\n    \"\"\"\n    log2_array = [compute_log2(x) for x in array]\n    return log2_array\n", "response_1": "from Compiler import floatingpoint\n\ndef compute_log2(array):\n    \"\"\"This function calculates the base-2 logarithm of each element in the input array.\"\"\"\n    ln_array = [floatingpoint.ln(x) for x in array]\n    ln_2 = floatingpoint.ln(2)\n    log2_array = [x / ln_2 for x in ln_array]\n    return log2_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_absolute", "response_0": "from Compiler import types\n\ndef obtain_absolute(array):\n    \"\"\"This function computes the absolute values in an array of secret-shared values.\"\"\"\n    # MP-SPDZ does not have a direct absolute function, so we implement it manually\n    # For each element in the array, compute the absolute value\n    absolute_array = types.Array(len(array), types.sint)\n    for i in range(len(array)):\n        # The absolute value of x is max(x, -x)\n        absolute_array[i] = types.sint.max(array[i], -array[i])\n    return absolute_array\n", "response_1": "from Compiler.types import sfix, Array\nfrom Compiler.library import print_ln\n\ndef obtain_absolute(array):\n    \"\"\"This function computes the absolute values in an MP-SPDZ array.\"\"\"\n    abs_array = Array(len(array), sfix)\n    for i in range(len(array)):\n        abs_array[i] = array[i].if_else(array[i], -array[i], array[i] < 0)\n    return abs_array\n\n# Example usage (not to be included in the final code)\n# array = Array(3, sfix)\n# array[0] = sfix(-1.5)\n# array[1] = sfix(2.3)\n# array[2] = sfix(-0.7)\n# abs_array = obtain_absolute(array)\n# print_ln(\"Absolute values: %s\", abs_array.reveal())\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arctan", "response_0": "from Compiler import types\n\ndef compute_arctan(array):\n    \"\"\"This function approximates the arctangent element-wise using a polynomial approximation.\"\"\"\n    # Polynomial coefficients for arctan approximation (e.g., using a Taylor series)\n    # This is a simple example and may not be accurate for all inputs\n    coeffs = [1, -1/3, 1/5, -1/7, 1/9]\n    \n    arctan_res = types.Array(len(array), types.sfix)\n    for i in range(len(array)):\n        x = array[i]\n        result = types.sfix(0)\n        x_pow = x\n        for coeff in coeffs:\n            result += coeff * x_pow\n            x_pow *= x * x\n        arctan_res[i] = result\n    \n    return arctan_res\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_arctan(array):\n    \"\"\"This function calculates the trigonometric inverse tangent, element-wise.\"\"\"\n    arctan_res = Array(len(array), sfix)\n    @for_range(len(array))\n    def _(i):\n        x = array[i]\n        # Taylor series approximation for arctan(x) around 0\n        # arctan(x) \u2248 x - x^3/3 + x^5/5 - x^7/7 + ...\n        arctan_res[i] = x - x**3 / 3 + x**5 / 5 - x**7 / 7\n    return arctan_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_log", "response_0": "from util import *\nfrom math import *\n\ndef compute_log(array):\n    \"\"\"This function calculates the natural logarithm for all elements in the input array.\"\"\"\n    # Initialize an array to store the log values\n    nlog = Array(len(array), sfix)\n    \n    # Compute the natural logarithm for each element in the array\n    for i in range(len(array)):\n        nlog[i] = log(array[i])\n    \n    return nlog\n", "response_1": "# Assuming the input array is a list of secret shared values\ndef compute_log(array):\n    \"\"\"This function calculates the natural logarithm for all p in the input array.\"\"\"\n    # Initialize an empty list to store the results\n    nlog = []\n    \n    # Iterate over each element in the array\n    for p in array:\n        # Approximate the natural logarithm using a Taylor series or other method\n        # This is a placeholder and should be replaced with an actual implementation\n        log_p = 0  # Placeholder for log(p)\n        \n        # Append the result to the list\n        nlog.append(log_p)\n    \n    return nlog\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_not_equal", "response_0": "from Compiler.types import Array, sbit\n\ndef compute_not_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e., whether arrayA is not equal to arrayB.\n    Both arrayA and arrayB are assumed to be of the same length and contain secret-shared values.\n    \"\"\"\n    # Assuming arrayA and arrayB are of type Array with elements of type sbit or sint\n    neq = Array(len(arrayA), sbit)\n    for i in range(len(arrayA)):\n        neq[i] = arrayA[i] != arrayB[i]\n    return neq\n", "response_1": "from Compiler import types\n\ndef compute_not_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e., whether arrayA is not equal to arrayB.\n    Both arrayA and arrayB are assumed to be arrays of secret-shared values.\n    \"\"\"\n    # Ensure both arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must have the same length\"\n    \n    # Initialize an array to store the results\n    neq = types.Array(len(arrayA), types.sint)\n    \n    # Perform element-wise comparison\n    for i in range(len(arrayA)):\n        neq[i] = arrayA[i] != arrayB[i]\n    \n    return neq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_equal", "response_0": "def compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is equal to arrayB.\"\"\"\n    # Initialize an empty list to store the results\n    eq = []\n    \n    # Iterate over the elements of the arrays\n    for i in range(len(arrayA)):\n        # Compare the elements and store the result\n        eq.append(arrayA[i] == arrayB[i])\n    \n    return eq\n", "response_1": "from util import if_else\nfrom Compiler.types import Array, sint\n\ndef compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are of the same length and type (e.g., Array of sint)\n    eq = Array(len(arrayA), sint)\n    for i in range(len(arrayA)):\n        eq[i] = if_else(arrayA[i] == arrayB[i], sint(1), sint(0))\n    return eq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_true_divide", "response_0": "from Compiler.library import Array, sfix\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"True divide between two MP-SPDZ arrays.\"\"\"\n    # Ensure both arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must have the same length\"\n    \n    # Initialize the result array\n    result = Array(len(arrayA), sfix)\n    \n    # Perform element-wise division\n    for i in range(len(arrayA)):\n        result[i] = arrayA[i] / arrayB[i]\n    \n    return result\n", "response_1": "from Compiler import types\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"\n    True divide between two 1-dimensional arrays in MP-SPDZ.\n    \"\"\"\n    # Assuming arrayA and arrayB are of the same length and are of type Array\n    result = types.Array(len(arrayA), types.sfix)\n    \n    for i in range(len(arrayA)):\n        result[i] = arrayA[i] / arrayB[i]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_greater_equal", "response_0": "from util import if_else\nfrom Compiler.library import for_range\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e., whether arrayA is greater than or equal to arrayB.\n    Both arrayA and arrayB are assumed to be lists of secret-shared integers.\n    The function returns a list of secret-shared bits where 1 indicates that the corresponding element in arrayA is greater than or equal to the corresponding element in arrayB.\n    \"\"\"\n    n = len(arrayA)\n    greater_eq = [None] * n\n\n    @for_range(n)\n    def _(i):\n        # Compare element-wise and store the result as a secret-shared bit\n        greater_eq[i] = arrayA[i] >= arrayB[i]\n\n    return greater_eq\n", "response_1": "from Compiler.library import for_range\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than or equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of secret-shared integers\n    greater_eq = [None] * len(arrayA)\n    \n    @for_range(len(arrayA))\n    def _(i):\n        greater_eq[i] = arrayA[i] >= arrayB[i]\n    \n    return greater_eq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_negative", "response_0": "from Compiler import types\n\ndef negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    # Assuming arrayA is a sfix or sint array\n    array = -arrayA\n    return array\n", "response_1": "def negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    # Create a new array to store the result\n    result = Array(len(arrayA), sint)\n    \n    # Iterate over the array and compute the negative of each element\n    for i in range(len(arrayA)):\n        result[i] = -arrayA[i]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_power", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    # Assuming arrayA and arrayB are lists of secret integers\n    result = types.Array(len(arrayA), types.sint)\n    \n    for i in range(len(arrayA)):\n        x = arrayA[i]\n        y = arrayB[i]\n        # Initialize the result to 1\n        res = types.sint(1)\n        # Compute x^y by multiplying x by itself y times\n        for _ in range(y.reveal()):\n            res = res * x\n        result[i] = res\n    \n    return result\n", "response_1": "def power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    result = Array(len(arrayA), sint)\n    for i in range(len(arrayA)):\n        result[i] = arrayA[i] ** arrayB[i]\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_exp2", "response_0": "from Compiler.library import *\n\ndef compute_exp2(array):\n    \"\"\"This function calculates 2**p for all p in the input array.\"\"\"\n    exp = Array(len(array), sint)\n    @for_range(len(array))\n    def _(i):\n        result = sint(1)\n        @for_range(array[i])\n        def _(j):\n            result = result * sint(2)\n        exp[i] = result\n    return exp\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef compute_exp2(array):\n    \"\"\"This function calculates 2**p for all p in the input array.\"\"\"\n    # Initialize an array to store the results\n    exp = types.Array(len(array), types.sint)\n    \n    # Iterate over the input array and compute 2**p for each element\n    for i in range(len(array)):\n        p = array[i]\n        result = types.sint(1)\n        for _ in range(p):\n            result = result * 2\n        exp[i] = result\n    \n    return exp\n", "model_name": "deepseek-v3"}
{"test_name": "cross_entropy_loss_class", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import print_ln, for_range\n\nclass CrossEntropy:\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss securely.\n        \"\"\"\n        # Compute the element-wise product of y and log2(y_pred)\n        log_y_pred = y_pred.log2()\n        y_log_y_pred = y * log_y_pred\n        \n        # Sum the elements and negate the result\n        cross_entropy = -y_log_y_pred.sum()\n        \n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross-entropy loss securely.\n        \"\"\"\n        n = len(y)\n        \n        # Compute the difference between y_pred and y\n        grad = y_pred - y\n        \n        # Normalize the gradient by the number of elements\n        grad = grad / n\n        \n        return grad\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\nclass CrossEntropy:\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss.\n        \"\"\"\n        # Convert y and y_pred to sfix if they are not already\n        y = sfix(y)\n        y_pred = sfix(y_pred)\n        \n        # Compute the element-wise product and log2\n        log_pred = y_pred.log2()\n        product = y * log_pred\n        \n        # Sum the elements and negate the result\n        cross_entropy = -product.sum()\n        \n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross entropy loss.\n        \"\"\"\n        # Convert y and y_pred to sfix if they are not already\n        y = sfix(y)\n        y_pred = sfix(y_pred)\n        \n        # Compute the gradient\n        grad = y_pred - y\n        \n        # Normalize by the number of elements\n        n = len(y)\n        grad = grad / sfix(n)\n        \n        return grad\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arccos", "response_0": "def approximate_arccos(x):\n    \"\"\"Approximate the arccos function using a polynomial or lookup table.\"\"\"\n    # Placeholder for the actual approximation logic\n    # This could be a polynomial approximation or a lookup table\n    return x * x  # Replace with actual approximation\n\ndef compute_arccos(array):\n    \"\"\"Calculate the trigonometric inverse cosine element-wise on a list of secret-shared values.\"\"\"\n    arccos_res = [approximate_arccos(x) for x in array]\n    return arccos_res\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_arccos(array):\n    \"\"\"This function calculates trigonometric inverse cosine, element-wise.\"\"\"\n    arccos_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        arccos_res[i] = arccos(array[i])\n    return arccos_res\n\ndef arccos(x):\n    \"\"\"Approximate arccos using a polynomial or lookup table.\"\"\"\n    # This is a placeholder for the actual implementation.\n    # You can use a polynomial approximation or a precomputed lookup table.\n    # For example, a simple linear approximation (not accurate):\n    return sfix(1.5708) - x  # pi/2 - x, which is a rough approximation of arccos(x)\n", "model_name": "deepseek-v3"}
{"test_name": "r2_score", "response_0": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score using secure multi-party computation.\n    \"\"\"\n    # Compute the mean of y_test\n    mean_y_test = sfix.sum(y_test) / len(y_test)\n    \n    # Compute the total sum of squares\n    total_sum_squares = sfix.sum((y_test - mean_y_test) ** 2)\n    \n    # Compute the residual sum of squares\n    residual_sum_squares = sfix.sum((y_test - y_hat) ** 2)\n    \n    # Compute and return the r2 score\n    return 1 - residual_sum_squares / total_sum_squares\n", "response_1": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score.\n    \"\"\"\n    # Compute the mean of y_test\n    mean_y_test = sum(y_test) / len(y_test)\n    \n    # Compute the total sum of squares\n    total_sum_squares = sum((y_test - mean_y_test) ** 2)\n    \n    # Compute the residual sum of squares\n    residual_sum_squares = sum((y_test - y_hat) ** 2)\n    \n    # Compute the r2 score\n    r2 = 1 - residual_sum_squares / total_sum_squares\n    \n    return r2\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arcsin", "response_0": "from Compiler import types\n\ndef compute_arcsin(array):\n    \"\"\"This function calculates the trigonometric inverse sine, element-wise.\"\"\"\n    # Define the coefficients for the polynomial approximation of arcsin\n    # This is a simple approximation and may not be highly accurate\n    coeffs = [0.0, 1.0, 0.0, 0.1667, 0.0, 0.075, 0.0, 0.0446]\n\n    # Initialize the result array\n    arcsin_res = types.Array(len(array), types.sfix)\n\n    for i in range(len(array)):\n        x = array[i]\n        # Ensure x is within the valid range for arcsin (-1 <= x <= 1)\n        x = x.max(-1.0).min(1.0)\n        \n        # Compute the polynomial approximation of arcsin(x)\n        result = coeffs[0]\n        x_pow = x\n        for j in range(1, len(coeffs)):\n            result += coeffs[j] * x_pow\n            x_pow *= x\n\n        arcsin_res[i] = result\n\n    return arcsin_res\n", "response_1": "# Function to compute arcsin using Taylor series approximation\ndef arcsin(x):\n    # Taylor series approximation for arcsin(x)\n    result = x\n    term = x\n    x_squared = x * x\n    n = 1\n    while True:\n        term = term * x_squared * (2 * n - 1) / (2 * n)\n        new_result = result + term / (2 * n + 1)\n        if new_result == result:\n            break\n        result = new_result\n        n = n + 1\n    return result\n\n# Function to compute arcsin element-wise on an array\ndef compute_arcsin(array):\n    \"\"\"This function calculates trigonometric inverse sine, element-wise.\"\"\"\n    arcsin_res = [arcsin(x) for x in array]\n    return arcsin_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_true_divide2", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"true divide between two lists of secret-shared values.\"\"\"\n    res = Array(len(arrayA), sfloat)\n    @for_range(len(arrayA))\n    def _(i):\n        res[i] = arrayA[i] / arrayB[i]\n    return res\n", "response_1": "def true_divide(arrayA, arrayB):\n    \"\"\"true divide between two MP-SPDZ arrays.\"\"\"\n    # Assuming arrayA and arrayB are of the same length\n    res = Array(len(arrayA), sfix)  # Create an array to store the result\n    for i in range(len(arrayA)):\n        res[i] = arrayA[i] / arrayB[i]  # Perform element-wise division\n    return res\n", "model_name": "deepseek-v3"}
{"test_name": "square_error_loss", "response_0": "def square_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    diff = y_pred - y\n    squared_diff = diff * diff\n    sum_squared_diff = sum(squared_diff)\n    return 0.5 * sum_squared_diff\n", "response_1": "def squre_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    diff = y_pred - y\n    squared_diff = diff * diff\n    sum_squared_diff = sum(squared_diff)\n    return 0.5 * sum_squared_diff\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_less", "response_0": "def compute_less(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is less than arrayB.\"\"\"\n    less_res = []\n    for a, b in zip(arrayA, arrayB):\n        less_res.append(a < b)\n    return less_res\n", "response_1": "def compute_less(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is less than arrayB.\"\"\"\n    # Initialize an empty list to store the result\n    less_res = []\n    \n    # Iterate over the elements of the arrays\n    for a, b in zip(arrayA, arrayB):\n        # Perform the comparison using MPC operations\n        less_res.append(a < b)\n    \n    return less_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_cos", "response_0": "from fixedpoint import *\nfrom library import *\n\ndef taylor_cos(x, terms=5):\n    \"\"\"Approximate cosine using Taylor series expansion.\"\"\"\n    result = sfix(1.0)\n    x_sq = x * x\n    sign = sfix(-1.0)\n    factorial = sfix(1.0)\n    for i in range(1, terms + 1):\n        factorial *= sfix(2 * i) * sfix(2 * i - 1)\n        term = sign * (x_sq ** i) / factorial\n        result += term\n        sign *= sfix(-1.0)\n    return result\n\ndef compute_cosine(array):\n    \"\"\"Calculate trigonometric cosine, element-wise.\"\"\"\n    cos_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        cos_res[i] = taylor_cos(array[i])\n    return cos_res\n\n# Example usage (commented out):\n# array = Array(3, sfix)\n# array[0] = sfix(0.0)\n# array[1] = sfix(1.0)\n# array[2] = sfix(3.14159)\n# result = compute_cosine(array)\n# print_ln(\"Cosine result: %s\", result.reveal())\n", "response_1": "# Define the Taylor series approximation for cosine\ndef taylor_cosine(x, terms=10):\n    \"\"\"Approximate cosine using Taylor series expansion.\"\"\"\n    result = 0\n    for n in range(terms):\n        term = (x ** (2 * n)) / factorial(2 * n)\n        if n % 2 == 0:\n            result += term\n        else:\n            result -= term\n    return result\n\n# Compute cosine element-wise for an array\ndef compute_cosine(array):\n    \"\"\"Calculate trigonometric cosine, element-wise.\"\"\"\n    cos_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        cos_res[i] = taylor_cosine(array[i])\n    return cos_res\n\n# Helper function to compute factorial\ndef factorial(n):\n    \"\"\"Compute the factorial of n.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_sin", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_sine(array):\n    \"\"\"This function calculates trigonometric sine, element-wise, using a Taylor series approximation.\"\"\"\n    def taylor_sine(x):\n        # Taylor series approximation for sine: sin(x) \u2248 x - x^3/3! + x^5/5! - x^7/7! + ...\n        x_sq = x * x\n        term = x\n        result = term\n        for i in range(1, 4):  # Adjust the number of terms for better precision\n            term = -term * x_sq / ((2 * i) * (2 * i + 1))\n            result += term\n        return result\n\n    sin_res = Array(len(array), sfloat)\n    for i in range(len(array)):\n        sin_res[i] = taylor_sine(array[i])\n    return sin_res\n", "response_1": "from Compiler import types\nfrom Compiler import library\n\ndef compute_sine(array):\n    \"\"\"This function calculates the trigonometric sine, element-wise.\"\"\"\n    # Taylor series approximation for sine function: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...\n    sin_res = types.Array(len(array), types.sfloat)\n    for i in range(len(array)):\n        x = array[i]\n        sin_x = x - (x ** 3) / 6 + (x ** 5) / 120 - (x ** 7) / 5040\n        sin_res[i] = sin_x\n    return sin_res\n", "model_name": "deepseek-v3"}
{"test_name": "update_weights", "response_0": "def update_weights(m, A, X, Y):\n    \"\"\"\n    Update the weights and return the difference.\n    \"\"\"\n    # Compute the difference A - Y\n    diff = A - Y\n    \n    # Compute the dot product of X and the difference\n    dot_product = X * diff\n    \n    # Scale the result by 1/m\n    dw = (1 / m) * dot_product\n    \n    return dw\n", "response_1": "def update_weights(m, A, X, Y):\n    \"\"\"\n    Update the weights and return the difference.\n    m: sfix or sfloat (scalar)\n    A: sfix or sfloat matrix (m x n)\n    X: sfix or sfloat matrix (m x n)\n    Y: sfix or sfloat matrix (m x n)\n    \"\"\"\n    # Compute A - Y\n    diff = A - Y\n    \n    # Compute the dot product X * (A - Y)\n    # Assuming X is a matrix and diff is a matrix\n    # We need to compute the dot product manually\n    # For simplicity, let's assume X is a vector and diff is a vector\n    # For matrix multiplication, you would need nested loops\n    dot_product = sfix(0)\n    for i in range(len(X)):\n        dot_product += X[i] * diff[i]\n    \n    # Compute dw = (1/m) * dot_product\n    dw = (1 / m) * dot_product\n    \n    return dw\n", "model_name": "deepseek-v3"}
{"test_name": "toy_layer", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef sigmoid(x):\n    # Approximate sigmoid using a piecewise linear function\n    return if_else(x > 5, 1, if_else(x < -5, 0, 0.5 + x * 0.1))\n\ndef toy_layer(input_data, weights, biases):\n    # Layer 1\n    layer1_input = input_data @ weights[0] + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    \n    # Layer 2\n    layer2_input = layer1_output @ weights[1] + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    \n    return layer2_output\n", "response_1": "from util import sint, cint, Matrix\n\ndef sigmoid(x):\n    return 1 / (1 + exp(-x))\n\ndef toy_layer(input_data, weights, biases):\n    # Assuming input_data, weights, and biases are matrices or vectors\n    layer1_input = input_data.dot(weights[0]) + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    layer2_input = layer1_output.dot(weights[1]) + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    return layer2_output\n", "model_name": "deepseek-v3"}
