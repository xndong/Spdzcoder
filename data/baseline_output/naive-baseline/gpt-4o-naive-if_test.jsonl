{"test_name": "sin_or_cos", "response_0": "# Import necessary modules for secure computation\nfrom Compiler.types import sfix\nfrom math import sin, cos\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Use secure comparison to check if x is nonnegative\n    is_nonnegative = x >= 0\n\n    # Calculate sin(x) and cos(x) securely\n    sin_x = sin(x)\n    cos_x = cos(x)\n\n    # Return sin(x) if nonnegative, otherwise return cos(x)\n    return is_nonnegative.if_else(sin_x, cos_x)\n\n# Example usage\nx = sfix.get_input_from(0)  # Securely input x\nresult = sin_or_cos(x)\nprint_ln(\"Result: %s\", result.reveal())  # Securely reveal the result\n", "response_1": "# Import necessary libraries for MP-SPDZ\nfrom Compiler import types, instructions\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Convert x to a secure fixed-point number\n    x = sfix(x)\n\n    # Perform the check if x is nonnegative\n    is_nonnegative = x >= 0\n\n    # Calculate sin(x) and cos(x)\n    sin_x = x.sin()\n    cos_x = x.cos()\n\n    # Use if_then_else to securely select between sin(x) and cos(x)\n    result = if_then_else(is_nonnegative, sin_x, cos_x)\n\n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "negative_relu", "response_0": "// Define a function for Negative ReLU\nvoid negative_relu(sfix input, sfix &output) {\n    // Compute the result of Negative ReLU\n    output = input < 0 ? input : 0;\n}\n\n// Main program\nint main() {\n    // Declare input and output variables\n    sfix input;\n    sfix output;\n\n    // Read input (in practice, this would be securely shared input)\n    input.input();\n\n    // Call the Negative ReLU function\n    negative_relu(input, output);\n\n    // Output the result\n    output.output();\n    \n    return 0;\n}\n", "response_1": "# Import the necessary MP-SPDZ library\nfrom Compiler.types import sint\n\ndef negative_relu(input: sint) -> sint:\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    zero = sint(0)\n    return input.if_else(input < zero, zero)\n", "model_name": "azure-gpt4o"}
{"test_name": "is_close", "response_0": "# Secure function to check if two secure integers are close (within 1)\ndef is_close(a, b):\n    # Compute the difference\n    diff = a - b\n    \n    # Calculate the absolute value of the difference\n    abs_diff = (diff >= 0).if_else(diff, -diff)\n    \n    # Check if the absolute difference is less than or equal to 1\n    return abs_diff <= 1\n\n# Example usage with secure types\na = sint(0)  # Initialize a secure integer\nb = sint(0)  # Initialize another secure integer\n\nresult = is_close(a, b)\n", "response_1": "# Import MP-SPDZ necessary library\nfrom Compiler.types import sint\n\ndef is_close(a: sint, b: sint) -> sint:\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    # Compute the absolute difference\n    diff = abs(a - b)\n    \n    # Check if the difference is less than or equal to 1\n    result = diff.less_equal(1)\n    \n    return result\n\n# Example usage would be handled outside this function in an MP-SPDZ script\n", "model_name": "azure-gpt4o"}
{"test_name": "hardswish", "response_0": "# Import necessary MP-SPDZ libraries\nfrom Compiler.types import sfix\n\ndef hardswish(x):\n    \"\"\"\n    Hardswish function in MP-SPDZ.\n    \"\"\"\n    # Define the boundaries\n    neg_three = sfix(-3)\n    pos_three = sfix(3)\n    zero = sfix(0)\n    six = sfix(6)\n\n    # Perform the conditional operations\n    result = sfix.if_else(x < neg_three, zero,\n                          sfix.if_else(x > pos_three, x,\n                                       x * (x + pos_three) / six))\n\n    return result\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function for MP-SPDZ.\n    \"\"\"\n    zero = sfix(0)\n    three = sfix(3)\n    six = sfix(6)\n\n    # Conditions\n    cond1 = x < -three\n    cond2 = x > three\n\n    # Calculate based on conditions\n    result = sfix.if_else(cond1, zero, sfix.if_else(cond2, x, x * (x + three) / six))\n\n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "clip_at_6", "response_0": "// Assuming x is an sfix (secret fixed-point number)\nsfix clip_at_6(sfix x) {\n    sfix six = 6;\n    sfix neg_six = -6;\n    \n    // Check if x > 6\n    sfix greater_than_six = x > six;\n    // Result if x > 6\n    sfix result_if_greater = greater_than_six * six + (1 - greater_than_six) * x;\n    \n    // Check if x < -6\n    sfix less_than_neg_six = x < neg_six;\n    // Final result considering both conditions\n    sfix final_result = less_than_neg_six * neg_six + (1 - less_than_neg_six) * result_if_greater;\n    \n    return final_result;\n}\n", "response_1": "# Define the function to clip the value to the range [-6, 6]\ndef clip_at_6(x):\n    # Check if x is greater than 6\n    x = x.if_else(6, x > 6)\n    # Check if x is less than -6\n    x = x.if_else(-6, x < -6)\n    return x\n\n# Note: This assumes `x` is of type `sint`. Adjust the type if needed.\n", "model_name": "azure-gpt4o"}
{"test_name": "piecewise_function", "response_0": "# Import the MP-SPDZ library for secure computation\nfrom Compiler.types import sint\n\ndef piecewise_function(x: sint) -> sint:\n    \"\"\"\n    A piecewise function implemented for secure computation using MP-SPDZ.\n    \"\"\"\n    # Initialize ret as a secure integer\n    ret = sint(0)\n\n    # Determine if x is greater than 1\n    x_gt_1 = x.greater_than(1)\n    # Determine if x is less than -1\n    x_lt_neg1 = x.less_than(-1)\n    # Determine if x is greater than 0\n    x_gt_0 = x.greater_than(0)\n    # Determine if x is less than 0\n    x_lt_0 = x.less_than(0)\n\n    # Compute the piecewise result using secure multiplexer\n    ret = x_gt_1 * x + (1 - x_gt_1) * ret\n    ret = x_lt_neg1 * x + (1 - x_lt_neg1) * ret\n    ret = x_gt_0 * (1 - x_gt_1) + (1 - x_gt_0) * ret\n    ret = x_lt_0 * (-1) * (1 - x_lt_neg1) + (1 - x_lt_0) * ret\n\n    return ret\n", "response_1": "def piecewise_function(x):\n    # Initialize the result as a secret integer\n    ret = sint(0)\n    \n    # Check conditions and assign values securely\n    ret = s_if(x > 1, x, ret)\n    ret = s_if(x < -1, x, ret)\n    ret = s_if((x > 0) * (x <= 1), sint(1), ret)\n    ret = s_if((x < 0) * (x >= -1), sint(-1), ret)\n    \n    return ret\n", "model_name": "azure-gpt4o"}
{"test_name": "middle", "response_0": "# Define the function to find the middle value among three secret integers\ndef middle(a, b, c):\n    # If a >= b, swap a and b\n    cond1 = a.greater_equal(b)\n    temp = a\n    a = cond1.if_else(b, a)\n    b = cond1.if_else(temp, b)\n\n    # If b >= c, swap b and c\n    cond2 = b.greater_equal(c)\n    temp = b\n    b = cond2.if_else(c, b)\n    c = cond2.if_else(temp, c)\n\n    # If a >= b, swap a and b again\n    cond3 = a.greater_equal(b)\n    temp = a\n    a = cond3.if_else(b, a)\n    b = cond3.if_else(temp, b)\n\n    # Return the middle value\n    return b\n\n# Example usage\na = sint.get_input_from(0)  # Assume party 0 inputs a\nb = sint.get_input_from(1)  # Assume party 1 inputs b\nc = sint.get_input_from(2)  # Assume party 2 inputs c\n\nmiddle_value = middle(a, b, c)\nmiddle_value.reveal().print_to(0)  # Print the result to party 0\n", "response_1": "from Compiler.types import sint\n\ndef middle(a: sint, b: sint, c: sint) -> sint:\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # First comparison and swap\n    temp = a\n    a = a.less_than(b) * a + (1 - a.less_than(b)) * b\n    b = a.less_than(b) * b + (1 - a.less_than(b)) * temp\n\n    # Second comparison and swap\n    temp = b\n    b = b.less_than(c) * b + (1 - b.less_than(c)) * c\n    c = b.less_than(c) * c + (1 - b.less_than(c)) * temp\n\n    # Third comparison and swap\n    temp = a\n    a = a.less_than(b) * a + (1 - a.less_than(b)) * b\n    b = a.less_than(b) * b + (1 - a.less_than(b)) * temp\n\n    return b\n", "model_name": "azure-gpt4o"}
{"test_name": "indicated_sin_or_cos", "response_0": "# Secure computation for sine or cosine based on an indicator.\n# x is a secret-shared fixed-point number (sfix).\n# ind is a secret-shared integer (sint) acting as a boolean indicator (0 or 1).\n\ndef indicated_sin_or_cos(x, ind):\n    from Compiler.library import if_else, sfix\n    import math\n\n    # Compute sine and cosine using approximations or available MP-SPDZ functions\n    sin_x = x.sin()\n    cos_x = x.cos()\n\n    # Use secure if-else operation to choose based on the indicator\n    result = if_else(ind, sin_x, cos_x)\n\n    return result\n\n# Example usage:\n# x = sfix(1.0)  # Example input value\n# ind = sint(1)  # Example indicator (1 for sine, 0 for cosine)\n# result = indicated_sin_or_cos(x, ind)\n", "response_1": "# Import the MP-SPDZ library for secure computations\nfrom Compiler.library import *\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input,\n    otherwise return the cosine value of the input.\n    \"\"\"\n    # Initialize the secure float variables\n    x = sfix(x)\n    ind = sbit(ind)  # Use sbit for the indicator as it is a boolean\n\n    # Compute sine and cosine values securely\n    sine_value = sin(x)\n    cosine_value = cos(x)\n\n    # Return the sine value if ind is True, otherwise return the cosine value\n    return ind.if_else(sine_value, cosine_value)\n\n# Example usage (note: in actual MP-SPDZ, the inputs should come from secure inputs)\n# x_input = sfix.get_input_from(0)  # get input from party 0\n# ind_input = sbit.get_input_from(0)  # get input from party 0\n# result = indicated_sin_or_cos(x_input, ind_input)\n# print_ln(\"Result: %s\", result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    # Subtract 2 from the input\n    result = x - 2\n    \n    # Check if the result is non-negative\n    is_non_negative = result >= 0\n    \n    # Use a conditional select based on the non-negativity check\n    final_result = is_non_negative.if_else(result, x)\n    \n    return final_result\n", "response_1": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    y = x - 2\n    condition = y.gteq(0)  # This checks if y >= 0\n    return condition.if_else(y, x)  # If condition is true, return y, else return x\n", "model_name": "azure-gpt4o"}
{"test_name": "relu6", "response_0": "# Import the necessary library for secure computation\nfrom Compiler.types import sint\n\ndef relu6(x):\n    \"\"\"\n    ReLU6 function using MP-SPDZ.\n    \"\"\"\n    zero = sint(0)  # Secure representation of 0\n    six = sint(6)   # Secure representation of 6\n\n    # Compute conditional results securely\n    is_negative = x < zero\n    is_greater_than_six = x > six\n\n    # Securely choose the result based on conditions\n    result = x * (1 - is_negative) * (1 - is_greater_than_six) + zero * is_negative + six * is_greater_than_six\n\n    return result\n", "response_1": "# Define the relu6 function in MP-SPDZ\ndef relu6(x):\n    # Ensure the input is a secure integer\n    x = sfix(x)\n\n    # Compute conditions as secure comparisons\n    is_negative = x.less_than(0)\n    is_greater_than_6 = x.greater_than(6)\n\n    # Handle each case using secure multiplexer\n    result = sfix.if_else(is_negative, sfix(0), sfix.if_else(is_greater_than_6, sfix(6), x))\n\n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "exp_slide", "response_0": "# Define the function in MP-SPDZ\ndef exp_slide(x):\n    # Convert input to secure fixed-point number\n    x = sfix(x)\n    \n    # Compute e^x for non-negative x\n    exp_x = sfix.exp(x)\n    \n    # Compute x + 1\n    x_plus_1 = x + 1\n    \n    # Use secure comparison to choose the result based on the condition\n    result = x.if_else(exp_x, x_plus_1)\n    \n    return result\n\n# Example usage\nx = sfix.get_input_from(0)  # Get input from party 0\noutput = exp_slide(x)\noutput.reveal_to(0)  # Reveal output to party 0\n", "response_1": "# Define a function to calculate the exponential slide\ndef exp_slide(x):\n    # Check if x is nonnegative\n    x_is_nonnegative = x >= 0\n    # Calculate e^x using sint exponential function if x is nonnegative\n    exp_x = x.exp()\n    # Calculate x+1 for the case where x is negative\n    x_plus_1 = x + 1\n    # Use the if_else function to choose between exp_x and x_plus_1\n    result = x_is_nonnegative.if_else(exp_x, x_plus_1)\n    return result\n\n# Main program\n# Assuming x is a secret integer input\nx = sint.get_input_from(0)  # Get input from party 0\noutput = exp_slide(x)\noutput.reveal().print_ln(\"Result: %s\")\n", "model_name": "azure-gpt4o"}
{"test_name": "pass_or_not", "response_0": "from Compiler.library import *\n\ndef pass_or_not(score):\n    # Convert the input score to a secret integer\n    score = sint.get_input_from(score)\n    \n    # Create a secret boolean for checking if the score is greater than or equal to 60\n    passed = score.greater_equal(60)\n    \n    # Use conditional assignment to set score to 59 if not passed\n    adjusted_score = passed.if_else(score, 59)\n    \n    # Output the score and pass status\n    adjusted_score_output = adjusted_score.reveal()\n    passed_output = passed.reveal()\n    \n    adjusted_score_output.print_ln(\"Adjusted Score: %s\")\n    passed_output.print_ln(\"Passed: %s\")\n\n# Example usage\npass_or_not(Secret(70))\n", "response_1": "# Import necessary modules from MP-SPDZ\nfrom Compiler.types import sint, sbool\n\ndef pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Convert input score to secure integer type\n    score = sint(score)\n\n    # Check if score is greater than or equal to 60\n    passed_flag = score.greater_equal(60)\n\n    # Use conditional selection based on the passed_flag\n    actual_score = passed_flag.if_else(score, 59)\n\n    # Determine if passed based on the score\n    passed = passed_flag.if_else(True, False)\n\n    return actual_score, passed\n", "model_name": "azure-gpt4o"}
{"test_name": "how_many_roots", "response_0": "# Import necessary library for secure integer operations\nfrom Compiler.library import *\n\n# Define the main function\ndef main():\n    # Declare input variables as secure integers\n    a = sint.get_input_from(0)  # Let's assume input from party 0\n    b = sint.get_input_from(0)\n    c = sint.get_input_from(0)\n\n    # Initialize the discriminant\n    discriminant = b * b - 4 * a * c\n\n    # Check if a is zero\n    is_a_zero = a.is_zero()\n    \n    # Check if b is zero\n    is_b_zero = b.is_zero()\n\n    # Determine the number of roots based on the conditions\n    num_roots = (1 - is_a_zero) * (discriminant > 0) * 2 + \\\n                (1 - is_a_zero) * (discriminant == 0) * 1 + \\\n                is_a_zero * (1 - is_b_zero)\n\n    # Output the number of roots\n    num_roots.output()\n\n", "response_1": "# This code assumes that a, b, and c are already defined as sfix or sfloat\n# Secure types should be used to represent private inputs in MP-SPDZ\n\ndef how_many_roots(a, b, c):\n    # Initialize constants\n    zero = 0\n    one = 1\n    two = 2\n    four = 4\n\n    # Use secure comparison to check if a is zero\n    a_is_zero = (a == zero)\n    b_is_zero = (b == zero)\n\n    # Initialize number of roots\n    num_roots = 0\n\n    # If a == 0\n    if a_is_zero:\n        # If b == 0\n        if b_is_zero:\n            num_roots = zero  # 0 roots\n        else:\n            num_roots = one   # 1 root (linear equation)\n    else:\n        # Calculate the discriminant b^2 - 4ac\n        discriminant = b * b - four * a * c\n\n        # Check discriminant conditions\n        discrim_positive = (discriminant > zero)\n        discrim_zero = (discriminant == zero)\n\n        if discrim_positive:\n            num_roots = two  # 2 roots\n        elif discrim_zero:\n            num_roots = one  # 1 root\n        else:\n            num_roots = zero # 0 roots\n\n    return num_roots\n\n# Usage of secure types and secure if-else structures is crucial in MP-SPDZ for privacy\n", "model_name": "azure-gpt4o"}
{"test_name": "elu", "response_0": "# Import necessary library for secure fixed-point arithmetic\nfrom Compiler.library import *\n\ndef elu(x):\n    \"\"\"\n    ELU function using secure computation\n    \"\"\"\n    # Ensure x is a secure fixed-point type\n    x = sfix(x)\n    \n    # Compute e^x - 1 securely\n    exp_x = sfix.exp(x)\n    exp_x_minus_1 = exp_x - 1\n    \n    # Use a secure conditional to check if x > 0\n    is_positive = x > 0\n    \n    # Return x if x > 0, otherwise return exp_x_minus_1\n    return is_positive * x + (1 - is_positive) * exp_x_minus_1\n", "response_1": "# Import necessary modules for MP-SPDZ\nfrom Compiler.library import *\n\ndef elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    # Ensure that x is treated as a secret fixed-point value\n    x = sfix(x)\n\n    # Compute ELU using conditional selection\n    # sfix.if_else(condition, true_value, false_value) is used for conditional selection\n\n    e = sfix(math.e)  # Constant for Euler's number\n    elu_result = x.if_else(x > 0, x, e**x - 1)\n    \n    return elu_result\n", "model_name": "azure-gpt4o"}
{"test_name": "relu", "response_0": "def relu(x):\n    # ReLU function for secret-shared values\n    return x * (x > 0)\n", "response_1": "# Import the secure types\nfrom Compiler.types import sint\n\ndef relu(x):\n    \"\"\"\n    Secure ReLU function using MP-SPDZ\n    \"\"\"\n    # Ensure x is a secret integer type\n    assert isinstance(x, sint), \"Input must be of type sint\"\n    \n    # ReLU operation: max(x, 0)\n    return x * (x > 0)\n", "model_name": "azure-gpt4o"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha in MP-SPDZ.\n    \"\"\"\n    # Assuming x and alpha are secret-shared fixed-point numbers (sfix)\n    zero = sfix(0)\n    # Determine the condition for x > 0\n    condition = x > zero\n    # Use conditional selection to choose between x and x * alpha\n    return condition.if_else(x, x * alpha)\n", "response_1": "def leaky_relu(x, alpha):\n    \"\"\"\n    Leaky ReLU function with a leaking factor alpha using MP-SPDZ.\n    \"\"\"\n    # x and alpha are secret-shared fixed-point numbers\n    return x.if_else(x > 0, x, x * alpha)\n", "model_name": "azure-gpt4o"}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    # Compare a and b, result is a secure integer (0 or 1)\n    is_a_greater = a >= b\n\n    # Use conditional selection to return the maximum value\n    return is_a_greater * a + (1 - is_a_greater) * b\n", "response_1": "# Define the function to calculate the maximum of two secret-shared integers\ndef max(a, b):\n    \"\"\"\n    Return the maximum value of the two secret-shared inputs.\n    \"\"\"\n    return a * (a >= b) + b * (b > a)\n\n# Example usage with secret-shared integers\n# a = sint.get_input_from(0)\n# b = sint.get_input_from(0)\n# result = max(a, b)\n# print_ln(\"Maximum value is: %s\", result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "bowl_shape", "response_0": "", "response_1": "# Import the necessary library for conditional operations\nfrom Compiler.library import if_else\n\ndef bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function in MP-SPDZ:\n    if x > 1, return x - 1;\n    if x < -1, return -x - 1;\n    else, return 0.\n    \"\"\"\n\n    # Represent the constants as secret shared fixed-point numbers\n    one = sfix(1)\n    minus_one = sfix(-1)\n    zero = sfix(0)\n\n    # Compute the conditions\n    cond1 = x > one\n    cond2 = x < minus_one\n\n    # Calculate the results for each branch\n    result1 = x - one\n    result2 = -x - one\n\n    # Use if_else for secure conditional selection\n    # If cond1 is true, select result1, otherwise go to the next condition\n    intermediate_result = if_else(cond1, result1, zero)\n    # If cond2 is true, select result2, otherwise return zero\n    final_result = if_else(cond2, result2, intermediate_result)\n\n    return final_result\n", "model_name": "azure-gpt4o"}
{"test_name": "rounded_kinetic_energy", "response_0": "# Import the necessary MP-SPDZ library\nfrom Compiler.types import sfix\n\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    # Convert inputs to secure fixed point numbers\n    m = sfix(m)\n    v = sfix(v)\n    \n    # Calculate kinetic energy\n    k = m * v * v / 2\n    \n    # Extract the integer part of the kinetic energy\n    k_int = k.floor()\n    \n    # Calculate the fractional part\n    frac_part = k - k_int\n    \n    # Compare fractional part with 0.5 and round accordingly\n    rounded_k = k_int.if_else(frac_part < 0.5, k_int, k_int + 1)\n    \n    return rounded_k\n\n", "response_1": "# Import necessary MP-SPDZ types\nfrom Compiler.types import sfix\n\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    Parameters m and v are secure fixed-point numbers.\n    \"\"\"\n    # Ensure m and v are of type sfix, the secure fixed-point data type\n    m = sfix(m)\n    v = sfix(v)\n    \n    # Compute kinetic energy: k = m * v^2 / 2\n    k = m * v * v / 2\n    \n    # Convert secure fixed-point to secure integer\n    k_int = k.round_to_int()\n    \n    # Determine if we should round up\n    # k - k_int is equivalent to finding the fractional part\n    fractional_part = k - sfix(k_int)\n    \n    # Compare fractional part with 0.5 and adjust k_int accordingly\n    # This involves secure comparison and conditional addition\n    rounded_k_int = k_int + (fractional_part >= 0.5)\n    \n    return rounded_k_int\n", "model_name": "azure-gpt4o"}
{"test_name": "danger_test", "response_0": "def danger_test():\n    # Secure input for origin and damage\n    origin = sfix.get_input_from(0)\n    damage = sfix.get_input_from(1)\n    \n    # Compute the health left after damage\n    health_left = origin - damage\n    \n    # Determine if the situation is dangerous\n    danger = health_left <= sfix(10)\n    \n    # Output the result\n    print_ln(\"Is the situation dangerous? %s\", danger.reveal())\n\n# Call the function\ndanger_test()\n", "response_1": "# Import necessary modules for secure computation\nfrom Compiler import types, instructions\n\n# Function to determine if the situation is dangerous\ndef danger_test(origin, damage):\n    # Define secure integer inputs\n    origin = sint.get_input_from(0)\n    damage = sint.get_input_from(1)\n    \n    # Compute remaining health\n    remaining_health = origin - damage\n    \n    # Check if the remaining health is less than or equal to 10\n    dangerous = remaining_health.less_than_equal(10)\n    \n    # Return whether the situation is dangerous\n    return dangerous\n\n# Call the function\nresult = danger_test(sint(), sint())\n# Output the result\nprint_ln(\"Is the situation dangerous? %s\", result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    # Assuming x and y are sfix and ind is sbool\n    return sif(ind, x + y, x * y)\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    # Securely computes x + y if ind is true, otherwise x * y.\n    sum_result = x + y\n    product_result = x * y\n    # Use if_then_else to choose between sum_result and product_result based on ind\n    result = if_then_else(ind, sum_result, product_result)\n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "median", "response_0": "# Import necessary libraries or define your secure types\nfrom Compiler.types import sint, sfix, Array\n\ndef median(arr):\n    # Check if the array is empty by securely computing its length\n    length = len(arr)\n    if length == 0:\n        raise ValueError(\"The length of the array is 0!\")\n\n    # Sort the array securely\n    # Implement a simple sorting algorithm like Bubble Sort for secure arrays\n    for i in range(length):\n        for j in range(length - i - 1):\n            a = arr[j]\n            b = arr[j + 1]\n            # Secure comparison and swapping\n            c = a < b\n            arr[j] = c.if_else(a, b)\n            arr[j + 1] = c.if_else(b, a)\n\n    # Compute the median\n    ret = sint(0)\n    if length % 2 == 1:\n        # Odd length, return the middle element\n        ret = arr[length // 2]\n    else:\n        # Even length, return the average of the two middle elements\n        mid1 = arr[length // 2]\n        mid2 = arr[length // 2 - 1]\n        ret = (mid1 + mid2) / 2\n\n    return ret\n", "response_1": "# Import necessary libraries\nfrom Compiler.library import *\n\ndef median(arr):\n    \"\"\"\n    Return the median of the array.\n    Check first whether the array is empty\n    \"\"\"\n    # Get the length of the array (public)\n    n = len(arr)\n\n    # Check if the array is empty\n    if n == 0:\n        raise ValueError(\"The length of the array is 0!\")\n\n    # Sort the array (securely)\n    sorted_arr = sfix.Array(n)\n    arr.copyto(sorted_arr)\n    sorted_arr.sort()\n\n    # Determine if the number of elements is odd or even\n    is_odd = n % 2\n\n    # Compute median\n    median_value = sfix()\n    if is_odd:\n        # If odd, return the middle element\n        median_value = sorted_arr[n // 2]\n    else:\n        # If even, return the average of the two middle elements\n        mid1 = sorted_arr[n // 2]\n        mid2 = sorted_arr[n // 2 - 1]\n        median_value = (mid1 + mid2) / 2\n\n    return median_value\n\n# Example usage (commented out, since MP-SPDZ does not support direct execution)\n# secret_input = sfix.Array(n)\n# median_value = median(secret_input)\n# print_float(median_value.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "add_upto_10", "response_0": "# Define a function in MP-SPDZ\ndef add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    # Compute the sum of a and b\n    sum_ab = a + b\n    \n    # Create a sint for the value 10\n    ten = sint(10)\n    \n    # Determine if the sum is greater than 10\n    # This will be a sint result, 1 if true, 0 if false\n    condition = sum_ab > ten\n    \n    # Use the condition to select between sum_ab and 10\n    result = condition.if_else(ten, sum_ab)\n    \n    return result\n\n# Example usage with secret shared integers\na = sint.get_input_from(0)  # Assume input from party 0\nb = sint.get_input_from(1)  # Assume input from party 1\n\nresult = add_upto_10(a, b)\n\n# Output the result\nprint_ln(\"Result: %s\", result.reveal())\n", "response_1": "# Define the function to add two secret integers and clip the result to 10\ndef add_upto_10(a, b):\n    # Perform the addition\n    sum = a + b\n    \n    # Check if the sum exceeds 10\n    # Use a comparison to create a boolean mask\n    exceeds_10 = sum > 10\n    \n    # Clip the sum to 10 if it exceeds 10\n    # Use conditional assignment\n    result = exceeds_10.if_else(10, sum)\n    \n    # Return the clipped result\n    return result\n\n\n# Example usage\n# Note: Inputs should be defined as secure types, e.g., s_int for secret integers\na = s_int.get_input_from(0)  # Assuming input from party 0\nb = s_int.get_input_from(1)  # Assuming input from party 1\n\n# Call the function\nresult = add_upto_10(a, b)\n\n# Output the result\nresult.print_reg()\n", "model_name": "azure-gpt4o"}
{"test_name": "taxi_fare", "response_0": "# Import the MP-SPDZ library for fixed-point arithmetic\nfrom Compiler import types\n\ndef taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers.\n    \"\"\"\n    # Convert input to fixed-point type\n    m = types.sfix(m)\n\n    # Base fare for the first 5 miles\n    base_fare = types.sfix(5)\n    # Fare for miles between 5 and 10\n    additional_fare_1 = types.sfix(1.2)\n    # Fare for miles above 10\n    additional_fare_2 = types.sfix(1.5)\n\n    # Compute fare based on distance\n    fare_5_or_less = base_fare\n    fare_5_to_10 = base_fare + additional_fare_1 * (m - 5)\n    fare_above_10 = types.sfix(11) + additional_fare_2 * (m - 10)\n\n    # Use conditional selection to compute the correct fare\n    fare = types.sfix.if_else(m <= 5, fare_5_or_less, types.sfix.if_else(m <= 10, fare_5_to_10, fare_above_10))\n\n    return fare\n\n# Example usage: secret input for miles\nm = types.sfix.get_input_from(0)  # Assume input party is 0\nfare = taxi_fare(m)\ntypes.sfix.output(fare, 0)  # Output the result to party 0\n", "response_1": "# Import necessary secure types\nfrom Compiler import types\n\n# Define the taxi fare function using secure fixed-point arithmetic\ndef taxi_fare(m):\n    # Define the base fare as a secure fixed-point number\n    base_fare = types.sfix(5)\n    \n    # Compute the additional fare for miles > 5 and <= 10\n    additional_fare_5_10 = types.sfix(1.2) * types.sfix(m - 5)\n    \n    # Compute the additional fare for miles > 10\n    additional_fare_10_plus = types.sfix(1.5) * types.sfix(m - 10)\n    \n    # Conditionally compute the total fare based on the miles\n    # Use secure comparisons and selections\n    fare = types.sfix.if_else(m <= 5, base_fare,\n              types.sfix.if_else(m <= 10, base_fare + additional_fare_5_10,\n              base_fare + types.sfix(6) + additional_fare_10_plus))\n    \n    return fare\n\n# Example of setting up an input value and calling the function\nm = types.sfix.get_input_from(0)  # Assume input is taken from party 0\nfare = taxi_fare(m)\n\n# Output the computed fare\nfare.output()\n", "model_name": "azure-gpt4o"}
{"test_name": "round", "response_0": "# MP-SPDZ code to round a secure fixed-point number to the nearest integer\n\n# Import the necessary library for secure fixed-point arithmetic\nfrom Compiler import types\n\n# Function to round a secret fixed-point number\ndef round_secure(x):\n    # Get the integer part\n    x_int = types.sfix.floor(x)\n    \n    # Calculate the difference\n    diff = x - x_int\n    \n    # Compare the difference to 0.5\n    # If diff < 0.5, return x_int, otherwise return x_int + 1\n    rounded_result = x_int + (diff >= 0.5)\n    \n    return rounded_result\n", "response_1": "# Import necessary library for secure computation\nfrom Compiler.library import *\n\ndef round(x):\n    \"\"\"\n    Securely round x to the nearest integer.\n    \"\"\"\n    # Floor operation using truncation\n    x_int = trunc(x, 0, x.size)\n\n    # Compute the difference\n    diff = x - x_int\n\n    # Compare the difference to 0.5\n    is_less_than_half = diff < 0.5\n\n    # Conditionally add 1 based on the comparison\n    result = x_int + (1 - is_less_than_half)\n\n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "gpa_calculator", "response_0": "# Import the necessary MP-SPDZ library for fixed-point numbers\nfrom Compiler import types\n\ndef gpa_calculator(score):\n    # Define the score as a fixed-point number\n    score = types.sfix(score)\n    \n    # Initialize the GPA as a fixed-point number\n    gpa = types.sfix(0)\n    \n    # Perform comparisons and assignments securely\n    gpa = types.if_else(score >= 90, types.sfix(4.0), gpa)\n    gpa = types.if_else((score >= 85) & (score < 90), types.sfix(3.6), gpa)\n    gpa = types.if_else((score >= 80) & (score < 85), types.sfix(3.3), gpa)\n    gpa = types.if_else((score >= 75) & (score < 80), types.sfix(3.0), gpa)\n    gpa = types.if_else((score >= 70) & (score < 75), types.sfix(2.6), gpa)\n    gpa = types.if_else(score < 70, types.sfix(2.3), gpa)\n    \n    return gpa\n", "response_1": "", "model_name": "azure-gpt4o"}
{"test_name": "sign", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_then_else\n\ndef sign(x: sint) -> sint:\n    # Check if x is zero\n    is_zero = x.is_zero()\n    # Determine if x is positive\n    is_positive = x > 0\n    # Compute the sign using if_then_else to keep conditions private\n    return if_then_else(is_zero, sint(0), if_then_else(is_positive, sint(1), sint(-1)))\n", "response_1": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    # Check if x is greater than zero\n    is_positive = x > 0\n    \n    # Check if x is less than zero\n    is_negative = x < 0\n    \n    # If x > 0, return 1\n    # If x < 0, return -1\n    # If x == 0, return 0\n    return is_positive - is_negative\n\n# Assume x is a secure integer type, e.g., sint\nx = sint.get_input_from(0)  # Example of input from party 0\nresult = sign(x)\nprint_ln(\"The sign of x is: %s\", result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "sum_or_difference", "response_0": "# Import necessary modules for MP-SPDZ\nfrom Compiler.types import sint\n\ndef sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input,\n    return their sum, otherwise return their difference.\n    \"\"\"\n    # Step 1: Compute the sum and difference\n    sum_result = a + b\n    diff_result = a - b\n    \n    # Step 2: Determine if a <= b\n    condition = a.less_equal(b)\n    \n    # Step 3: Use if_else to select sum or difference based on the condition\n    result = condition.if_else(sum_result, diff_result)\n    \n    return result\n", "response_1": "from Compiler.library import if_else\n\ndef sum_or_difference(a, b):\n    # Compute the condition a <= b\n    condition = a.less_equal(b)\n    # Use if_else to choose between sum and difference\n    result = if_else(condition, a + b, a - b)\n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using secure computation.\n    \"\"\"\n    # Securely compute the flip result\n    # If control_bit is 1, flip the flip_bit, else do nothing\n    return control_bit * (1 - flip_bit) + (1 - control_bit) * flip_bit\n\n# Example of using the CNOT function with secret shared bits\n# control_bit = sbitint.get_input_from(0)\n# flip_bit = sbitint.get_input_from(0)\n# result = CNOT(control_bit, flip_bit)\n# result.reveal().print_reg()\n", "response_1": "# MP-SPDZ translation of the CNOT function\n\ndef CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ.\n    \"\"\"\n    # Using 1 - flip_bit to simulate the NOT operation when control is 1\n    return control_bit * (1 - flip_bit) + (1 - control_bit) * flip_bit\n", "model_name": "azure-gpt4o"}
{"test_name": "negative_plus1", "response_0": "c\ndef negative_plus1(y):\n    # y is of type sint\n    is_negative = y < 0  # This will be a sint (0 for False, 1 for True)\n    return y + (is_negative * 1)\n\n# Example usage with secret integer inputs\ny = sint.get_input_from(0)  # Assume input is provided by party 0\nresult = negative_plus1(y)\nprint_ln(\"Result: %s\", result.reveal())  # Reveal the result for demonstration\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Assuming y is a secret integer (sint)\n    y = sint(y)  # Convert y to secret integer if not already\n    condition = y < 0\n    return condition.if_else(y + 1, y)\n", "model_name": "azure-gpt4o"}
{"test_name": "is_a_parallelogram", "response_0": "# Function to check if four points form a parallelogram\ndef is_a_parallelogram(a, b, c, d):\n    # Function to check if two points are the same\n    def same(x, y):\n        return (x[0] == y[0]) * (x[1] == y[1])\n\n    # Check if any points are the same\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return 0  # False\n\n    # Check if the points form a parallelogram\n    cond1 = (a[0] + b[0] == c[0] + d[0]) * (a[1] + b[1] == c[1] + d[1])\n    cond2 = (a[0] + c[0] == b[0] + d[0]) * (a[1] + c[1] == b[1] + d[1])\n    cond3 = (a[0] + d[0] == b[0] + c[0]) * (a[1] + d[1] == b[1] + c[1])\n\n    return cond1 + cond2 + cond3 > 0  # True if any condition is true\n\n# Secure input example\na = [(sint(0), sint(0)), (sint(0), sint(0))]  # Example input\nb = [(sint(1), sint(1)), (sint(1), sint(1))]\nc = [(sint(2), sint(2)), (sint(2), sint(2))]\nd = [(sint(3), sint(3)), (sint(3), sint(3))]\n\n# Call function\nresult = is_a_parallelogram(a, b, c, d)\n", "response_1": "# Define the coordinates as secure integers\na_x = sint.get_input_from(0)\na_y = sint.get_input_from(0)\nb_x = sint.get_input_from(1)\nb_y = sint.get_input_from(1)\nc_x = sint.get_input_from(2)\nc_y = sint.get_input_from(2)\nd_x = sint.get_input_from(3)\nd_y = sint.get_input_from(3)\n\n# Define a function to check if two points are the same\ndef same(x0, y0, x1, y1):\n    return (x0.equal(x1)) * (y0.equal(y1))\n\n# Check if any two points are the same\nsame_ab = same(a_x, a_y, b_x, b_y)\nsame_ac = same(a_x, a_y, c_x, c_y)\nsame_ad = same(a_x, a_y, d_x, d_y)\nsame_bc = same(b_x, b_y, c_x, c_y)\nsame_bd = same(b_x, b_y, d_x, d_y)\nsame_cd = same(c_x, c_y, d_x, d_y)\n\n# If any two points are the same, it's not a parallelogram\nnot_parallelogram = same_ab + same_ac + same_ad + same_bc + same_bd + same_cd\n\n# Calculate the conditions for a parallelogram\ncondition1 = ((a_x + b_x).equal(c_x + d_x)) * ((a_y + b_y).equal(c_y + d_y))\ncondition2 = ((a_x + c_x).equal(b_x + d_x)) * ((a_y + c_y).equal(b_y + d_y))\ncondition3 = ((a_x + d_x).equal(b_x + c_x)) * ((a_y + d_y).equal(b_y + c_y))\n\n# Check if any of the conditions hold and no points are the same\nis_parallelogram = (condition1 + condition2 + condition3) * (1 - not_parallelogram)\n\n# Output the result\nis_parallelogram.output()\n", "model_name": "azure-gpt4o"}
{"test_name": "min", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef min(a, b):\n    \"\"\"\n    Return the minimum value of the two secret-shared inputs.\n    \"\"\"\n    # Perform comparison securely\n    condition = a.less_than_equal(b)  # a <= b returns a secret boolean\n    return if_else(condition, a, b)   # Select a if condition is true, else b\n", "response_1": "# Import the MP-SPDZ library for secure integer operations\nfrom Compiler.types import sint\n\ndef min(a: sint, b: sint) -> sint:\n    \"\"\"\n    Return the minimum value of the two secret inputs.\n    \"\"\"\n    # Compute the condition a <= b securely\n    condition = a <= b\n    # Use the condition to select the minimum value securely\n    return condition * a + (1 - condition) * b\n", "model_name": "azure-gpt4o"}
{"test_name": "choice_of_the_knight", "response_0": "# Import necessary modules for secure integers\nfrom Compiler.library import *\n\ndef choice_of_the_knight(x, y):\n    # Convert inputs to secure integers\n    x = sint(x)\n    y = sint(y)\n\n    # Initialize counter as a secure integer\n    counter = sint(0)\n\n    # Function to check if the position is legal\n    def legal(a, b):\n        # Returns 1 if position is legal, 0 otherwise\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    # Calculate potential new positions\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n\n    # Return the counter as a secure integer\n    return counter\n\n# Example of calling the function with secure inputs\nx = sint.get_input_from(0)\ny = sint.get_input_from(0)\nresult = choice_of_the_knight(x, y)\nprint_ln(\"Number of reachable positions: %s\", result.reveal())\n", "response_1": "def choice_of_the_knight(x, y):\n    # Initialize counter as a secure integer\n    counter = sfix(0)\n\n    # Define the legal function to check if a position is within the chessboard limits\n    def legal(a, b):\n        # Securely check if 0 <= a <= 7 and 0 <= b <= 7\n        cond_a = (a >= 0) * (a <= 7)\n        cond_b = (b >= 0) * (b <= 7)\n        return cond_a * cond_b\n\n    # Securely increment the counter if the position is legal\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n    \n    # Return the secure counter\n    return counter\n\n# Example of usage\n# Note: You need to initialize secure inputs and call the function within an MP-SPDZ program.\n", "model_name": "azure-gpt4o"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n\n    # Secure comparison to select the maximum value\n    is_sum_greater = sum_ab > diff_ab\n\n    # Return sum_ab if is_sum_greater is true, else return diff_ab\n    result = is_sum_greater.if_else(sum_ab, diff_ab)\n    return result\n", "response_1": "# Import the MP-SPDZ library for secure integers\nfrom Compiler import types\n\ndef max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b using secure computations.\n    \"\"\"\n    # Assume a and b are already secret-shared inputs of type sint\n    a = types.sint(a)\n    b = types.sint(b)\n    \n    # Compute the sum and difference\n    sum_ab = a + b\n    diff_ab = a - b\n    \n    # Compare securely and select the maximum\n    is_sum_greater = sum_ab.greater_than(diff_ab)\n    \n    # Return the maximum based on the comparison\n    return is_sum_greater.if_else(sum_ab, diff_ab)\n", "model_name": "azure-gpt4o"}
