{"test_name": "next_integer", "response_0": "def next_integer(t):\n    # Assuming `t` is a floating-point value represented as a fixed-point number in MP-SPDZ\n    # Convert `t` to an integer by truncating the fractional part\n    integer_part = sint(t)  # Convert to sint to truncate the fractional part\n    # Add 1 to get the smallest integer strictly greater than `t`\n    result = integer_part + 1\n    return result\n", "response_1": "# Import the necessary libraries\nfrom Compiler.types import sint\n\ndef next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    # Convert the input to an integer\n    t_int = t.round()  # Assume t is a sint and round it to the nearest integer\n    t_ceil = t_int + (t != t_int)  # Add 1 if t is not equal to t_int\n    return t_ceil\n", "model_name": "azure-gpt4o"}
{"test_name": "father_and_son", "response_0": "# Import the necessary library for secure computation\nfrom Compiler import types\n\n# Define the function\ndef father_and_son(father_age, son_age):\n    # Calculate the absolute difference\n    result = abs(father_age - son_age * 2)\n    return result\n\n# Main program\ndef main():\n    # Securely input the ages\n    father_age = types.sint.get_input_from(0)  # Party 0 provides the father's age\n    son_age = types.sint.get_input_from(1)     # Party 1 provides the son's age\n    \n    # Call the function\n    years_difference = father_and_son(father_age, son_age)\n    \n    # Output the result securely\n    years_difference.print_reveal()\n\n# Call the main program\nmain()\n", "response_1": "# Import the necessary module for secure integer types\nfrom Compiler.types import sint\n\ndef father_and_son(father_age: sint, son_age: sint) -> sint:\n    \"\"\"\n    Given the age of father and son as secret shared values,\n    return the absolute difference of father's age and twice the son's age.\n    \"\"\"\n    # Calculate the difference and take the absolute value securely\n    difference = father_age - son_age * 2\n    return difference.abs()\n", "model_name": "azure-gpt4o"}
{"test_name": "triangle_area", "response_0": "# MP-SPDZ code to compute the area of a triangle given a side and height\n\ndef triangle_area(side, height):\n    # Assuming side and height are both of type sfix for secure fixed-point computation\n    return side * height / 2\n\n# Example usage with secure inputs\nside = sfix.get_input_from(0)    # Secure input for side\nheight = sfix.get_input_from(0)  # Secure input for height\n\narea = triangle_area(side, height)\narea.output()  # Output the computed area securely\n", "response_1": "", "model_name": "azure-gpt4o"}
{"test_name": "sin_plus_cos", "response_0": "# Importing required library for mathematical operations\nfrom math import *\n\n# Define the function using MP-SPDZ syntax\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a) using secure computation\n    \"\"\"\n    # Ensure 'a' is treated as a secure fixed-point value\n    a = sfix(a)\n    \n    # Calculate sin(a) and cos(a) using MP-SPDZ functions\n    sin_a = sin(a)\n    cos_a = cos(a)\n    \n    # Return the sum of sin(a) and cos(a)\n    return sin_a + cos_a\n\n# Example usage\na = sfix.get_input_from(0)  # Assuming input comes from party 0\nresult = sin_plus_cos(a)\nprint_ln(\"sin(a) + cos(a) = %s\", result.reveal())\n", "response_1": "# Import the math library from MP-SPDZ\nfrom Compiler import mpc_math\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a) using secure computation.\n    \"\"\"\n    # Convert input to secure fixed-point number\n    a = mpc_math.sfix(a)\n    \n    # Calculate sin(a) and cos(a) using secure math functions\n    sin_a = mpc_math.sin(a)\n    cos_a = mpc_math.cos(a)\n    \n    # Return the sum of sin(a) and cos(a)\n    return sin_a + cos_a\n", "model_name": "azure-gpt4o"}
{"test_name": "sigmoid", "response_0": "# Import the necessary MP-SPDZ library for secure fixed-point arithmetic\nfrom Compiler import types\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function using MP-SPDZ\n    \"\"\"\n    # Ensure x is an sfix type for secure computation\n    x = types.sfix(x)\n\n    # The sigmoid function: 1 / (1 + exp(-x))\n    # Use the secure exp function provided by MP-SPDZ\n    exp_neg_x = types.sfix.exp(-x)\n\n    # Calculate the sigmoid\n    result = 1 / (1 + exp_neg_x)\n\n    return result\n", "response_1": "# Import the required MP-SPDZ modules\nfrom Compiler.library import *\n\ndef sigmoid(x):\n    \"\"\"\n    Sigmoid function using MP-SPDZ\n    \"\"\"\n    # Compute the exponentiation securely\n    exp_neg_x = exp(-x)\n    \n    # Compute the denominator\n    denominator = 1 + exp_neg_x\n    \n    # Compute the sigmoid result\n    result = 1 / denominator\n    \n    return result\n\n# Example usage\n# x = sfix.get_input_from(0)  # For example, to get input from party 0\n# result = sigmoid(x)\n# print_ln('Sigmoid: %s', result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "self_exponent", "response_0": "# Import the necessary MP-SPDZ library\nfrom Compiler.types import sint\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k in MP-SPDZ.\n    \"\"\"\n    # Ensure that k is treated as a secure integer\n    k = sint(k)\n    \n    # Compute k^k using the pow function for secure integers\n    return k ** k\n", "response_1": "# MP-SPDZ translation of the self_exponent function\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k in a secure computation.\n    \"\"\"\n    result = k ** k\n    return result\n\n# Usage example\nk = sint.get_input_from(0)  # Assume party 0 provides input\nresult = self_exponent(k)\nprint_ln(\"Result: %s\", result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "silu", "response_0": "# Assume necessary MP-SPDZ setup and imports are already done\n# Importing necessary library for secure fixed-point computations\nfrom Compiler.library import *\n\ndef silu(x):\n    \"\"\"\n    SiLU function in MP-SPDZ\n    \"\"\"\n    # Ensure x is of type sfix for secure fixed-point computation\n    x = sfix(x)\n    # Compute the exponential part\n    exp_neg_x = sfix.exp(-x)\n    # Compute the SiLU function\n    result = x / (1 + exp_neg_x)\n    return result\n\n# Example usage\n# Note: The actual input should be a secure input in MP-SPDZ\n# x = sfix.get_input_from(<party>)\n# result = silu(x)\n# print_ln(\"SiLU result: %s\", result.reveal())\n", "response_1": "# MP-SPDZ code\ndef silu(x):\n    \"\"\"\n    Secure SiLU function\n    \"\"\"\n    import math\n    # Assuming x is a secure fixed-point number (sfix)\n    return x / (1 + sfix.exp(-x))\n\n# Usage of silu would require x to be an sfix type, e.g., sfix(0.5)\n", "model_name": "azure-gpt4o"}
{"test_name": "Gaussian_bracket", "response_0": "from Compiler.library import *\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    # Convert x to a public fixed-point number\n    x_public = sfix(x)\n    \n    # Get the integer part using floor\n    x_int = x_public.floor()\n    \n    # Subtract integer part from x to get the fractional part\n    result = x_public - sfix(x_int)\n    \n    # Return the result as a fixed-point number\n    return result\n", "response_1": "# Import the required library for fixed-point arithmetic\nfrom Compiler import types\n\n# Define the function for Gaussian bracket\ndef Gaussian_bracket(x):\n    # Convert input to a fixed-point number if not already\n    x_fixed = types.sfix(x)\n    \n    # Get the integer part of the fixed-point number\n    x_int = x_fixed.round()\n    \n    # Compute the fractional part by subtracting the integer part\n    result = x_fixed - x_int\n    \n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "asin_and_square", "response_0": "# This is a hypothetical example assuming an asin approximation function is available.\n\ndef asin_approx(x):\n    # Implementation of an arcsin approximation\n    # This would be a custom function or a series of operations\n    # to approximate arcsin, which might not be trivial.\n    pass\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    # Assume x is of type sfix\n    x = sfix(x)\n    # Calculate the arcsin using an approximation method\n    asin_x = asin_approx(x)\n    # Square the result\n    result = asin_x * asin_x\n    # Output the result\n    print_ln('Result: %s', result.reveal())\n\n# Example usage (not included in the code block as per instructions)\n", "response_1": "# Import the necessary MP-SPDZ library for fixed-point arithmetic\nfrom Compiler.library import *\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    # Ensure x is a secret-shared input\n    x = sfix(x)\n    \n    # Use an available method or approximation for arcsin in MP-SPDZ\n    asin_result = x.arcsin()  # Assuming arcsin() is defined in MP-SPDZ for sfix\n    \n    # Compute the square of the arcsin result\n    square_result = asin_result * asin_result\n    \n    # Return the squared result\n    return square_result\n", "model_name": "azure-gpt4o"}
{"test_name": "cylinder_surface", "response_0": "# Define the function to calculate the surface area of a cylinder\ndef cylinder_surface(r, h):\n    # Define pi as a public floating-point constant\n    pi = sfix(3.141592653589793)\n\n    # Calculate the surface area using MP-SPDZ syntax\n    surface_area = 2 * pi * r * r + 2 * pi * r * h\n\n    # Return the surface area\n    return surface_area\n\n# Inputs\nr = sfix.get_input_from(0)  # Private input for radius\nh = sfix.get_input_from(0)  # Private input for height\n\n# Compute and output the surface area\nresult = cylinder_surface(r, h)\nprint_ln('Surface area: %s', result.reveal())\n", "response_1": "# MP-SPDZ code for calculating the surface area of a cylinder\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    # Assuming r and h are secret shared fixed-point numbers\n    pi = 3.141592653589793  # Define pi constant\n    return 2 * pi * r**2 + 2 * pi * r * h\n\n# Example usage with secret shared values\nr = sfix.get_input_from(0)  # Get secret input for radius from party 0\nh = sfix.get_input_from(1)  # Get secret input for height from party 1\nsurface_area = cylinder_surface(r, h)\nsurface_area.reveal_to_all()  # Reveal the computed surface area to all parties\n", "model_name": "azure-gpt4o"}
{"test_name": "radian_to_degree", "response_0": "# Import the MP-SPDZ library\nfrom Compiler import types\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree in MP-SPDZ\n    \"\"\"\n    # Use a fixed-point number type for secure computation\n    r = types.sfix(r)\n    \n    # Approximation of pi\n    pi_approx = types.sfix(3.141592653589793)\n    \n    # Conversion formula from radian to degree\n    degree = r / pi_approx * 180\n    \n    return degree\n", "response_1": "# Import the necessary MP-SPDZ library\nfrom Compiler.library import *\n\n# Define the function to convert radians to degrees\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    # Using the MP-SPDZ constant for pi\n    pi = sfix(3.141592653589793)\n    \n    # Perform the conversion\n    return r / pi * sfix(180)\n\n# Example usage (assuming 'r' is a secure input)\nr = sfix.get_input_from(0) # Secure input from party 0\nresult = radian_to_degree(r)\nresult.print_reveal() # Print the result in a secure manner\n", "model_name": "azure-gpt4o"}
{"test_name": "square_root", "response_0": "# Import necessary MP-SPDZ modules\nfrom Compiler.types import sfix\nfrom math import sqrt\n\ndef square_root(a):\n    \"\"\"\n    Return the square root of the input using secure computation.\n    \"\"\"\n    # Ensure that the input is a secure fixed-point number\n    a_secure = sfix(a)\n    \n    # Compute the square root securely\n    result = a_secure.sqrt()\n    \n    return result\n\n# Example usage:\n# a = sfix.get_input_from(...)  # Get secure input from a party\n# result = square_root(a)\n# print_ln(\"Square root: %s\", result.reveal())\n", "response_1": "# Import necessary modules for fixed-point arithmetic\nfrom Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef square_root(a):\n    \"\"\"\n    Calculate the square root of a securely input number.\n    \"\"\"\n    # Convert input to secure fixed-point number\n    a_sfix = sfix(a)\n    \n    # Compute square root using the library function\n    result = sqrt(a_sfix)\n    \n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "cosine_theorem", "response_0": "# Import necessary library for square root and cosine\nfrom Compiler.library import sqrt\nfrom math import cos\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    # Convert inputs to secure fixed-point numbers\n    a = sfix(a)\n    b = sfix(b)\n    rad = sfix(rad)\n    \n    # Calculate the third edge using cosine theorem\n    c_square = a**2 + b**2 - 2 * a * b * cos(rad)\n    c = sqrt(c_square)\n    \n    return c\n\n# Example usage (assumes input is already provided securely)\n# result = cosine_theorem(a_input, b_input, rad_input)\n# print_ln('Third edge length: %s', result.reveal())\n", "response_1": "# Load necessary libraries for secure computation\nfrom Compiler.types import sfix\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them,\n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    # Ensure inputs are secure fixed-point numbers\n    a = sfix(a)\n    b = sfix(b)\n    rad = sfix(rad)\n    \n    # Compute the square of a and b\n    a_squared = a * a\n    b_squared = b * b\n    \n    # Compute the cosine term\n    cos_term = 2 * a * b * rad.cos()\n    \n    # Compute the length of the third edge using the cosine theorem\n    c_squared = a_squared + b_squared - cos_term\n    \n    # Return the square root of c_squared\n    return c_squared.sqrt()\n\n# Example usage would involve secure inputs, typically outside of this script\n", "model_name": "azure-gpt4o"}
{"test_name": "lights_states", "response_0": "# MP-SPDZ translation of the lights_states function\n\ndef lights_states(num):\n    # Initialize the result to 1 (since any number to the power of 0 is 1)\n    result = 1\n    \n    # Multiply result by 2, num times\n    for _ in range(num):\n        result *= 2\n        \n    return result\n\n# Usage\nnum = sfix.get_input_from(0)  # Assuming 'num' is an input from party 0\nresult = lights_states(num)\nprint_ln('The total number of possible states is: %s', result)\n", "response_1": "# Assuming num is a public integer input\ndef lights_states(num):\n    # Compute the total number of possible states for the given number of lights\n    return 2 ** num\n\n# Example usage\nnum = cint.get_input_from(0)  # Input from party 0\nresult = lights_states(num)\nprint_ln('Total states: %s', result)\n", "model_name": "azure-gpt4o"}
{"test_name": "degree_to_radian", "response_0": "# Convert degrees to radians in MP-SPDZ\nfrom Compiler import types\n\ndef degree_to_radian(d):\n    # Define pi as a constant\n    pi = 3.141592653589793\n    \n    # Ensure d is a secure type, for example, sfix for fixed-point\n    d = types.sfix(d)\n    \n    # Perform the conversion\n    radian = d / 180 * pi\n    \n    # Return the result\n    return radian\n\n# Example usage\nd = types.sfix.get_input_from(0)  # Taking input securely from party 0\nradian_result = degree_to_radian(d)\nradian_result.output()  # Output the result securely\n", "response_1": "// Convert degrees to radians in MP-SPDZ\n\n// Load the required floating-point library for operations\n#include <FHE/Math/gf2n.h>\n#include <FHE/Math/gfp.h>\n\nvoid main()\n{\n    // Define the input as an integer or fixed-point, depending on context\n    fixed<31, 31> d;\n    \n    // Input the degree value\n    std::cin >> d;\n\n    // Define the constant value for \u03c0\n    fixed<31, 31> pi = 3.141592653589793;\n\n    // Perform the degree to radian conversion\n    fixed<31, 31> radian = d / 180 * pi;\n\n    // Output the result\n    std::cout << radian;\n}\n", "model_name": "azure-gpt4o"}
{"test_name": "Fah_to_Cel", "response_0": "# Import the necessary modules for MP-SPDZ\n# Depending on the setup, you might need to include specific libraries\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature using MP-SPDZ.\n    \"\"\"\n    # Assuming F is a secret shared fixed-point number\n    # We use sfix to denote secret fixed-point numbers\n    F = sfix(F)\n    \n    # Convert Fahrenheit to Celsius\n    # We need to handle the fixed-point arithmetic explicitly\n    result = (F - sfix(32)) / sfix(1.8)\n    \n    return result\n\n# Example call\n# Assume F is provided as a secret input elsewhere in the program\n# result = Fah_to_Cel(F)\n", "response_1": "# Import the necessary MP-SPDZ library\nfrom Compiler import types\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature using MP-SPDZ.\n    \"\"\"\n    # Convert input to secure fixed-point type\n    F = types.sfix(F)\n    \n    # Perform the conversion using secure arithmetic\n    result = (F - 32) / 1.8\n\n    return result\n\n# Example usage\n# F is expected to be a secure input, typically provided by one of the parties\nF = types.sfix.get_input_from(0)  # Example: Get input from party 0\nC = Fah_to_Cel(F)\ntypes.sfix.output(C)  # Output the result securely\n", "model_name": "azure-gpt4o"}
{"test_name": "elliptic_area", "response_0": "# Import necessary library for secure fixed-point arithmetic\nfrom Compiler.library import *\n\n# Define the elliptic_area function\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    # Define pi as a fixed-point constant\n    pi = sfix(math.pi)\n    # Calculate the area using the formula: \u03c0 * a * b\n    return pi * a * b\n\n# Example inputs as secure fixed-point numbers\na = sfix.get_input_from(0)  # Player 0 inputs the length of the major axis\nb = sfix.get_input_from(0)  # Player 0 inputs the length of the minor axis\n\n# Calculate the elliptic area\narea = elliptic_area(a, b)\n\n# Output the result\nprint_ln(\"Elliptic Area: %s\", area.reveal())\n", "response_1": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic,\n    return its area using secure computation.\n    \"\"\"\n    # Use the secure data type for inputs\n    # Typically, 'sfix' is used for fixed-point arithmetic in MP-SPDZ\n    # Assuming 'a' and 'b' are already secure inputs\n\n    # Secure multiplication and constant\n    pi = 3.141592653589793\n    area = pi * a * b\n    return area\n\n# Example of how you might call this function with secret-shared inputs\n# a = sfix.get_input_from(0)\n# b = sfix.get_input_from(0)\n# result = elliptic_area(a, b)\n# print_ln(\"Elliptic Area: %s\", result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "floor", "response_0": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    from Compiler.types import sfix\n\n    # Assume z is a secret fixed-point number (sfix type)\n    # Convert it to an integer by truncating the fractional part\n    z_int = z.floor()\n    return z_int\n", "response_1": "# Import necessary MP-SPDZ modules\nfrom Compiler.types import sfix\n\ndef floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Ensure input is a secret fixed-point number\n    z = sfix(z)\n    # Use the floor method for secret fixed-point numbers\n    return z.floor()\n", "model_name": "azure-gpt4o"}
{"test_name": "log_and_cube", "response_0": "# Import necessary MP-SPDZ libraries\nfrom Compiler.library import *\n\n# Define the logarithm and cube function\ndef log_and_cube(x):\n    \"\"\"\n    Take log (with base-2) of the input, then compute the cube of the outcome\n    \"\"\"\n    # Assume a secure method for log base 2 is available as secure_log2\n    log_result = secure_log2(x)\n    \n    # Compute the cube using secure multiplication\n    cube_result = log_result * log_result * log_result\n    \n    return cube_result\n\n# Placeholder for the secure logarithm base 2 function\ndef secure_log2(x):\n    # Implement or approximate the secure log base 2 operation here\n    pass\n", "response_1": "# Import the necessary MP-SPDZ modules\nfrom Compiler.library import *\nfrom Compiler.types import sfix\n\ndef log2_approx(x):\n    # Approximate log base 2 using a fixed-point arithmetic method\n    # Using natural log approximation and conversion: log2(x) = ln(x) / ln(2)\n    ln2_inv = sfix(1.44269504089)  # 1 / ln(2) approximated\n    ln_x = ln_approx(x)  # Use MP-SPDZ's approximation for natural log\n    return ln_x * ln2_inv\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    # Ensure x is an sfix type for fixed-point arithmetic\n    x = sfix(x)\n    \n    # Calculate log2(x)\n    log2_x = log2_approx(x)\n    \n    # Calculate (log2(x))^3\n    cube_result = log2_x * log2_x * log2_x\n    \n    return cube_result\n\n# Example usage with an input\nx = sfix.get_input_from(0)  # Assuming player 0 provides input\nresult = log_and_cube(x)\nresult.output()\n", "model_name": "azure-gpt4o"}
{"test_name": "floor_and_square", "response_0": "# Import the necessary MP-SPDZ modules\nfrom Compiler import types\n\ndef floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input.\n    Then return the square of the previous outcome.\n    \"\"\"\n\n    # Assuming `z` is a secure fixed-point number\n    # Convert the input to a secure integer\n    z_int = types.sint(z)\n\n    # Square the result\n    result = z_int * z_int\n\n    return result\n", "response_1": "# MP-SPDZ translation of the function\ndef floor_and_square(z):\n    # Assume z is a secure fixed-point number (sfix)\n    # Convert to an integer by truncating the fractional part\n    int_z = sint(z)\n\n    # Return the square of the integer part\n    return int_z * int_z\n\n# Example of function usage with a secure input (commented out as per instructions)\n# z = sfix.get_input_from(0) # Example secure input\n# result = floor_and_square(z)\n# print_ln(\"Result: %s\", result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "meters_to_feet", "response_0": "# Define a function to convert meters to feet\ndef meters_to_feet(m):\n    # Conversion factor from meters to feet\n    conversion_factor = sfix(3.2808)\n    # Return the result of the multiplication\n    return m * conversion_factor\n\n# Example usage within MP-SPDZ would require loading inputs and using the function\n", "response_1": "# Convert meters to feet using secure fixed-point arithmetic\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    # Convert meters to feet using the factor 3.2808\n    conversion_factor = sfix(3.2808)\n    return m * conversion_factor\n\n# Example usage\n# m is a secure fixed-point number representing meters\nm = sfix.get_input_from(0) # secure input from party 0\nfeet = meters_to_feet(m)\nfeet.output()\n", "model_name": "azure-gpt4o"}
{"test_name": "sphere_area", "response_0": "# Import necessary library functions\nfrom Compiler.library import *\n\ndef sphere_area():\n    \"\"\"\n    Securely compute the area of a sphere surface with given secret-shared radius r.\n    \"\"\"\n    # Secret input for the radius\n    r = sfix.get_input_from(0)  # Assume party 0 provides the input\n\n    # Pi as a fixed-point constant\n    pi = sfix(math.pi)\n\n    # Compute the area of the sphere\n    area = 4 * pi * r * r\n\n    # Output the result\n    print_ln(\"Sphere area: %s\", area.reveal())\n", "response_1": "# MP-SPDZ program to calculate the area of a sphere given a radius r\n\n# Import necessary libraries from MP-SPDZ\nfrom Compiler import types\n\n# Define the constant pi\npi = types.sfix(3.141592653589793)\n\ndef sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    # Ensure r is a secure fixed-point number\n    r = types.sfix(r)\n    \n    # Calculate the area using the formula 4 * pi * r^2\n    area = types.sfix(4) * pi * (r * r)\n    \n    return area\n\n# Example usage\n# r = types.sfix(5)  # Example radius (commented out to avoid direct usage in the code block)\n# print_ln(\"The area of the sphere is: %s\", sphere_area(r).reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "coarse_abs", "response_0": "# Import the necessary MP-SPDZ libraries for working with secure fixed-point numbers\nfrom Compiler import types\n\n# Define the coarse_abs function for secure computations\ndef coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    # Ensure the input is a secure fixed-point number\n    x = types.sfix(x)\n    \n    # Compute the absolute value\n    abs_x = types.sfix.abs(x)\n    \n    # Floor the absolute value to the nearest integer\n    floored_abs_x = abs_x.floor()\n    \n    return floored_abs_x\n\n# Example usage\n# secret_x = types.sfix.get_input_from(0)  # Assume input from party 0\n# result = coarse_abs(secret_x)\n# result.reveal()  # Reveal the result for demonstration purposes\n", "response_1": "# MP-SPDZ version of coarse_abs function\ndef coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, truncated to zero.\n    \"\"\"\n    # Assuming x is of type sint (secure integer)\n    abs_x = abs(x)  # Use secure absolute value\n    return abs_x  # No need for floor with integers\n", "model_name": "azure-gpt4o"}
{"test_name": "how_many_chickens", "response_0": "# This MP-SPDZ script calculates the number of chickens in the rabbit-chicken problem.\n\n# Import necessary library for public input/output\nfrom Compiler.library import *\n\n# Function definition\ndef how_many_chickens(heads, legs):\n    # Assuming heads and legs are inputs (public or private based on the use case)\n    result = heads - (legs - heads * 2) // 2\n    return result\n\n# Main program\ndef main():\n    # Read public inputs; in actual use, these might be secret inputs\n    heads = sint.get_input_from(0)  # Read the number of heads (can be public or secret)\n    legs = sint.get_input_from(0)   # Read the number of legs (can be public or secret)\n\n    # Calculate the number of chickens\n    chickens = how_many_chickens(heads, legs)\n\n    # Output the result\n    print_ln('Number of chickens: %s', chickens.reveal())\n\n# Run the main program\nmain()\n", "response_1": "# Function to compute the number of chickens given heads and legs in MP-SPDZ.\ndef how_many_chickens(heads, legs):\n    # heads and legs should be of the same secure type, e.g., sfix or sint\n    # Here we assume they are of type sint (secure integer)\n    \n    # Compute the number of chickens\n    chickens = heads - (legs - heads * 2) // 2\n    \n    return chickens\n\n# Example usage in MP-SPDZ\n# Initialize secure variables for heads and legs\nheads = sint.get_input_from(0)  # Assume input from party 0\nlegs = sint.get_input_from(1)   # Assume input from party 1\n\n# Call the function\nchickens = how_many_chickens(heads, legs)\n\n# Output the result securely\nchickens.output()\n", "model_name": "azure-gpt4o"}
{"test_name": "interest_calculator", "response_0": "# Import necessary MP-SPDZ library for secure fixed-point numbers\nfrom Compiler import types\n\n# Function to calculate interest using MP-SPDZ\ndef interest_calculator(capital, ratio, months):\n    # Convert inputs to secure fixed-point numbers\n    s_capital = types.sfix(capital)\n    s_ratio = types.sfix(ratio)\n    s_months = types.sint(months)\n    \n    # Calculate compound interest using a loop (1 + ratio) ** months\n    s_total_ratio = types.sfix(1)\n    for i in range(s_months):\n        s_total_ratio *= (1 + s_ratio)\n    \n    # Calculate final interest\n    s_interest = (s_total_ratio - 1) * s_capital\n    \n    return s_interest\n\n# Example of using the function\n# capital = secure input, ratio = secure input, months = secure input\n# result = interest_calculator(capital, ratio, months)\n", "response_1": "# Secure types are used for holding the values\ncapital = sfix.get_input_from(0)  # Suppose party 0 provides capital\nratio = sfix.get_input_from(1)    # Suppose party 1 provides ratio\nmonths = sfix.get_input_from(2)   # Suppose party 2 provides months\n\n# Calculate the interest using MP-SPDZ's arithmetic operations\n# (1 + ratio) ** months - 1\ncompound_factor = (1 + ratio) ** months\ninterest = (compound_factor - 1) * capital\n\n# Output the interest to all parties\nprint_ln('Interest: %s', interest.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "circle_area", "response_0": "# Define a constant for pi in MP-SPDZ\npi = 3.141592653589793\n\n# Define a function to calculate the circle area\ndef circle_area(r):\n    # Return the area using the formula pi * r^2\n    return pi * r * r\n\n# Example usage\n# r = sfix(5)  # Assuming the radius is a secret fixed-point number\n# area = circle_area(r)\n", "response_1": "# Define a function to calculate the area of a circle given a secret-shared radius\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius using secret-shared computation.\n    \"\"\"\n    # Define the value of \u03c0 as a cleartext constant (can be adjusted for precision)\n    pi = 3.141592653589793\n    \n    # Calculate area using secret-shared multiplication\n    area = pi * r * r\n    \n    return area\n\n# Example usage of the function\n# r = sfix.get_input_from(0)  # Example of getting input for secure computation\n# area = circle_area(r)\n# area.reveal().print()\n", "model_name": "azure-gpt4o"}
{"test_name": "cube_and_square_root", "response_0": "# Define a function to compute the cube and square root\ndef cube_and_square_root(x):\n    # Cube the input\n    cube = x * x * x\n    # Square root of the cube\n    result = cube.sqrt()\n    return result\n\n# Input a secret-shared value\nx = sint.get_input_from(0)\n\n# Call the function\nresult = cube_and_square_root(x)\n\n# Reveal the result to party 0 for output\nresult.reveal_to(0)\n", "response_1": "# Define the function in MP-SPDZ\ndef cube_and_square_root(x):\n    # Raise x to the power of 3\n    cube = x ** 3\n    # Compute the square root of the cube\n    result = sqrt(cube)\n    return result\n\n# Main program\ndef main():\n    # Initialize the input as a secure fixed-point number\n    x = sfix.get_input_from(0)  # Assuming input from party 0\n    # Call the function\n    result = cube_and_square_root(x)\n    # Output the result\n    print_ln('The square root of the cube of the input is: %s', result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "round", "response_0": "# MP-SPDZ code for rounding a fixed-point number\n\n# Secure fixed-point number input\nx = sfix.get_input_from(0)  # Assuming input from party 0\n\n# Extract integer part\nx_int = x.floor()\n\n# Compute fractional part\nfractional_part = x - x_int\n\n# Compare fractional part with 0.5\nis_less_than_half = fractional_part.less_than(sfix(0.5))\n\n# Result: x_int if fractional_part < 0.5 else x_int + 1\nrounded_result = x_int + is_less_than_half.if_else(0, 1)\n\n# Output the result\nrounded_result.output_to(0)\n", "response_1": "# Import the required MP-SPDZ types\nfrom Compiler.library import *\n\ndef secure_round(x):\n    \"\"\"\n    Round x to the nearest integer using MP-SPDZ operations.\n    \"\"\"\n    # Assume x is a secure fixed-point number (sfix)\n    x_int = x.floor()  # Use floor method for secure fixed-point numbers\n    # Calculate the difference\n    diff = x - x_int\n    # Compare diff with 0.5\n    add_one = (diff >= sfix(0.5))\n    # If diff is greater or equal to 0.5, add 1 to x_int\n    result = x_int + add_one\n    return result\n\n# Example usage for demonstration purposes\nif __name__ == '__main__':\n    x = sfix(3.7)  # Example secure fixed-point number\n    result = secure_round(x)\n    print_ln('Rounded result: %s', result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "cryptic_adjustment", "response_0": "def cryptic_adjustment(origin):\n    \"\"\"\n    The professor wants to adjust the pessimistic score of his students' mid-term exam. \n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    from Compiler.library import sqrt\n\n    # Convert origin to a secure floating point number\n    origin_sfix = sfix(origin)\n    \n    # Perform the nested square root operation\n    inner_sqrt = sqrt(origin_sfix)\n    outer_sqrt = sqrt(10 * inner_sqrt)\n    \n    # Return the adjusted score\n    return 10 * outer_sqrt\n\n# Assuming `origin` is securely input by the user\norigin = sfix.get_input_from(0) # Example: getting input from party 0\nadjusted_score = cryptic_adjustment(origin)\nprint_ln(\"Adjusted score: %s\", adjusted_score.reveal())\n", "response_1": "// Import the necessary header for fixed-point computation\n#include <sfix.h>\n\n// Define the function for cryptic adjustment\nvoid cryptic_adjustment(sfix origin, sfix& result)\n{\n    // Calculate the adjustment: 10 * sqrt(10 * sqrt(origin))\n    sfix inner_sqrt = sqrt(origin);\n    sfix adjusted_inner = 10 * inner_sqrt;\n    sfix outer_sqrt = sqrt(adjusted_inner);\n    result = 10 * outer_sqrt;\n}\n\n// Main program\nvoid main()\n{\n    // Declare the input and output variables\n    sfix origin;\n    sfix result;\n\n    // Input the value of origin\n    input(origin);\n\n    // Perform the cryptic adjustment\n    cryptic_adjustment(origin, result);\n\n    // Output the result\n    output(result);\n}\n", "model_name": "azure-gpt4o"}
{"test_name": "specific_pow", "response_0": "# Import necessary MP-SPDZ functionality\nfrom Compiler.types import sfix\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using MP-SPDZ.\n    \"\"\"\n    # Ensure x is a secret-shared fixed-point number\n    x = sfix(x)\n    \n    # MP-SPDZ does not directly support fractional exponents like 2.5\n    # We can break it down to x^2 * x^0.5\n    x_squared = x * x\n    x_half = x.sqrt()  # Square root of x\n\n    # Return the result of x^2 * x^0.5 = x^2.5\n    return x_squared * x_half\n\n# Example usage (not included in the function)\n# x = sfix.get_input_from(0)  # Get a secret-shared input from party 0\n# result = specific_pow(x)\n", "response_1": "# Import the MP-SPDZ library for secure computation\nfrom Compiler.library import *\n\n# Define a function to compute x^(2.5) using MP-SPDZ\ndef specific_pow(x):\n    # Ensure x is a secure fixed-point number\n    x = sfix(x)\n    \n    # Compute x^(2.5) using the power function for secure fixed-point numbers\n    # This involves raising x to the power of 2 and then multiplying by the square root of x\n    result = x ** 2 * x.sqrt()\n    \n    # Return the result\n    return result\n\n# Example usage:\n# Secure input x can be provided by parties\n# x = sfix.get_input_from(0)  # Party 0 provides input x\n# result = specific_pow(x)\n# print_ln('Result: %s', result.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "soft_plus", "response_0": "# Import necessary secure types\nfrom Compiler.types import sfix\n\ndef soft_plus(x):\n    \"\"\"\n    Softplus function in MP-SPDZ\n    \"\"\"\n    # Initialize x as secure type, assuming it's already an sfix\n    # If x is not secure, use sfix(x) to convert it to secure type\n    one = sfix(1)\n    e = sfix.exp(x)  # Secure exponentiation\n    result = sfix.log(one + e)  # Secure logarithm\n    return result\n", "response_1": "# MP-SPDZ code for the softplus function\n\ndef soft_plus(x):\n    \"\"\"\n    Softplus function in MP-SPDZ\n    \"\"\"\n    # Assume x is already an sfix or secure input\n    import library\n\n    one = sfix(1)\n    e = sfix(library.math.e)  # Use the library's representation of e if available\n\n    # Calculate exponentiation e^x\n    e_to_x = e ** x\n\n    # Calculate log(1 + e^x)\n    result = library.math.log(one + e_to_x)\n\n    return result\n", "model_name": "azure-gpt4o"}
{"test_name": "ball_volume", "response_0": "# Assume sfix is the secure fixed-point type used for real numbers.\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius using secure computation.\n    \"\"\"\n    pi = sfix(3.141592653589793)  # Hardcoded value for \u03c0\n    radius_cubed = r ** 3          # Securely compute r^3\n    volume = pi * radius_cubed * sfix(4) / sfix(3)  # 4/3 * \u03c0 * r^3\n    return volume\n\n# Example of how you might call this function in an MP-SPDZ script:\n# r = sfix(input_value)  # input_value should be provided securely\n# volume = ball_volume(r)\n", "response_1": "# MP-SPDZ program for calculating the volume of a ball given the radius\nfrom Compiler.library import *\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    r is expected to be a secret-shared fixed-point number (sfix).\n    \"\"\"\n    pi = sfix(3.141592653589793)  # A fixed-point approximation of pi\n    volume = pi * r**3 * sfix(4) / sfix(3)\n    return volume\n\n# Example usage within an MP-SPDZ program\n# r = sfix.get_input_from(0)  # This could be used to input the radius as a secret value\n# vol = ball_volume(r)\n# vol.output()  # Securely output the volume\n", "model_name": "azure-gpt4o"}
{"test_name": "Heron", "response_0": "def Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    # Compute the semi-perimeter\n    p = (a + b + c) / 2\n    # Compute the area using Heron's formula\n    area = (p * (p - a) * (p - b) * (p - c)).sqrt()\n    return area\n\n# Example inputs as secure fixed-point numbers\na = sfix(3)\nb = sfix(4)\nc = sfix(5)\n\n# Compute the area using Heron's formula\narea = Heron(a, b, c)\nprint_ln(\"Area of the triangle: %s\", area.reveal())\n", "response_1": "# Secure version of Heron's formula in MP-SPDZ\ndef Heron(a, b, c):\n    # Assume a, b, c are inputs of type sfix for secure fixed-point arithmetic\n    p = (a + b + c) / 2  # Compute the semi-perimeter\n    area_squared = p * (p - a) * (p - b) * (p - c)  # Heron's formula without sqrt\n    area = area_squared.sqrt()  # Secure square root\n    return area\n\n# Example input (these would typically be secret-shared inputs in MP-SPDZ)\na = sfix.get_input_from(0)  # Party 0 provides the input\nb = sfix.get_input_from(1)  # Party 1 provides the input\nc = sfix.get_input_from(2)  # Party 2 provides the input\n\n# Compute the area using Heron's formula\narea = Heron(a, b, c)\n\n# Output the result securely\narea.output()\n", "model_name": "azure-gpt4o"}
{"test_name": "next_perfect_square", "response_0": "# MP-SPDZ program\n\n# Define a function to compute the next perfect square\ndef next_perfect_square(x):\n    # Ensure x is interpreted as a secure integer\n    x = sint(x)\n    \n    # Start with an initial guess for the square root\n    guess = x / 2\n    better_guess = (guess + x / guess) / 2\n\n    # Iteratively improve the guess\n    for _ in range(10):\n        better_guess = (guess + x / guess) / 2\n        guess = better_guess\n\n    # Ensure the guess is an integer\n    guess = guess.round()\n\n    # Calculate the next perfect square\n    next_square = (guess + 1) * (guess + 1)\n    \n    return next_square\n\n# Main program\nx = sint.get_input_from(0)  # Securely get input from party 0\nresult = next_perfect_square(x)\nprint_ln(\"Next perfect square: %s\", result.reveal())\n", "response_1": "# MP-SPDZ code, assuming 'sint' is the secure integer type.\n\ndef next_perfect_square(x):\n    # Step 1: Calculate the approximate square root of x.\n    sqrt_x = x.sqrt()  # Assuming x.sqrt() is available in MP-SPDZ\n    \n    # Step 2: Floor the result (implicitly done by converting to integer).\n    floored_sqrt = sint(sqrt_x)\n    \n    # Step 3: Increment the result.\n    next_root = floored_sqrt + 1\n    \n    # Step 4: Square the result.\n    next_square = next_root * next_root\n    \n    return next_square\n\n# Usage of the function would replace x with a secure integer input.\n", "model_name": "azure-gpt4o"}
{"test_name": "pi_to_the_x", "response_0": "# Import necessary MP-SPDZ library functions\nfrom Compiler.library import *\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x in a secure computation environment.\n    \"\"\"\n    # Define pi as a secret-shared fixed-point number\n    pi = sfix(math.pi)\n    \n    # Compute pi^x using secure fixed-point arithmetic\n    result = pow_fx(pi, x)\n    \n    return result\n", "response_1": "# Import the necessary library for mathematical operations\nfrom math import pow\n\n# Define the main program\ndef main():\n    # Declare the input as a secure floating-point number\n    x = sfix.get_input_from(0)  # Player 0 inputs the value of x\n\n    # Define the value of pi using a secure fixed-point type\n    pi = sfix(3.141592653589793)\n\n    # Compute pi^x using the pow function\n    result = pow(pi, x)\n\n    # Output the result\n    result.output()\n", "model_name": "azure-gpt4o"}
{"test_name": "spring_rocket", "response_0": "# Import necessary MP-SPDZ modules\nfrom Compiler.library import *\n\ndef spring_rocket(height, m, k):\n    # Define g as a secure fixed-point number\n    g = sfix(9.8)\n    \n    # Calculate the minimum compression length\n    # Use the sfix type for all computations\n    compression_length = ((sfix(2) * m * g * height) / k).sqrt()\n    \n    # Return the result\n    return compression_length\n\ndef main():\n    # Example values for height, mass, and stiffness\n    height = sfix.get_input_from(0)\n    m = sfix.get_input_from(0)\n    k = sfix.get_input_from(0)\n    \n    # Call the function\n    result = spring_rocket(height, m, k)\n    \n    # Output the result\n    result.print_to(0)\n", "response_1": "# Spring Rocket Calculation in MP-SPDZ\n# Assume height, m, and k are public for simplicity, if they are secret inputs, use sfix.\n\ndef spring_rocket(height, m, k):\n    # Define gravity as a constant\n    g = 9.8\n    \n    # Calculate energy needed to reach the height\n    energy = 2 * m * g * height / k\n    \n    # Calculate the square root of the energy\n    min_compression = sqrt(energy)\n    \n    return min_compression\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assume inputs are public\n    height = cfix(10.0)  # Example height\n    m = cfix(5.0)        # Example mass\n    k = cfix(200.0)      # Example spring stiffness\n\n    result = spring_rocket(height, m, k)\n    print_ln(\"Minimum compression of the spring: %s\", result)\n", "model_name": "azure-gpt4o"}
{"test_name": "cone_volume", "response_0": "# Import the necessary MP-SPDZ modules\nfrom Compiler.types import sfix, sint\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    # Define \u03c0 using fixed-point representation\n    pi = sfix(3.141592653589793)\n\n    # Convert inputs to fixed-point\n    r = sfix(r)\n    h = sfix(h)\n\n    # Compute the volume of the cone\n    volume = pi * r * r * h / sfix(3)\n\n    return volume\n\n# Example usage (uncomment when running in an MP-SPDZ environment with input setup):\n# r = sint.get_input_from(0)  # Assume player 0 provides the radius\n# h = sint.get_input_from(1)  # Assume player 1 provides the height\n# volume = cone_volume(r, h)\n# print_ln(\"The volume of the cone is: %s\", volume.reveal())\n", "response_1": "# MP-SPDZ Program to calculate the volume of a cone\n\n# Define the constant pi\npi = sfix(3.141592653589793)\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the secure radius and height, compute the secure volume of the cone.\n    \"\"\"\n    # Ensure r and h are of sfix type\n    r = sfix(r)\n    h = sfix(h)\n\n    # Calculate volume\n    volume = pi * r * r * h / sfix(3)\n\n    return volume\n\n# Example usage (for demonstration purposes, not to be included in the program):\n# r = sfix(input())\n# h = sfix(input())\n# volume = cone_volume(r, h)\n# print_ln(\"Volume of the cone: %s\", volume.reveal())\n", "model_name": "azure-gpt4o"}
{"test_name": "how_many_rabbits", "response_0": "# MP-SPDZ code\n# Import the required libraries\nfrom Compiler.library import *\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem using secret shared values.\n    \"\"\"\n    # Assume heads and legs are secret-shared inputs\n    heads = sint.get_input_from(0)\n    legs = sint.get_input_from(0)\n\n    # Compute the number of rabbits\n    rabbits = (legs - heads * 2) / 2\n\n    # Output the result\n    rabbits.output()\n\n# Call the function\nhow_many_rabbits(sint(), sint())\n", "response_1": "# Import the necessary modules\nfrom Compiler.types import sint\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    # Declare inputs as secure integers\n    heads = sint(heads)\n    legs = sint(legs)\n    \n    # Perform the computation\n    result = (legs - heads * 2) / 2\n    \n    return result\n", "model_name": "azure-gpt4o"}
