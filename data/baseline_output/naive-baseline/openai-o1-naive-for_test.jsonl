{"test_name": "multiply_first_five", "response_0": "from Compiler.types import sint\n\ndef multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sint(1)\n    for i, val in enumerate(array):\n        prod *= val\n        if i >= 4:\n            break\n    return prod\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sint(1)\n    for i in range(len(array)):\n        cond = i < 5\n        prod = if_else(cond, prod * array[i], prod)\n    return prod\n", "model_name": "azure-openai-o1"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint\n\ndef second_largest(arr):\n    # Initialize largest and second elements\n    cond_init = arr[0] >= arr[1]\n    largest = cond_init.if_else(arr[0], arr[1])\n    second = cond_init.if_else(arr[1], arr[0])\n\n    # Iterate over the rest of the array\n    for i in range(2, len(arr)):\n        cond = arr[i] >= largest\n        old_largest = largest\n        # Update largest and second if arr[i] is the new largest\n        largest = cond.if_else(arr[i], largest)\n        second = cond.if_else(old_largest, second)\n\n        # Otherwise, check if arr[i] should update second\n        cond2 = (arr[i] >= second) * (1 - cond)\n        second = cond2.if_else(arr[i], second)\n\n    return second\n", "response_1": "def second_largest(arr):\n    # Initialize largest and second based on comparing first two elements\n    cond_init = arr[0] >= arr[1]\n    largest = cond_init * arr[0] + (1 - cond_init) * arr[1]\n    second = cond_init * arr[1] + (1 - cond_init) * arr[0]\n    \n    # Loop through the rest of the array\n    for i in range(2, len(arr)):\n        cond1 = arr[i] >= largest\n        new_largest = cond1 * arr[i] + (1 - cond1) * largest\n        new_second  = cond1 * largest + (1 - cond1) * second\n        \n        cond2 = (1 - cond1) * (arr[i] >= new_second)\n        second = cond2 * arr[i] + (1 - cond2) * new_second\n        \n        largest = new_largest\n    \n    return second\n", "model_name": "azure-openai-o1"}
{"test_name": "partial_sum", "response_0": "# MP-SPDZ code translation of the Python partial_sum function\n\ndef partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array in MP-SPDZ.\n    \"\"\"\n    partial = sint(0)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "def partial_sum(arr):\n    partial = sint(0)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "max_adjacent_product", "response_0": "def max_adjacent_product(arr):\n    # In MP-SPDZ, arr should be a list of secret integer types (e.g., sint).\n    # This high-level code uses secure comparisons in the same way as Python.\n    n = len(arr)\n    cur = arr[0] * arr[1]\n    for i in range(n - 1):\n        product = arr[i] * arr[i + 1]\n        if product > cur:\n            cur = product\n    return cur\n", "response_1": "# Use sfix or a similar secret-sharing data type as needed.\n# Here, arr is assumed to be a list of secret-shared values (e.g., sfix).\n\ndef max_adjacent_product(arr):\n    # Initialize current maximum product with first two elements\n    cur = arr[0] * arr[1]\n    \n    # Iterate through the array to find the maximum product\n    for i in range(len(arr) - 1):\n        tmp = arr[i] * arr[i + 1]\n        # Update cur with an if-else check using MP-SPDZ's conditional functionality\n        is_greater = tmp > cur\n        cur = is_greater.if_else(tmp, cur)\n    \n    return cur\n", "model_name": "azure-openai-o1"}
{"test_name": "argmax", "response_0": "# This MP-SPDZ code defines a function argmax for secret-shared arrays.\n# It returns a secret index of the maximum element in the array.\n\ndef argmax(a):\n    n = len(a)\n    current = a[0]\n    index = sint(0)\n    for i in range(1, n):\n        # Compare a[i] with current securely\n        c = a[i] > current\n        index = c * sint(i) + (1 - c) * index\n        current = c * a[i] + (1 - c) * current\n    return index\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "count_distinct", "response_0": "from Compiler.types import sint\n\ndef count_distinct(arr):\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            eq = (arr[j] == arr[i])\n            unique = unique * (1 - eq)\n        counter = counter + unique\n    return counter\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef count_distinct(arr):\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            eq = arr[j] == arr[i]\n            unique = unique * (1 - eq)\n        counter = counter + unique\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_true", "response_0": "def main():\n    # Number of inputs (this value or method might vary depending on your use case)\n    n = 5\n\n    # Reading secret boolean bits (arr) from player 0's input (modify as needed)\n    arr = [sbit.get_input_from(0) for _ in range(n)]\n\n    # Initialize the result bit (False equivalent)\n    ret = sbit(0)\n\n    # Perform a logical OR across all bits in arr\n    for i in range(n):\n        ret = ret | arr[i]\n\n    # Reveal and print the result\n    ret.reveal().print_reg()\n", "response_1": "def exists_true(arr):\n    # Initialize an accumulator\n    ret = sint(0)\n\n    # Accumulate the sum of all Boolean elements\n    for item in arr:\n        ret = ret + item\n\n    # Return whether the sum is greater than 0\n    return ret > 0\n", "model_name": "azure-openai-o1"}
{"test_name": "range", "response_0": "from Compiler.types import sint\n\ndef secure_range(arr):\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = (max_value >= item).if_else(max_value, item)\n        min_value = (min_value <= item).if_else(min_value, item)\n    return max_value - min_value\n", "response_1": "def range(arr):\n    # arr is a list of secure integers (sint).\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        # Compare for maximum\n        bigger = max_value < item\n        max_value = bigger * item + (1 - bigger) * max_value\n        \n        # Compare for minimum\n        smaller = min_value > item\n        min_value = smaller * item + (1 - smaller) * min_value\n    \n    # Return the difference\n    return max_value - min_value\n", "model_name": "azure-openai-o1"}
{"test_name": "count_larger_than_5", "response_0": "from Compiler.types import sint\n\ndef count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5, \n    using MP-SPDZ secure types.\n    \"\"\"\n    counter = sint(0)\n    for item in arr:\n        counter += item.greater_than(5)\n    return counter\n", "response_1": "def count_larger_than_5(arr):\n    counter = sint(0)\n    for item in arr:\n        comparison = (item > cint(5))\n        counter += comparison\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr):\n    max_val = sfix(0)\n    sum_val = sfix(0)\n    length = len(arr)\n\n    for i in range(length):\n        item = arr[i].abs()\n        max_val = (item > max_val).if_else(item, max_val)\n        sum_val = sum_val + item\n\n    return (2 * max_val) > sum_val\n", "response_1": "def exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array,\n    whose absolute value is strictly larger than the sum of the absolute values of all other elements.\n    \"\"\"\n    max_val = sfix(0)\n    sum_val = sfix(0)\n    for x in arr:\n        x_abs = x.abs()\n        bigger = x_abs > max_val\n        max_val = bigger.if_else(x_abs, max_val)\n        sum_val += x_abs\n    return (sfix(2) * max_val) > sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "greedy_picker", "response_0": "def greedy_picker(items, captivity):\n    # Here, items and captivity are secret-shared integers (sint).\n    # We maintain a sint variable num to count picked items.\n    num = sint(0)\n\n    # Loop through the secret-shared list of items\n    for i in range(len(items)):\n        # Compute cond as a secret bit that is 1 if items[i] <= captivity, otherwise 0\n        cond = (items[i] <= captivity).if_else(sint(1), sint(0))\n\n        # Update captivity only if cond is 1 (and do nothing otherwise), in a data-oblivious manner\n        captivity = captivity - items[i] * cond\n\n        # Increase num only if the item was picked\n        num = num + cond\n\n    # Return the final number of items picked\n    return num\n", "response_1": "# MP-SPDZ translation of the Python function \"greedy_picker\"\n# This function computes how many items can be picked under a greedy strategy.\n\ndef greedy_picker(items, captivity):\n    # items: list of secret integers (sint)\n    # captivity: a single secret integer (sint)\n    # returns: a secret integer (sint) representing the number of items picked\n    \n    picked_count = sint(0)\n    n = len(items)\n\n    for i in range(n):\n        # Determine if the current item fits in the remaining capacity\n        # cond is 1 if items[i] <= captivity, else 0\n        cond = (items[i] <= captivity)\n        \n        # Reduce the capacity based on the condition\n        captivity = captivity - (items[i] * cond)\n        \n        # Increase the count of items picked\n        picked_count = picked_count + cond\n\n    return picked_count\n", "model_name": "azure-openai-o1"}
{"test_name": "scalar_add_array", "response_0": "# MP-SPDZ translation of the scalar_add_array function\nfrom Compiler.types import sint\n\ndef scalar_add_array(s: sint, l: list[sint]) -> sint:\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result. \n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n", "response_1": "def scalar_add_array(s, l):\n    # 's' and each 'item' in 'l' are secure data types in MP-SPDZ.\n    for item in l:\n        s = s + item\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "is_equidistant_seq", "response_0": "from Compiler.types import sint, sbit\n\ndef is_equidistant_seq(arr):\n    # Return whether or not the array is an equidistant sequence in MP-SPDZ.\n    n = len(arr)\n    # We'll store the result as a secret bit (1 = True, 0 = False).\n    res = sbit(1)\n\n    # If the array has length 1 or 0, we're done (result stays True).\n    if n <= 1:\n        return res\n\n    # Initialize the common difference using the first two elements.\n    d = arr[1] - arr[0]\n\n    # Check the difference between successive elements.\n    for i in range(1, n - 1):\n        difference = arr[i + 1] - arr[i]\n        # Compare difference with d. This yields a secret bit (1 if equal, else 0).\n        eq = (difference == d)\n        # Update res to indicate if all differences checked so far are the same.\n        res = res & eq\n\n    return res\n\ndef main():\n    # Read the length of the array from command-line arguments.\n    import sys\n    n = int(sys.argv[1])\n\n    # Securely input n integers from player 0 into an array of sints.\n    arr = [sint.get_input_from(0) for _ in range(n)]\n\n    # Compute the result of the is_equidistant_seq function.\n    output = is_equidistant_seq(arr)\n\n    # Reveal the result (secret bit) and print it.\n    output.reveal().print_reg()\n", "response_1": "from Compiler.types import sint, MemValue\nfrom Compiler.library import if_\n\ndef is_equidistant_seq(arr, n):\n    \"\"\"\n    Returns 1 (as secure integer) if arr is an equidistant sequence, else 0.\n    If n <= 1, always returns 1.\n    \"\"\"\n    one = sint(1)\n    eq = MemValue(one)\n\n    cond = (n > 1)\n    @if_(cond)\n    def check_diff():\n        d = MemValue(arr[1] - arr[0])\n        for i in range(2, n):\n            eq.write(eq.read() * ((arr[i] - arr[i-1]) == d.read()))\n\n    return eq.read()\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product", "response_0": "from Compiler.types import sfix\n\ndef inner_product(vec1, vec2):\n    # Initialize the sum as secret fixed-point zero\n    sum_val = sfix(0)\n    # Loop over corresponding elements of both vectors\n    for i in range(len(vec1)):\n        sum_val = sum_val + (vec1[i] * vec2[i])\n    return sum_val\n", "response_1": "def inner_product(vec1, vec2):\n    s = sfix(0)\n    for i in range(len(vec1)):\n        s += vec1[i] * vec2[i]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "more_distinct_nonnegative", "response_0": "from Compiler.types import sint, sbit\n\ndef more_distinct_nonnegative(arr, n):\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    for i in range(n):\n        unique = sbit(1)\n        for j in range(i):\n            eq = arr[j].equal(arr[i])\n            unique = unique & eq.not_()\n        temp_nonnegative = arr[i].geq(sint(0))\n        temp_negative = arr[i].ltz()\n        nonnegative_counter = nonnegative_counter + sint.conv(unique) * sint.conv(temp_nonnegative)\n        negative_counter = negative_counter + sint.conv(unique) * sint.conv(temp_negative)\n    return nonnegative_counter.greater_than(negative_counter)\n", "response_1": "def more_distinct_nonnegative(arr):\n    from Compiler.types import sint\n    n = len(arr)\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            unique *= 1 - (arr[i] == arr[j])\n        is_nonnegative = 1 - (arr[i] < 0)\n        nonnegative_counter += unique * is_nonnegative\n        negative_counter += unique * (1 - is_nonnegative)\n    return nonnegative_counter > negative_counter\n", "model_name": "azure-openai-o1"}
{"test_name": "flip_positives", "response_0": "n = 5\narray = [sfix.get_input_from(0) for _ in range(n)]\n\n@for_range(n)\ndef flip_positives(i):\n    cond = array[i] > 0\n    array[i] = cond.if_else(-array[i], array[i])\n\n@for_range(n)\ndef output(i):\n    print_ln('%s', array[i].reveal())\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "divide_and_plus", "response_0": "from Compiler.types import sfix\n\ndef divide_and_plus(x):\n    for i in range(4):\n        x = x / sfix(2)\n        x = x + sfix(1)\n    return x\n", "response_1": "# Example translation of the Python 'divide_and_plus' function into MP-SPDZ\n\nfrom Compiler.mpc_types import sfix\nfrom Compiler.library import program\n\ndef main():\n    # Step 1: Read secret input from party 0\n    x = sfix.get_input_from(0)\n\n    # Step 2: Perform the \"divide by 2, then plus 1\" operation four times\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n\n    # Step 3: Output the result\n    x.output()\n", "model_name": "azure-openai-o1"}
{"test_name": "array_log2", "response_0": "from Compiler.types import sfix\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two of all elements in the input array (of sfix type).\n    \"\"\"\n    # Precompute reciprocal of the natural logarithm of 2 (approx 1.4426950408)\n    inv_ln2 = sfix(1.4426950408)\n    for i in range(len(arr)):\n        # Use the natural log method .log() and multiply by 1 / ln(2)\n        arr[i] = arr[i].log() * inv_ln2\n    return arr\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two of all elements in the input sfix array.\n    \"\"\"\n    two = sfix(2)\n    # log2(x) = log(x) / log(2)\n    for i in range(len(arr)):\n        arr[i] = mpc_math.log_fx(arr[i]) / mpc_math.log_fx(two)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_to_ten", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\ndef sum_to_ten(array):\n    partial_sum = sfix(0)\n    keep_looping = sint(1)\n    @for_range(len(array))\n    def _(i):\n        nonlocal partial_sum, keep_looping\n        partial_sum = partial_sum + sfix(array[i]) * keep_looping\n        condition_met = partial_sum >= sfix(10)\n        keep_looping = keep_looping * (sint(1) - condition_met)\n    return partial_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array (of secure integers) until the sum becomes\n    no smaller than 10, in an MP-SPDZ compliant way without data-dependent breaks.\n    \"\"\"\n    total_sum = sint(0)\n    mask = sint(1)\n    for i in range(len(array)):\n        cond = total_sum < 10\n        total_sum = total_sum + array[i] * mask\n        mask = mask * cond\n    return total_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(arr)\n    @for_range(n)\n    def _(i):\n        if i % 2 == 1:\n            arr[i] = arr[i] + sint(1)\n        else:\n            arr[i] = arr[i] - sint(1)\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    for i in range(len(arr)):\n        if i % 2 == 1:\n            arr[i] = arr[i] + sint(1)\n        else:\n            arr[i] = arr[i] - sint(1)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "min_element", "response_0": "def min_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    for i in range(1, len(a)):\n        condition = (current <= a[i])\n        current = condition.if_else(current, a[i])\n    return current\n", "response_1": "# mp-spdz code\n# This function returns the array's minimum using the same semantics \n# as your Python function (even though the original docstring mentions max).\n\nfrom Compiler.types import sfix\n\ndef min_element(a):\n    \"\"\"\n    Return the max value of an array.  <-- (Original docstring, but actual code finds min.)\n    \"\"\"\n    current = a[0]\n    for item in a:\n        cond = current <= item\n        current = cond * current + (1 - cond) * item\n    return current\n", "model_name": "azure-openai-o1"}
{"test_name": "soft_max", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef soft_max(arr):\n    \"\"\"\n    Return the softmax array of the input secure array arr.\n    \"\"\"\n    denominator = sfix(0)\n    for item in arr:\n        denominator += exp(item)\n    brr = []\n    for item in arr:\n        brr.append(exp(item) / denominator)\n    return brr\n", "response_1": "def soft_max(arr):\n    # Assume arr is a list of sfix (secure fixed-point) values in MP-SPDZ\n    # We'll compute the sum of exponentials and then assign each element\n    # exp(arr[i]) / denominator\n    from Compiler.types import sfix\n    \n    denominator = sfix(0)\n    for item in arr:\n        denominator += item.exp()\n    \n    brr = []\n    for i in range(len(arr)):\n        brr.append(arr[i].exp() / denominator)\n    \n    return brr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_reverse_pair_with_break", "response_0": "def count_reverse_pair_with_break(arr):\n    # arr is assumed to be a list of s_int (secure integers)\n    n = len(arr)\n    count = s_int(0)\n    still_run = s_int(1)  # This will emulate 'break' in a data-oblivious way\n\n    for i in range(1, n):\n        # Check if the current element exceeds 10 (returns an s_bit)\n        c = arr[i] > 10\n        \n        # Only perform the inner loop if we have not 'broken' yet\n        for j in range(i):\n            cond = (arr[j] > arr[i])\n            # Increase count if arr[j] > arr[i] and we haven't 'broken'\n            count = count + cond * still_run\n        \n        # If arr[i] > 10, we 'break' by setting still_run to 0, which\n        # will skip all subsequent increments\n        still_run = still_run * (1 - c)\n    \n    return count\n", "response_1": "# MP-SPDZ code translating the Python function:\n# def count_reverse_pair_with_break(arr):\n#     \"\"\"\n#     Count the number of reverse pairs before we find an element bigger than 10\n#     \"\"\"\n#     count = 0\n#     for i in range(1,len(arr)):\n#         if arr[i]>10:\n#             break\n#         for j in range(i):\n#             if arr[j]>arr[i]:\n#                 count += 1\n#     return count\n\nfrom Compiler.types import sint\n\ndef count_reverse_pair_with_break(arr):\n    \"\"\"\n    Data-oblivious translation of the Python 'count_reverse_pair_with_break' function to MP-SPDZ.\n    Instead of a direct 'break', we track a 'should_stop' flag.\n    Once 'should_stop' is set, that iteration (and all subsequent ones) contribute zero to 'count'.\n    \"\"\"\n    n = len(arr)\n    one = sint(1)\n    zero = sint(0)\n    \n    count = zero\n    should_stop = zero\n    \n    # Iterate from i = 1 to n-1\n    for i in range(1, n):\n        # Compare arr[i] to 10 (data-oblivious)\n        cond = arr[i] > 10\n        \n        # Accumulate into 'should_stop'\n        should_stop = should_stop + (one - should_stop) * cond\n        \n        # If 'should_stop' is 1, 'skip' becomes 0\n        skip = one - should_stop\n        \n        # Only count reverse pairs if 'skip' is 1\n        for j in range(i):\n            count = count + skip * (arr[j] > arr[i])\n    \n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_unique", "response_0": "def sum_unique(arr, n):\n    s = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(n):\n            if j != i:\n                cond = (arr[j] == arr[i])\n                unique = unique * (sint(1) - cond)\n        s = s + arr[i] * unique\n    return s\n", "response_1": "def sum_unique(arr):\n    # Return the sum of unique elements in the array in MP-SPDZ\n    n = len(arr)\n    s = sint(0)\n    for i in range(n):\n        # 'unique' is a secure bit indicating whether arr[i] is unique\n        unique = sbit(1)\n        for j in range(n):\n            if i != j:\n                is_equal = (arr[i] == arr[j])\n                unique = unique & ~is_equal\n        s = s + unique.if_else(arr[i], sint(0))\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "check_sum", "response_0": "def check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value using MP-SPDZ.\n    \"\"\"\n    s = sint(0)\n    for num in array:\n        s += num\n    return s == target\n", "response_1": "from Compiler.types import sfix\n\ndef check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    In MP-SPDZ, we use sfix (or another secure type) instead of regular Python integers.\n    \"\"\"\n    sum_value = sfix(0)\n    for num in array:\n        sum_value = sum_value + num\n    return sum_value.equal(target)\n", "model_name": "azure-openai-o1"}
{"test_name": "prod", "response_0": "from Compiler.types import sint\n\ndef prod(array):\n    \"\"\"\n    Multiply together all elements in the array (list of sint).\n    \"\"\"\n    result = sint(1)\n    for num in array:\n        result = result * num\n    return result\n", "response_1": "def prod(array):\n    from Compiler.types import sint\n    product = sint(1)\n    for num in array:\n        product = product * num\n    return product\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_till_negative", "response_0": "def sum_till_negative(array):\n    # We will assume array is a list of sfix or sint values\n    # and we use secure comparisons/operations.\n    \n    running_sum = sfix(0)\n    found_negative = sbit(0)\n    \n    for x in array:\n        # Compare x with 0 securely\n        is_negative = x < sfix(0)\n        \n        # We decide whether to add this element based on whether\n        # we have not yet encountered a negative value\n        do_add = sbit(1) - found_negative\n        \n        running_sum = running_sum + x * do_add\n        \n        # Update the flag to indicate that once a negative is found,\n        # we keep skipping further additions\n        found_negative = found_negative | is_negative\n    \n    return running_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_till_negative(array):\n    cond = sint(1)\n    total = sint(0)\n    for i in range(len(array)):\n        total = total + array[i] * cond\n        is_negative = array[i].less_than(0)\n        cond = cond * (1 - is_negative)\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfies the predicator.\n    In MP-SPDZ, we rely on predicator(...) returning a secret 0/1 value\n    instead of using a conditional statement since if-statements with\n    secret conditions are not directly supported.\n    \"\"\"\n    sum_s = sint(0)\n    for i in range(len(arr)):\n        sum_s = sum_s + predicator(arr[i])\n    return sum_s\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    count = sint(0)\n    for i in range(len(arr)):\n        # predicator should be written to return a secret integer (sint) 0 or 1\n        count = count + predicator(arr[i])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "standard_deviation", "response_0": "from Compiler.types import sfix\n\ndef standard_deviation(arr):\n    n = sfix(len(arr))\n    average = sfix(0)\n    for item in arr:\n        average += item / n\n    variance = sfix(0)\n    for item in arr:\n        diff = item - average\n        variance += diff * diff / n\n    return variance.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef standard_deviation(arr):\n    n = sfix(len(arr))\n    average = sfix(0)\n    for item in arr:\n        average += item\n    average /= n  # Compute the mean\n\n    variance = sfix(0)\n    for item in arr:\n        diff = item - average\n        variance += diff * diff\n    variance /= n  # Compute the average of squared differences\n\n    return variance.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "dominate", "response_0": "def dominate(a, b):\n    ret = sint(1)\n    for i in range(len(a)):\n        ret = ret * (a[i] >= b[i])\n    return ret\n", "response_1": "def dominate(a, b):\n    # a and b are lists of secure integer values (e.g., sint)\n    # We want to return a secure bit indicating\n    # whether, for all indices i, a[i] >= b[i].\n    ret = sbit(1)\n    n = len(a)\n    for i in range(n):\n        # a[i] < b[i] returns a bit that is 1 if true, else 0\n        # So 'not' that bit to check if a[i] is not smaller than b[i].\n        ret = ret & ~(a[i] < b[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    # Assume brr is a list of sfix values.\n    max_abs = sfix(0)\n    n = len(brr)\n\n    # First pass: compute the maximum absolute value\n    for i in range(n):\n        item_abs = brr[i].abs()\n        cond = item_abs > max_abs\n        max_abs = cond.if_else(item_abs, max_abs)\n\n    # Second pass: divide each element by max_abs to fit into [-1,1]\n    for i in range(n):\n        brr[i] = brr[i] / max_abs\n\n    return brr\n", "response_1": "from Compiler.types import sfix\n\ndef rescale(brr):\n    max_abs = sfix(0)\n    for item in brr:\n        abs_item = (item < sfix(0)).if_else(-item, item)\n        max_abs = (abs_item > max_abs).if_else(abs_item, max_abs)\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_minus7", "response_0": "def array_minus7(arr, n):\n    # Subtract 7 from each element in a secure array of length n\n    for i in range(n):\n        arr[i] = arr[i] - 7\n    return arr\n", "response_1": "def array_minus7(arr):\n    # Subtract 7 from each element of the secret/shared array in MP-SPDZ\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] - 7\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sint, Array\n\ndef traverse_and_sum(arr1, arr2):\n    sum_result = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum_result = sum_result + arr1[i] * arr2[j]\n    return sum_result\n\n# Example of reading input arrays, performing the sum, and outputting the result:\n\nn = sint.get_input_from(0)  # Length of first array\narr1 = Array(n, sint)\nfor i in range(n):\n    arr1[i] = sint.get_input_from(0)\n\nm = sint.get_input_from(0)  # Length of second array\narr2 = Array(m, sint)\nfor j in range(m):\n    arr2[j] = sint.get_input_from(0)\n\nres = traverse_and_sum(arr1, arr2)\nres.print_ln()\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef traverse_and_sum(arr1, arr2):\n    # Initialize a secure integer to store the sum\n    s = sint(0)\n    \n    # Traverse through each index of arr1\n    for i in range(len(arr1)):\n        # Traverse through each index of arr2\n        for j in range(len(arr2)):\n            # Accumulate the sum of products securely\n            s = s + arr1[i] * arr2[j]\n    \n    # Return the result as a secure integer\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler.types import sint\n\ndef smax(x, y):\n    c = x >= y\n    return c.if_else(x, y)\n\ndef longest_nondec_subseq(a):\n    n = len(a)\n    max_length = sint(0)\n    cur_length = sint(1)\n    \n    for i in range(1, n):\n        c = a[i] >= a[i - 1]\n        max_length = c.if_else(max_length, smax(max_length, cur_length))\n        cur_length = c.if_else(cur_length + 1, sint(1))\n    \n    max_length = smax(max_length, cur_length)\n    return max_length\n", "response_1": "# This MP-SPDZ program reads an array of secret integers from party 0 and\n# computes the length of the longest non-decreasing subsequence.\n\n# Define a helper function to compute max between two secret integers.\ndef max_sint(x, y):\n    cond = x >= y\n    return cond.if_else(x, y)\n\n# Read input size n (clear).\nn = int(input())\n\n# Create an array of secret integers and read them from party 0.\na = Array(n, sint)\nfor i in range(n):\n    a[i] = sint.get_input_from(0)\n\n# Initialize variables as secret integers.\nmax_length = sint(1)\ncur_length = sint(1)\n\n# Main loop similar to the Python version, but using secret comparisons.\nfor i in range(1, n):\n    cond = a[i] >= a[i - 1]\n    # If a[i] >= a[i-1], increment cur_length, otherwise reset to 1.\n    new_cur_length = cond.if_else(cur_length + 1, sint(1))\n    # Update max_length.\n    max_length = max_sint(max_length, new_cur_length)\n    cur_length = new_cur_length\n\n# Reveal and print the result.\nprint_ln('%s', max_length.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_but_skip_biggest", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_but_skip_biggest(array):\n    partial_sum = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        cond = array[i] >= biggest\n        biggest = biggest * (1 - cond) + array[i] * cond\n        partial_sum = partial_sum + array[i] * (1 - cond)\n    return partial_sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef sum_but_skip_biggest(array):\n    sum_val = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        cond = array[i] >= biggest\n        sum_val = sum_val + if_else(cond, sint(0), array[i])\n        biggest = if_else(cond, array[i], biggest)\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "second_test", "response_0": "def second_test(arr):\n    n = len(arr)\n    count = sint(0)\n    for i in range(1, n):\n        count = count + (arr[0] < arr[i])\n    return (count == 1)\n", "response_1": "from Compiler.types import sint\n\ndef second_test(arr):\n    count = sint(0)\n    for i in range(1, len(arr)):\n        count = count + (arr[0] < arr[i])\n    return (count == 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "Manhattan_distance", "response_0": "# This helper function computes the absolute value of a secret integer.\ndef sabs(x):\n    sign = x < 0\n    return sign.if_else(-x, x)\n\n# This function computes the Manhattan distance of two vectors a and b\n# that are arrays of secret integers (sint). Both have the same length n.\ndef Manhattan_distance(a, b, n):\n    ret = sint(0)\n    for i in range(n):\n        diff = a[i] - b[i]\n        ret += sabs(diff)\n    return ret\n", "response_1": "def Manhattan_distance(a, b):\n    # a and b are lists of secure types (e.g. sfix).\n    ret = sfix(0)\n    for i in range(len(a)):\n        diff = a[i] - b[i]\n        ret = ret + diff.abs()\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "deal_with_only_positive", "response_0": "def deal_with_only_positive(array):\n    from Compiler.types import s_int\n    sign = s_int(1)\n    ssum = s_int(0)\n    for i in range(len(array)):\n        positive_indicator = array[i].gt(0)\n        ssum = ssum + sign * array[i] * positive_indicator\n        sign = sign * (s_int(1) - s_int(2) * positive_indicator)\n    return ssum\n", "response_1": "def deal_with_only_positive(array):\n    from Compiler.types import sfix\n    sign = sfix(1)\n    partial_sum = sfix(0)\n    for i in range(len(array)):\n        cond = array[i] > sfix(0)\n        positive_value = cond.if_else(array[i], sfix(0))\n        partial_sum = partial_sum + sign * positive_value\n        sign = cond.if_else(-sign, sign)\n    return partial_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import sint, sbit\nfrom Compiler.library import for_range\n\ndef compare_and_return(arr, brr):\n    # Assume arr and brr are lists of sints of the same length.\n    n = len(arr)\n    found = sbit(0)\n    ret = sint(-1)\n    for i in for_range(n):\n        eq = arr[i].equal(brr[i])\n        assign = eq * (1 - found)\n        ret = ret * (1 - assign) + sint(i) * assign\n        found = found + assign\n    return ret\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "sum_odd_positive", "response_0": "from Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    s = sint(0)\n    for item in arr:\n        odd = item.mod2()         # 1 if item is odd, else 0\n        pos = (item > 0)          # 1 if item is positive, else 0\n        s = s + (item * odd * pos)\n    return s\n", "response_1": "def sum_odd_positive(arr):\n    sum_val = sint(0)\n    for item in arr:\n        cond_odd = item % 2\n        cond_pos = item > 0\n        sum_val = sum_val + item * (cond_odd * cond_pos)\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "two_sum", "response_0": "# This MP-SPDZ program reads an integer n (array length), then reads n secret integers as arr,\n# followed by a single secret integer as target. It checks whether any two numbers in arr \n# (possibly the same) sum to the target, revealing 1 if so, and 0 otherwise.\n\nn = sint.get_input_from(0)\narr = Array(n, sint)\narr.input_from(0)\ntarget = sint.get_input_from(0)\n\nfound = sbit(0)\nfor i in range(n):\n    for j in range(n):\n        found |= (arr[i] + arr[j]) == target\n\nprint_ln(\"%s\", found.reveal())\n", "response_1": "def two_sum(arr, target, n):\n    # arr is a list/array of secure integers (sint)\n    # target is also a secure integer (sint)\n    # n is a public integer representing the length of arr\n    found = sbit(0)\n    for i in range(n):\n        for j in range(n):\n            found = found | ((arr[i] + arr[j]) == target)\n    # 'found' is an sbit that indicates whether any two elements sum up to target\n    return found\n", "model_name": "azure-openai-o1"}
{"test_name": "seq_search", "response_0": "# seq_search in MP-SPDZ\n# Performs a sequential search over a secret-shared array arr for a secret-shared target.\n# Returns the index of the target, or -1 if not found.\n\nfrom Compiler.types import sint\n\ndef seq_search(arr, target):\n    n = len(arr)\n    done = sint(0)\n    found = sint(-1)\n    for i in range(n):\n        eq = (arr[i] == target)\n        cond = (done == 0) * eq\n        found = cond.if_else(sint(i), found)\n        done = cond.if_else(sint(1), done)\n    return found\n", "response_1": "def seq_search(arr, target):\n    # arr is a list of sint\n    # target is a single sint\n    n = len(arr)\n    ret = sint(-1)\n    for i in range(n):\n        eq = (arr[i] == target)              # Secret boolean (0 or 1 as sint)\n        ret = ret + eq * (sint(i) - ret)     # Update index conditionally\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_array", "response_0": "from Compiler.types import sbit\n\ndef choppy_array(arr):\n    n = len(arr)\n    # We store whether the array remains a \"choppy array\" in res (1 = True, 0 = False).\n    res = sbit(1)\n    \n    for i in range(n):\n        for j in range(n - i):\n            # Compare arr[i+j] with arr[i]; these comparisons yield sbit results.\n            scond_gt = (arr[i+j] > arr[i])\n            scond_lt = (arr[i+j] < arr[i])\n            \n            # If i is odd, we fail if arr[i+j] > arr[i].\n            if i % 2 == 1:\n                res = res & ~scond_gt\n            # If i is even, we fail if arr[i+j] < arr[i].\n            else:\n                res = res & ~scond_lt\n    \n    return res\n", "response_1": "def choppy_array(arr):\n    n = len(arr)\n    # Start assuming it is a choppy array (True), as a secure bit\n    res = sbit(1)\n    \n    # Nested loops: same structure as Python version\n    for i in range(n):\n        # i is public, so we can use a normal if\n        if i % 2 == 1:\n            # If i is odd, check if arr[i+j] > arr[i] for j in range(n-i]\n            for j in range(n - i):\n                # comp is 1 (true) if arr[i+j] > arr[i], else 0\n                comp = arr[i+j] > arr[i]\n                # If comp == 1, that violates the condition, so set res = 0\n                res = res & (comp ^ sbit(1))\n        else:\n            # If i is even, check if arr[i+j] < arr[i] for j in range(n-i]\n            for j in range(n - i):\n                # comp is 1 (true) if arr[i] > arr[i+j], meaning arr[i+j] < arr[i]\n                comp = arr[i] > arr[i+j]\n                # If comp == 1, that violates the condition, so set res = 0\n                res = res & (comp ^ sbit(1))\n    \n    # Return sbit(1) if choppy, sbit(0) otherwise\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process", "response_0": "def array_process(arr, n, func):\n    @for_range(n)\n    def _(i):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "# array_process.mpc\n\n# Define a placeholder function 'func'. \n# In MP-SPDZ, function references cannot be passed directly like in Python. \n# One approach is to define a specific function to apply within this file.\ndef func(x):\n    # Example processing: increment value\n    return x + 1\n\ndef array_process(arr, n):\n    \"\"\"\n    Process all elements in the input array with a given function.\n    \"\"\"\n    # Note: In MP-SPDZ, 'len(arr)' is not directly available, \n    # so we rely on a provided length 'n'.\n    for i in range(n):\n        arr[i] = func(arr[i])\n    # Return the processed array\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "normalize", "response_0": "# MP-SPDZ code translating the Python normalize(vec) function \n# Note: We assume vec is a list of sfix or sfloat. \n#       MP-SPDZ provides built-in sqrt for these types.\n\nfrom Compiler.types import sfix\n\ndef normalize(vec):\n    s = sfix(0)\n    for item in vec:\n        s = s + item * item\n    base = s.sqrt()\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef normalize(vec):\n    # sum of squares\n    sum_squares = sfix(0)\n    for i in range(len(vec)):\n        sum_squares += vec[i] * vec[i]\n    # compute square root\n    base = sqrt(sum_squares)\n    # divide each element by base\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "model_name": "azure-openai-o1"}
{"test_name": "impatient_merchant", "response_0": "# Translated MP-SPDZ version of the impatient_merchant function.\n# Here, 'days' is assumed to be an array of secret-shared integer values (sint).\n# The function returns a secret-shared integer (sint) representing the net value.\n\ndef impatient_merchant_mpspdz(days):\n    can_buy = sint(1)\n    net = sint(0)\n    orig_price = sint(0)\n    n = len(days)\n\n    for i in range(n):\n        # Condition for buying\n        cond_buy = can_buy\n        net = net - (days[i] * cond_buy)\n        orig_price = (orig_price * (1 - cond_buy)) + (days[i] * cond_buy)\n\n        # Condition for selling (only if we are not in \"buy\" mode) and price is higher\n        cond_sell = (1 - can_buy) * (days[i] > orig_price)\n        net = net + (days[i] * cond_sell)\n\n        # Update can_buy for the next iteration\n        new_can_buy = (can_buy * (1 - cond_buy)) + cond_sell\n        can_buy = new_can_buy\n\n    return net\n", "response_1": "# MP-SPDZ program for the impatient_merchant logic.\n# It expects:\n#  1) to read n (number of days) from an input player (e.g., player 0),\n#  2) to read the n prices from the same player (though you can adjust if needed),\n#  3) to perform the merchant logic,\n#  4) and finally reveal (or return) the net result.\n\nfrom Compiler.types import sint\nfrom Compiler.library import reveal\n\ndef main():\n    # Step 1: Read number of days and prices\n    n = sint.get_input_from(0)              # Secret-shared integer: number of days\n    # For a public integer, you could do: n = cint.get_input_from(0)\n    \n    # Often you first reveal 'n' to the parties to know the loop range, here let's assume a small known upper bound.\n    # Or if n is known, you can just hardcode it. For demonstration, we assume you know 'n' at compile time.\n    # If not, you'd need a known maximum length loop or dynamic loops.\n\n    # In practice, we might do something like:\n    # n_plain = reveal(n)\n    # Then create a loop up to n_plain. For simplicity, use a fixed range.\n    \n    # Step 2: Read 'days' prices (secret shared)\n    # We'll assume a small maximum for demonstration; adjust as appropriate.\n    max_days = 10\n    days = []\n    for i in range(max_days):\n        # Here we decide if we read the price based on i < n_plain (hidden by a secure conditional if needed),\n        # but for simplicity, read unconditionally and rely on controlling the loop.\n        days.append(sint.get_input_from(0))\n    \n    # Step 3: Initialize helper variables\n    can_buy = sint(1)      # 1 => can buy, 0 => cannot buy\n    net = sint(0)          # net value\n    orig_price = sint(0)   # remembers the price at which we last bought\n    \n    # Step 4: Execute the 'impatient merchant' logic\n    # We assume a loop up to 'n_plain'. Here, for demonstration, we do 'max_days'.\n    # If i >= n, the added conditions effectively do nothing because we never trade.\n    for i in range(max_days):\n        price = days[i]\n        \n        # Compute \"buy\" effect if can_buy == 1\n        # - We pay 'price' (net -> net - price), and store orig_price = price\n        # - If can_buy == 0, those terms are neutral.\n        buy_net = net - (can_buy * price)\n        new_orig_price = (can_buy * price) + ((1 - can_buy) * orig_price)\n        \n        # Compute \"sell\" condition:\n        #  Only allowed to sell if can_buy == 0 and price > orig_price.\n        #  Let cond = (1 - can_buy) * (price > orig_price).\n        cond = (1 - can_buy) * price.gth(new_orig_price)\n        \n        # If cond == 1, net -> net + price, and can_buy -> 1\n        sell_net = buy_net + (cond * price)\n        \n        # New 'can_buy' = old can_buy + 1 if cond == 1, or 0 if we triggered a buy\n        # But more simply:\n        #  - we set can_buy to 0 if we just bought (by setting it to 1 - can_buy)\n        #    minus (buy action triggers can_buy to 0), but we already used buy_net logic\n        #  - we set can_buy to 1 if we just sold\n        # A direct formula is: can_buy_next = can_buy + cond - (can_buy * 1_onA_buy)\n        # Here we do: can_buy was 1 => buy, so next is 0. can_buy was 0 => we might sell => next is cond. \n        # Combining:\n        can_buy_next = (can_buy - can_buy) + cond  # or simply: cond if buy happened, else cond\n\n        # Update everything for the next iteration\n        net = sell_net\n        orig_price = new_orig_price\n        can_buy = can_buy_next\n    \n    # Step 5: Reveal the final result\n    # The merchant's net is in 'net'. We typically reveal it.\n    reveal(net).print_ln(\"Net value the impatient merchant can earn: %s\", [net])\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1):\n        a[n-1-i] = a[n-2-i]\n    a[0] = temp\n    return a\n", "response_1": "def array_shift(a):\n    n = len(a)\n    temp = a[n - 1]\n    for i in range(n - 1):\n        a[n - i - 1] = a[n - i - 2]\n    a[0] = temp\n    return a\n", "model_name": "azure-openai-o1"}
{"test_name": "array_double", "response_0": "# In MP-SPDZ, each element in arr is typically s_int (secret integer).\n# This function doubles all elements in the array of secret integers.\ndef array_double(arr):\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "def array_double(A, n):\n    # Double all elements in the input array A of length n\n    for i in range(n):\n        A[i] = A[i] * 2\n", "model_name": "azure-openai-o1"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.types import sint\n\ndef stop_at_zero(sint_array):\n    cond = sint(1)\n    one = sint(1)\n    for i in range(len(sint_array)):\n        is_zero = sint_array[i].equal(sint(0))\n        # Increment only if cond is still 1 and current element is non-zero\n        sint_array[i] = sint_array[i] + cond * (one - is_zero)\n        # Update cond to 0 if a zero is encountered, remain 1 otherwise\n        cond = cond * (one - is_zero)\n    return sint_array\n", "response_1": "from Compiler.types import sint\n\ndef stop_at_zero(sarray):\n    stop_flag = sint(0)\n    for i in range(len(sarray)):\n        is_zero = sarray[i].equal(0)\n        stop_flag = stop_flag + is_zero - stop_flag * is_zero\n        sarray[i] = sarray[i] + (1 - stop_flag)\n    return sarray\n", "model_name": "azure-openai-o1"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input sbit array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = sbit(1) ^ arr[i]\n    return arr\n", "response_1": "def array_not(arr):\n    \"\"\"\n    Take the boolean opposite of all elements in the input array.\n    Note: in MP-SPDZ, if 'arr' holds boolean shares, use '1 - arr[i]' for each element.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = 1 - arr[i]\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_then_clip", "response_0": "# This MP-SPDZ code provides an equivalent implementation of the Python function \n# \"array_process_then_clip\". Note that MP-SPDZ does not support passing functions\n# as parameters, so you may redefine or inline any processing logic here.\n\n# Example placeholder for your processing function.\n# Replace this body with your actual processing logic.\ndef func(x):\n    # Here you can define how to process each element (e.g., multiply by a constant).\n    # For example: return 2 * x\n    return 2 * x\n\ndef array_process_then_clip(arr):\n    n = len(arr)\n    for i in range(n):\n        # Apply the processing function\n        arr[i] = func(arr[i])\n\n        # Clip values exceeding 10\n        arr[i] = (arr[i] > 10).if_else(10, arr[i])\n\n        # Clip values less than -10\n        arr[i] = (arr[i] < -10).if_else(-10, arr[i])\n    return arr\n", "response_1": "# This MP-SPDZ program demonstrates how to process each element in a secret array,\n# apply a user-defined function to it, then clip the result to [-10, 10].\n# Note: In MP-SPDZ, passing arbitrary function references is not supported.\n#       Here, the \"func\" is defined inline as a placeholder.\n\ndef array_process_then_clip(arr):\n    \"\"\"\n    Process all elements in the array with an inline function, \n    then clip the outcome in the range [-10,10].\n    \"\"\"\n    def func(x):\n        # Replace this function body with the desired operation\n        return x\n\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        arr[i] = if_else(arr[i] > 10, sfix(10), arr[i])\n        arr[i] = if_else(arr[i] < -10, sfix(-10), arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "add_and_count_positive", "response_0": "# In MP-SPDZ, we can represent the array elements and k as secure integers (sint).\n# Below is a direct translation of the Python function into an MP-SPDZ function\n# where arithmetic and comparisons operate on secure data types:\n\ndef add_and_count_positive(array, k):\n    n = len(array)\n    count = sint(0)\n    for i in range(n):\n        array[i] = array[i] + k\n        # Compare with zero (returns a secure bit). Summing it up yields the final count.\n        cond = array[i] > 0\n        count += cond\n    return array, count\n", "response_1": "from Compiler.types import sint\n\ndef add_and_count_positive(array, k):\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        is_positive = array[i] > 0\n        count = count + is_positive\n    return array, count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    from Compiler.types import sint\n\n    len_a = len(a)\n    len_b = len(b)\n    \n    if len_a > len_b:\n        ret = [sint(0) for _ in range(len_a)]\n        for i in range(len_b):\n            ret[i] = a[i] - b[i]\n        for i in range(len_a - len_b):\n            ret[len_b + i] = a[len_b + i]\n        return ret\n    else:\n        ret = [sint(0) for _ in range(len_b)]\n        for i in range(len_a):\n            ret[i] = a[i] - b[i]\n        for i in range(len_b - len_a):\n            ret[len_a + i] = sint(0) - b[len_a + i]\n        return ret\n", "response_1": "def array_subtract(a, b):\n    from Compiler.types import sint\n    la = len(a)\n    lb = len(b)\n    if la > lb:\n        ret = [sint(0) for _ in range(la)]\n        for i in range(lb):\n            ret[i] = a[i] - b[i]\n        for i in range(la - lb):\n            ret[lb + i] = a[lb + i]\n        return ret\n    else:\n        ret = [sint(0) for _ in range(lb)]\n        for i in range(la):\n            ret[i] = a[i] - b[i]\n        for i in range(lb - la):\n            ret[la + i] = -b[la + i]\n        return ret\n\ndef main():\n    pass\n", "model_name": "azure-openai-o1"}
{"test_name": "lower_bound", "response_0": "# MP-SPDZ translation of the Python lower_bound function\n\n# Note:\n# 1. This translation uses 'sint' for secret-shared integers and 'cint' for clear integers.\n# 2. The logic uses secure comparisons and conditional assignments (if_else) for secrecy.\n# 3. We use MemValue for storing and updating intermediate results inside a loop.\n\nfrom Compiler.types import sint, cint, if_else, MemValue\n\ndef lower_bound(arr, x):\n    ret = MemValue(sint(-1))\n    distance = MemValue(sint(0))\n    found = MemValue(sint(0))\n\n    n = len(arr)\n    for i in range(n):\n        # cond checks if arr[i] <= x\n        cond = arr[i].less_equal(x)\n\n        # found0 checks if we haven't found any valid element\n        found0 = found.read().equal_to(0)\n\n        # little checks if (x - arr[i]) is smaller than the current distance\n        difference = x - arr[i]\n        little = difference.less_than(distance.read())\n\n        # betterCond captures \"not found yet or we found a smaller distance\"\n        betterCond = found0 + little - (found0 * little)\n\n        # go indicates if we update ret/distance/found at this iteration\n        go = cond * betterCond\n\n        ret.write(if_else(go, cint(i), ret.read()))\n        distance.write(if_else(go, difference, distance.read()))\n        found.write(if_else(go, sint(1), found.read()))\n\n    return ret.read()\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef lower_bound(arr, x):\n    n = len(arr)\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n    for i in range(n):\n        cond1 = arr[i] <= x\n        tdist = x - arr[i]\n        cond2 = found.eq(0).if_else(sint(1), tdist < distance)\n        cond = cond1 * cond2\n        ret = cond.if_else(sint(i), ret)\n        distance = cond.if_else(tdist, distance)\n        found = cond.if_else(sint(1), found)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "argmin", "response_0": "from Compiler.types import sint\n\ndef argmin(a):\n    # a is a list of secret-shared integers (sint)\n    current = a[0]\n    index = sint(0)\n    for i in range(1, len(a)):\n        cmp_result = a[i] < current\n        index = cmp_result.if_else(i, index)\n        current = cmp_result.if_else(a[i], current)\n    return index\n", "response_1": "from Compiler.types import sint\n\ndef argmin(a):\n    current = a[0]\n    index = sint(0)\n    for i in range(1, len(a)):\n        cond = current.less_equal(a[i])\n        index = cond.if_else(index, sint(i))\n        current = cond.if_else(current, a[i])\n    return index\n", "model_name": "azure-openai-o1"}
{"test_name": "independent_robbery", "response_0": "# Independent Robbery in MP-SPDZ\n\n# To run this code in MP-SPDZ, you typically would place it in a file (e.g. indy_robbery.mpc)\n# and then invoke the MP-SPDZ compiler and runtime accordingly.\n \n# We assume the input is provided as follows:\n# 1) The first input is the number of houses n.\n# 2) Then n house values follow consecutively.\n#\n# This example expects player 0 to provide all inputs, but it can be adapted\n# for multiple players if needed by changing the get_input_from calls.\n\nfrom Compiler.types import sint\nfrom Compiler.library import if_else, reveal\n\ndef main():\n    # Read the number of houses\n    n = sint.get_input_from(0)\n    \n    # Prepare the list of house values\n    houses = []\n    for _ in range(reveal(n)):\n        houses.append(sint.get_input_from(0))\n    \n    # Prepare the dp array\n    dp = [sint(0) for _ in range(reveal(n))]\n    \n    # Base cases for the dp array\n    dp[0] = houses[0]\n    cmp_first = houses[1] >= dp[0]\n    dp[1] = if_else(cmp_first, houses[1], dp[0])\n\n    # Fill dp using the same recurrence as in Python:\n    # dp[i] = max(dp[i-1], dp[i-2] + houses[i])\n    for i in range(2, reveal(n)):\n        candidate = dp[i-2] + houses[i]\n        cmp_val = candidate >= dp[i-1]\n        dp[i] = if_else(cmp_val, candidate, dp[i-1])\n\n    # Finally reveal the result dp[n-1] and print it\n    # This is the maximum amount we can rob without robbing two adjacent houses\n    reveal(dp[reveal(n) - 1]).print_reg()\n", "response_1": "from Compiler.types import sint\nfrom Compiler.types import Array\n\ndef independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem:\n    The robber wants to rob some houses along a street, each of which has some amount of money in it (guaranteed to be nonnegative). \n    The robber cannot rob two consecutive houses, we want to know the max amount of money he can get. \n    The number of houses is guaranteed to be no smaller than 3.\n    \"\"\"\n    n = len(houses)\n    dp = Array(n, sint)\n    # Initialize dp array with 0\n    for i in range(n):\n        dp[i] = sint(0)\n    \n    # Translate the same logic from Python code\n    dp[0] = houses[0]\n    dp[1] = (dp[1] >= dp[0]).if_else(dp[1], dp[0])\n    \n    for i in range(2, n):\n        cond = (dp[i-2] + houses[i]) >= dp[i-1]\n        dp[i] = cond.if_else(dp[i-2] + houses[i], dp[i-1])\n    \n    return dp[n-1]\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_odd_and_odd", "response_0": "", "response_1": "def sum_odd_and_odd(arr):\n    s = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            s = s + arr[j]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "is_monotonous", "response_0": "# is_monotonous.mpc\n\n# We read the size of the array as a secret integer.\nn = sint.get_input_from(0)\n\n# We then read the array elements as secret fixed-point values.\narr = [sfix.get_input_from(0) for _ in range(n)]\n\n# We keep a secret integer flag that indicates whether\n# the array is (still) strictly monotonous.\nis_monotonous = sint(1)\n\n# We keep track of the previous difference in a secret fixed-point.\nd = sfix(0)\n\n# We iterate over the array to compare consecutive differences.\nfor i in range(n - 1):\n    diff = arr[i + 1] - arr[i]\n    # We check the product of consecutive differences only after i>0.\n    if i > 0:\n        # Compare (diff * d) <= 0 securely.\n        cond = (diff * d <= 0)\n        # If this condition is true, we set is_monotonous to zero.\n        is_monotonous = is_monotonous * (1 - cond)\n    # Update the last difference.\n    d = diff\n\n# Reveal the result and print it.\nprint_ln('%s', is_monotonous.reveal())\n", "response_1": "def is_monotonous(arr):\n    # Here arr is assumed to be a list of secure numeric values (e.g., sfix).\n    # The function will produce a secure bit (1/True or 0/False) indicating\n    # whether arr is strictly monotonous.\n    \n    d = sfix(0)\n    ret = sbit(1)\n    \n    for i in range(len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        # Because i is a public integer, we can use a plain Python if to skip\n        # checking for the first iteration. For i>0, we do a secure check:\n        if i > 0:\n            # Check if (diff * d) <= 0\n            cond = (diff * d).less_equal(0)\n            # If cond is True, that means the sequence is no longer strictly monotonous:\n            ret = ret & ~cond\n        d = diff\n    \n    # ret is 1 (True) if strictly monotonous, 0 (False) otherwise\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    # Initialize counters as secret shared integers\n    count = sint(0)\n    neg_sum = sint(0)\n\n    # Iterate over the array\n    for item in arr:\n        # Increment count if item > 0\n        count = count + (item > 0)\n        # Add to negative sum if item < 0\n        neg_sum = neg_sum + item * (item < 0)\n\n    return count, neg_sum\n", "response_1": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    count = sint(0)\n    neg_sum = sint(0)\n    for x in arr:\n        is_pos = x > 0\n        is_neg = x < 0\n        count = count + is_pos\n        neg_sum = neg_sum + x * is_neg\n    return count, neg_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_even", "response_0": "def sum_even(arr):\n    s = sint(0)\n    for item in arr:\n        is_even = (item % 2) == 0\n        s = s + (item * is_even)\n    return s\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "one_norm", "response_0": "from Compiler.types import sfix\n\ndef one_norm(vec):\n    total = sfix(0)\n    for item in vec:\n        total = total + item.abs()\n    return total\n", "response_1": "from Compiler.types import sfix\n\ndef one_norm(vec):\n    total = sfix(0)\n    for item in vec:\n        total = total + item.abs()\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "array_floor", "response_0": "# mp-spdz code translating the Python function:\n# def array_floor(arr):\n#     import math\n#     ret = [0 for i in range(len(arr))]\n#     for i in range(len(arr)):\n#         ret[i] = math.floor(arr[i])\n#     return ret\n\n# In MP-SPDZ, we represent secret-shared fixed-point values via sfix.\n# The code below implements the proper floor (i.e., rounding down) \n# for both non-negative and negative values.\n\nfrom Compiler.types import sfix, Array, sint\nfrom Compiler.library import for_range\n\ndef array_floor(secret_arr):\n    length = len(secret_arr)\n    result = Array(length, sfix)\n\n    @for_range(length)\n    def _(i):\n        x = secret_arr[i]\n        # Trunc() removes the fractional part by rounding toward zero\n        truncated = x.Trunc()\n        # Compute the fractional part\n        fractional_part = x - truncated\n        # Check sign of x (secret comparison)\n        is_negative = x < 0\n        # Check if fractional part is non-zero\n        frac_nonzero = fractional_part != 0\n        # For negative inputs with fractional != 0, subtract 1\n        result[i] = truncated - (is_negative * frac_nonzero)\n\n    return result\n", "response_1": "# MP-SPDZ code\n# This code replicates the Python \"array_floor\" function, returning the floor of each element in arr.\n# The function returns an array of secret integers (sint), ensuring correct floor behavior for negative values.\n\nfrom Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\ndef array_floor(arr):\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # Truncation towards zero\n        truncated = arr[i].Trunc()\n        # Fractional part: arr[i] - truncated\n        fractional = arr[i] - sfix(truncated)\n        # Check if fractional part is non-zero\n        is_frac = fractional != 0\n        # Check if value is negative\n        is_neg = arr[i] < 0\n        # If negative and fractional != 0 => subtract 1\n        adjust = is_frac & is_neg\n        ret[i] = truncated - adjust\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "three_five", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef three_five(arr):\n    \"\"\"\n    If the input array contain both/neither 3 and/or 5, return 1 (True),\n    otherwise return 0 (False).\n    \"\"\"\n    has3 = sint(0)\n    has5 = sint(0)\n    for item in arr:\n        eq3 = (item == 3)\n        eq5 = (item == 5)\n        # 'OR' using a + b - a*b (valid for values in {0,1})\n        has3 = has3 + eq3 - has3 * eq3\n        has5 = has5 + eq5 - has5 * eq5\n\n    # (has3 and has5) or ((not has3) and (not has5))\n    return (has3 * has5) + ((1 - has3) * (1 - has5))\n", "model_name": "azure-openai-o1"}
{"test_name": "num_above_average", "response_0": "from Compiler.types import sint\n\ndef num_above_average(n, arr):\n    s = sint(0)\n    c = sint(0)\n    \n    # Calculate the sum of all elements\n    for i in range(n):\n        s = s + arr[i]\n    \n    # Compute the average\n    avg = s / n\n    \n    # Count how many elements are >= average\n    for i in range(n):\n        c = c + (arr[i] >= avg)\n    \n    # Return the count\n    return c\n", "response_1": "from Compiler.types import sfix\n\ndef num_above_average(arr):\n    # Compute the sum of elements\n    total_sum = sfix(0)\n    n = len(arr)\n    for i in range(n):\n        total_sum = total_sum + arr[i]\n    # Compute the average\n    avg = total_sum / n\n    \n    # Count how many elements are >= average\n    count = sfix(0)\n    for i in range(n):\n        cond = arr[i] >= avg\n        count = count + cond.if_else(sfix(1), sfix(0))\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound, lower_bound):\n    for i in range(len(arr)):\n        cond_lower = arr[i] < lower_bound\n        arr[i] = cond_lower.if_else(lower_bound, arr[i])\n\n        cond_upper = arr[i] > upper_bound\n        arr[i] = cond_upper.if_else(upper_bound, arr[i])\n\n    return arr\n", "response_1": "from Compiler.types import sfix\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = (arr[i] < lower_bound).if_else(lower_bound, arr[i])\n        arr[i] = (arr[i] > upper_bound).if_else(upper_bound, arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "from Compiler.types import sint\n\ndef sum_with_certain_element_skipped(array):\n    s = sint(0)\n    for i in range(len(array)):\n        new_sum = s + array[i]\n        cond = (new_sum >= 5) * (new_sum <= 10)\n        s = s + (1 - cond) * array[i]\n    return s\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_with_certain_element_skipped(arr):\n    s = sint(0)\n    for i in range(len(arr)):\n        temp = s + arr[i]\n        c1 = temp.greater_equal(5)\n        c2 = temp.less_equal(10)\n        skip_condition = c1 * c2     # 1 if 5 <= temp <= 10, else 0\n        s = s + (1 - skip_condition) * arr[i]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be secret-shared integers.\n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        is_odd = item & sint(1)\n        odd_sum += item * is_odd\n        even_sum += item * (sint(1) - is_odd)\n    return odd_sum, even_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr):\n    # arr is a list (or array) of secure integers (sint) in MP-SPDZ\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        is_odd = item & 1  # Equivalent to item % 2 for secure integers\n        odd_sum += item * is_odd\n        even_sum += item * (1 - is_odd)\n    return odd_sum, even_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "distance", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt_sfix\n\ndef distance(vec1, vec2):\n    # Initialize the accumulator as a secret-shared fixed-point\n    sum_squares = sfix(0)\n    \n    # We assume vec1 and vec2 are lists or arrays of sfix\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        sum_squares += diff * diff\n    \n    # Return the square root of the sum of squares\n    return sqrt_sfix(sum_squares)\n", "response_1": "from Compiler.types import sfix\n\ndef distance(vec1, vec2):\n    # Initialize a secure fixed-point accumulator.\n    s = sfix(0)\n    # Accumulate the squares of differences.\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        s += diff * diff\n    # Return the secure square root of the sum.\n    return s.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "num_occurrence", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef num_occurrence(arr, target):\n    # arr: list of sint\n    # target: sint\n    count = sint(0)\n    for i in range(len(arr)):\n        count = count + (arr[i] == target)\n    return count\n", "response_1": "def num_occurrence(arr, target):\n    # arr is a list of secret integers (sint).\n    # target is a secret integer (sint).\n    # returns the number of occurrences as a secret integer (sint).\n    \n    length = len(arr)\n    count = sint(0)\n    for i in range(length):\n        eq = (arr[i] == target)\n        count += eq\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "palindrome", "response_0": "def palindrome(arr):\n    # Check whether the secure array is a palindrome.\n    n = len(arr)\n    flag = sbit(1)        # Initialize a secret bit to True (1)\n    for i in range(n):\n        # Compare symmetric positions and update the flag\n        flag &= (arr[i] == arr[n - 1 - i])\n    return flag           # Returns a secret bit (1 if palindrome, 0 otherwise)\n", "response_1": "# MP-SPDZ code\nfrom Compiler.types import sint\n\ndef palindrome(arr):\n    # arr: list of secure integers (sint)\n    n = len(arr)\n    flag = sint(1)\n    for i in range(n):\n        eq = (arr[i] == arr[n - 1 - i])\n        flag = flag * eq\n    return flag\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr, length):\n    \"\"\"\n    Count the number of reverse order pairs in the secret-shared array.\n    \"\"\"\n    # Initialize the counter as a secret integer.\n    num = sint(0)\n\n    # Nested loops for pairwise comparison.\n    for i in range(length):\n        for j in range(i + 1, length):\n            # Compare arr[i] and arr[j] and convert secret bit to secret int (0 or 1).\n            num = num + (arr[i] > arr[j]).if_else(1, 0)\n\n    # Return the final count of reverse order pairs.\n    return num\n", "response_1": "def reverse_order_pair(arr):\n    from Compiler.types import sint\n    num = sint(0)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            num += arr[i].gt(arr[j])\n    return num\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_of_cubes", "response_0": "# In MP-SPDZ, we declare data as secure types (e.g., sfix or sint).\n# Below is one way to translate the sum_of_cubes function from the original Python snippet.\n\ndef sum_of_cubes(arr):\n    # Initialize a secure fixed-point variable or integer variable\n    ret = sfix(0)\n    # Compute the sum of cubes\n    for item in arr:\n        ret = ret + (item * item * item)\n    return ret\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "max_element", "response_0": "def max_element(a):\n    # a is an array of secure integers (e.g., sint) in MP-SPDZ\n    current = a[0]\n    for i in range(1, len(a)):\n        cond = current >= a[i]\n        current = cond.if_else(current, a[i])\n    return current\n", "response_1": "def max_element(a):\n    current = a[0]\n    for i in range(1, len(a)):\n        is_bigger = a[i] >= current\n        current = is_bigger.if_else(a[i], current)\n    return current\n", "model_name": "azure-openai-o1"}
{"test_name": "array_if_else", "response_0": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array,\n    if the predicator returns True (a secure bit),\n    then apply the if-function to the element,\n    otherwise apply the else-function to the element.\n    \"\"\"\n    for i in range(len(arr)):\n        condition = predicator(arr[i])\n        arr[i] = condition.if_else(if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "response_1": "# array_if_else.mpc\n# This file shows how one might translate the Python \"array_if_else\" functionality into MP-SPDZ.\n# Note: predicator should return an sbit (or equivalent) representing the boolean result.\n\nfrom Compiler.types import sfix, sbit\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    n = len(arr)\n    for i in range(n):\n        # Evaluate the condition using predicator\n        condition = predicator(arr[i])  # Should produce an sbit\n\n        # Secure \"if-else\" corresponds to if_else in MP-SPDZ\n        arr[i] = condition.if_else( if_func(arr[i]), else_func(arr[i]) )\n\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "inf_norm", "response_0": "def inf_norm(vec):\n    # Initialize the running maximum to zero (in sfix form).\n    max_val = sfix(0)\n    \n    # Iterate over the vector to compute the infinite norm.\n    for item in vec:\n        # Compute the absolute value of the current item using if_else.\n        abs_item = (item >= sfix(0)).if_else(item, -item)\n        # Update max_val if abs_item is larger.\n        max_val = (max_val >= abs_item).if_else(max_val, abs_item)\n    \n    # Return the result as the infinite norm.\n    return max_val\n", "response_1": "def inf_norm(vec):\n    s = sfix(0)\n    for item in vec:\n        a = item.abs()\n        cond = s >= a\n        s = cond.if_else(s, a)\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "array_inc", "response_0": "from Compiler.types import sint\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1 (in an MP-SPDZ program).\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + sint(1)\n    return arr\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "count_rises", "response_0": "def count_rises_sint(arr):\n    # arr is a list/array of secret-shared ints (s_int) in MP-SPDZ\n    count = s_int(0)\n    for i in range(len(arr) - 1):\n        # Compare consecutive secret-shared values (returns s_bit in MP-SPDZ)\n        cond = (arr[i] < arr[i + 1])\n        # Accumulate the number of rises\n        count = count + cond\n    return count\n", "response_1": "def count_rises(arr, n):\n    s_count = sint(0)\n    for i in range(n - 1):\n        s_count = s_count + (arr[i] < arr[i + 1])\n    return s_count\n", "model_name": "azure-openai-o1"}
{"test_name": "skip_at_zero", "response_0": "def skip_at_zero(array):\n    # Add 1 to all elements in the array, but skip if an element equals 0\n    n = len(array)\n    for i in range(n):\n        is_zero = array[i].equal(0)\n        array[i] = array[i] + (1 - is_zero)\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef skip_at_zero(array):\n    for i in range(len(array)):\n        # Determine if array[i] equals 0 (returns a secret bit)\n        zero_flag = array[i].is_zero()\n        # Conditionally add 1 only when array[i] != 0\n        array[i] = array[i] + zero_flag.if_else(sint(0), sint(1))\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_intersect", "response_0": "def array_intersect(p, q):\n    found = s_bit(0)\n    for i in range(len(p)):\n        for j in range(len(q)):\n            found = found | (p[i] == q[j])\n    return found\n", "response_1": "from Compiler.types import sint\n\ndef array_intersect(p, q):\n    found = sint(0)\n    for i in range(len(p)):\n        for j in range(len(q)):\n            found = found + (p[i] == q[j])\n    return found > 0\n", "model_name": "azure-openai-o1"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    s = sfix(0)\n    for item in vec:\n        s = s + (item * item)\n    return s.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector using MP-SPDZ.\n    \"\"\"\n    sum_of_squares = sfix(0)\n    for item in vec:\n        sum_of_squares = sum_of_squares + (item * item)\n    return sum_of_squares.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_between", "response_0": "from Compiler.types import sint\n\ndef sum_between(arr, l, u):\n    s = sint(0)\n    for item in arr:\n        cond1 = item >= l\n        cond2 = item <= u\n        s = s + item * cond1 * cond2\n    return s\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "largest_gap", "response_0": "def largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    Here, 'arr' is a list of secure integers (sint) in MP-SPDZ.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    n = len(arr)\n    diffs = []\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        diffs.append(diff.abs())\n    max_diff = diffs[0]\n    for i in range(1, len(diffs)):\n        max_diff = smax(max_diff, diffs[i])\n    return max_diff\n", "response_1": "from Compiler.types import sint, MemValue\nfrom Compiler.library import if_else, for_range\n\ndef largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array (arr is an array of sint).\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    n = len(arr)\n    cur = MemValue(sint(0))\n    @for_range(n - 1)\n    def compute_gap(i):\n        diff = arr[i + 1] - arr[i]\n        abs_diff = if_else(diff < 0, -diff, diff)\n        cond = abs_diff > cur.read()\n        cur.write(if_else(cond, abs_diff, cur.read()))\n    return cur.read()\n", "model_name": "azure-openai-o1"}
{"test_name": "totally_dominate", "response_0": "from Compiler.types import sint\nfrom Compiler.types import sbit\n\ndef totally_dominate(a, b):\n    # a, b are arrays of sint\n    amin = a[0]\n    bmax = b[0]\n    for i in range(1, len(a)):\n        c = a[i] < amin\n        amin = c.if_else(a[i], amin)\n    for i in range(1, len(b)):\n        c = b[i] > bmax\n        bmax = c.if_else(b[i], bmax)\n    return amin >= bmax\n", "response_1": "from Compiler.types import sint\n\ndef totally_dominate(a, b):\n    amin = a[0]\n    for i in range(1, len(a)):\n        # Secure minimum\n        is_less = a[i] < amin\n        amin = is_less.if_else(a[i], amin)\n    bmax = b[0]\n    for i in range(1, len(b)):\n        # Secure maximum\n        is_greater = b[i] > bmax\n        bmax = is_greater.if_else(b[i], bmax)\n    # Secure comparison\n    return amin >= bmax\n", "model_name": "azure-openai-o1"}
{"test_name": "element_count", "response_0": "def element_count(arr, target):\n    n = len(arr)\n    ret = sint(0)\n    for i in range(n):\n        ret = ret + (arr[i] == target)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    ret = sint(0)\n    for item in arr:\n        # 'item == target' yields a secret-shared comparison result (sint)\n        ret = ret + (item == target)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "is_subarray", "response_0": "def is_subarray(c, d):\n    \"\"\"\n    Return whether the first array (c) is a continuous subarray of the second array (d),\n    implemented in MP-SPDZ. The result is a secure integer with value 1 if c is a subarray\n    of d, and 0 otherwise.\n    \"\"\"\n    found = sint(0)\n    for i in range(len(d)):\n        if i + len(c) <= len(d):\n            subarray_flag = sint(1)\n            for j in range(len(c)):\n                subarray_flag = subarray_flag * (c[j] == d[i + j])\n            # We update 'found' by logically OR-ing it with 'subarray_flag'\n            found = found + subarray_flag - found * subarray_flag\n    return found\n", "response_1": "from Compiler.types import sint\n\ndef is_subarray(c, d):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    Both c and d are lists (or arrays) of secure types (e.g., sint).\n    \"\"\"\n    found = sint(0)\n    n = len(d)\n    m = len(c)\n    for i in range(n):\n        # Public comparison on lengths\n        if m <= n - i:\n            flag = sint(1)\n            for j in range(m):\n                # Secure comparison for each pair of elements\n                flag = flag * (d[i + j].equal(c[j]))\n            # Accumulate if a match is found\n            found = found + flag\n    # Return a secret boolean (1 if any match is found, 0 otherwise)\n    return found != 0\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import s_bool\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array (list of secret integers) contains 5 or 7.\n    \"\"\"\n    found = s_bool(0)\n    for item in arr:\n        condition_5 = (item == 5)\n        condition_7 = (item == 7)\n        found = found | condition_5 | condition_7\n    return found\n", "response_1": "from Compiler.types import sint, sbit\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7 in MP-SPDZ.\n    \"\"\"\n    result = sbit(0)\n    for item in arr:\n        check_5_or_7 = (item == 5) + (item == 7)\n        result = result.bit_or(check_5_or_7)\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "variance", "response_0": "def variance(arr):\n    # arr is assumed to be a list of sfix or similar secure data type.\n    # MP-SPDZ does not automatically know the length of the list, \n    # so the length is typically determined beforehand or managed manually.\n    n = len(arr)                # In MP-SPDZ, this may require a static value or manual collection.\n    avg = sfix(0)\n    var = sfix(0)\n\n    # Compute mean\n    for i in range(n):\n        avg = avg + arr[i] / n\n\n    # Compute variance\n    for i in range(n):\n        diff = arr[i] - avg\n        var = var + (diff * diff) / n\n\n    return var\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "is_ascending", "response_0": "def is_ascending(arr):\n    n = len(arr)\n    if n <= 1:\n        return sint(1)\n    res = sint(1)\n    for i in range(n - 1):\n        # This comparison returns a secure int (0 or 1).\n        # Multiplying accumulates the overall check.\n        res = res * (arr[i] < arr[i + 1])\n    return res\n", "response_1": "from Compiler.types import sbit, sint\n\ndef is_ascending(arr):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, the function returns True.\n    \"\"\"\n    n = len(arr)\n    # Start with a default of True\n    result = sbit(1)\n\n    # If n == 1, the loop won't run and 'result' remains True.\n    for i in range(n - 1):\n        # Compare adjacent elements\n        condition = arr[i] < arr[i + 1]\n        result = result & condition\n\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "xor_all", "response_0": "# In MP-SPDZ, we can define a function that takes an array of secure bits (sbit)\n# and returns the XOR of all elements in the array.\n# Assume that 'arr' is a list/array of secure bits (sbit) each holding 0 or 1.\n# The following function demonstrates a direct translation of the Python code.\n\nfrom Compiler.types import sbit\n\ndef xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "upper_bound", "response_0": "def orBit(a, b):\n    # Logical OR for secret bits: returns 1 if either a or b is 1, else 0\n    return a + b - a * b\n\ndef upper_bound(arr, x):\n    # arr: secret shared array of sfix (or another secret integer type)\n    # x: secret shared value of sfix (or another secret integer type)\n    # Returns a secret shared integer index of the smallest element in arr\n    # that is strictly greater than x, or -1 if no such element exists.\n\n    ret = sint(-1)       # Store final index\n    distance = sfix(0)   # Store smallest gap between arr[i] and x\n    found = sint(0)      # 0 if nothing found yet, 1 after first find\n\n    n = len(arr)\n    for i in range(n):\n        cond1 = (arr[i] > x)\n        cond2 = orBit((found == 0), (arr[i] - x) < distance)\n        cond = cond1 * cond2\n\n        # Update ret if cond is true\n        ret = cond * i + (sint(1) - cond) * ret\n\n        # Update distance if cond is true\n        distance = sfix.cond_swap(cond, distance, arr[i] - x)\n\n        # Once found is 1, it remains 1\n        found = orBit(found, cond)\n\n    return ret\n", "response_1": "def upper_bound(arr, x, n):\n    # Initialize return index, distance, and found flag as secure integers\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n\n    for i in range(n):\n        # Check if arr[i] > x\n        cond1_sbit = arr[i].gt(x)\n        cond1_sint = cond1_sbit.if_else(1, 0)\n\n        # Compare arr[i] - x with distance\n        diff = arr[i] - x\n        cond2_sbit = diff.lt(distance)\n        cond2_sint = cond2_sbit.if_else(1, 0)\n\n        # Update condition if arr[i] > x and (not found or diff < distance)\n        update_cond = cond1_sint * ((1 - found) + found * cond2_sint)\n\n        # Conditionally update ret, distance, and found\n        ret = update_cond * i + (1 - update_cond) * ret\n        distance = update_cond * diff + (1 - update_cond) * distance\n        found = update_cond + (1 - update_cond) * found\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_then_sum", "response_0": "def array_process_then_sum(arr, f):\n    # Initialize a secret integer accumulator.\n    acc = sint(0)\n    \n    # Iterate over array, apply the given function, then sum.\n    for i in range(len(arr)):\n        arr[i] = f(arr[i])\n        acc = acc + arr[i]\n    \n    # Return the final sum.\n    return acc\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "average", "response_0": "def average(arr):\n    s = sfix(0)\n    length = len(arr)\n    for i in range(length):\n        s = s + arr[i]\n    ret = s / sfix(length)\n    return ret\n", "response_1": "def average(arr):\n    ssum = sfix(0)\n    length = len(arr)\n    for i in range(length):\n        ssum = ssum + arr[i]\n    ret = ssum / sfix(length)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_filter", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sfix, sbit, Array\n\ndef array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array,\n    if the predicator returns 1 (true), preserve the element,\n    otherwise set the element to 0.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Here, predicator should return an sbit indicating\n        # whether arr[i] should be preserved (1) or filtered (0).\n        arr[i] = arr[i] * predicator(arr[i])\n    return arr\n", "response_1": "def array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array,\n    if the predicator returns 1 (true),\n    then preserve the element,\n    otherwise set it to 0.\n    \"\"\"\n    for i in range(len(arr)):\n        # predicator(arr[i]) should return a secret bit (0 or 1)\n        arr[i] = arr[i] * predicator(arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_up", "response_0": "def sum_up(array):\n    s = sint(0)\n    for num in array:\n        s = s + num\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_up(array):\n    s = sint(0)\n    for num in array:\n        s = s + num\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_to_zero", "response_0": "def negative_to_zero(arr):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    arr is assumed to be a list of secret integers (sint) in MP-SPDZ\n    \"\"\"\n    for i in range(len(arr)):\n        # (arr[i] >= 0) securely compares arr[i] with 0 and returns 1 if true, 0 otherwise\n        arr[i] = arr[i] * (arr[i] >= 0)\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef negative_to_zero(array, length):\n    # Turn the negative secret-shared elements in the array to zero\n    for i in range(length):\n        is_negative = (array[i] < 0)\n        # If is_negative is True, replace with 0, else keep array[i]\n        array[i] = is_negative.if_else(sint(0), array[i])\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_only_positive_to_ten", "response_0": "# sum_only_positive_to_ten.mpc\n\n# In MP-SPDZ, direct \"break\" and \"continue\" statements inside loops\n# driven by secret data may not work as expected for secure data\n# (they are handled only at compile time). Below is a direct translation\n# assuming array elements and the sum are known at compile time or\n# considered public. If the array elements and sum are secret, a more\n# complex rewriting (avoiding data-dependent control flow) is needed.\n\ndef sum_only_positive_to_ten(array):\n    # Initialize an integer sum to zero (use 'sint' if array is secret)\n    s = 0\n\n    # Loop through the array\n    for i in range(len(array)):\n        # Skip non-positive elements\n        if array[i] <= 0:\n            continue\n\n        # Stop if sum already 10 or more\n        if s >= 10:\n            break\n\n        # Accumulate\n        s = s + array[i]\n\n    # Return the partial sum\n    return s\n", "response_1": "from Compiler.types import sfix\n\ndef sum_only_positive_to_ten(n, array):\n    # 'array' is assumed to be a list of secure sfix values.\n    # This function sums only the positive elements until the partial sum reaches at least 10,\n    # and then stops adding further elements.\n    s = sfix(0)\n    stop = sfix(0)  # 0 means \"continue summation\", 1 means \"stop\"\n    for i in range(n):\n        # Only add array[i] if not stopped yet and array[i] > 0.\n        cond = (1 - stop) * (array[i] > 0)\n        s = s + (array[i] * cond)\n        # Update 'stop' to 1 if sum has reached or exceeded 10.\n        stop = stop + ((1 - stop) * (s >= 10))\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "bubble_sort", "response_0": "from Compiler.types import sint\n\ndef bubble_sort_sint(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            cond = arr[j] >= arr[j + 1]\n            temp = arr[j]\n            arr[j] = arr[j] + cond * (arr[j + 1] - arr[j])\n            arr[j + 1] = arr[j + 1] + cond * (temp - arr[j + 1])\n    return arr\n", "response_1": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            swap_cond = arr[j] >= arr[j + 1]\n            temp = arr[j]\n            arr[j] = swap_cond.if_else(arr[j + 1], arr[j])\n            arr[j + 1] = swap_cond.if_else(temp, arr[j + 1])\n    return arr\n", "model_name": "azure-openai-o1"}
