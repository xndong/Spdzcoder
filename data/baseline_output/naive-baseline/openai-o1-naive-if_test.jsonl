{"test_name": "sin_or_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sin, cos\n\ndef sin_or_cos(x):\n    # If x is nonnegative, return sin(x), otherwise return cos(x).\n    cond = (x >= sfix(0))\n    return cond.if_else(sin(x), cos(x))\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "negative_relu", "response_0": "from Compiler.types import sfix\n\ndef negative_relu(x):\n    comparison = x < 0\n    return comparison.if_else(x, sfix(0))\n", "response_1": "def negative_relu(x):\n    cond = x < 0\n    return cond.if_else(x, sfix(0))\n", "model_name": "azure-openai-o1"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two secret inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    diff = a - b\n    abs_diff = diff.abs()\n    return abs_diff <= 1\n", "response_1": "def is_close(a, b):\n    # Return whether or not the two inputs are close: their absolute difference <= 1\n    diff = a - b\n    sign = diff < 0\n    # If diff < 0, pick -diff, else diff\n    abs_diff = sign.if_else(-diff, diff)\n    return abs_diff <= 1\n", "model_name": "azure-openai-o1"}
{"test_name": "hardswish", "response_0": "# Hardswish function in MP-SPDZ\n# Returns 0 if x < -3, x if x > 3, otherwise x*(x+3)/6\ndef hardswish(x):\n    c1 = x < sfix(-3)\n    c2 = x > sfix(3)\n    return c1.if_else(sfix(0), c2.if_else(x, x * (x + sfix(3)) / sfix(6)))\n", "response_1": "from Compiler.types import sfix\n\ndef hardswish(x):\n    temp = (x > sfix(3)).if_else(x, x * (x + sfix(3)) / sfix(6))\n    return (x < sfix(-3)).if_else(sfix(0), temp)\n", "model_name": "azure-openai-o1"}
{"test_name": "clip_at_6", "response_0": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    # Compare x with 6\n    cond_above_6 = x > 6\n    # Compare x with -6\n    cond_below_neg_6 = x < -6\n    # If x > 6, clip to 6; else if x < -6, clip to -6; else x\n    val_after_upper_clip = cond_above_6.if_else(sfix(6), x)\n    clipped_val = cond_below_neg_6.if_else(sfix(-6), val_after_upper_clip)\n    return clipped_val\n", "response_1": "def clip_at_6(x):\n    six = sfix(6)\n    neg_six = sfix(-6)\n    temp = x\n\n    # Clip if x > 6\n    temp = (six * (x > six)) + (x * (x <= six))\n\n    # Clip if x < -6\n    temp = (neg_six * (temp < neg_six)) + (temp * (temp >= neg_six))\n\n    return temp\n", "model_name": "azure-openai-o1"}
{"test_name": "piecewise_function", "response_0": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    cond1 = x > sfix(1)\n    ret = cond1.if_else(x, sfix(0))\n    cond2 = cond1.not_() & (x < sfix(-1))\n    ret = cond2.if_else(x, ret)\n    cond3 = (cond1.not_() & cond2.not_()) & (x > sfix(0))\n    ret = cond3.if_else(sfix(1), ret)\n    cond4 = (cond1.not_() & cond2.not_() & cond3.not_()) & (x < sfix(0))\n    ret = cond4.if_else(sfix(-1), ret)\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    return (x > sfix(1)).if_else(\n        x,\n        (x < sfix(-1)).if_else(\n            x,\n            (x > sfix(0)).if_else(\n                sfix(1),\n                (x < sfix(0)).if_else(sfix(-1), sfix(0))\n            )\n        )\n    )\n", "model_name": "azure-openai-o1"}
{"test_name": "middle", "response_0": "from Compiler.types import sfix\n\ndef middle(a, b, c):\n    cond1 = a >= b\n    temp = cond1.if_else(a, b)\n    a = cond1.if_else(b, a)\n    b = temp\n\n    cond2 = b >= c\n    temp = cond2.if_else(b, c)\n    b = cond2.if_else(c, b)\n    c = temp\n\n    cond3 = a >= b\n    temp = cond3.if_else(a, b)\n    a = cond3.if_else(b, a)\n    b = temp\n\n    return b\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef middle(a: sint, b: sint, c: sint) -> sint:\n    # Compare a and b, swap if a >= b\n    cond_ab = a >= b\n    a_new = if_else(cond_ab, b, a)\n    b_new = if_else(cond_ab, a, b)\n    a, b = a_new, b_new\n\n    # Compare b and c, swap if b >= c\n    cond_bc = b >= c\n    b_new = if_else(cond_bc, c, b)\n    c_new = if_else(cond_bc, b, c)\n    b, c = b_new, c_new\n\n    # Compare a and b again after potential swap\n    cond_ab2 = a >= b\n    a_new = if_else(cond_ab2, b, a)\n    b_new = if_else(cond_ab2, a, b)\n    a, b = a_new, b_new\n\n    return b\n", "model_name": "azure-openai-o1"}
{"test_name": "indicated_sin_or_cos", "response_0": "def indicated_sin_or_cos(x, ind):\n    # x is a secure type (e.g., sfix or sfloat)\n    # ind is a secure bit or 0/1 in a secure type (e.g., sfix or sbit)\n    sin_val = x.sin()\n    cos_val = x.cos()\n    return ind * sin_val + (1 - ind) * cos_val\n", "response_1": "# indicated_sin_or_cos.mpc\n# MP-SPDZ translation of the Python function:\n# def indicated_sin_or_cos(x, ind):\n#     import math\n#     if ind:\n#         return math.sin(x)\n#     return math.cos(x)\n\nfrom Compiler.types import sfix\n\ndef indicated_sin_or_cos(x: sfix, ind: sfix):\n    # Compute sine and cosine of x\n    sin_x = x.sin()\n    cos_x = x.cos()\n    # Return sin(x) if ind == 1, otherwise cos(x)\n    return sin_x * ind + cos_x * (1 - ind)\n", "model_name": "azure-openai-o1"}
{"test_name": "minus2_if_else", "response_0": "from Compiler.types import sfix\n\ndef minus2_if_else(x):\n    cond = (x - sfix(2)) >= sfix(0)\n    return cond.if_else(x - sfix(2), x)\n", "response_1": "from Compiler.types import sint\n\ndef minus2_if_else(x):\n    # x is a secure integer\n    # We check if x >= 2 (in secure domain),\n    # then subtract 2 if true, else return x.\n    cond = (x >= 2)\n    return cond.if_else(x - 2, x)\n", "model_name": "azure-openai-o1"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    is_less_than_zero = x < 0\n    non_negative = is_less_than_zero.if_else(0, x)\n    is_greater_than_six = non_negative > 6\n    capped_at_six = is_greater_than_six.if_else(6, non_negative)\n    return capped_at_six\n", "response_1": "def relu6(x):\n    zero = sfix(0)\n    six = sfix(6)\n    x_pos = (x < zero).if_else(zero, x)\n    x_clipped = (x_pos > six).if_else(six, x_pos)\n    return x_clipped\n", "model_name": "azure-openai-o1"}
{"test_name": "exp_slide", "response_0": "def exp_slide(x):\n    # x is an sfix variable\n    condition = (x >= 0)\n    return condition.if_else(x.exp(), x + 1)\n", "response_1": "from Compiler.types import sfix\n\ndef exp_slide(x: sfix):\n    # Secure \"if\" evaluation\n    cond = x >= 0\n    # If x >= 0, compute e^x using x.exp(); otherwise x + 1\n    return cond.if_else(x.exp(), x + sfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "pass_or_not", "response_0": "from Compiler.types import sint, sbit\n\ndef pass_or_not(score: sint):\n    comparison_result = score >= 60\n    adjusted_score = comparison_result.if_else(score, sint(59))\n    passed = comparison_result\n    return adjusted_score, passed\n", "response_1": "# pass_or_not.mpc\n#\n# You are a professor, and your student asks you whether she has passed the exam.\n# If she passed (score >= 60), you should return her actual score and True (indicating that she has passed).\n# If she did not pass, you should return that her score is 59 and False.\n\ndef pass_or_not(score):\n    cond = (score >= sfix(60))\n    adjusted_score = cond_select(cond, score, sfix(59))\n    return adjusted_score, cond\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    disc = b * b - 4 * a * c\n    disc_pos = disc > 0\n    disc_eq = disc == 0\n\n    result_if_a_is_not_0 = disc_pos.if_else(2, disc_eq.if_else(1, 0))\n\n    eq_a_zero = a == 0\n    eq_b_zero = b == 0\n    result_if_a_is_0 = eq_b_zero.if_else(0, 1)\n\n    return eq_a_zero.if_else(result_if_a_is_0, result_if_a_is_not_0)\n", "response_1": "from Compiler.types import cint\n\ndef how_many_roots(a, b, c):\n    # Direct translation of the Python logic using public (cint) variables\n    if a == 0:\n        if b == 0:\n            return cint(0)\n        else:\n            return cint(1)\n    discriminant = b * b - 4 * a * c\n    if discriminant > 0:\n        return cint(2)\n    elif discriminant == 0:\n        return cint(1)\n    else:\n        return cint(0)\n\ndef main():\n    # Reading three public integer inputs\n    a = cint.get_input_from(0)\n    b = cint.get_input_from(0)\n    c = cint.get_input_from(0)\n    \n    # Print the result (public)\n    print_ln('%s', how_many_roots(a, b, c))\n", "model_name": "azure-openai-o1"}
{"test_name": "elu", "response_0": "# elu.mpc\nfrom Compiler.types import sfix\ndef elu(x):\n    return (x > sfix(0)).if_else(x, sfix.exp(x) - sfix(1))\n", "response_1": "from Compiler.library import if_else\nfrom Compiler.types import sfix\n\ndef elu(x):\n    return if_else(x > sfix(0), x, x.exp() - sfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "relu", "response_0": "def relu(x):\n    # ReLU function in MP-SPDZ\n    return (x > 0) * x\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    # x and alpha are secure fixed-point values (sfix)\n    cond = x > 0\n    return cond.if_else(x, alpha * x)\n", "response_1": "from Compiler.types import sfix\n\ndef leaky_relu(x: sfix, alpha: sfix):\n    is_positive = x > sfix(0)\n    return x * is_positive + (alpha * x) * (1 - is_positive)\n", "model_name": "azure-openai-o1"}
{"test_name": "max", "response_0": "from Compiler.types import sint\n\ndef secure_max(a: sint, b: sint) -> sint:\n    c = a >= b\n    return c * a + (1 - c) * b\n", "response_1": "def max(a, b):\n    # Return the maximum value of the two inputs in MP-SPDZ\n    cond = a >= b\n    return cond.if_else(a, b)\n", "model_name": "azure-openai-o1"}
{"test_name": "bowl_shape", "response_0": "from Compiler.types import sfix\n\ndef bowl_shape(x):\n    one = sfix(1)\n    minus_one = sfix(-1)\n    cond1 = (x > one)\n    cond2 = (x < minus_one)\n    return cond1.if_else(x - one, cond2.if_else(-x - one, sfix(0)))\n", "response_1": "from Compiler.types import sfix\n\ndef bowl_shape(x):\n    # Compare x with 1 and -1 using secure comparisons\n    # (x > sfix(1)) is 1 if x > 1, otherwise 0\n    # (x < sfix(-1)) is 1 if x < -1, otherwise 0\n\n    return (x > sfix(1)) * (x - sfix(1)) \\\n         + (x < sfix(-1)) * ((-x) - sfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "rounded_kinetic_energy", "response_0": "# In MP-SPDZ, floating-point operations are usually performed \n# with the sfix or sfloat type. Below is a direct translation \n# of the Python function into an MP-SPDZ style program.\n\ndef rounded_kinetic_energy(m, v):\n    # Compute m*v^2/2\n    k = m * (v * v) / 2\n    \n    # Obtain the integer part by flooring k.\n    k_int = sfix.Trunc(k, 0, True)  \n    \n    # Compare the fractional part to 0.5.\n    fractional_part = k - k_int\n    condition = fractional_part < sfix(0.5)\n    \n    # Return the integer part or integer part + 1 based on the comparison.\n    return sfix.if_else(condition, k_int, k_int + sfix(1))\n", "response_1": "# MP-SPDZ code translating the rounded kinetic energy calculation.\n# This uses sfix for secret-shared fixed-point arithmetic\n# and manually implements rounding by comparing the fractional part to 0.5.\n\ndef rounded_kinetic_energy(m, v):\n    # Compute k = m*v^2/2 using sfix arithmetic\n    k = m * (v * v) / 2\n    # Truncate to get floor(k)\n    k_int = k.trunc()\n    # Extract fractional part: k - floor(k)\n    frac = k - k_int\n    # Determine whether the fractional part is >= 0.5\n    is_greater = frac.gte(0.5)\n    # Add 1 if frac >= 0.5, else add 0\n    return k_int + is_greater\n", "model_name": "azure-openai-o1"}
{"test_name": "danger_test", "response_0": "from Compiler.types import sint, sbit, cint\nfrom Compiler.library import reveal\n\ndef danger_test(origin: sint, damage: sint) -> sbit:\n    return (origin - damage) <= cint(10)\n\ndef main():\n    origin = sint.get_input_from(0)\n    damage = sint.get_input_from(0)\n    result = danger_test(origin, damage)\n    reveal(result).print_reg()\n", "response_1": "from Compiler.types import sint\n\n# Securely read the initial health (origin) and the damage\norigin = sint.get_input_from(0)\ndamage = sint.get_input_from(0)\n\n# Calculate health left and check if it is no more than 10\nhealth_left = origin - damage\ndanger_bit = health_left.less_equal(10)\n\n# Reveal the result (0 or 1)\ndanger_result = danger_bit.reveal()\nprint_ln('%s', danger_result)\n", "model_name": "azure-openai-o1"}
{"test_name": "indicated_sum_or_multiply", "response_0": "from Compiler.types import sint, sbit\n\ndef indicated_sum_or_multiply(x: sint, y: sint, ind: sbit):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the two inputs.\n    \"\"\"\n    return ind.if_else(x + y, x * y)\n", "response_1": "from Compiler.types import sbit, sint\n\ndef indicated_sum_or_multiply(x, y, ind):\n    # ind is a secret bit (sbit).\n    # x and y are secret-shared integers (sint).\n    # We cannot use a direct Python if-statement on secret-shared bits.\n    # Instead, we use the if_else method:\n    return ind.if_else(x + y, x * y)\n", "model_name": "azure-openai-o1"}
{"test_name": "median", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else, for_range\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i - 1):\n            swap = arr[j] > arr[j+1]\n            tmp = arr[j]\n            arr[j] = if_else(swap, arr[j+1], arr[j])\n            arr[j+1] = if_else(swap, tmp, arr[j+1])\n    return arr\n\ndef median(arr):\n    \"\"\"\n    Returns the median of 'arr' in MP-SPDZ style. \n    Note: Avoids explicit exception throwing for empty arrays.\n    \"\"\"\n    n = len(arr)\n    sorted_arr = bubble_sort(arr)\n    half = n // 2\n    is_odd = n % 2\n    ret_if_odd = sorted_arr[half]\n    ret_if_even = (sorted_arr[half] + sorted_arr[half - 1]) / sfix(2)\n    return if_else(is_odd, ret_if_odd, ret_if_even)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.sorting import merge_sort\n\ndef median(arr):\n    # Ensure the array is non-empty. In MP-SPDZ, we cannot raise a traditional error;\n    # typically, we would assert this in practice or handle it differently.\n    n = len(arr)\n    if n == 0:\n        # Minimal fallback; in actual usage, a runtime check or secure protocol-specific handling would be needed.\n        return sfix(0)\n\n    # Sort the array securely\n    sorted_arr = merge_sort(arr)\n\n    # Compute the median\n    mid_index = n // 2\n    if (n % 2) == 1:\n        return sorted_arr[mid_index]\n    else:\n        return (sorted_arr[mid_index] + sorted_arr[mid_index - 1]) / sfix(2)\n", "model_name": "azure-openai-o1"}
{"test_name": "add_upto_10", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef add_upto_10(a: sint, b: sint) -> sint:\n    s = a + b\n    condition = s > 10\n    return if_else(condition, 10, s)\n", "response_1": "# Return the value of a+b, if the sum exceeds 10, clip it to 10.\n# MP-SPDZ translation:\n# Here \"a\" and \"b\" should be secure data types (e.g., sfix or sint).\n# The if_else construct is used for secure conditionals.\ndef add_upto_10(a, b):\n    s = a + b\n    cond = s > sfix(10)\n    return cond.if_else(sfix(10), s)\n", "model_name": "azure-openai-o1"}
{"test_name": "taxi_fare", "response_0": "# File: taxi_fare.mpc\n\n# We define a function taxi_fare that takes\n# a secret fixed-point number m and returns\n# the secret taxi fare accordingly.\ndef taxi_fare(m):\n    # Boolean-like secret conditions\n    c1 = m <= sfix(5)     # True if m <= 5\n    c2 = m <= sfix(10)    # True if m <= 10\n\n    # Potential return values based on conditions\n    tmp1 = sfix(5)                                # if m <= 5\n    tmp2 = sfix(5) + sfix(1.2) * (m - sfix(5))     # if 5 < m <= 10\n    tmp3 = sfix(11) + sfix(1.5) * (m - sfix(10))   # if  m > 10\n\n    # Combine them using conditional selection\n    # if(c1) return tmp1\n    # else if(c2) return tmp2\n    # else return tmp3\n    return c1.if_else(tmp1, c2.if_else(tmp2, tmp3))\n\n# Securely read the input from player 0\nm = sfix.get_input_from(0)\n\n# Compute the taxi fare\nfare = taxi_fare(m)\n\n# Reveal the result to all parties\nprint_ln(\"The fare is: %s\", fare.reveal())\n", "response_1": "# taxi_fare.mpc\n\n# Import library for secure fixed-point type\nfrom Compiler.types import sfix\n\n# Read input (securely) from player 0\nm = sfix.get_input_from(0)\n\n# Compute the taxi fare:\n# if m <= 5: 5\n# else if m <= 10: 5 + 1.2*(m-5)\n# else: 11 + 1.5*(m-10)\nres = (m <= 5).if_else(\n    sfix(5),\n    (m <= 10).if_else(\n        sfix(5) + sfix(1.2)*(m - sfix(5)),\n        sfix(11) + sfix(1.5)*(m - sfix(10))\n    )\n)\n\n# Output the result\nprint_float_plain(res)\n", "model_name": "azure-openai-o1"}
{"test_name": "round", "response_0": "from Compiler.types import sfix\n\ndef secure_round(x):\n    x_int = x.floor()\n    diff = x - x_int\n    cond = diff < sfix(0.5)\n    return x_int + sfix.if_else(cond, sfix(0), sfix(1))\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef sfix_round(x):\n    x_int = x.floor()\n    cond = (x - x_int) < sfix(0.5)\n    return if_else(cond, x_int, x_int + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "gpa_calculator", "response_0": "# MP-SPDZ code translating the given Python GPA calculator logic.\n\n# We use sfix (secret fixed-point type) for the score and result.\n\ndef gpa_calculator(score):\n    cond1 = score >= sfix(90)\n    cond2 = score >= sfix(85)\n    cond3 = score >= sfix(80)\n    cond4 = score >= sfix(75)\n    cond5 = score >= sfix(70)\n    return cond1.if_else(\n        sfix(4.0),\n        cond2.if_else(\n            sfix(3.6),\n            cond3.if_else(\n                sfix(3.3),\n                cond4.if_else(\n                    sfix(3.0),\n                    cond5.if_else(sfix(2.6), sfix(2.3))\n                )\n            )\n        )\n    )\n\ndef main():\n    score = sfix.get_input_from(0)  # Secret input from party 0\n    gpa_value = gpa_calculator(score)\n    # Output or further processing as needed:\n    gpa_value.reveal().print_float()  # Reveal and print the computed GPA\n", "response_1": "from Compiler.types import sfix\n\ndef gpa_calculator(score):\n    cond1 = (score >= 90)\n    cond2 = (score >= 85) * (score < 90)\n    cond3 = (score >= 80) * (score < 85)\n    cond4 = (score >= 75) * (score < 80)\n    cond5 = (score >= 70) * (score < 75)\n    cond6 = (score >= 0)  * (score < 70)\n    return cond1 * sfix(4.0) \\\n         + cond2 * sfix(3.6) \\\n         + cond3 * sfix(3.3) \\\n         + cond4 * sfix(3.0) \\\n         + cond5 * sfix(2.6) \\\n         + cond6 * sfix(2.3)\n", "model_name": "azure-openai-o1"}
{"test_name": "sign", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0.\n    If x is zero, return 0.\n    \"\"\"\n    return if_else(x == 0, sint(0), if_else(x > 0, sint(1), sint(-1)))\n", "response_1": "from Compiler.types import sint\n\ndef sign(x):\n    zero = (x == 0)\n    positive = (x > 0)\n    return zero.if_else(sint(0), positive.if_else(sint(1), sint(-1)))\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_or_difference", "response_0": "# Step 1: Define secure integer inputs for a and b\na = sint.get_input_from(0)\nb = sint.get_input_from(0)\n\n# Step 2: Evaluate the condition a <= b\ncond = (a <= b)\n\n# Step 3: Compute sum and difference\ntmp_sum = a + b\ntmp_diff = a - b\n\n# Step 4: Select sum if condition is true, otherwise difference\nres = cond.if_else(tmp_sum, tmp_diff)\n\n# (Optional) Step 5: Store the final result\nres.store_in_mem(0)\n", "response_1": "from Compiler.types import sint\n\ndef sum_or_difference(a: sint, b: sint) -> sint:\n    comparison_result = a <= b\n    return comparison_result * (a + b) + (1 - comparison_result) * (a - b)\n", "model_name": "azure-openai-o1"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in an MP-SPDZ context. We assume both\n    control_bit and flip_bit are boolean shares (e.g., sbit).\n    \"\"\"\n    return control_bit * (1 - flip_bit) + (1 - control_bit) * flip_bit\n", "response_1": "def CNOT(control_bit, flip_bit):\n    # In MP-SPDZ, use XOR for flipping the target bit if the control bit is 1\n    return control_bit ^ flip_bit\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_plus1", "response_0": "from Compiler.types import sint\n\ndef negative_plus1(y: sint) -> sint:\n    cond = y < 0\n    return cond.if_else(y + 1, y)\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    in MP-SPDZ, y is a secret integer (sint).\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    is_neg = y < zero\n    return y + is_neg * one\n", "model_name": "azure-openai-o1"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler.types import sint\n\ndef same(x, y):\n    return (x[0] == y[0]) * (x[1] == y[1])\n\ndef is_a_parallelogram(a, b, c, d):\n    eqAB = same(a, b)\n    eqAC = same(a, c)\n    eqAD = same(a, d)\n    eqBC = same(b, c)\n    eqBD = same(b, d)\n    eqCD = same(c, d)\n\n    repeated = eqAB + eqAC + eqAD + eqBC + eqBD + eqCD\n\n    cond1 = ((a[0] + b[0]) == (c[0] + d[0])) * ((a[1] + b[1]) == (c[1] + d[1]))\n    cond2 = ((a[0] + c[0]) == (b[0] + d[0])) * ((a[1] + c[1]) == (b[1] + d[1]))\n    cond3 = ((a[0] + d[0]) == (b[0] + c[0])) * ((a[1] + d[1]) == (b[1] + c[1]))\n\n    parallelogram = (cond1 + cond2 + cond3) > 0\n    return (repeated == 0) * parallelogram\n", "response_1": "# This MP-SPDZ program reads four 2D vertices (a, b, c, d) from party 0\n# and computes whether they form a parallelogram, outputting 1 for True or 0 for False.\n\n# Each coordinate is taken as a secret-shared integer (sint).\na0 = sint.get_input_from(0)\na1 = sint.get_input_from(0)\nb0 = sint.get_input_from(0)\nb1 = sint.get_input_from(0)\nc0 = sint.get_input_from(0)\nc1 = sint.get_input_from(0)\nd0 = sint.get_input_from(0)\nd1 = sint.get_input_from(0)\n\n# Checks if two points (x0, x1) and (y0, y1) are the same.\ndef same(x0, x1, y0, y1):\n    eq_x = x0.equal(y0)  # sbit: 1 if x0 == y0 else 0\n    eq_y = x1.equal(y1)  # sbit: 1 if x1 == y1 else 0\n    return eq_x & eq_y   # sbit: 1 if both eq_x, eq_y are 1; else 0\n\n# Compute if any pair of points is exactly the same (which invalidates parallelogram).\nsameAB = same(a0, a1, b0, b1)\nsameAC = same(a0, a1, c0, c1)\nsameAD = same(a0, a1, d0, d1)\nsameBC = same(b0, b1, c0, c1)\nsameBD = same(b0, b1, d0, d1)\nsameCD = same(c0, c1, d0, d1)\n\n# Sum up the bit results into an sint to check if any equals 1.\n# (Using + on sbit returns sint in MP-SPDZ.)\nany_repeat_sum = sameAB + sameAC + sameAD + sameBC + sameBD + sameCD\n# Convert to sbit: 1 if any_repeat_sum > 0, else 0.\nany_repeat = (any_repeat_sum > sint(0))\n\n# Check parallelogram condition:\n# 1) a+b == c+d, or\n# 2) a+c == b+d, or\n# 3) a+d == b+c\n#\n# Evaluate each pair of sums on both x- and y-coordinates, returning sbit.\ncheck1 = ((a0 + b0).equal(c0 + d0)) & ((a1 + b1).equal(c1 + d1))\ncheck2 = ((a0 + c0).equal(b0 + d0)) & ((a1 + c1).equal(b1 + d1))\ncheck3 = ((a0 + d0).equal(b0 + c0)) & ((a1 + d1).equal(b1 + c1))\n\n# If any of the three checks is true, we get an sbit result of 1.\nparallelogram_check = check1 | check2 | check3\n\n# Final result:\n# 0 if repeated points are found, or\n# (1 if no repeat) & parallelogram_check otherwise.\nresult = (sbit(1) - any_repeat) & parallelogram_check\n\n# Reveal result (1 for parallelogram, 0 for not a parallelogram)\nprint_ln(\"Parallelogram check result: %s\", result.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "min", "response_0": "def min(a, b):\n    c = (a <= b)\n    return c * a + (1 - c) * b\n", "response_1": "def min(a, b):\n    cond = a <= b\n    return cond.if_else(a, b)\n", "model_name": "azure-openai-o1"}
{"test_name": "choice_of_the_knight", "response_0": "# You can place the following code in an MP-SPDZ file (e.g., knight.mpc).\n# This code defines a secure \"choice_of_the_knight\" function that \n# calculates how many valid moves a knight can make on an 8\u00d78 chessboard.\n\nfrom Compiler.types import sint\n\ndef legal(a, b):\n    # Each comparison (>=, <=) returns a secure boolean (sbit),\n    # and multiplying them together acts like an AND operation.\n    return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\ndef choice_of_the_knight(x, y):\n    # x and y are expected to be secure integers of MP-SPDZ (sint).\n    counter = sint(0)\n    counter = counter + legal(x + 1, y + 2)\n    counter = counter + legal(x - 1, y + 2)\n    counter = counter + legal(x + 1, y - 2)\n    counter = counter + legal(x - 1, y - 2)\n    counter = counter + legal(x + 2, y + 1)\n    counter = counter + legal(x - 2, y + 1)\n    counter = counter + legal(x + 2, y - 1)\n    counter = counter + legal(x - 2, y - 1)\n    return counter\n", "response_1": "from Compiler.types import sint, sbit, if_else, cint\n\ndef legal(a, b):\n    # Checks if both coordinates are in the range [0,7]\n    return (a >= cint(0)) & (a <= cint(7)) & (b >= cint(0)) & (b <= cint(7))\n\ndef choice_of_the_knight(x, y):\n    # x and y are expected to be private (sint) or public (cint) integers\n    counter = sint(0)\n    counter = counter + if_else(legal(x + 1, y + 2), cint(1), cint(0))\n    counter = counter + if_else(legal(x - 1, y + 2), cint(1), cint(0))\n    counter = counter + if_else(legal(x + 1, y - 2), cint(1), cint(0))\n    counter = counter + if_else(legal(x - 1, y - 2), cint(1), cint(0))\n    counter = counter + if_else(legal(x + 2, y + 1), cint(1), cint(0))\n    counter = counter + if_else(legal(x - 2, y + 1), cint(1), cint(0))\n    counter = counter + if_else(legal(x + 2, y - 1), cint(1), cint(0))\n    counter = counter + if_else(legal(x - 2, y - 1), cint(1), cint(0))\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "max_sum_difference", "response_0": "# In MP-SPDZ, values are stored in secure types (e.g., sfix).\n# This example uses sfix for demonstration.\n\nfrom Compiler.types import sfix\n\ndef max_sum_different(a, b):\n    cond = (a + b) > (a - b)\n    return cond.if_else(a + b, a - b)\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef max_sum_different(a: sint, b: sint):\n    sum_ = a + b\n    diff = a - b\n    cond = sum_ > diff\n    return if_else(cond, sum_, diff)\n", "model_name": "azure-openai-o1"}
