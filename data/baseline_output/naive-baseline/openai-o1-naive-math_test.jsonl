{"test_name": "next_integer", "response_0": "from Compiler.types import sfix\n\ndef floor_sfix(x):\n    truncated = x.trunc()               # Truncation toward zero\n    difference = x - truncated          # Observe any fractional part\n    is_neg = x < 0                      # Check if x is negative\n    is_diff = 1 - difference.is_zero()  # 1 if there is a fractional part, else 0\n    correction = is_neg * is_diff       # Subtract 1 only if negative and fractional\n    return truncated - correction\n\ndef next_integer(t):\n    # Return the minimum integer strictly bigger than t\n    return floor_sfix(t) + 1\n", "response_1": "# Return the minimum integer strictly bigger than the input value.\n# Assumes 't' is an sfix (secret fixed-point) value.\n\nfrom Compiler.types import sfix\n\ndef next_integer(t):\n    floor_t = t.trunc()  # truncate towards 0 (floor for non-negative t)\n    return floor_t + 1\n", "model_name": "azure-openai-o1"}
{"test_name": "father_and_son", "response_0": "", "response_1": "# Input secret-shared ages as sint from party 0\nfather_age = sint.get_input_from(0)\nson_age = sint.get_input_from(0)\n\n# Define the function to compute the absolute difference\ndef father_and_son(father_age, son_age):\n    diff = father_age - son_age * 2\n    # Implement absolute value using conditional\n    abs_diff = (diff >= 0).if_else(diff, -diff)\n    return abs_diff\n\n# Compute result and reveal\nresult = father_and_son(father_age, son_age)\nresult.reveal().print_reg()\n", "model_name": "azure-openai-o1"}
{"test_name": "triangle_area", "response_0": "from Compiler.types import sfix\n\ndef triangle_area(side: sfix, height: sfix):\n    return (side * height) / sfix(2)\n", "response_1": "# MP-SPDZ code snippet translating the Python function:\n# def triangle_area(side, height):\n#     return side * height / 2\n\n# In MP-SPDZ, we typically use secure fixed-point types (sfix) for arithmetic:\ndef triangle_area(side, height):\n    return side * height / sfix(2)\n", "model_name": "azure-openai-o1"}
{"test_name": "sin_plus_cos", "response_0": "from Compiler.library import sin, cos\nfrom Compiler.types import sfix\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a)+cos(a)\n    \"\"\"\n    return sin(a) + cos(a)\n\ndef main():\n    # Read 'a' as secret-shared input (from party 0, for example)\n    a = sfix.get_input_from(0)\n    res = sin_plus_cos(a)\n    # Reveal the result to all parties\n    res.reveal_to_all()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sin_fx, cos_fx\n\ndef sin_plus_cos(a):\n    # Return sin(a) + cos(a)\n    return sin_fx(a) + cos_fx(a)\n\ndef main():\n    # Read secret-shared input from player 0\n    a = sfix.get_input_from(0)\n    # Compute sin(a)+cos(a)\n    result = sin_plus_cos(a)\n    # Output the result\n    result.output()\n", "model_name": "azure-openai-o1"}
{"test_name": "sigmoid", "response_0": "from Compiler.types import sfix\n\ndef sigmoid(x):\n    # Translated sigmoid function for MP-SPDZ\n    return sfix(1) / (sfix(1) + sfix.exp(-x))\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    return sfix(1) / (sfix(1) + exp(-x))\n", "model_name": "azure-openai-o1"}
{"test_name": "self_exponent", "response_0": "from Compiler.types import sint\n\ndef self_exponent(k: sint):\n    # Return the exponent k^k using secure integers in MP-SPDZ\n    return k ** k\n", "response_1": "# MP-SPDZ code translating the Python self_exponent(k) = k^k\n# using integer exponentiation by squaring for a secret-shared (sint) k.\n\ndef self_exponent(k):\n    one = sint(1)\n    res = one\n    base = k\n    e = k\n    # Loop assumes a 32-bit exponent, adjust as needed\n    for _ in range(32):\n        bit = e & 1\n        # Choose base if bit=1, else 1\n        masked_base = one + (base - one) * bit\n        res = res * masked_base\n        base = base * base\n        e = e >> 1\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "silu", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef silu(x: sfix) -> sfix:\n    # SiLU(x) = x / (1 + exp(-x))\n    return x / (sfix(1) + exp(-x))\n", "response_1": "from Compiler.types import sfix\n\ndef silu(x):\n    return x / (sfix(1) + sfix.exp(-x))\n", "model_name": "azure-openai-o1"}
{"test_name": "Gaussian_bracket", "response_0": "from Compiler.types import sfix\n\ndef Gaussian_bracket(x: sfix) -> sfix:\n    # x_int represents the truncated integer part of x\n    x_int = x.trunc()\n    # Return the fractional part of x\n    return x - x_int\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import TruncPr, if_else\n\ndef floor_sfix(x):\n    # TruncPr(x, 0) truncates x toward zero (integer part), not always floor for negative x.\n    x_trunc = TruncPr(x, 0)\n    is_int = (x == x_trunc)\n    is_neg = (x < sfix(0))\n    # Subtract 1 only if x is negative and not already integral (to replicate math.floor).\n    sub_one = is_neg * (1 - is_int)\n    return x_trunc - sub_one\n\ndef Gaussian_bracket(x):\n    x_int = floor_sfix(x)\n    return x - x_int\n", "model_name": "azure-openai-o1"}
{"test_name": "asin_and_square", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef arcsin_approx(x):\n    # Polynomial approximation of arcsin(x) for x in [-1,1].\n    x3 = x * x * x\n    x5 = x3 * x * x\n    x7 = x5 * x * x\n    return x + x3/6 + (3*x5)/40 + (5*x7)/112\n\nx = sfix.get_input_from(0)\nres = arcsin_approx(x)\nres_sq = res * res\nprint_ln('Result of arcsin_and_square: %s', res_sq.reveal())\n", "response_1": "# asin_and_square.mpc\n\n# In MP-SPDZ, we generally implement transcendental functions such as arcsin\n# by using polynomial or series approximations. Below is a simple Maclaurin\n# series approximation for arcsin(x) valid for |x| \u2264 1, truncated for\n# demonstration purposes. The function then squares that approximate result.\n# Note: Higher degree approximations can improve accuracy.\n\nfrom Compiler.types import sfix\n\ndef arcsin_approx(x):\n    # Maclaurin series approximation of arcsin(x) up to x^7:\n    # arcsin(x) ~ x + (x^3)/6 + (3 x^5)/40 + (5 x^7)/112  ...\n    x2 = x * x\n    x3 = x2 * x\n    x5 = x3 * x2\n    x7 = x5 * x2\n\n    return x + (x3 * sfix(1.0/6)) + (x5 * sfix(3.0/40)) + (x7 * sfix(5.0/112))\n\ndef main():\n    # Read secure input\n    x = sfix.get_input_from(0)\n    \n    # Compute arcsin approximation\n    arc_val = arcsin_approx(x)\n    \n    # Square the result\n    result = arc_val * arc_val\n    \n    # Reveal (for demonstration) or securely use 'result' as needed\n    result.print_reveal()\n", "model_name": "azure-openai-o1"}
{"test_name": "cylinder_surface", "response_0": "from Compiler.types import sfix\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, \n    return its surface area in MP-SPDZ.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return 2 * pi * (r * r) + 2 * pi * r * h\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef main():\n    r = sfix.get_input_from(0)\n    h = sfix.get_input_from(0)\n    pi = sfix(3.14159)\n    surface_area = 2 * pi * (r * r) + 2 * pi * r * h\n    print_ln(\"%s\", surface_area.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "radian_to_degree", "response_0": "from Compiler.types import sfix\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree in MP-SPDZ\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return (r / pi) * sfix(180.0)\n", "response_1": "from Compiler.types import sfix\n\nPI = sfix(3.141592653589793)\n\ndef radian_to_degree(r):\n    return r / PI * sfix(180)\n", "model_name": "azure-openai-o1"}
{"test_name": "square_root", "response_0": "from Compiler.types import sfix\n\ndef square_root(a):\n    \"\"\"\n    Returns the square root of the secret fixed-point number 'a'.\n    \"\"\"\n    return a.sqrt()\n", "response_1": "def square_root(a):\n    \"\"\"\n    return the square root of the input.\n    \"\"\"\n    return a.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "cosine_theorem", "response_0": "from Compiler.types import sfix\n\ndef cosine_theorem(a: sfix, b: sfix, rad: sfix):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them,\n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    c = sfix.cos(rad)\n    return (a*a + b*b - 2*a*b*c).sqrt()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import cos, sqrt\n\ndef cosine_theorem(a, b, rad):\n    # Given two edges a, b and the angle rad between them,\n    # use cosine theorem to compute the length of the third edge.\n    return sqrt(a*a + b*b - sfix(2)*a*b*cos(rad))\n", "model_name": "azure-openai-o1"}
{"test_name": "lights_states", "response_0": "# lights_states.mpc\n\n# Step 1: Receive the public input \"num\" (number of lights) from party 0.\nnum = cint.get_input_from(0)\n\n# Step 2: Compute 2^num using a simple loop.\nres = 1\nfor i in range(num):\n    res *= 2\n\n# Step 3: Reveal and print the result (total number of possible states).\nres.reveal().print_stdout()\n", "response_1": "from Compiler.types import cint\n\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    return cint(2) ** num\n", "model_name": "azure-openai-o1"}
{"test_name": "degree_to_radian", "response_0": "from Compiler.types import sfix\n\ndef degree_to_radian(d):\n    return d / sfix(180) * sfix(3.141592653589793)\n", "response_1": "from Compiler.types import sfix\n\nPI = sfix(3.141592653589793)\n\ndef degree_to_radian(d):\n    return d / sfix(180) * PI\n", "model_name": "azure-openai-o1"}
{"test_name": "Fah_to_Cel", "response_0": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    return (F - sfix(32)) / sfix(1.8)\n", "response_1": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature \n    using the sfix (secure fixed-point) type in MP-SPDZ.\n    \"\"\"\n    return (F - sfix(32)) / sfix(1.8)\n", "model_name": "azure-openai-o1"}
{"test_name": "elliptic_area", "response_0": "# mp-spdz code for computing the area of an ellipse with semi-major axis a and semi-minor axis b\n\nfrom Compiler.types import sfix\nfrom Compiler.library import print_ln\n\n# Define inputs (secret-shared)\na = sfix.get_input_from(0)\nb = sfix.get_input_from(0)\n\n# Define pi as a fixed-point constant\npi = sfix(3.141592653589793)\n\n# Compute area\narea = pi * a * b\n\n# Reveal result\nprint_ln(\"%s\", area.reveal())\n", "response_1": "from Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    # Define PI as an sfix constant for MP-SPDZ\n    PI = sfix(3.141592653589793)\n    return PI * a * b\n", "model_name": "azure-openai-o1"}
{"test_name": "floor", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef floor(z):\n    # 1) Truncate toward zero to remove the fractional part\n    truncated = z.trunc()\n\n    # 2) Compute the fractional part\n    fraction = z - truncated\n\n    # 3) Determine if the input is negative (z < 0)\n    is_neg = z < 0\n\n    # 4) Determine if the fractional part is non-zero (fraction != 0)\n    has_fraction = fraction != 0\n\n    # 5) For negative z with a fractional part, subtract 1 to get floor\n    subtract_one = (is_neg * has_fraction).if_else(1, 0)\n\n    # 6) Return the result as a secret fixed-point number\n    return truncated - sfix(subtract_one)\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "log_and_cube", "response_0": "", "response_1": "from Compiler.types import sfix\n\ndef log_and_cube(x):\n    # Approximate 1.0 / ln(2) \u2248 1.4426950408889634\n    log_val = x.log() * sfix(1.4426950408889634)\n    return log_val * log_val * log_val\n", "model_name": "azure-openai-o1"}
{"test_name": "floor_and_square", "response_0": "from Compiler.types import sfix\n\ndef floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input.\n    Then return the square of that integer.\n    \"\"\"\n    # Truncate towards zero, stored in x.\n    x = z.trunc()\n\n    # frac_bit indicates whether z has a non-zero fractional part.\n    # (z == x) is a secure comparison, yielding a secure bit (1 if equal, else 0).\n    frac_bit = 1 - (z == x)\n\n    # sign_bit is 1 if z < 0 (secure bit), else 0 if z >= 0.\n    sign_bit = (z < 0)\n\n    # If z is negative and has a fractional part, subtract 1 from x.\n    floor_z = x - sign_bit * frac_bit\n    return floor_z * floor_z\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import comparison\n\ndef floor_sfix(x):\n    int_part = x.trunc()\n    frac = x - int_part\n    negative = x < 0\n    return int_part - comparison.if_else(negative & (frac != 0), sfix(1), sfix(0))\n\ndef floor_and_square(z):\n    \"\"\"\n    Returns the square of the floor of z.\n    \"\"\"\n    f = floor_sfix(z)\n    return f * f\n", "model_name": "azure-openai-o1"}
{"test_name": "meters_to_feet", "response_0": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * sfix(3.2808)\n", "response_1": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    return m * sfix(3.2808)\n", "model_name": "azure-openai-o1"}
{"test_name": "sphere_area", "response_0": "# MP-SPDZ code translating the Python sphere_area(r) function.\n# This version uses the sfix type for fixed-point arithmetic and predefines \u03c0 as a constant.\n\ndef sphere_area(r):\n    pi = sfix(3.141592653589793)\n    four = sfix(4)\n    return four * pi * r * r\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef sphere_area(r):\n    # Using a hard-coded value for pi in sfix format\n    pi_value = sfix(3.141592653589793)\n    return 4 * pi_value * r * r\n\ndef main():\n    # Read secret-shared input r (from player 0 for example)\n    r = sfix.get_input_from(0)\n    area = sphere_area(r)\n    # Reveal and print the result\n    print_ln(\"Sphere area: %s\", area.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "coarse_abs", "response_0": "from Compiler.types import sfix\n\ndef coarse_abs(x):\n    # Return the absolute value of x, and round it to zero.\n    return x.abs().trunc()\n", "response_1": "def coarse_abs(x):\n    # Use the built-in abs() method for secret-shared types, and then truncate\n    return x.abs().Trunc()\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_chickens", "response_0": "from Compiler.types import sint\nfrom Compiler.library import print_ln\n\n# Secure inputs for heads and legs\nheads = sint.get_input_from(0)\nlegs = sint.get_input_from(0)\n\n# Compute how many chickens\ntemp = legs - heads * 2\nchickens = heads - temp.sdiv(2)\n\n# Reveal the result\nprint_ln(\"%s\", [chickens.reveal()])\n", "response_1": "from Compiler.types import sint, cint\n\ndef how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    tmp = legs - heads * sint(2)\n    return heads - tmp.int_div(cint(2))\n", "model_name": "azure-openai-o1"}
{"test_name": "interest_calculator", "response_0": "# Step 1: Import relevant types or library functions for fixed-point and exponentiation\nfrom Compiler.types import sfix, sint\n\n# Optionally, import built-in exponentiation support for sfix\n# from Compiler.library import pow_fx  # Depending on your setup, you may need this\n\n# Step 2: Define the function to calculate interest\ndef interest_calculator(capital, ratio, months):\n    # Convert ratio to fixed-point if it is not already\n    # Convert months to sint if needed (it must be integral type)\n    \n    # Step 3: Compute (1 + ratio) to the power of months\n    exponent_result = (sfix(1) + ratio).pow(months)\n    \n    # Step 4: Subtract 1\n    interest_factor = exponent_result - sfix(1)\n    \n    # Step 5: Multiply by capital to get final interest\n    return interest_factor * capital\n\n# You can now use interest_calculator() in your secure computation as needed.\n", "response_1": "from Compiler.types import sfix\n\ndef interest_calculator(capital, ratio, months):\n    return ((sfix(1) + ratio) ** months - sfix(1)) * capital\n", "model_name": "azure-openai-o1"}
{"test_name": "circle_area", "response_0": "# Return the area of the circle with a given radius in MP-SPDZ.\n\nfrom Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef circle_area(r):\n    # Return the area of the circle with given radius.\n    pi = sfix(3.141592653589793)\n    return pi * (r * r)\n\n# Example translation of the original function usage in an MP-SPDZ program:\n# (Note: Not providing an external usage example, only the code itself.)\nr = sfix.get_input_from(0)\narea = circle_area(r)\nprint_ln(\"%s\", area.reveal())\n", "response_1": "from Compiler.types import sfix\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = sfix(3141592653) / sfix(1000000000)\n    return pi * r * r\n", "model_name": "azure-openai-o1"}
{"test_name": "cube_and_square_root", "response_0": "def cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    return (x * x * x).sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    return (x * x * x).sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "round", "response_0": "# In MP-SPDZ, you can approximate Python's `round` function for sfix as below:\n# Note: This example assumes `x` is an sfix type.\n\ndef sround(x):\n    x_floor = x.floor()                # Secure floor of x\n    diff = x - x_floor                 # Difference from floor\n    cond = diff.less_than(0.5)         # Compare with 0.5\n    return cond.if_else(x_floor, x_floor + 1)\n", "response_1": "from Compiler.types import sfix\n\ndef round_mp_spdz(x):\n    x_int = x.trunc()\n    diff = x - x_int\n    cond = diff < 0.5\n    return cond.if_else(x_int, x_int + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "cryptic_adjustment", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef cryptic_adjustment(origin):\n    return 10 * sqrt(10 * sqrt(origin))\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef cryptic_adjustment(origin):\n    # The adjustment formula: 10 * sqrt(10 * sqrt(origin))\n    return 10 * sqrt(10 * sqrt(origin))\n\ndef main():\n    # Retrieve secure input from player 0\n    origin = sfix.get_input_from(0)\n    # Compute adjusted score\n    adjusted_score = cryptic_adjustment(origin)\n    # Print result\n    adjusted_score.print_ln(\"Adjusted Score: %s\")\n", "model_name": "azure-openai-o1"}
{"test_name": "specific_pow", "response_0": "from Compiler.types import sfix\n\ndef specific_pow(x):\n    # x is assumed to be an sfix or compatible secure type\n    # x^(2.5) = x^(5/2) = sqrt(x^5)\n    return (x**5).sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef specific_pow(x):\n    # x^(2.5) = x^2 * sqrt(x)\n    return x * x * x.sqrt()\n\ndef main():\n    x = sfix.get_input_from(0)\n    result = specific_pow(x)\n    result.output()\n", "model_name": "azure-openai-o1"}
{"test_name": "soft_plus", "response_0": "from Compiler.types import sfix\n\ndef soft_plus(x):\n    return (1 + x.exp()).log()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import *\n\ndef soft_plus(x):\n    # x is expected to be an sfix.\n    # This computes ln(1 + e^x) by using built-in MP-SPDZ methods for exponent and logarithm.\n    return (sfix(1) + x.exp()).log()\n", "model_name": "azure-openai-o1"}
{"test_name": "ball_volume", "response_0": "from Compiler.types import sfloat\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    (Translated to MP-SPDZ)\n    \"\"\"\n    pi = sfloat(3.141592653589793)\n    volume = pi * (r * r * r) * sfloat(4) / sfloat(3)\n    return volume\n", "response_1": "from Compiler.types import sfix\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return (sfix(4) / sfix(3)) * pi * (r * r * r)\n", "model_name": "azure-openai-o1"}
{"test_name": "Heron", "response_0": "from Compiler.types import sfix\n\ndef Heron(a, b, c):\n    # a, b, c are sfix shared inputs\n    p = (a + b + c) / sfix(2)\n    return (p * (p - a) * (p - b) * (p - c)).sqrt()\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "next_perfect_square", "response_0": "from Compiler.types import sfix\n\ndef next_perfect_square(x):\n    # Convert x to a fixed-point representation if not already\n    sx = sfix(x)\n    # Compute square root in sfix\n    sqrt_x = sx.sqrt()\n    # Floor of the square root\n    floor_sqrt_x = sqrt_x.floor()\n    # (floor_sqrt_x + 1)**2\n    return (floor_sqrt_x + sfix(1)) * (floor_sqrt_x + sfix(1))\n\ndef main():\n    # Obtain secret-shared input x from player 0\n    x = sfix.get_input_from(0)\n    # Calculate the next perfect square bigger than x\n    result = next_perfect_square(x)\n    # Print the result to stdout\n    result.print_reg()\n", "response_1": "# MP-SPDZ code translating the Python 'next_perfect_square' logic.\n# This version computes floor_sqrt(x) via binary search and returns\n# (floor_sqrt(x) + 1) squared.\n\nfrom Compiler.types import sint\nfrom Compiler.types import regint\n\ndef floor_sqrt(x: sint) -> sint:\n    low = sint(0)\n    high = x + 1\n    while low < high:\n        mid = (low + high) >> 1\n        cond = mid * mid <= x\n        low = low.if_else(mid + 1, low)\n        high = high.if_else(high, mid)\n    return low - 1\n\ndef next_perfect_square(x: sint) -> sint:\n    return (floor_sqrt(x) + 1) * (floor_sqrt(x) + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "pi_to_the_x", "response_0": "def pi_to_the_x(x):\n    \"\"\"\n    Return pi^x using MP-SPDZ.\n    \"\"\"\n    from Compiler.types import sfix\n    from Compiler.library import pow_fx\n    pi_val = sfix(3.141592653589793)\n    return pow_fx(pi_val, x)\n", "response_1": "from Compiler.types import sfix\n\ndef pi_to_the_x(x):\n    # Return the value of pi^x\n    pi = sfix(3.141592653589793)\n    return pow(pi, x)\n", "model_name": "azure-openai-o1"}
{"test_name": "spring_rocket", "response_0": "# spring_rocket.mpc\n\n# Import necessary libraries and types from MP-SPDZ\nfrom Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef spring_rocket(height : sfix, m : sfix, k : sfix) -> sfix:\n    g = sfix(9.8)\n    return sqrt((sfix(2) * m * g * height) / k)\n\n# Example main program to read inputs, compute spring_rocket, and print the result\ndef main():\n    # Read secret inputs from parties (adjust player IDs as needed)\n    height = sfix.get_input_from(0)\n    m = sfix.get_input_from(1)\n    k = sfix.get_input_from(2)\n\n    # Compute the minimum length the spring should be compressed\n    res = spring_rocket(height, m, k)\n\n    # Print the result\n    res.print_ln(\"%s\")\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef spring_rocket(height: sfix, m: sfix, k: sfix) -> sfix:\n    g = sfix(9.8)\n    return sqrt(sfix(2) * m * g * height / k)\n", "model_name": "azure-openai-o1"}
{"test_name": "cone_volume", "response_0": "from Compiler.types import sfix\nfrom math import pi\n\ndef cone_volume(r, h):\n    # Compute volume of a cone\n    return sfix(pi) * r * r * h / sfix(3)\n\ndef main():\n    # Read secure inputs (replace party indices as needed)\n    r = sfix.get_input_from(0)\n    h = sfix.get_input_from(1)\n    # Call the function\n    volume = cone_volume(r, h)\n    # Reveal result (or use volume as needed in further secure computations)\n    volume.print_reveal()\n", "response_1": "from Compiler.types import sfix\n\ndef cone_volume(r, h):\n    # MP-SPDZ does not provide the standard 'math' module,\n    # so we define pi as a secure fixed-point constant.\n    pi = sfix(3.141592653589793)\n    return pi * r * r * h / sfix(3)\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_rabbits", "response_0": "from Compiler.types import sint\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    heads, legs: secret integers (sint)\n    \"\"\"\n    return (legs - (heads * 2)) >> 1\n", "response_1": "def how_many_rabbits(heads, legs):\n    # Here, heads and legs are secure integers (sint).\n    return (legs - heads * 2) / 2\n\n# Obtain secure inputs (e.g., from player 0).\nheads = sint.get_input_from(0)\nlegs = sint.get_input_from(0)\n\n# Compute the result and reveal the output.\nrabbits = how_many_rabbits(heads, legs)\nrabbits.store_out()\n", "model_name": "azure-openai-o1"}
