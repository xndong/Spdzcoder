{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\nstart = sfix(0)\nend = sfix(99)\nnum = 10\na = Array(sfix, num)\n\nstep = (end - start) / sfix(num - 1)\n\nfor i in range(num):\n    a[i] = start + step * sfix(i)\n", "response_1": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range, print_ln\n\ndef main():\n    start = sfix(0)\n    end = sfix(99)\n    num = 10\n    step = (end - start) / sfix(num - 1)\n    a = Array(num, sfix)\n\n    for i in range(num):\n        a[i] = start + step * sfix(i)\n\n    for i in range(num):\n        print_ln(\"%s\", a[i])\n", "model_name": "azure-openai-o1"}
{"test_name": "more_positive", "response_0": "# more_positive.mpc\n\n# This program reads an array of secret integers from party 0,\n# computes the sum of their signs, and checks if it's greater than 0.\n\nn = int(program.args[0])                # Number of integers in the array\narr = [sint.get_input_from(0) for _ in range(n)]\n\ncount = sint(0)\nfor x in arr:\n    # sign(x) = (x > 0) - (x < 0)\n    x_pos = x > 0\n    x_neg = x < 0\n    sign_val = x_pos - x_neg\n    count += sign_val\n\nresult = count > 0                      # This is a secret bit\nresult_open = result.reveal()           # Reveal for output\nprint_ln(\"%s\", result_open)\n", "response_1": "# In MP-SPDZ, we cannot directly use numpy or its sign function.\n# Instead, we compute the sign of each secret-shared value by comparing it with 0.\n# This example expects an array of sfix values as input.\n\ndef more_positive(arr):\n    # We'll sum up 1 for positive, -1 for negative, and 0 for zero.\n    sum_signs = sfix(0)\n    for x in arr:\n        positive_flag = x > 0       # sbit indicating if x is positive\n        negative_flag = x < 0       # sbit indicating if x is negative\n        sign_val = sfix.if_else(positive_flag, sfix(1), sfix(0)) \\\n                   - sfix.if_else(negative_flag, sfix(1), sfix(0))\n        sum_signs += sign_val\n    # Returns a secret bit indicating whether the sum of signs is greater than zero\n    return sum_signs > 0\n", "model_name": "azure-openai-o1"}
{"test_name": "select", "response_0": "from Compiler.types import sfix, sbit\n\ndef select(ind, a, b):\n    \"\"\"\n    Select elements from arrays a and b based on the secret bit array ind.\n    Each position i in the result is a[i] if ind[i] is 1, otherwise b[i].\n    \"\"\"\n    n = len(ind)\n    result = []\n    for i in range(n):\n        # Assuming ind[i] is an sbit and a[i], b[i] are sfix\n        result.append(ind[i].if_else(a[i], b[i]))\n    return result\n", "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data in MP-SPDZ.\n    \"\"\"\n    from Compiler.types import sfix, Array\n\n    n = len(ind)\n    c = Array(n, sfix)\n    for i in range(n):\n        # c[i] = ind[i] ? a[i] : b[i]\n        c[i] = ind[i] * a[i] + (1 - ind[i]) * b[i]\n    return c\n", "model_name": "azure-openai-o1"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    # MP-SPDZ ReLU function: output y if y > 0, else 0\n    return y * (y > 0)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef relu(y):\n    # ReLU function in MP-SPDZ\n    return if_else(y > 0, y, sfix(0))\n", "model_name": "azure-openai-o1"}
{"test_name": "cost_matrix", "response_0": "# In MP-SPDZ, we can implement the cost_matrix function as follows:\n\ndef cost_matrix(profit_matrix):\n    # Compute the shape of the matrix\n    nrows = len(profit_matrix)\n    ncols = len(profit_matrix[0])\n    \n    # Find the maximum value in profit_matrix\n    max_val = profit_matrix[0][0]\n    for i in range(nrows):\n        for j in range(ncols):\n            is_bigger = profit_matrix[i][j] > max_val\n            max_val = is_bigger.if_else(profit_matrix[i][j], max_val)\n    \n    # Subtract profit_matrix from the offset matrix (all elements are max_val)\n    cost_mat = []\n    for i in range(nrows):\n        row = []\n        for j in range(ncols):\n            row.append(max_val - profit_matrix[i][j])\n        cost_mat.append(row)\n    \n    return cost_mat\n", "response_1": "def cost_matrix(profit_matrix):\n    n = len(profit_matrix)\n    m = len(profit_matrix[0])\n    max_val = profit_matrix[0][0]\n    # Compute the maximum value in profit_matrix\n    for i in range(n):\n        for j in range(m):\n            is_bigger = profit_matrix[i][j] > max_val\n            max_val = is_bigger.if_else(profit_matrix[i][j], max_val)\n    # Create cost matrix by subtracting each entry from max_val\n    cost_mat = Matrix(sfix, n, m)\n    for i in range(n):\n        for j in range(m):\n            cost_mat[i][j] = max_val - profit_matrix[i][j]\n    return cost_mat\n", "model_name": "azure-openai-o1"}
{"test_name": "np_zeros", "response_0": "", "response_1": "n = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = 0\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler.types import sint, Array\n\n# This function replicates: array = ndarray[row_index][:]\n# \"ndarray\" is expected to be a 2-D data structure (list of lists or Matrix)\n# \"row_index\" is a secure integer determining which row to extract\n# \"num_cols\" is the number of columns in each row\ndef array_dimensional_indexing_2D(ndarray, row_index, num_cols):\n    row_result = Array(num_cols, sint)\n    @for_range(num_cols)\n    def _(j):\n        row_result[j] = ndarray[row_index][j]\n    return row_result\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range, if_statement\n\ndef array_dimensional_indexing(ndarray, row_index):\n    rows = len(ndarray)\n    cols = len(ndarray[0])\n    \n    result = sfix.Array(cols)\n    \n    @for_range(cols)\n    def _(j):\n        temp_val = sfix(0)\n        \n        @for_range(rows)\n        def _(i):\n            # Compare row_index with i\n            cond = (row_index == i)\n            \n            # If they match, pick array[i][j] for temp_val\n            @if_statement(cond)\n            def _():\n                nonlocal temp_val\n                temp_val = ndarray[i][j]\n        \n        result[j] = temp_val\n    \n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    arr = sfix.Array(n)\n    for i in range(n):\n        arr[i] = sfix(0)\n    return arr\n", "response_1": "from Compiler.types import Array, sfix\n\ndef zeros(n):\n    out = Array(n, sfix)\n    for i in range(n):\n        out[i] = sfix(0)\n    return out\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_slicing_stride", "response_0": "from Compiler.types import sint, Array\n\ndef array_concate(ndarrayA, ndarrayB):\n    # Determine lengths of the input arrays\n    nA = len(ndarrayA)\n    nB = len(ndarrayB)\n    \n    # Prepare lengths for result\n    lenA_even = (nA + 1) // 2  # number of even indices in ndarrayA\n    lenB_odd = nB // 2        # number of odd indices in ndarrayB\n    total_len = lenA_even + lenB_odd\n    \n    # Allocate storage for the result\n    result = Array(total_len, sint)\n    \n    # Fill result with elements at even indices from ndarrayA\n    r_index = 0\n    for i in range(nA):\n        if (i % 2) == 0:\n            result[r_index] = ndarrayA[i]\n            r_index += 1\n\n    # Fill result with elements at odd indices from ndarrayB\n    for i in range(nB):\n        if (i % 2) == 1:\n            result[r_index] = ndarrayB[i]\n            r_index += 1\n\n    return result\n", "response_1": "# This MP-SPDZ code replicates the Python function:\n#    def array_concate(ndarrayA, ndarrayB):\n#        viewA = ndarrayA[::2]\n#        viewB = ndarrayB[1:][::2]\n#        array = np.concatenate((viewA,viewB)).copy()\n#        return array\n#\n# by gathering the even-indexed elements from A and the odd-indexed\n# elements from B, then concatenating them.\n\ndef array_concate(A, B, nA, nB):\n    # Assuming A and B are arrays of secret-shared sfix or sint\n    viewA_size = nA // 2 + (nA % 2)\n    viewB_size = nB // 2\n\n    viewA = [sfix(0) for _ in range(viewA_size)]\n    viewB = [sfix(0) for _ in range(viewB_size)]\n\n    even_idx = 0\n    for i in range(nA):\n        if (i % 2) == 0:\n            viewA[even_idx] = A[i]\n            even_idx += 1\n\n    odd_idx = 0\n    for i in range(nB):\n        if (i % 2) == 1:\n            viewB[odd_idx] = B[i]\n            odd_idx += 1\n\n    # Concatenate resulting arrays\n    C = viewA + viewB\n    return C\n", "model_name": "azure-openai-o1"}
{"test_name": "QR_decomposition", "response_0": "def dot_product(vec_a, vec_b):\n    # vec_a and vec_b are lists of sfix\n    length = len(vec_a)\n    result = sfix(0)\n    for i in range(length):\n        result += vec_a[i] * vec_b[i]\n    return result\n\ndef QR_decomposition(mat):\n    # mat is a 2D list/array of sfix, dimension n x m\n    # Returns a matrix Q of dimension n x m\n    n = len(mat)\n    m = len(mat[0])\n    Q = sfix.Matrix(n, m)\n    \n    for j in range(m):\n        # Extract the j-th column as w\n        w = [mat[i][j] for i in range(n)]\n        \n        # Subtract projections onto all previously computed columns in Q\n        for k in range(j):\n            alpha = dot_product(w, [Q[i][k] for i in range(n)])\n            for i in range(n):\n                w[i] = w[i] - alpha * Q[i][k]\n        \n        # Compute norm of w\n        norm_w = dot_product(w, w).sqrt()\n        \n        # Normalize w to get the j-th column of Q\n        for i in range(n):\n            Q[i][j] = w[i] / norm_w\n    \n    return Q\n", "response_1": "# MP-SPDZ program translating a Python QR decomposition (returning Q) using classical Gram-Schmidt\n# Note: This code assumes that the matrix dimensions n, m and the inputs are already known.\n#       It reads a matrix from party 0's input and then computes the Q factor.\n\n# Important: In MP-SPDZ, fixed-point (sfix) or floating-point (sfloat) data types are used\n# instead of standard Python floats. Below, we demonstrate the use of sfix. \n# Adjust types or precision as necessary for your application.\n\nfrom Compiler.types import sfix, Matrix, Array\nfrom Compiler.library import for_range\n\nn = 3  # Number of rows\nm = 3  # Number of columns\n\n# Initialize the input matrix\nA = Matrix(sfix, n, m)\nfor i in range(n):\n    for j in range(m):\n        A[i][j] = sfix.get_input_from(0)\n\n# Initialize Q matrix for the result\nQ = Matrix(sfix, n, m)\n\n# Classical Gram-Schmidt to compute Q\nfor j in range(m):\n    # Copy A[:, j] into Q[:, j]\n    for i in range(n):\n        Q[i][j] = A[i][j]\n    # Subtract projective components from each Q[:, j]\n    for k in range(j):\n        r_kj = sfix(0)\n        for i in range(n):\n            r_kj += Q[i][k] * Q[i][j]  # Dot product\n        for i in range(n):\n            Q[i][j] -= r_kj * Q[i][k]\n    # Normalize Q[:, j]\n    norm = sfix(0)\n    for i in range(n):\n        norm += Q[i][j] * Q[i][j]\n    norm = norm.sqrt()\n    for i in range(n):\n        Q[i][j] = Q[i][j] / norm\n\n# Output the Q matrix\nfor i in range(n):\n    for j in range(m):\n        Q[i][j].print_plain()\n", "model_name": "azure-openai-o1"}
{"test_name": "find_nearest_index", "response_0": "# MP-SPDZ translation of \"find_nearest_index\" that returns the index of the\n# element in 'arr' closest to 'val'.\n\nfrom Compiler.types import sfix, cint\n\ndef find_nearest_index(arr, val):\n    # Initialize min_diff to a large sfix number for comparison.\n    min_diff = sfix(999999999)\n    # Initialize min_idx to -1 (or any invalid index sentinel).\n    min_idx = cint(-1)\n    n = len(arr)\n\n    for i in range(n):\n        diff = arr[i] - val\n\n        # Compute absolute value of diff:\n        # if diff < 0, take -diff, else keep diff\n        is_neg = diff < 0\n        diff_abs = -diff * is_neg + diff * (1 - is_neg)\n\n        # Update min_diff and min_idx if a new minimum is found\n        is_less = diff_abs < min_diff\n        min_diff = sfix.if_else(is_less, diff_abs, min_diff)\n        min_idx = cint.if_else(is_less, i, min_idx)\n\n    return min_idx\n", "response_1": "# In MP-SPDZ, we do not have direct NumPy support or a built-in argmin,\n# so we replicate the logic with a loop and conditional assignments.\n# This function returns the index of the nearest value in 'array' to 'value'.\n\ndef find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    n = len(array)\n    # Initialize minimum difference and index\n    min_val = sfix(999999999)\n    min_idx = sint(0)\n\n    # Iterate over the array to find the minimum absolute difference\n    for i in range(n):\n        diff = (array[i] - value).abs()\n        cond = diff < min_val\n        min_val = cond.if_else(diff, min_val)\n        min_idx = cond.if_else(i, min_idx)\n\n    return min_idx\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_simple_row", "response_0": "# In MP-SPDZ, we cannot directly use numpy, but we can simulate a row-wise concatenation\n# by creating a new matrix capturing the combined shape and copying elements. \n# This code shows a simple function to concatenate two 2-D matrices A and B along axis 0\n# (equivalent to np.concatenate((ndarrayA, ndarrayB), axis=0)).\n\n# Here, we assume:\n#  - 'A' is shape [a x c]\n#  - 'B' is shape [b x c]\n#  - both contain sfix (or any other secret type) elements\n#  - we wish to produce a new matrix of shape [(a+b) x c]\n\ndef array_simple_concate_rows(A, B, a, b, c):\n    # Create a new matrix to hold the concatenated result\n    C = Matrix(a + b, c, sfix)\n\n    # Copy rows from A\n    for i in range(a):\n        for j in range(c):\n            C[i][j] = A[i][j]\n\n    # Copy rows from B\n    for i in range(b):\n        for j in range(c):\n            C[a + i][j] = B[i][j]\n\n    return C\n", "response_1": "# MP-SPDZ translation of array_simple_concate_rows\n# This function expects two 2-D lists (matrix) of sfix values (or other secure types).\n# Both matrices must have the same number of columns.\n\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    # Determine dimensions\n    rowsA = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    rowsB = len(ndarrayB)\n    colsB = len(ndarrayB[0])\n\n    # (Optional) Check matching column dimensions\n    # In an actual MP-SPDZ program, you can add checks for dimension consistency if necessary.\n\n    # Create the new array to hold concatenated result\n    new_rows = rowsA + rowsB\n    new_cols = colsA\n    concat_array = [[sfix(0) for _ in range(new_cols)] for _ in range(new_rows)]\n\n    # Copy elements of the first array\n    for i in range(rowsA):\n        for j in range(colsA):\n            concat_array[i][j] = ndarrayA[i][j]\n\n    # Copy elements of the second array\n    for i in range(rowsB):\n        for j in range(colsB):\n            concat_array[rowsA + i][j] = ndarrayB[i][j]\n\n    return concat_array\n", "model_name": "azure-openai-o1"}
{"test_name": "np_copy", "response_0": "", "response_1": "def array_copy(ndarray):\n    n = len(ndarray)\n    new_array = Array(n, sint)\n    for i in range(n):\n        new_array[i] = ndarray[i]\n    return new_array\n", "model_name": "azure-openai-o1"}
{"test_name": "max_pooling", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range, if_else\n\ndef sfix_max(a, b):\n    \"\"\"\n    Returns the maximum of a and b in sfix.\n    \"\"\"\n    return (a > b).if_else(a, b)\n\ndef max_pooling(x, stride, batch_size, row_size, col_size):\n    \"\"\"\n    Computes the max pooling of a 3D secret-shared array x \n    with given stride over dimensions:\n      x.shape = [batch_size, row_size, col_size]\n    Returns:\n      out.shape = [batch_size, row_size//stride, col_size//stride]\n    \"\"\"\n    out_row = row_size // stride\n    out_col = col_size // stride\n    # Allocate output array\n    out = [[[sfix(0) for _ in range(out_col)]\n                for _ in range(out_row)]\n                for _ in range(batch_size)]\n    \n    for b in range(batch_size):\n        for i in range(0, row_size, stride):\n            for j in range(0, col_size, stride):\n                temp = x[b][i][j]\n                # Compute max over the stride window\n                for ii in range(stride):\n                    for jj in range(stride):\n                        temp = sfix_max(temp, x[b][i + ii][j + jj])\n                out[b][i // stride][j // stride] = temp\n    return out\n", "response_1": "# MP-SPDZ code snippet demonstrating max pooling\n\ndef max_pooling(x, B, R, C, stride):\n    # B, R, C are integer dimensions of x, where x has shape [B, R, C]\n    # x is a flat sfix array but logically it is B x R x C\n    # stride is an integer indicating the pooling stride\n    \n    out_B = B\n    out_R = R // stride\n    out_C = C // stride\n    \n    # Create output array\n    out = sfix.Array(out_B * out_R * out_C)\n    \n    # Helper function for 3D -> 1D index\n    def idx3(b, r, c):\n        return b * (R * C) + r * C + c\n    \n    # Helper function for output 3D -> 1D index\n    def idx3_out(b, r, c):\n        return b * (out_R * out_C) + r * out_C + c\n    \n    # Perform the max-pooling\n    for b in range(B):\n        for i in range(0, R, stride):\n            for j in range(0, C, stride):\n                # Initialize local_max to the first element in the current stride block\n                local_max = x[idx3(b, i, j)]\n                \n                # Compare and update local_max with every element in the pooling window\n                for ii in range(i, i + stride):\n                    for jj in range(j, j + stride):\n                        diff = x[idx3(b, ii, jj)] - local_max\n                        is_greater = diff > sfix(0)\n                        local_max = local_max + is_greater * diff\n\n                # Assign the computed max to the corresponding output cell\n                out[idx3_out(b, i // stride, j // stride)] = local_max\n    \n    return out\n", "model_name": "azure-openai-o1"}
{"test_name": "array_reshape", "response_0": "n = 0\na = Matrix(sint, 3, 5)\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = sint(n)\n        n += 1\n", "response_1": "from Compiler.types import sint\n\n# Define dimensions\nrows = 3\ncols = 5\n\n# Initialize a 3x5 matrix with values from 0 to 14\na = [[sint(0) for _ in range(cols)] for _ in range(rows)]\nfor i in range(rows):\n    for j in range(cols):\n        a[i][j] = i * cols + j\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_simple_column", "response_0": "# MP-SPDZ code translating the NumPy array concatenation along axis 1.\n# Assumes A and B have the same number of rows.\n\n# Import the required types from MP-SPDZ\nfrom Compiler.types import sfix, Matrix\n\ndef array_simple_concate_column(A, B):\n    \"\"\"\n    A and B are matrices of type sfix (secure fixed-point),\n    and both have the same number of rows.\n    This function concatenates them along the columns.\n    \"\"\"\n    # Gather dimensions\n    n = len(A)           # Number of rows\n    mA = len(A[0])       # Number of columns in A\n    mB = len(B[0])       # Number of columns in B\n    \n    # Create result matrix with combined column dimension\n    res = Matrix(sfix, n, mA + mB)\n    \n    # Fill the result matrix\n    for i in range(n):\n        for j in range(mA):\n            res[i][j] = A[i][j]\n        for j in range(mB):\n            res[i][mA + j] = B[i][j]\n    \n    return res\n", "response_1": "from Compiler.types import sfix\n\ndef array_simple_concate_column(A, B):\n    # A is an n x k matrix\n    n = A.sizes[0]\n    k = A.sizes[1]\n    # B is an n x m matrix\n    m = B.sizes[1]\n    # Prepare result C as an n x (k+m) matrix\n    C = sfix.Matrix(n, k + m)\n\n    # Copy elements from A to C\n    for i in range(n):\n        for j in range(k):\n            C[i][j] = A[i][j]\n\n    # Copy elements from B to the remaining columns of C\n    for i in range(n):\n        for j in range(m):\n            C[i][k + j] = B[i][j]\n\n    return C\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "# array_dimensional_indexing.mpc\n\nfrom Compiler.types import sfix, Array\n\ndef array_dimensional_indexing(Mat, column_index, n, m):\n    \"\"\"\n    MP-SPDZ program to index i-th column from a 2-D array (Mat).\n    Mat is a matrix of dimensions n x m.\n    column_index is an integer (public or secret, depending on usage).\n    \"\"\"\n    res = Array(n, sfix)\n    for i in range(n):\n        res[i] = Mat[i][column_index]\n    return res\n", "response_1": "from Compiler.types import s_int\n\ndef array_dimensional_indexing(ndarray, column_index):\n    # ndarray is assumed to be a list of lists of s_int (2-D array)\n    # column_index is an s_int or int specifying the desired column\n    rows = len(ndarray)\n    res = [s_int(0) for _ in range(rows)]\n    for i in range(rows):\n        res[i] = ndarray[i][column_index]\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_diagonal", "response_0": "def diag(arr):\n    n = arr.length()\n    diag_arr = Array(n, sint)\n    for i in range(n):\n        diag_arr[i] = arr[i][i]\n    return diag_arr\n", "response_1": "# This MP-SPDZ code translates the functionality of returning the main diagonal\n# of a 2D array from the original Python implementation.\n# The function below assumes 'array' is a 2D structure of secret-shared values,\n# such as sfix, and returns a 1D array containing the diagonal elements.\n\ndef diag(array):\n    rows = len(array)\n    cols = len(array[0])\n    # The number of diagonal elements is the smaller dimension of the matrix\n    diag_length = rows if rows < cols else cols\n    \n    result = [None]*diag_length\n    for i in range(diag_length):\n        result[i] = array[i][i]\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_special", "response_0": "# array_special_concate.mpc\n\nfrom Compiler.types import sfix\nfrom Compiler.types import Array\nfrom Compiler.library import for_range\n\n# Example dimensions (number of rows N, columns M1 for A, columns M2 for B):\nN = 3\nM1 = 4\nM2 = 5\n\n# Define secret-shared 2D arrays for A and B\nA = Array(N, Array(M1, sfix))\nB = Array(N, Array(M2, sfix))\n\n# (Optional) Initialize A and B from player 0's input shares\nfor i in range(N):\n    for j in range(M1):\n        A[i][j] = sfix.get_input_from(0)\nfor i in range(N):\n    for j in range(M2):\n        B[i][j] = sfix.get_input_from(0)\n\n# The goal is to collect all even columns from A (0, 2, 4, ...)\n# and all odd columns from B (1, 3, 5, ...), then concatenate along axis=1.\n\n# Calculate the final number of columns after concatenation\nM_new = (M1 + 1) // 2 + (M2 // 2)\n\n# Prepare the result array C\nC = Array(N, Array(M_new, sfix))\n\n# Fill C with even columns from A\ncol_idx = 0\nfor j in range(0, M1, 2):\n    for i in range(N):\n        C[i][col_idx] = A[i][j]\n    col_idx += 1\n\n# Fill C with odd columns from B\nfor j in range(1, M2, 2):\n    for i in range(N):\n        C[i][col_idx] = B[i][j]\n    col_idx += 1\n\n# (Optional) Reveal or use the result. For example:\nfor i in range(N):\n    for j in range(M_new):\n        C[i][j].print_reveal()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import Matrix\n\ndef array_special_concate(A, B):\n    # A and B are assumed to be matrices of type sfix with the same number of rows\n    n = len(A)\n    m = len(A[0])\n    \n    # Determine total columns for the result (all even columns from A + all odd columns from B)\n    total_cols = (m + 1) // 2 + m // 2\n    \n    # Create the result matrix\n    C = Matrix(sfix, n, total_cols)\n    c_col = 0\n    \n    # Copy even columns from A into C\n    for col in range(0, m, 2):\n        for row in range(n):\n            C[row][c_col] = A[row][col]\n        c_col += 1\n    \n    # Copy odd columns from B into C\n    for col in range(1, m, 2):\n        for row in range(n):\n            C[row][c_col] = B[row][col]\n        c_col += 1\n    \n    return C\n", "model_name": "azure-openai-o1"}
{"test_name": "np_arange", "response_0": "from Compiler.types import cint, Array\nfrom Compiler.library import for_range\n\ndef arange_cint(start, stop, step):\n    # Compute the length in the clear (plain text domain)\n    length = (stop - start) // step  # integer division\n    \n    # Prepare an array of length 'length' with plain text integers\n    result = Array(length, cint)\n    \n    @for_range(length)\n    def _(i):\n        # Each element is start + i*step\n        result[i] = start + i * step\n    \n    return result\n", "response_1": "from Compiler.types import Array, regint\n\ndef arange(start, stop=None, step=1):\n    # Convert plain integers into MP-SPDZ regint if needed\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Compute the length of the range using integer division\n    length = (stop - start + (step - 1)) // step\n\n    # Allocate an Array of regint to hold the output\n    res = Array(length, regint)\n\n    # Fill the array with the arithmetic progression\n    for i in range(length):\n        res[i] = start + i * step\n\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_eye_2", "response_0": "from Compiler.types import sfix, Matrix\n\nm = 3\nn = 5\na = Matrix(sfix, m, n)\nfor i in range(m):\n    for j in range(n):\n        a[i][j] = sfix(1 if i == j else 0)\n", "response_1": "m = 3\nn = 5\na = Matrix(sint, m, n)\n\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = 1\n        else:\n            a[i][j] = 0\n", "model_name": "azure-openai-o1"}
{"test_name": "third_smallest", "response_0": "from Compiler.types import sint, regint\nfrom Compiler.library import if_else\n\ndef third_smallest(arr):\n    n = len(arr)\n    # Perform a simple bubble sort\n    for i in range(n):\n        for j in range(n - i - 1):\n            c = arr[j] > arr[j + 1]\n            # Conditionally swap arr[j] and arr[j+1]\n            arr_j    = if_else(c, arr[j + 1], arr[j])\n            arr_j1   = if_else(c, arr[j], arr[j + 1])\n            arr[j]   = arr_j\n            arr[j+1] = arr_j1\n    # Return the third smallest element (assuming array length >= 3)\n    return arr[2]\n\ndef main():\n    # Retrieve array length\n    n = regint.get_input_from(0)\n    # Retrieve array elements\n    arr = [sint.get_input_from(0) for _ in range(n)]\n    # Compute and reveal the third smallest element\n    result = third_smallest(arr)\n    result.print_reveal()\n", "response_1": "# third_smallest.mpc\n\n# Helper function to find the minimum value and its index in a secret-shared array\ndef find_min_val_and_index(arr):\n    n = len(arr)\n    min_val = arr[0]\n    min_idx = 0\n    for i in range(1, n):\n        # Compare arr[i] with current minimum\n        smaller = arr[i] < min_val\n        min_val = smaller.if_else(arr[i], min_val)\n        min_idx = smaller.if_else(i, min_idx)\n    return min_val, min_idx\n\ndef third_smallest(arr):\n    # Find the first minimum and index\n    min_val_1, min_idx_1 = find_min_val_and_index(arr)\n    # Replace this minimum with a large value\n    arr[min_idx_1] = type(arr[min_idx_1])(1e15)\n\n    # Find the second minimum and index\n    min_val_2, min_idx_2 = find_min_val_and_index(arr)\n    # Replace this minimum with a large value\n    arr[min_idx_2] = type(arr[min_idx_2])(1e15)\n\n    # Find the third minimum\n    min_val_3, _ = find_min_val_and_index(arr)\n    return min_val_3\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    # Assuming ndarray is a 2-D list of secure data types (e.g., sfix, sint) in MP-SPDZ\n    ncols = len(ndarray[0])\n    return [ndarray[row_index][j] for j in range(ncols)]\n", "response_1": "from Compiler.types import sfix, Array, sint\nfrom Compiler.library import if_else\n\ndef array_dimensional_indexing(matrix, row_index):\n    # Step 1: Determine the number of rows and columns\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Step 2: Prepare an array to hold the resulting row\n    result = Array(cols, sfix)\n    for j in range(cols):\n        result[j] = sfix(0)\n    \n    # Step 3: Use a conditional selection to copy the correct row\n    for i in range(rows):\n        condition = (row_index == sint(i))\n        for j in range(cols):\n            result[j] = if_else(condition, matrix[i][j], result[j])\n    \n    # Step 4: Return the indexed row\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_from_intrinsic_arange", "response_0": "", "response_1": "n = 10\n\na = Array(n, cint)\nfor i in range(n):\n    a[i] = cint(i)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "# array_dimensional_indexing.mpc\nfrom Compiler.types import sfix, Array, sint\nfrom Compiler.library import for_range\n\ndef array_dimensional_indexing(matrix, row_index, n_rows, n_columns):\n    \"\"\"\n    MP-SPDZ program to index the i-th row from a 2-D array (matrix).\n    matrix      : A 2-D array of sfix elements\n    row_index   : The specific row index (public or compile-time integer)\n    n_rows      : The number of rows in the matrix\n    n_columns   : The number of columns in the matrix\n    Returns     : A one-dimensional array of sfix elements representing the selected row\n    \"\"\"\n    row_vector = Array(n_columns, sfix)\n    @for_range(n_columns)\n    def _(j):\n        row_vector[j] = matrix[row_index][j]\n    return row_vector\n", "response_1": "from Compiler.types import sint, sfix\n\ndef array_dimensional_indexing(ndarray, row_index):\n    # ndarray is a 2-D sfix.Matrix (or other secure type) in MP-SPDZ.\n    # row_index is an integer index (typically public) for selecting the row.\n    # This function returns the i-th row from the input 2-D array.\n    return ndarray[row_index]\n", "model_name": "azure-openai-o1"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler.types import Array, sint\n\na_l = [0, 10, 20, 30, 40]\na = Array(len(a_l), sint)\nfor i in range(len(a_l)):\n    a[i] = sint(a_l[i])\n", "response_1": "from Compiler.types import sint, Array\n\n# Python built-in list\na_l = [0, 10, 20, 30, 40]\n\n# Convert list elements to secret integer type\na_l_sint = [sint(x) for x in a_l]\n\n# Create a 1-dim MP-SPDZ array with length 5\na = Array.create_from(a_l_sint)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_reshape", "response_0": "# MP-SPDZ code translating the Python array_reshape function\n# into a version that reshapes an array (flattened) into a matrix of size m x n.\n\n# We assume the array is of secret integer type (sint). Adjust types as needed.\n\nfrom Compiler.types import sint, Array, Matrix\nfrom Compiler.library import for_range\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a secret shared array.\n    \"\"\"\n    reshaped_array = Matrix(m, n, sint)\n    index = 0\n    for i in range(m):\n        for j in range(n):\n            reshaped_array[i][j] = ndarray[index]\n            index += 1\n    return reshaped_array\n", "response_1": "/// MP-SPDZ code translating the Python array reshape functionality\n\n# The function below demonstrates how to reshape a one-dimensional array of sfix elements\n# into a two-dimensional array (matrix) with dimensions m x n.\n\ndef array_reshape(ndarray, m, n):\n    # Create an m-by-n matrix of sfix elements\n    reshaped_matrix = sfix.Matrix(m, n)\n    \n    # Fill the new matrix with elements from the 1D array in row-major order\n    for i in range(m):\n        for j in range(n):\n            reshaped_matrix[i][j] = ndarray[i * n + j]\n    \n    return reshaped_matrix\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ones", "response_0": "# In MP-SPDZ, you first declare the secure integer type and\n# create an Array to hold your data.\n\nfrom Compiler.types import s_int\nfrom Compiler.library import Array\n\nn = 10\nones_array = Array(n, s_int)\n\n# Fill the array with secure 1's\nfor i in range(n):\n    ones_array[i] = s_int(1)\n", "response_1": "from Compiler.types import sfix\n\nn = 10\na = sfix.Array(n)\nfor i in range(n):\n    a[i] = sfix(1)\n", "model_name": "azure-openai-o1"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    # Iterate through each element in y\n    for i in range(len(y)):\n        # Check if y[i] is 1, resulting in a secret value of 1 or 0\n        cond = (y[i] == 1)\n        # Replace y[i] with 0 if cond is 1, otherwise keep it unchanged\n        y[i] = y[i] * (1 - cond)\n    return y\n", "response_1": "// This MP-SPDZ code sets any element in a secure integer array y that equals 1 to 0.\n\n# import any necessary libraries and declare shares as needed\n\ndef set_one_to_zero(y):\n    # y is an array of secure integers (sint or sfix depending on context)\n    n = len(y)\n    for i in range(n):\n        cond = (y[i] == 1)\n        # if cond is 1, set y[i] to 0; otherwise leave it as is\n        y[i] = cond.if_else(0, y[i])\n    return y\n", "model_name": "azure-openai-o1"}
{"test_name": "np_eye", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\nn = 10\na = Array(n, Array(n, sfix))\n\n@for_range(n)\ndef _(i):\n    @for_range(n)\n    def _(j):\n        a[i][j] = sfix(1) if i == j else sfix(0)\n", "response_1": "n = 10\na = Matrix(sfix, n, n)\nfor i in range(n):\n    for j in range(n):\n        a[i][j] = sfix(int(i == j))\n", "model_name": "azure-openai-o1"}
{"test_name": "np_diag", "response_0": "# Initialize an array a_l of length 6 with sfix type\na_l = Array(6, sfix)\na_l[0] = sfix(1)\na_l[1] = sfix(3)\na_l[2] = sfix(5)\na_l[3] = sfix(2)\na_l[4] = sfix(4)\na_l[5] = sfix(6)\n\n# Create a 6x6 matrix a with sfix type\na = Matrix(sfix, 6, 6)\n\n# Fill the matrix with 0\nfor i in range(6):\n    for j in range(6):\n        a[i][j] = sfix(0)\n\n# Place a_l elements on the diagonal\nfor i in range(6):\n    a[i][i] = a_l[i]\n", "response_1": "a_l = Array(6, sint)\na_l[0] = 1\na_l[1] = 3\na_l[2] = 5\na_l[3] = 2\na_l[4] = 4\na_l[5] = 6\n\na = Matrix(6, 6, sint)\nfor i in range(6):\n    for j in range(6):\n        a[i][j] = a_l[i] * (i == j)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_advanced_integer_indexing", "response_0": "def integer_array_indexing(array, indices):\n    \"\"\"\n    indexing a secure MP-SPDZ array using an integer array of indices.\n    \"\"\"\n    length = len(indices)\n    ret_array = array.get_vector(length)\n    for i in range(length):\n        ret_array[i] = array[indices[i]]\n    return ret_array\n", "response_1": "def integer_array_indexing(array, indices):\n    # In MP-SPDZ, 'array' could be an sfix or cint array,\n    # and 'indices' could be an array of sint or cint, depending on requirements.\n    # This function replicates retrieving array elements by their integer indices.\n    \n    n_indices = len(indices)\n    ret_array = sfix.Array(n_indices)\n    for i in range(n_indices):\n        ret_array[i] = array[indices[i]]\n    return ret_array\n", "model_name": "azure-openai-o1"}
