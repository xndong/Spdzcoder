{"test_name": "cross_entropy_loss", "response_0": "# cross_entropy.mpc\n\nfrom Compiler.types import sfix\nfrom Compiler.library import log_sfix\n\ndef cross_entropy(y):\n    # y is a list/array of sfix values\n    total = sfix(0)\n    for val in y:\n        total += val * log_sfix(val)\n    return -total\n", "response_1": "# In MP-SPDZ, we do not rely on NumPy. Instead, we use secret-shared data types\n# (such as sfix or sfloat) and the math functionality provided by the compiler.\n# Below is a possible translation of the Python cross_entropy function into MP-SPDZ\n# semantics using sfix and a math.log_fx function (which computes a natural logarithm).\n\n# We assume y is a list of sfix (secret-shared fixed-point) values.\n\nfrom Compiler.types import sfix\nimport math\n\ndef cross_entropy(y):\n    s = sfix(0)\n    for yi in y:\n        # This uses the secret-shared log computation for a natural log:\n        s -= yi * math.log_fx(yi)\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_square_sqrt", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt_fx\n\ndef compute_RMSD(array):\n    # array is assumed to be a list or array of sfix\n    length = len(array)\n    total = sfix(0)\n    for i in range(length):\n        total += array[i]\n\n    mean = total / sfix(length)\n\n    sq_sum = sfix(0)\n    for i in range(length):\n        diff = array[i] - mean\n        sq_sum += diff * diff\n\n    sq_mean = sq_sum / sfix(length)\n    rmsd = sqrt_fx(sq_mean)\n    return rmsd\n", "response_1": "from Compiler.types import sfix\n\ndef compute_RMSD(array):\n    # This function calculates the root mean square deviation\n    n = len(array)\n    summation = sfix(0)\n    for i in range(n):\n        summation += array[i]\n    mean = summation / n\n\n    squares_sum = sfix(0)\n    for i in range(n):\n        deviation = array[i] - mean\n        squares_sum += deviation * deviation\n\n    square_mean = squares_sum / n\n    rmsd = square_mean.sqrt()\n    return rmsd\n", "model_name": "azure-openai-o1"}
{"test_name": "logsumexp", "response_0": "# MP-SPDZ code\n\ndef logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp\n    \"\"\"\n    n = len(log_probs)\n    _max = log_probs[0]\n    for i in range(1, n):\n        cond = log_probs[i] > _max\n        _max = cond.if_else(log_probs[i], _max)\n    ds = [None]*n\n    for i in range(n):\n        ds[i] = log_probs[i] - _max\n    exp_sum = sfix(0)\n    for i in range(n):\n        exp_sum += ds[i].exp()\n    return _max + exp_sum.ln()\n", "response_1": "from Compiler.types import sfloat\nfrom Compiler.library import if_else\n\ndef logsumexp(log_probs):\n    # Find the maximum value in log_probs\n    _max = log_probs[0]\n    for i in range(1, len(log_probs)):\n        _max = if_else(log_probs[i] > _max, log_probs[i], _max)\n    \n    # Compute ds (log_probs - _max)\n    ds = [lp - _max for lp in log_probs]\n    \n    # Compute the sum of exponentials\n    exp_sum = sfloat(0)\n    for d in ds:\n        exp_sum += d.exp()\n    \n    # Return (max + log of the sum of exponentials)\n    return _max + exp_sum.log()\n", "model_name": "azure-openai-o1"}
{"test_name": "binary_cross_entropy_loss", "response_0": "# MP-SPDZ code translating the binary_cross_entropy Python function.\n# This code assumes y_hat and y are arrays of sfix and that their lengths are equal.\n# It uses approximate logarithms in base 2 by multiplying the natural log by 1 / ln(2).\n# Also, it clamps y_hat to [0.001, 0.999] to avoid log(0) issues.\n\nfrom Compiler.types import sfix, cfix\nfrom Compiler.library import if_else\n\nLOG2_CONV = cfix(1.4426950408889634)  # 1 / ln(2)\n\ndef binary_cross_entropy(y_hat, y, length):\n    # Clamp y_hat to [0.001, 0.999]\n    lower_bound = cfix(0.001)\n    upper_bound = cfix(0.999)\n    total_loss = sfix(0)\n    one = cfix(1)\n\n    for i in range(length):\n        too_small = y_hat[i] < lower_bound\n        y_hat[i] = if_else(too_small, sfix(lower_bound), y_hat[i])\n        too_large = y_hat[i] > upper_bound\n        y_hat[i] = if_else(too_large, sfix(upper_bound), y_hat[i])\n\n        # log2(y_hat): approximate log base 2\n        log_y_hat = y_hat[i].log() * LOG2_CONV\n        # log2(1 - y_hat)\n        log_one_minus_y_hat = (one - y_hat[i]).log() * LOG2_CONV\n\n        total_loss += y[i] * log_y_hat + (one - y[i]) * log_one_minus_y_hat\n\n    # Compute the mean and negate\n    return -total_loss / sfix(cfix(length))\n", "response_1": "def binary_cross_entropy(y_hat, y, n):\n    # Here, y_hat and y are lists/arrays of sfix shares, and n is their length.\n    # This function assumes that each y_hat[i] is in [0,1], and ensures it\n    # is clipped away from 0 and 1 by 0.001. Then, it computes binary cross-entropy\n    # in base 2, returning an sfix share of the loss.\n    \n    sfix_epsilon = sfix(0.001)\n    sfix_one_minus_epsilon = sfix(1) - sfix_epsilon\n    sum_val = sfix(0)\n    \n    for i in range(n):\n        # Clip y_hat[i] away from 0\n        eq_zero = y_hat[i].equal(sfix(0))\n        # Temporarily update y_hat[i] if it equals 0\n        tmp = eq_zero * sfix_epsilon + (sfix(1) - eq_zero) * y_hat[i]\n        \n        # Clip away from 1\n        eq_one = y_hat[i].equal(sfix(1))\n        # Final clipped value for y_hat_i\n        y_hat_i = eq_one * sfix_one_minus_epsilon + (sfix(1) - eq_one) * tmp\n        \n        # Compute the term y*log2(y_hat_i) + (1-y)*log2(1-y_hat_i)\n        # log2 is provided by MP-SPDZ for sfix\n        val = y[i] * y_hat_i.log2() + (sfix(1) - y[i]) * (sfix(1) - y_hat_i).log2()\n        sum_val += val\n    \n    # Average and negate for the binary cross-entropy loss\n    return -sum_val / sfix(n)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_less_equal", "response_0": "def compute_less_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e. whether arrayA is\n    less than or equal to arrayB, translated into MP-SPDZ style. Each element in\n    arrayA and arrayB is assumed to be a secure type such as sfix or sint.\n\n    The logic in MP-SPDZ for determining (a <= b) can be split into:\n    (a < b) OR (a == b)\n\n    Note that:\n      a < b   -> a.less_than(b) or using the '<' operator\n      a == b  -> a.equal(b)\n\n    Both operations in MP-SPDZ produce secure bits/sints, which we combine via addition\n    to represent the boolean outcome of (a <= b).\n    \"\"\"\n    less_eq = []\n    for i in range(len(arrayA)):\n        is_less = arrayA[i] < arrayB[i]\n        is_equal = arrayA[i].equal(arrayB[i])\n        less_eq.append(is_less + is_equal)\n    return less_eq\n", "response_1": "def compute_less_equal(arrayA, arrayB, size):\n    \"\"\"\n    This MP-SPDZ function calculates element-wise (arrayA <= arrayB). \n    arrayA and arrayB are assumed to be secure arrays of length 'size'.\n    \"\"\"\n    # Create an array of secure bits to hold the comparison result\n    result = sbit.Array(size)\n    for i in range(size):\n        result[i] = (arrayA[i] <= arrayB[i])\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "RMS_prop_step", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef RMS_prop_step(grads, layers):\n    alpha = sfix(0.5)\n    beta = sfix(1.0)\n    s = [sfix(0) for _ in grads]\n    for i in range(len(grads)):\n        s[i] = beta * s[i] + (sfix(1) - beta) * (grads[i] * grads[i])\n        grad_step = alpha * (grads[i] / sqrt(s[i]))\n        layers[i] = layers[i] + grad_step\n    return layers\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import sfix\n\ndef RMS_prop_step(grads, layers):\n    alpha = sfix(0.5)\n    beta = sfix(1.0)\n    s = [sfix(0) for _ in grads]\n    for i in range(len(grads)):\n        s[i] = beta * s[i] + (sfix(1) - beta) * (grads[i] * grads[i])\n        grad_update = alpha * (grads[i] / s[i].sqrt())\n        layers[i] = layers[i] + grad_update\n    return layers\n", "model_name": "azure-openai-o1"}
{"test_name": "entropy", "response_0": "# Entropy computation in MP-SPDZ\n# This code securely computes an entropy-like measure for an input array y.\n# It reads a secret-shared integer n (length of y), then n secret-shared values y[0..n-1].\n# Finally, it outputs the secret-shared entropy.\n\n# Import MP-SPDZ types and approximate log function\nfrom Compiler.types import sint, sfix\nfrom Compiler.library import log_fx\n\n# Helper to count how many elements of array 'arr' equal 'val'\ndef count_occurrences(arr, val):\n    count = sint(0)\n    for x in arr:\n        count += (x == val)\n    return count\n\n# Approximate base-2 logarithm of a secret-shared sfix value x using log_fx\n# log_fx(x, use_base2=False) gives ln(x). So for log base 2, we divide by ln(2).\ndef log2_sfix(x):\n    # ln(x) / ln(2)\n    return log_fx(x, False) / log_fx(sfix(2), False)\n\ndef main():\n    # Read the length of the array\n    n = sint.get_input_from(0)\n\n    # Read the array of secret-shared integers\n    y = [sint.get_input_from(0) for _ in range(n)]\n\n    # Convert n to a fixed-point for dividing\n    n_fix = sfix(n)\n\n    # Initialize result sum\n    entropy_sum = sfix(0)\n\n    # For each position i, check if y[i] is a \"new\" value (not encountered before)\n    for i in range(n):\n        is_new = sint(1)\n        # Compare y[i] to all previous elements y[0..i-1]\n        for j in range(i):\n            is_new *= (y[i] != y[j])\n\n        # If is_new == 1, compute contribution for that distinct value\n        # All multiplications by is_new ensure that if it's not new, contribution is 0.\n        v = count_occurrences(y, y[i])\n        v_fix = sfix(v)\n        p = v_fix / n_fix\n        # Avoid log(0) by ensuring p>0 in practice. For very small p, log2_sfix is approximate.\n        entropy_sum += is_new * (-(p * log2_sfix(p)))\n\n    # Reveal the final entropy (still as secret-shared unless explicitly revealed)\n    entropy_sum.reveal()\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range, log_fx\n\ndef entropy(y):\n    n = len(y)\n    sum_ = sfix(0)\n\n    @for_range(n)\n    def loop_unique(i):\n        repeated = sint(0)\n        @for_range(i)\n        def loop_repeated(j):\n            nonlocal repeated\n            repeated += (y[i] == y[j])\n        freq = sfix(0)\n        @for_range(n)\n        def loop_freq(k):\n            nonlocal freq\n            freq += (y[k] == y[i])\n        fraction = freq / sfix(n)\n        # log_fx computes natural log; divide by log_fx(sfix(2)) to get log base 2\n        log2_fraction = log_fx(fraction) / log_fx(sfix(2))\n        term = -fraction * log2_fraction\n        # only add if no repeats found so far\n        sum_new = (repeated == 0) * term\n        nonlocal sum_\n        sum_ += sum_new\n\n    return sum_\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_exp", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import exp\n\ndef compute_softmax(array):\n    length = len(array)\n    exp_values = Array(length, sfix)\n    for i in range(length):\n        exp_values[i] = exp(array[i])\n    summation = sfix(0)\n    for i in range(length):\n        summation += exp_values[i]\n    softmax = Array(length, sfix)\n    for i in range(length):\n        softmax[i] = exp_values[i] / summation\n    return softmax\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef compute_softmax(array):\n    # Compute exponent for each element\n    exp_values = [exp(x) for x in array]\n    \n    # Sum all exponentiated values\n    total = sum(exp_values)\n    \n    # Normalize each value by dividing by the total\n    softmax_output = [x / total for x in exp_values]\n    \n    return softmax_output\n", "model_name": "azure-openai-o1"}
{"test_name": "tanh", "response_0": "# Tanh.mpc\n\nfrom Compiler.types import sfix\nfrom Compiler.library import exp\n\nclass Tanh:\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on secret-shared input `z`.\n        Uses the definition tanh(z) = (e^(2z) - 1) / (e^(2z) + 1).\n        \"\"\"\n        two_z = sfix(2) * z\n        numerator = exp(two_z) - sfix(1)\n        denominator = exp(two_z) + sfix(1)\n        return numerator / denominator\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on secret-shared input `x`.\n        The derivative of tanh(x) is 1 - tanh(x)^2.\n        \"\"\"\n        tanh_x = self.fn(x)\n        return sfix(1) - tanh_x * tanh_x\n", "response_1": "from Compiler.types import sfix\n\ndef custom_tanh(z):\n    e_x = sfix.exp(z)\n    e_neg_x = sfix.exp(-z)\n    return (e_x - e_neg_x) / (e_x + e_neg_x)\n\nclass Tanh():\n    def fn(self, z):\n        return custom_tanh(z)\n\n    def grad(self, x):\n        t = custom_tanh(x)\n        return 1 - t * t\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_tan", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef compute_tan(array):\n    \"\"\"\n    This function calculates the trigonometric tangent, element-wise.\n    Assumes 'array' is a list of sfix values.\n    \"\"\"\n    length = len(array)\n    tan_res = [sfix(0) for _ in range(length)]\n    for i in range(length):\n        sin_val = array[i].sin()\n        cos_val = array[i].cos()\n        tan_res[i] = sin_val / cos_val\n    return tan_res\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef compute_tan(secret_array):\n    # This function calculates the trigonometric tangent, element-wise, using MP-SPDZ.\n    result = sfix.Array(len(secret_array))\n    @for_range(len(secret_array))\n    def _(i):\n        result[i] = sfix.sin(secret_array[i]) / sfix.cos(secret_array[i])\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_greater", "response_0": "from Compiler.types import sfix\n\ndef compute_greater(arrayA, arrayB):\n    # This function calculates the element-wise comparison\n    # i.e. whether arrayA is greater than arrayB\n    greater_res = []\n    for i in range(len(arrayA)):\n        greater_res.append(arrayA[i] > arrayB[i])\n    return greater_res\n", "response_1": "from Compiler.types import sfix\n\ndef compute_greater(arrayA, arrayB):\n    # arrayA and arrayB are lists of MP-SPDZ secure values (for example, sfix).\n    # This function returns a list of secure bits indicating element-wise \u201carrayA > arrayB\u201d.\n    result = []\n    for i in range(len(arrayA)):\n        # MP-SPDZ allows the '>' operator on secure types;\n        # it produces a secure bit indicating the comparison result.\n        result.append(arrayA[i] > arrayB[i])\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_maximum", "response_0": "from Compiler.types import sfix\n\ndef compute_maximum(arrayA, arrayB):\n    n = len(arrayA)\n    result = [None] * n\n    for i in range(n):\n        is_A_greater_or_equal = (arrayA[i] >= arrayB[i])\n        result[i] = is_A_greater_or_equal.if_else(arrayA[i], arrayB[i])\n    return result\n", "response_1": "# MP-SPDZ code translating the Python function for element-wise maximum\n\n# Import MP-SPDZ types for secret-shared arithmetic\nfrom Compiler.types import sfix\n\ndef compute_maximum(arrayA, arrayB):\n    \"\"\"\n    Element-wise maximum of array elements in MP-SPDZ.\n    arrayA and arrayB are lists of secret-shared values (sfix).\n    \"\"\"\n    n = len(arrayA)\n    max_ones = []\n    for i in range(n):\n        condition = arrayA[i] > arrayB[i]\n        max_val = condition.if_else(arrayA[i], arrayB[i])\n        max_ones.append(max_val)\n    return max_ones\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_log2", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import log_e\n\ndef compute_log2(array):\n    \"\"\"This function calculates the base-2 logarithm for each element in the input array.\"\"\"\n    two = sfix(2)\n    log_two = log_e(two)\n    log2_values = []\n    for x in array:\n        log2_values.append(log_e(x) / log_two)\n    return log2_values\n", "response_1": "# This MP-SPDZ code calculates the base-2 logarithm for an array of secret fixed-point values.\n\nfrom Compiler.types import sfix, cfix\nfrom math import log\n\ndef compute_log2(array):\n    \"\"\"\n    This function calculates the base-2 logarithm of each sfix value in an input array.\n    \"\"\"\n    results = []\n    for x in array:\n        # Approximate natural log\n        ln_val = x.log_approx()\n        # Convert ln(x) to log2(x) by multiplying with 1 / ln(2)\n        log2_val = ln_val * cfix(1.0 / log(2))\n        results.append(log2_val)\n    return results\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_absolute", "response_0": "# In MP-SPDZ, we typically work with secure types (e.g., sfix) instead of standard Python types.\n\ndef obtain_absolute(secret_array):\n    \"\"\"\n    This function computes the absolute values in a secret shared array.\n    \"\"\"\n    result = []\n    for i in range(len(secret_array)):\n        # Using the built-in abs() method for MP-SPDZ secure numeric types\n        result.append(secret_array[i].abs())\n    return result\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_arctan", "response_0": "# MP-SPDZ code translating the Python function that calculates the arctan of each element in an array.\n# Note: This code assumes 'array' is a list of secret shared sfix values \n#       and that the MP-SPDZ environment provides the .arctan() operation on sfix.\n\ndef compute_arctan(array):\n    \"\"\"\n    This function calculates the trigonometric inverse tangent, element-wise, \n    on a list of secret shared sfix values.\n    \"\"\"\n    res = []\n    for x in array:\n        arctan_x = x.arctan()  # Uses MP-SPDZ's sfix.arctan() functionality\n        res.append(arctan_x)\n    return res\n", "response_1": "from Compiler.types import sfix, Array\n\ndef compute_arctan(array):\n    \"\"\"\n    This function calculates a polynomial approximation of the\n    trigonometric inverse tangent, element-wise.\n    For values of |x| <= 1, it uses the series expansion:\n    arctan(x) \u2248 x - x^3/3 + x^5/5\n    \"\"\"\n    n = len(array)\n    arctan_res = Array(n, sfix)\n    for i in range(n):\n        x = array[i]\n        x2 = x * x\n        x3 = x2 * x\n        x5 = x3 * x2\n        # Simple polynomial approximation for arctan\n        # arctan(x) \u2248 x - x^3/3 + x^5/5\n        arctan_res[i] = x - (x3 / 3) + (x5 / 5)\n    return arctan_res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_log", "response_0": "from Compiler.types import sfix\n\ndef compute_log(array):\n    \"\"\"\n    This function calculates the natural logarithm for all values in the input array of sfix.\n    \"\"\"\n    return [x.log() for x in array]\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_not_equal", "response_0": "from Compiler.types import sfix, sbit\n\ndef compute_not_equal(arrayA, arrayB):\n    # This function calculates the element-wise comparison,\n    # i.e., whether arrayA is not equal to arrayB.\n    length = len(arrayA)\n    result = [None] * length\n    for i in range(length):\n        # eq_bit becomes 1 if arrayA[i] == arrayB[i], otherwise 0.\n        eq_bit = (arrayA[i] - arrayB[i]).is_zero()\n        # Hence, not_equal is 1 if eq_bit is 0, otherwise 0.\n        result[i] = sbit(1) ^ eq_bit\n    return result\n", "response_1": "# MP-SPDZ program translating the element-wise \"not equal\" comparison.\n# This code reads two secret-shared arrays of length n from player 0,\n# computes their element-wise inequality, and prints the results.\n\nn = 4\narrayA = [sint.get_input_from(0) for _ in range(n)]\narrayB = [sint.get_input_from(0) for _ in range(n)]\n\nfor i in range(n):\n    eq_bit = (arrayA[i] - arrayB[i]).is_zero()\n    neq_bit = 1 - eq_bit\n    reveal(neq_bit).print_reg()\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_equal", "response_0": "# This MP-SPDZ program compares two secret-shared arrays element-wise for equality.\n# The two arrays are read as private inputs from player 0 and player 1 respectively.\n\nfrom Compiler.types import sint\n\n# Define the size of the arrays to compare\nN = 5\n\n# Read array inputs from player 0 and player 1\narrayA = [sint.get_input_from(0) for _ in range(N)]\narrayB = [sint.get_input_from(1) for _ in range(N)]\n\n# Element-wise comparison for equality\neq = [x == y for (x, y) in zip(arrayA, arrayB)]\n\n# Reveal and print the comparison results\nfor i in range(N):\n    print_ln('%s', eq[i].reveal())\n", "response_1": "from Compiler.types import sint\n\ndef compute_equal(arrayA, arrayB):\n    # This function calculates element-wise equality for secret-shared values.\n    eq = [a.equal(b) for a, b in zip(arrayA, arrayB)]\n    return eq\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_true_divide", "response_0": "def true_divide(arrayA, arrayB):\n    \"\"\"true divide between two 1-d arrays using MP-SPDZ types.\"\"\"\n    n = len(arrayA)\n    result = [sfix(0) for _ in range(n)]\n    for i in range(n):\n        result[i] = arrayA[i] / arrayB[i]\n    return result\n", "response_1": "from Compiler.types import sfix, Array, sint\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"True divide between two secret-shared 1-D arrays.\"\"\"\n    n = len(arrayA)\n    result = Array(n, sfix)\n    for i in range(n):\n        result[i] = arrayA[i] / arrayB[i]\n    return result\n\n# Example structure for reading input and performing the operation\n# (No usage example included in code)\nn = 4  # Fixed array length for demonstration\narrayA = Array(n, sfix)\narrayB = Array(n, sfix)\n\nfor i in range(n):\n    arrayA[i] = sfix.get_input_from(0)  # Reads input from player 0\nfor i in range(n):\n    arrayB[i] = sfix.get_input_from(0)  # Reads input from player 0\n\ndivision_result = true_divide(arrayA, arrayB)\n\nfor i in range(n):\n    division_result[i].reveal().print_reg()\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_greater_equal", "response_0": "from Compiler.types import sfix, sbit\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison,\n    i.e. whether arrayA is greater than or equal to arrayB\n    using secure computations.\n    \"\"\"\n    result = []\n    for i in range(len(arrayA)):\n        result.append(arrayA[i] >= arrayB[i])\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison:\n    whether each element in arrayA is greater than or equal\n    to the corresponding element in arrayB.\n\n    arrayA: list of secure integers (sint)\n    arrayB: list of secure integers (sint)\n    returns: list of secure bits/integers representing the comparison result [0 or 1]\n    \"\"\"\n    n = len(arrayA)\n    res = [None] * n\n    for i in range(n):\n        res[i] = (arrayA[i] >= arrayB[i])\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_negative", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\ndef negative(arrayA):\n    # This function returns a copy of the input array with all its elements negated.\n    n = len(arrayA)\n    negated_array = Array(n, sfix)\n    for i in for_range(n):\n        negated_array[i] = -arrayA[i]\n    return negated_array\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_power", "response_0": "from Compiler.types import sfix\n\n# This function computes x^y for each pair x,y from two arrays in MP-SPDZ\ndef power(arrayA, arrayB):\n    n = len(arrayA)\n    result = [sfix(0) for _ in range(n)]\n    for i in range(n):\n        result[i] = arrayA[i].pow(arrayB[i])\n    return result\n", "response_1": "# Translation of the Python program into MP-SPDZ:\n# This function computes x^y component-wise for two arrays (arrayA and arrayB).\n# In this translation, we assume that arrayB contains public integer exponents.\n# We use a repeated multiplication approach because MP-SPDZ does not provide\n# a direct exponentiation operator for a variable secret base and exponent.\n\nfrom Compiler.types import sfix, cint\n\ndef power(arrayA, arrayB):\n    # Assume arrayA and arrayB have the same length\n    length = len(arrayA)\n    result = []\n    for i in range(length):\n        temp = sfix(1)\n        # Repeated multiplication for exponent arrayB[i]\n        for _ in range(arrayB[i]):\n            temp = temp * arrayA[i]\n        result.append(temp)\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_exp2", "response_0": "from Compiler.types import sfix, sint\nimport math\n\ndef mpc_main():\n    # Read the length of the input array from party 0\n    n = sint.get_input_from(0)\n    \n    # Read the array of sfix values (secret-shared floating-point)\n    input_values = [sfix.get_input_from(0) for _ in range(n)]\n    \n    # Compute 2^p for each p in the array using e^(p * ln(2))\n    results = []\n    for p in input_values:\n        result = sfix.exp(p * math.log(2))\n        results.append(result)\n    \n    # Output the results\n    for val in results:\n        val.print_ln()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\n# Natural log of 2 as a constant for exponentiation.\nLN2 = sfix(0.6931471805599453)\n\ndef compute_exp2(x_array):\n    \"\"\"\n    This function calculates 2**p for all p in the input x_array.\n    Each element of x_array is assumed to be an sfix secret sharing.\n    \"\"\"\n    result = []\n    for x in x_array:\n        # 2**x = exp(x * ln(2))\n        result.append(exp(x * LN2))\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "cross_entropy_loss_class", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef cross_entropy_loss(y, y_pred, n):\n    cross_entropy = sfix(0)\n    for i in for_range(n):\n        cross_entropy = cross_entropy - y[i] * y_pred[i].log2()\n    return cross_entropy\n\ndef cross_entropy_grad(y, y_pred, n):\n    grad = [sfix(0) for _ in range(n)]\n    inv_n = sfix(1.0) / sfix(n)\n    for i in for_range(n):\n        grad[i] = (y_pred[i] - y[i]) * inv_n\n    return grad\n", "response_1": "# CrossEntropy.mpc\n\n# 1) We choose a fixed length n to illustrate the array handling.\n#    Depending on your actual scenario, n will typically\n#    come from the size of the inputs.\nn = 10\n\n# 2) Define secret-shared arrays for y and y_pred.\n#    In an actual application, these might be populated\n#    with externally provided inputs or data shares.\ny = Array(n, sfix)\ny_pred = Array(n, sfix)\n\n# 3) Initialize a variable to accumulate the cross-entropy loss.\ncross_entropy = sfix(0)\n\n# 4) Compute the cross-entropy loss:\n#       cross_entropy = - sum_{i}( y[i] * log2(y_pred[i]) ).\n#    The MP-SPDZ sfix type offers a log2() method (if compiled with\n#    appropriate floating-point support). Otherwise, you can use:\n#       y_pred[i].log() / log(2)\nfor i in range(n):\n    cross_entropy = cross_entropy - y[i] * y_pred[i].log2()\n\n# 5) Prepare an array for the gradient values.\ngrad = Array(n, sfix)\n\n# 6) Compute the gradient:\n#       grad[i] = (y_pred[i] - y[i]) / n\n#    We loop over each element to mirror the Python logic.\nfor i in range(n):\n    grad[i] = (y_pred[i] - y[i]) / n\n\n# At this point, 'cross_entropy' holds the overall loss value,\n# and 'grad' holds the computed gradient array.\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_arccos", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import for_range\nfrom math import pi\n\n#\n# Polynomial approximation of arcsin(x) around x=0:\n# arcsin(x) \u2248 x + (x^3)/6\n#\ndef arcsin_approx_sfix(x):\n    x_sq = x * x\n    return x + (x_sq * x) / 6\n\ndef compute_arccos(input_array):\n    n = len(input_array)\n    out_array = Array(n, sfix)\n    half_pi = sfix(pi / 2)\n    for i in for_range(n):\n        out_array[i] = half_pi - arcsin_approx_sfix(input_array[i])\n    return out_array\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "r2_score", "response_0": "def r2_score(n, y_test, y_hat):\n    # n: number of elements in y_test and y_hat\n    # y_test, y_hat: arrays of sfix values\n\n    # Compute the mean of y_test\n    sum_y_test = sfix(0)\n    for i in range(n):\n        sum_y_test += y_test[i]\n    mean_y_test = sum_y_test / sfix(n)\n\n    # Compute total sum of squares\n    total_sum_squares = sfix(0)\n    for i in range(n):\n        diff_test_mean = y_test[i] - mean_y_test\n        total_sum_squares += diff_test_mean * diff_test_mean\n\n    # Compute residual sum of squares\n    residual_sum_squares = sfix(0)\n    for i in range(n):\n        diff_test_hat = y_test[i] - y_hat[i]\n        residual_sum_squares += diff_test_hat * diff_test_hat\n\n    # Compute and return R^2 score\n    return sfix(1) - (residual_sum_squares / total_sum_squares)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef secure_mean(data):\n    s = sfix(0)\n    n = len(data)\n    for i in for_range(n):\n        s += data[i]\n    return s / n\n\ndef r2_score(y_hat, y_test):\n    y_mean = secure_mean(y_test)\n    total_sum_squares = sfix(0)\n    residual_sum_squares = sfix(0)\n    n = len(y_test)\n    for i in for_range(n):\n        diff_t = y_test[i] - y_mean\n        total_sum_squares += diff_t * diff_t\n        diff_r = y_test[i] - y_hat[i]\n        residual_sum_squares += diff_r * diff_r\n    return sfix(1) - residual_sum_squares / total_sum_squares\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_arcsin", "response_0": "# mp-spdz_arcsin.mpc\n# This MP-SPDZ program provides a polynomial approximation of arcsin and applies it element-wise.\n\nfrom Compiler.types import sfix, Array\nfrom Compiler.library import for_range\n\ndef arcsin_approx_sfix(x):\n    \"\"\"\n    A polynomial approximation for arcsin(x) \n    using the first few terms of its Taylor series expansion around 0.\n    \"\"\"\n    x2 = x * x\n    x3 = x2 * x\n    term1 = x\n    term2 = x3 * (1/6)\n    x5 = x3 * x2\n    term3 = x5 * (3/40)\n    x7 = x5 * x2\n    term4 = x7 * (5/112)\n    x9 = x7 * x2\n    term5 = x9 * (35/1152)\n    return term1 + term2 + term3 + term4 + term5\n\ndef compute_arcsin(array):\n    \"\"\"\n    This function calculates the trigonometric inverse sine, element-wise,\n    on an array of sfix using a polynomial approximation.\n    \"\"\"\n    n = len(array)\n    arcsin_res = Array(n, sfix)\n    for i in range(n):\n        arcsin_res[i] = arcsin_approx_sfix(array[i])\n    return arcsin_res\n", "response_1": "# mp_spdz_arcsin.mpc\n# Translation of the Python function compute_arcsin using an arcsin approximation\n\nfrom Compiler.types import sfix\nfrom Compiler.library import for_range\n\n# Polynomial approximation of arcsin(x) \u2248 x + x^3/6 + 3*x^5/40 + 5*x^7/112\ndef arcsin_approx(x):\n    x2 = x * x\n    x3 = x * x2\n    x5 = x3 * x2 * x2\n    x7 = x5 * x2\n    return x + x3 / 6 + (3 * x5) / 40 + (5 * x7) / 112\n\ndef compute_arcsin(array):\n    \"\"\"\n    This function calculates the approximate trigonometric inverse sine, element-wise.\n    \"\"\"\n    n = len(array)\n    result = []\n    for i in range(n):\n        result.append(arcsin_approx(array[i]))\n    return result\n\ndef main():\n    # Example array length\n    n = 5\n    \n    # Input array in secret-shared format\n    input_data = [sfix.get_input_from(0) for _ in range(n)]\n    \n    # Compute arcsin result\n    arcsin_res = compute_arcsin(input_data)\n    \n    # Output result\n    for i in range(n):\n        arcsin_res[i].print_float()\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_true_divide2", "response_0": "from Compiler.types import sfix\n\ndef true_divide(arrayA, arrayB):\n    # Step 1: Note that the input arrays arrayA and arrayB must be lists of secure\n    #         numeric types (e.g., sfix) in MP-SPDZ rather than ordinary Python floats.\n    \n    # Step 2: Perform element-wise division in a loop. Each division is a secure\n    #         operation when the inputs are secret-shared (sfix values).\n    res = []\n    for a, b in zip(arrayA, arrayB):\n        res.append(a / b)\n    \n    # Step 3: Return the resulting list of secure values. \n    return res\n", "response_1": "from Compiler.types import sfix\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"true divide between two sfix 1-D arrays.\"\"\"\n    length = len(arrayA)\n    res = [sfix(0) for _ in range(length)]\n    for i in range(length):\n        res[i] = arrayA[i] / arrayB[i]\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "square_error_loss", "response_0": "from Compiler.types import sfix\n\ndef squre_error(y, y_pred, n):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    squaresum = sfix(0)\n    for i in range(n):\n        diff = y_pred[i] - y[i]\n        squaresum += diff * diff\n    return squaresum * sfix(0.5)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef squre_error(y, y_pred, length):\n    # y and y_pred are arrays of sfix with the given length\n    error_sum = sfix(0)\n    for i in range(length):\n        diff = y_pred[i] - y[i]\n        error_sum = error_sum + diff * diff\n    return error_sum * cfix(0.5)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_less", "response_0": "from Compiler.types import sint, Array\n\ndef compute_less(arrayA, arrayB):\n    # Ensure both arrays have the same length\n    length = len(arrayA)\n    less_res = Array(length, sint)\n    for i in range(length):\n        # The comparison returns a secret integer (0 or 1)\n        less_res[i] = arrayA[i] < arrayB[i]\n    return less_res\n", "response_1": "from Compiler.types import sfix, sbit\n\ndef compute_less(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e. whether arrayA is less than arrayB,\n    returning a list of secure bits (sbit).\n    \"\"\"\n    n = len(arrayA)\n    less_res = [None] * n\n    for i in range(n):\n        less_res[i] = (arrayA[i] < arrayB[i])\n    return less_res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import cos_fx\n\ndef compute_cosine(array):\n    \"\"\"\n    This function calculates trigonometric cosine, element-wise.\n    \"\"\"\n    cos_res = []\n    for val in array:\n        cos_res.append(cos_fx(val))\n    return cos_res\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "np_ufunc_sin", "response_0": "from Compiler.types import sfix\n\ndef compute_sine(array):\n    \"\"\"\n    This function calculate trigonometric sine, element-wise.\n    \"\"\"\n    # In MP-SPDZ, we use the sfix type's built-in sin() method\n    # to compute the sine of each element securely.\n    result = []\n    for x in array:\n        result.append(x.sin())\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import Array\n\ndef compute_sine(array):\n    \"\"\"\n    This function calculates trigonometric sine, element-wise using MP-SPDZ.\n    \"\"\"\n    length = len(array)\n    sin_res = Array(length, sfix)\n    for i in range(length):\n        sin_res[i] = array[i].sin()\n    return sin_res\n", "model_name": "azure-openai-o1"}
{"test_name": "update_weights", "response_0": "from Compiler.types import sfix, Array\n\ndef update_weights(m, A, X, Y):\n    # A, Y: 1-D arrays of sfix\n    # X: 2-D array (matrix) of sfix\n    # m: sfix (scalar)\n    #\n    # Computes dw = (1/m) * dot(X, (A - Y))\n    # If X has dimensions (d, n), A and Y have length n, result dw has length d.\n\n    d, n = X.sizes\n    dw = Array(d, sfix)\n    for i in range(d):\n        temp_sum = sfix(0)\n        for j in range(n):\n            temp_sum += X[i][j] * (A[j] - Y[j])\n        dw[i] = temp_sum / m\n    return dw\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sfixArray\n\ndef update_weights(m, A, X, Y, n, c):\n    # m: sfix scalar\n    # A, Y: sfixArray of length c\n    # X: sfixArray representing an n x c matrix\n    # n, c: integer dimensions\n    difference = sfixArray(c)\n    for i in range(c):\n        difference[i] = A[i] - Y[i]\n    dw = sfixArray(n)\n    inv_m = sfix(1) / m\n    for i in range(n):\n        temp_sum = sfix(0)\n        for j in range(c):\n            temp_sum += X[i * c + j] * difference[j]\n        dw[i] = temp_sum * inv_m\n    return dw\n", "model_name": "azure-openai-o1"}
{"test_name": "toy_layer", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef sigmoid(x):\n    return sfix(1) / (sfix(1) + sfix.exp(-x))\n\ndef matmul(A, B):\n    # Assuming A is shape (n_rows, n_cols) and B is shape (n_cols, p_cols)\n    n_rows = len(A)\n    n_cols = len(A[0])\n    p_cols = len(B[0])\n    # Create result as an n_rows x p_cols matrix of sfix(0)\n    result = [[sfix(0) for _ in range(p_cols)] for _ in range(n_rows)]\n    # Nested loop for matrix multiplication\n    for i in for_range(n_rows):\n        for j in for_range(p_cols):\n            tmp_sum = sfix(0)\n            for k in for_range(n_cols):\n                tmp_sum += A[i][k] * B[k][j]\n            result[i][j] = tmp_sum\n    return result\n\ndef add_bias(matrix, bias):\n    # Assuming matrix is shape (n_rows, n_cols) and bias is shape (n_cols)\n    n_rows = len(matrix)\n    n_cols = len(matrix[0])\n    for i in for_range(n_rows):\n        for j in for_range(n_cols):\n            matrix[i][j] = matrix[i][j] + bias[j]\n    return matrix\n\ndef toy_layer(input_data, weights, biases):\n    # weights[0] and biases[0] are for the first layer\n    # weights[1] and biases[1] are for the second layer\n    layer1_input = matmul(input_data, weights[0])\n    layer1_input = add_bias(layer1_input, biases[0])\n    layer1_output = [[sigmoid(x) for x in row] for row in layer1_input]\n    \n    layer2_input = matmul(layer1_output, weights[1])\n    layer2_input = add_bias(layer2_input, biases[1])\n    layer2_output = [[sigmoid(x) for x in row] for row in layer2_input]\n    \n    return layer2_output\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import sfix\n\ndef matrix_multiply(A, B):\n    rows_A = len(A)\n    cols_A = len(A[0])\n    rows_B = len(B)\n    cols_B = len(B[0])\n    # Here, cols_A should match rows_B\n    C = [[sfix(0) for _ in range(cols_B)] for _ in range(rows_A)]\n    for i in range(rows_A):\n        for j in range(cols_B):\n            temp_sum = sfix(0)\n            for k in range(cols_A):\n                temp_sum += A[i][k] * B[k][j]\n            C[i][j] = temp_sum\n    return C\n\ndef add_bias(mat, bias):\n    rows = len(mat)\n    cols = len(mat[0])\n    # Assuming 'bias' is a 1-D list of length 'cols'\n    for i in range(rows):\n        for j in range(cols):\n            mat[i][j] += bias[j]\n    return mat\n\ndef sigmoid_matrix(X):\n    rows = len(X)\n    cols = len(X[0])\n    Y = [[sfix(0) for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            # 1 / (1 + exp(-X[i][j]))\n            Y[i][j] = sfix(1) / (sfix(1) + (sfix(0) - X[i][j]).exp())\n    return Y\n\ndef toy_layer(input_data, weights, biases):\n    layer1_input = matrix_multiply(input_data, weights[0])\n    layer1_input = add_bias(layer1_input, biases[0])\n    layer1_output = sigmoid_matrix(layer1_input)\n    \n    layer2_input = matrix_multiply(layer1_output, weights[1])\n    layer2_input = add_bias(layer2_input, biases[1])\n    layer2_output = sigmoid_matrix(layer2_input)\n    return layer2_output\n", "model_name": "azure-openai-o1"}
