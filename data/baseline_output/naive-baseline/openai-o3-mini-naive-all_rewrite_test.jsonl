{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with a given clear index in the array to the end of the array.\n    The index is assumed to be legal.\n    \"\"\"\n    # Create a new list by taking a slice before index and a slice after index\n    new_array = arr[:index] + arr[index+1:]\n    # Append the element at the given index\n    new_array.append(arr[index])\n    return new_array\n", "response_1": "def move_to_end(arr, index):\n    # Move the element at position 'index' to the end of the array.\n    # Create a new list with the element at 'index' removed.\n    new_arr = arr[:index] + arr[index+1:]\n    # Append the removed element at the end.\n    new_arr.append(arr[index])\n    return new_arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef second_largest(arr):\n    # assume arr is a list of secret integers (sint)\n    # Initialize our two candidate values.\n    cand0 = arr[0]\n    cand1 = arr[1]\n    \n    # Loop over the rest of the array (the loop bound is public).\n    for i in range(2, len(arr)):\n        # Compute secure Boolean bits (of type sbit)\n        # Note: In MP-SPDZ, comparisons like (x > y) yield secure bits.\n        cond0 = arr[i] > cand0\n        cond1 = arr[i] > cand1\n        # Compute the OR of these secure bits\n        # (where True is represented as 1 and False as 0)\n        cond = cond0 + cond1 - (cond0 * cond1)\n        \n        # Decide which candidate is smaller:\n        # If cand0 < cand1 then cand0 is the smaller candidate;\n        # otherwise cand1 is the smaller candidate.\n        b = cand0 < cand1  # secure bit: 1 if true, 0 if false\n        \n        # Update the candidate that is smaller if arr[i] qualifies.\n        cand0 = if_else(cond * b, arr[i], cand0)\n        cand1 = if_else(cond * (1 - b), arr[i], cand1)\n    \n    # Return the smaller of the two candidate values.\n    return if_else(cand0 < cand1, cand0, cand1)\n", "response_1": "from Compiler.types import sint\n\ndef second_largest(arr):\n    # Assume len(arr) >= 2.\n    # The two running largest values are stored in arr[0] and arr[1].\n    # Loop through the rest of the array.\n    for i in range(2, len(arr)):\n        # b0 and b1 are secret bits indicating if arr[i] is greater than arr[0] or arr[1].\n        b0 = lt(arr[0], arr[i])\n        b1 = lt(arr[1], arr[i])\n        # cond is a secret bit that is 1 if arr[i] is greater than at least one of arr[0] and arr[1].\n        cond = 1 - (1 - b0) * (1 - b1)\n        # Determine which of arr[0] and arr[1] is smaller.\n        # If small_indicator is 1, then arr[0] < arr[1] and arr[0] is the candidate to update,\n        # otherwise, arr[1] is the candidate.\n        small_indicator = lt(arr[0], arr[1])\n        # Update the candidate element using secret-selection:\n        # For arr[0]: update if small_indicator is 1.\n        arr[0] = (1 - cond * small_indicator) * arr[0] + (cond * small_indicator) * arr[i]\n        # For arr[1]: update if small_indicator is 0.\n        arr[1] = (1 - cond * (1 - small_indicator)) * arr[1] + (cond * (1 - small_indicator)) * arr[i]\n    # After the loop the two numbers in arr[0] and arr[1] are the two largest.\n    # The second largest is the smaller of the two.\n    # Use secret-selection again.\n    second_largest_val = (1 - lt(arr[0], arr[1])) * arr[0] + lt(arr[0], arr[1]) * arr[1]\n    return second_largest_val\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    # Compute the product of (1 - x) for all x in arr.\n    product = 1\n    for x in arr:\n        product *= (1 - x)\n    # If every element is False then product==1, otherwise product==0.\n    ret = 1 - product\n    return ret\n", "response_1": "from Compiler.types import sbit\n\ndef exists_true(arr):\n    ret = sbit(0)\n    for x in arr:\n        ret = ret | x\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_indicator", "response_0": "# Import secure types if needed (for example, sint)\nfrom Compiler.types import sint\n\ndef array_indicator(arr, predicator):\n    # Create an empty list to hold the results.\n    ret = []\n    # Iterate over each element in the array.\n    for i in range(len(arr)):\n        # Apply the predicate on the current element and append the result.\n        ret.append(predicator(arr[i]))\n    # Return the new array.\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    # Initialize an empty list to store the result\n    ret = []\n    # Loop over each element in the input secure array\n    for e in arr:\n        # Apply the predicate function to the element and append the result.\n        ret.append(predicator(e))\n    # Return the resulting secure array\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inner_product", "response_0": "# The following function computes the inner product of two lists\n# of secret integers (sint). Be sure that both lists are of equal length.\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of vec1 and vec2.\n    Both vec1 and vec2 are lists of secure integers of type sint.\n    \"\"\"\n    summation = sint(0)\n    # Iterate over the indices of the vectors (assuming equal length)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n\n# You can now use inner_product with secret inputs, for example:\n#\n#   a = [sint.get_input_from(0) for _ in range(n)]\n#   b = [sint.get_input_from(1) for _ in range(n)]\n#   ip = inner_product(a, b)\n#   ip.reveal()   # To output the result securely\n#\n# Remember that the above usage code should be adapted to your exact protocol\n# and input settings.\n", "response_1": "def inner_product(vec1, vec2):\n    summation = 0\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_shift_2", "response_0": "# Import the secret type (assuming secret integers are used)\nfrom Compiler.types import sint\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array by one position. For example, [0,1,2] becomes [1,2,0].\n    (Note: the Python code given originally shifts the array in a different direction.\n    Here we modify the code so that shifting corresponds to the docstring.)\n    \"\"\"\n    n = len(a)\n    shifted = [None] * n\n    # Shift the array to left by one position:\n    # shifted[i] = a[(i+1)%n] so that, for i==last index, we wrap-around.\n    for i in range(n):\n        shifted[i] = a[(i+1) % n]\n    return shifted\n", "response_1": "# In MP-SPDZ, we define the function array_shift as follows.\ndef array_shift(a):\n    \"\"\"\n    Shift the elements of the array by 1.\n    (According to the index arithmetic: result[i] = a[(i-1) mod len(a)])\n    For example, if a = [0, 1, 2] then shifted = [2, 0, 1].\n    If you wish to have the shifted array be [1, 2, 0] instead (i.e. a left-shift),\n    replace (i-1) with (i+1) below.\n    \"\"\"\n    n = len(a)\n    shifted = [0 for _ in range(n)]\n    for i in range(n):\n        shifted[i] = a[(i - 1) % n]\n    return shifted\n\n# The rest of your MP-SPDZ program can call array_shift as needed.\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    ret = []\n    for a in arr:\n        ret.append(a > bound)\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    # Initialize an empty list for the results.\n    ret = []\n    # Loop over each index of the array. \"len(arr)\" is public.\n    for i in range(len(arr)):\n        # Compute whether arr[i] is greater than bound.\n        # The \">\" operator for sint executes a secure comparison.\n        ret.append(arr[i] > bound)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_rises_2", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr):\n    # Initialize the count as a secret integer with value 0.\n    count = sint(0)\n    # Iterate over consecutive elements.\n    for i in range(len(arr) - 1):\n        # (arr[i] < arr[i+1]) returns a secret 0/1 value.\n        count += (arr[i] < arr[i+1])\n    return count\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import lt\n\ndef count_rises(arr):\n    # Initialize count as a secret integer with value 0.\n    count = sint(0)\n    n = len(arr)\n    # Loop over indices from 0 to n-2\n    for i in range(n-1):\n        # Compute a secret bit: 1 if arr[i] < arr[i+1], else 0.\n        flag = lt(arr[i], arr[i+1])\n        count = count + flag\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    n = len(arr)\n    new_arr = [0] * n\n    for i in range(n):\n        # If the index is even (i % 2 == 0), we decrement the element.\n        if i % 2 == 0:\n            new_arr[i] = arr[i] - 1\n        # Else (odd index) we increment the element.\n        else:\n            new_arr[i] = arr[i] + 1\n    return new_arr\n", "response_1": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    # Create an output list\n    res = []\n    for i in range(len(arr)):\n        # The index i is public so plain if/else works.\n        if i % 2 == 0:\n            # For even indices, subtract 1 from the element.\n            res.append(arr[i] - 1)\n        else:\n            # For odd indices, add 1 to the element.\n            res.append(arr[i] + 1)\n    return res\n\ndef main():\n    # In an actual MP-SPDZ program you would read secret input values.\n    # For instance, you could read a list using sint.get_input_from() if needed.\n    # This main function is left empty as no usage example is provided.\n    pass\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "how_many_roots", "response_0": "from Compiler.library import if_else\n\ndef how_many_roots(a, b, c):\n    # Check if a is zero\n    a_is_zero = a.eq(0)\n    # In the case a == 0, then the number of roots is 0 if b==0, otherwise 1.\n    b_is_zero = b.eq(0)\n    result_case1 = if_else(b_is_zero, 0, 1)\n    \n    # In the case a != 0, compute the discriminant delta:\n    delta = b * b - 4 * a * c\n    delta_pos = delta.gt(0)  # delta > 0 ? \n    delta_zero = delta.eq(0)\n    # Use nested if_else calls: if delta > 0, return 2; else if delta == 0, return 1; otherwise return 0.\n    result_case2 = if_else(delta_pos, 2, if_else(delta_zero, 1, 0))\n    \n    # Finally, select which result to output based on whether a is zero.\n    result = if_else(a_is_zero, result_case1, result_case2)\n    return result\n", "response_1": "from Compiler.library import if_else\n\n# The function how_many_roots takes secret inputs a, b, c.\ndef how_many_roots(a, b, c):\n    # When a == 0:\n    #   if b == 0 then return 0 (degenerate case: constant function),\n    #   else return 1 (resulting in a linear function with one root).\n    # Otherwise, when a != 0, compute the discriminant and use:\n    #   if discriminant > 0 then 2,\n    #   elif discriminant == 0 then 1,\n    #   else 0.\n    \n    disc = b * b - 4 * a * c  # Compute the discriminant only once.\n\n    # For the quadratic branch: use if_else constructs for secure selection.\n    # Since comparisons on secret data yield a secret bit (0 or 1),\n    # we use:\n    #   if disc > 0, then contribute 2,\n    #   if disc == 0, then contribute 1,\n    #   else (disc < 0) both if_else calls yield 0.\n    roots_quad = 2 * if_else(disc > 0, 1, 0) + if_else(disc == 0, 1, 0)\n    \n    # For the a == 0 branch: if b == 0 then 0 else 1.\n    roots_linear = if_else(b == 0, 0, 1)\n\n    # Now select between the linear case (a == 0) and the quadratic case (a != 0)\n    # using a secure if_else on (a == 0).\n    return if_else(a == 0, roots_linear, roots_quad)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint, sbit\n\n# if_else is available in MP-SPDZ.\n# It returns: cond * a + (1-cond) * b,\n# where cond is an sbit (i.e. secret Boolean).\ndef if_else(cond, a, b):\n    return cond * a + (1 - cond) * b\n\n# The predicate function: returns secret 1 if x > 0, else secret 0.\ndef predicator(x):\n    # x > 0 returns an sbit, so we securely select between 1 and 0.\n    return if_else(x > 0, sint(1), sint(0))\n\n# Count the number of elements in the array that satisfy the predicate.\n# Here n is the number of elements in arr.\ndef count_satisfied(arr, n):\n    total = sint(0)\n    for i in range(n):\n        total = total + predicator(arr[i])\n    return total\n", "response_1": "from Compiler.types import sint\n\n# Define a predicate function.\n# Example: check if an element is nonzero (you can replace this with your own)\ndef predicator(e):\n    # e != 0 becomes a secure bit (assuming 0/1 conversion is defined)\n    return sint(1) - (e == sint(0))  # returns 1 if e is nonzero, else 0\n\n# Count the number of elements in arr that satisfy the predicate.\ndef count_satisfied(arr, pred):\n    total = sint(0)\n    for e in arr:\n        # We assume that pred(e) returns a secret bit: 1 if satisfied, 0 otherwise.\n        # It is important that both 1 and 0 are interpreted as secret integers.\n        if pred(e):  \n            total = total + sint(1)\n        else:\n            total = total + sint(0)\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    ret = sint(0)\n    n = len(arr1)\n    for i in range(n):\n        ret = ret + arr1[i] * arr2[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two input lists,\n    compute the product of each corresponding pair and sum them.\n    \"\"\"\n    n = len(arr1)\n    result = sint(0)\n    for i in range(n):\n        result += arr1[i] * arr2[i]\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_round", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_else\n\ndef secure_round(x):\n    # Secure rounding function for a fixed-point number x.\n    # Rounds x to the nearest integer (round half away from zero).\n    pos_round = sint(x + sfix(0.5))\n    neg_round = -sint(-x + sfix(0.5))\n    return if_else(x >= 0, pos_round, neg_round)\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = []\n    for e in arr:\n        ret.append(secure_round(e))\n    return ret\n", "response_1": "def array_round(arr):\n    # Create an empty list to store rounded results.\n    ret = []\n    # Loop over each element in the array.\n    for i in range(len(arr)):\n        # Round the current element.\n        r = round(arr[i])\n        ret.append(r)\n    # Return the new list of rounded values.\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For two input arrays arr and brr (containing secret integers),\n    return an array ret of the same size.\n    For each index i, if arr[i] >= brr[i] then ret[i] is 1, otherwise ret[i] is 0.\n    The two input arrays are assumed to have the same length.\n    \"\"\"\n    ret = [0 for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # (arr[i] < brr[i]) is a secret bit, so 1 - (arr[i] < brr[i])\n        # equals 1 if arr[i]>=brr[i] and 0 otherwise.\n        ret[i] = 1 - (arr[i] < brr[i])\n    return ret\n", "response_1": "from Compiler.types import sint\nfrom Compiler.comparison import lt\n\ndef array_greater_eq(arr, brr):\n    # Create a result array\n    ret = [sint(0)] * len(arr)\n    for i in range(len(arr)):\n        # Compute a secure bit: 1 if arr[i] >= brr[i] (i.e. if NOT arr[i] < brr[i]), else 0.\n        ret[i] = 1 - lt(arr[i], brr[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given array of secret integers, return an array with the same size.\n    If an element of the input array is negative, the corresponding element in the\n    returned array is 1; otherwise, it is 0.\n    \"\"\"\n    ret = []\n    for a in arr:\n        # Use secure selection to check if a is negative, then choose 1 or 0.\n        ret.append(if_else(a < 0, sint(1), sint(0)))\n    return ret\n", "response_1": "from Compiler import if_else, sint\n\ndef indicate_negative(arr):\n    # Compute a new list with 1 if the element is negative, 0 otherwise.\n    ret = [if_else(e < 0, 1, 0) for e in arr]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    For padding, if a is shorter than b, the remaining elements from b are subtracted (i.e. negated).\n    If a is longer than b, the extra elements from a are added as is.\n    \"\"\"\n    pad_length = abs(len(a) - len(b))\n    if len(a) == len(b):\n        pad = []\n    elif len(a) < len(b):\n        pad = b[-pad_length:]\n        pad = [-e for e in pad]\n    else:\n        pad = a[-pad_length:]\n        pad = [e for e in pad]  # no sign change\n    ret = [x - y for x, y in zip(a, b)] + pad\n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    pad_length = abs(len(a) - len(b))\n    \n    # Determine the padding.\n    if len(a) == len(b):\n        pad = []\n    elif len(a) < len(b):\n        # If a is shorter than b, take the last pad_length elements from b and negate them.\n        pad = [-e for e in b[-pad_length:]]\n    else:\n        # If a is longer than b, take the last pad_length elements from a.\n        pad = [e for e in a[-pad_length:]]\n    \n    # Compute the elementwise subtraction for the overlapping portion\n    ret = [x - y for x, y in zip(a, b)]\n    ret += pad   # Append the padding as defined.\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process", "response_0": "# This program shows a function that processes each element of an input array.\n# In this example the processing function is passed from the caller as func.\n# Note: In MP-SPDZ you typically \u201cinline\u201d the functionality of func, or define \n# separate functions, because passing functions as first\u2013class objects is limited.\n\ndef array_process(arr, func):\n    # Get the length of the input array.\n    n = len(arr)\n    # Allocate a new array for the results. In MP-SPDZ arrays have fixed size.\n    new_arr = [None] * n\n    # Loop over each element and apply the function.\n    for i in range(n):\n        new_arr[i] = func(arr[i])\n    return new_arr\n\n# An example processing function that could be inlined or separately defined.\ndef my_func(x):\n    # Example: square the element.\n    return x * x\n\n# If desired one can now use array_process with an input array and the function.\n# For instance:\n# input_arr = [sint(1), sint(2), sint(3)]\n# output_arr = array_process(input_arr, my_func)\n", "response_1": "# In MP-SPDZ, you often import types such as sfix or sint.\nfrom Compiler.types import sfix  # use sfix or sint as appropriate\n\n# Define a processing function for each element.\ndef process_element(e):\n    # For demonstration, we simply perform a sample operation.\n    # Replace this with the actual computation.\n    return e * e\n\n# Process each element of the array using process_element.\ndef array_process(arr):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = process_element(arr[i])\n    return arr\n\n# Main code can then call array_process with a statically defined function.\ndef main():\n    # For example, we create an array of sfix numbers.\n    arr = [sfix(1), sfix(2), sfix(3)]\n    result = array_process(arr)\n    # (The result will be used later or output as needed.)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array to the right by one position.\n    For example, if a = [0, 1, 2] then b = [2, 0, 1].\n    \"\"\"\n    n = len(a)\n    # Create a new list of length n (assuming integers, adjust if using secret types)\n    b = [0] * n\n    # The first element becomes the last element of the original array.\n    b[0] = a[n - 1]\n    # For remaining indices, b[i] gets the value a[i-1].\n    for i in range(1, n):\n        b[i] = a[i - 1]\n    return b\n\n# In a complete MP-SPDZ program, you might have a main block to run the code.\n# For example:\ndef main():\n    # Example: create an array of secret integers (or public integers as needed)\n    a = [1, 2, 3, 4]\n    # Perform the shift operation.\n    shifted = array_shift(a)\n    # Output the result (for public output, convert to integer type if necessary)\n    print_ln(\"Shifted array: %s\", shifted)\n\n# Call the main function.\nmain()\n", "response_1": "def array_shift(a):\n    # Determine the size of the input array\n    n = len(a)\n    # Create a new list of the same length (initialize with 0 or dummy values)\n    res = [0] * n\n    # Place the last element of a as the first element of res.\n    res[0] = a[n - 1]\n    # For the remaining positions, shift each element one position to the right.\n    for i in range(1, n):\n        res[i] = a[i - 1]\n    return res\n\n# Example usage:\n# Let's assume the secret-shared (or public) array contains three elements.\n# Note that in MP-SPDZ, types should be declared appropriately (e.g., sint for secret integers).\n# Here we assume a is a list of public integers. Adjust the type if working with secret values.\na = [0, 1, 2]\nshifted_a = array_shift(a)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "compare_and_select", "response_0": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise, \n    and save the larger value into the returned array.\n    \"\"\"\n    n = len(a)\n    ret = []           # initialize an empty list for the results\n    for i in range(n):\n        # Compute a secret-shared bit; cond is 1 if a[i] > b[i], else 0.\n        cond = a[i] > b[i]\n        # Securely select the larger element:\n        # When cond=1, the result is a[i]; otherwise, it is b[i].\n        ret.append(a[i] * cond + b[i] * (1 - cond))\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    # Create an output list of the same length as a (and b)\n    ret = [None] * len(a)\n    for i in range(len(a)):\n        # Compute a secret bit which is 1 if a[i] > b[i], else 0.\n        # This secret bit multiplication trick avoids secret-dependent branching.\n        c = (a[i] > b[i])\n        ret[i] = c * a[i] + (1 - c) * b[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_subtract", "response_0": "from Compiler.types import sfix\n\ndef array_subtract(a, b):\n    # Pad the shorter array with sfix(0) so both arrays have equal length.\n    if len(a) < len(b):\n        pad = [sfix(0)] * (len(b) - len(a))\n        a = a + pad\n    else:\n        pad = [sfix(0)] * (len(a) - len(b))\n        b = b + pad\n    ret = [x - y for x, y in zip(a, b)]\n    return ret\n", "response_1": "def array_subtract(a, b):\n    # Subtract the first array by the second one elementwise.\n    # If one array is shorter than the other, it is padded with 0.\n    diff = abs(len(a) - len(b))\n    # Create a pad of secure zeros (using sfix(0) for secure fixed-point 0)\n    pad = [sfix(0)] * diff\n    if len(a) < len(b):\n        a = a + pad\n    else:\n        b = b + pad\n    ret = [x - y for x, y in zip(a, b)]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c + c\n", "response_1": "def repeat_array(c):\n    ret = []\n    for element in c:\n        ret.append(element)\n    for element in c:\n        ret.append(element)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "zeros", "response_0": "def zeros(num):\n    \"\"\"\n    Return an array (list) of zeros with length num.\n    \"\"\"\n    return [0 for _ in range(num)]\n", "response_1": "def zeros(num):\n    res = [0] * num\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    # A helper function that securely clips one element based on the bounds.\n    def helper_func(x, ub, lb):\n        # First, choose ub if x >= ub, otherwise choose x.\n        temp = if_else(x >= ub, ub, x)\n        # Now, if temp is above lb it remains unchanged; if not, choose lb.\n        return if_else(temp > lb, temp, lb)\n\n    result = []\n    for x in arr:\n        result.append(helper_func(x, upper_bound, lower_bound))\n    return result\n", "response_1": "from Compiler.library import if_else\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    # For each secret value x in arr the function returns:\n    #   upper_bound, if x >= upper_bound;\n    #   x,           if lower_bound < x < upper_bound;\n    #   lower_bound, if x <= lower_bound.\n    res = []\n    for x in arr:\n        # The inner if_else structure implements the piecewise decision.\n        y = if_else(x >= upper_bound, upper_bound,\n                     if_else(x > lower_bound, x, lower_bound))\n        res.append(y)\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicate):\n    # Initialize the summation (here we assume the output is of type sint)\n    summation = sint(0)\n    # Iterate over each element in the array\n    for a in arr:\n        # Compute a flag by applying the predicate to the element\n        flag = predicate(a)\n        # Add the result to our summation\n        summation = summation + flag\n    return summation\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicate):\n    \"\"\"\n    Count the number of elements in arr satisfying predicate.\n    Here, arr is expected to be a list of secret integers (sint) and \n    predicate is a function that returns 0 or 1 (as a sint) when applied to an element.\n    \"\"\"\n    total = sint(0)\n    for a in arr:\n        total += predicate(a)\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import regint\n\ndef reverse_order_pair(arr):\n    # count the number of reverse order pairs in arr; \n    # a reverse order pair is a pair of indices i < j with arr[i] > arr[j]\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    # Assume arr is a list of secret integers (sint);\n    # if the inputs are public then you may use clear integers.\n    n = len(arr)\n    count = sint(0)\n    for i in range(n):\n        for j in range(i+1, n):\n            # The expression 'arr[i] > arr[j]' produces a secret bit (0 or 1).\n            count = count + (arr[i] > arr[j])\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    # Option 1: using list comprehensions\n    return [x + 1 for x in arr]\n\n    # Option 2: using an explicit loop (uncomment if preferred)\n    # result = []\n    # for x in arr:\n    #     result.append(x + 1)\n    # return result\n", "response_1": "def array_inc(arr):\n    # Increment each element in the secret integer array by 1\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr):\n    count = sint(0)\n    # Iterate over indices 0 to len(arr)-2 since we compare arr[i] with arr[i+1]\n    for i in range(len(arr) - 1):\n        # The expression (arr[i] < arr[i+1]) computes a secure bit (0/1)\n        count = count + (arr[i] < arr[i+1])\n    return count\n", "response_1": "# Import the secret integer type.\nfrom Compiler.types import sint\n\ndef count_rises(arr):\n    # Initialize a secret integer for the count.\n    count = sint(0)\n    # Loop over indices from 0 to len(arr)-2\n    for i in range(len(arr) - 1):\n        # lt returns a secret bit that is 1 if arr[i] < arr[i+1], 0 otherwise.\n        count += lt(arr[i], arr[i+1])\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process_2", "response_0": "# Define the function to be applied to each element.\ndef my_func(x):\n    # Process x here. (For instance, add 1 or perform any other operation.)\n    return x + 1\n\n# Process all elements in the input array using my_func.\ndef array_process(arr, n):\n    # 'n' is the number of elements in arr.\n    for i in range(n):\n        arr[i] = my_func(arr[i])\n    return arr\n", "response_1": "def array_process(arr, func):\n    # Process all elements in the input array with the given function.\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "two_norm", "response_0": "from Compiler.library import sqrt\nfrom Compiler.types import sfix\n\ndef two_norm(vec):\n    # Return the two-norm (Euclidean norm) of the vector vec\n    total = sfix(0)\n    for item in vec:\n        total += item * item\n    return sqrt(total)\n", "response_1": "from Compiler.types import sfix\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    s = sfix(0)\n    for x in vec:\n        s = s + x * x\n    return s.sqrt()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether secret array a \"totally dominates\" secret array b,\n    meaning any element in a is no smaller than any element in b.\n    This is achieved by computing the secret minimum of a and the secret maximum of b,\n    then comparing them.\n    \"\"\"\n    # Compute the secret minimum of a\n    amin = a[0]\n    for x in a[1:]:\n        # The secret operation: if x < amin then select x, else keep amin.\n        cond = x < amin   # cond is a secret bit: 1 if True, 0 if False.\n        # Use secret multiplexer: new amin = cond * x + (1-cond) * amin\n        amin = cond * x + (1 - cond) * amin\n\n    # Compute the secret maximum of b\n    bmax = b[0]\n    for x in b[1:]:\n        # If x > bmax then select x, else keep bmax.\n        cond = x > bmax  # cond is a secret bit.\n        bmax = cond * x + (1 - cond) * bmax\n\n    # The arrays satisfy the totally dominant relation if amin >= bmax.\n    # We compute the secret Boolean for the condition\n    # Note that (amin < bmax) returns a secret bit that is 1 if true.\n    result = 1 - (amin < bmax)\n    return result\n", "response_1": "def totally_dominate(a, b):\n    # Compute the minimum element of a.\n    amin = a[0]\n    for i in range(1, len(a)):\n        # if a[i] < amin then choose a[i], else retain amin.\n        # The function if_else(c, x, y) returns x when condition c holds and y otherwise.\n        amin = if_else(a[i] < amin, a[i], amin)\n    # Compute the maximum element of b.\n    bmax = b[0]\n    for i in range(1, len(b)):\n        bmax = if_else(b[i] > bmax, b[i], bmax)\n    # Return whether amin is no smaller than bmax.\n    return amin >= bmax\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1, vec2):\n    summation = sint(0)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    # Compute the inner product of two arrays\n    summation = 0\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    # Create an empty list to hold the subarray\n    ret = []\n    # Loop over the public indices and append the corresponding element from a.\n    for i in indices:\n        ret.append(a[i])\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = []\n    for i in indices:\n        ret.append(a[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    # Initialize a secure indicator to 0\n    exists = sint(0)\n    for x in arr:\n        # x==5 and x==7 each produce a secret 0/1, so we add them.\n        exists += (x == 5) + (x == 7)\n    # If at least one occurrence occurred, exists is nonzero.\n    # The expression (exists != 0) returns a secret boolean (sint) that is 1 if true, else 0.\n    return exists != 0\n", "response_1": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    found = sint(0)\n    for a in arr:\n        # (a == 5) and (a == 7) produce secret bits (0 or 1)\n        found += (a == 5) + (a == 7)\n    return (found > 0)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    ret = []\n    for i in range(len(arr)):\n        if i != index:\n            ret.append(arr[i])\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    # Create an output array of size one less than the input\n    ret = [0] * (len(arr) - 1)\n    pos = 0\n    # Iterate through all indices of the original array\n    for i in range(len(arr)):\n        # Skip the element at the given index\n        if i == index:\n            continue\n        ret[pos] = arr[i]\n        pos += 1\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "average", "response_0": "def average(arr):\n    # Compute the sum manually; built\u2010in sum() may not be available\n    summation = 0\n    for a in arr:\n        summation = summation + a\n\n    # Determine the length of the array\n    length = len(arr)\n\n    # Compute the average by dividing the sum by the length\n    # If using secure fixed point, the division is performed on sfix values.\n    ret = summation / length\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef average(arr):\n    # Compute the total sum of secret fixed-point numbers in the array.\n    summation = sfix(0)\n    for x in arr:\n        summation = summation + x\n    # Divide the sum by the array length (a public constant).\n    ret = summation / len(arr)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
