{"test_name": "indicate_positive", "response_0": "from Compiler.library import if_else\nfrom Compiler.types import sint\n\ndef indicate_positive(arr):\n    ret = [0 for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # if arr[i] > 0 then choose 1 else 0, using secure selection\n        ret[i] = if_else(arr[i] > 0, 1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_positive(arr):\n    # Create an output list of the same size, initialized with secret zeros.\n    ret = [sint(0) for i in range(len(arr))]\n    for i in range(len(arr)):\n        # (arr[i] > 0) is a secret boolean.\n        # Use its if_else method to securely choose between 1 and 0.\n        ret[i] = (arr[i] > 0).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_xor", "response_0": "def array_xor(a, b):\n    \"\"\"\n    Compute the elementwise XOR of the two input vectors assumed to be secret bits.\n    \"\"\"\n    ret = [sbit(0) for _ in range(len(a))]\n    for i in range(len(a)):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "response_1": "def array_xor(a, b):\n    # Allocate a result vector of the same length as a and b.\n    ret = [0 for _ in range(len(a))]\n    for i in range(len(a)):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "interlaced_placement", "response_0": "# Declare our interlaced placement function. We assume that a and b\n# are lists of secret integers (sint) and that they have the same length.\ndef interlaced_placement(a, b):\n    # Allocate a new list of secret integers. Here we initialize every entry\n    # to 0. The secret type sint is used for secure integers.\n    ret = [sint(0) for i in range(len(a) * 2)]\n    \n    # Loop through all positions in the result array. The loop counter i is public.\n    for i in range(len(a) * 2):\n        # When i is odd, pick an element from b.\n        if i % 2 == 1:\n            # Compute the index for b. Note that (i-1)//2 is public.\n            ret[i] = b[(i - 1) // 2]\n        else:\n            # Otherwise, pick an element from a.\n            ret[i] = a[i // 2]\n    \n    return ret\n\n# [The rest of the program would call interlaced_placement with appropriate input arrays.]\n", "response_1": "def interlaced_placement(a, b):\n    # It is assumed that len(a) == len(b) and that this length is public.\n    n = len(a)\n    ret = [0] * (2 * n)\n    for i in range(2 * n):\n        if i % 2:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_and", "response_0": "def array_and(a, b):\n    # Compute the elementwise AND (i.e. multiplication when booleans are in {0,1})\n    ret = [0] * len(a)\n    for i in range(len(a)):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "def array_and(a, b):\n    # We assume that a and b are lists of secret shared bits (or 0/1 secret integers)\n    n = len(a)\n    ret = [0] * n\n    for i in range(n):\n        # Multiply the bits to compute the AND: (0*anything=0, 1*1=1)\n        ret[i] = a[i] * b[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_indicator", "response_0": "from Compiler.types import sbit\n\ndef array_indicator(arr, predicator):\n    # Initialize an array of the same length as arr, filled with secure false (sbit(0))\n    ret = [sbit(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # Apply the predicate to each element.\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    # Create a return array (of the same length) initialized with a default value.\n    # Here we assume that the return type is compatible with the output of predicator.\n    ret = [0] * len(arr)\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    ret = []\n    for i in range(len(arr)):\n        # The result of (arr[i] > bound) is a secret boolean (sbit)\n        ret.append(arr[i] > bound)\n    return ret\n", "response_1": "from Compiler.types import sint, sbit\n\ndef array_greater_than_scalar(arr, bound):\n    # Initialize the return list with dummy secret booleans.\n    ret = [None] * len(arr)\n    for i in range(len(arr)):\n        # Compare each secret integer in arr with the bound.\n        # The result is a secret boolean (sbit).\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_no_greater_than_scalar", "response_0": "from Compiler.types import sint, sbit\n\ndef array_no_greater_than_scalar(arr, bound):\n    # Initialize a list of sbit false (0) for each element in arr.\n    ret = [sbit(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # The expression `arr[i] <= bound` returns a secret bit (sbit) indicating \n        # whether the element is no greater than the bound.\n        ret[i] = arr[i] <= bound\n    return ret\n", "response_1": "def array_no_greater_than_scalar(arr, bound):\n    # Allocate an array to hold the result (each element is a secret bit)\n    ret = [False for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # This comparison (if arr[i] and bound are of type sint) \n        # yields a secret boolean (sbit) representing whether arr[i] is no greater than bound.\n        ret[i] = arr[i] <= bound\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    n = len(a)\n    # create a list b of length n (initialize with zeros)\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[n - 1 - i]\n    # Concatenate a and b\n    return a + b\n", "response_1": "def reverse_and_concat(a):\n    n = len(a)\n    # Create array b for the reverse of a.\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[n - 1 - i]\n    \n    # Create array c for the final result which is the concatenation of a and b.\n    c = [0] * (2 * n)\n    for i in range(n):\n        c[i] = a[i]\n    for i in range(n):\n        c[n + i] = b[i]\n    \n    return c\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_round", "response_0": "from Compiler.types import sfix, sint, sbit\n\ndef array_round(arr):\n    # Create an output array of the same length as arr.\n    ret = [0] * len(arr)\n    for i in range(len(arr)):\n        # Convert the sfix value to an integer via truncation.\n        int_part = int(arr[i])\n        # Compute the difference between arr[i] and the integer floor.\n        diff = arr[i] - sfix(int_part)\n        # Use the secret comparison: if diff < 0.5 then cond is a secret bit (sbit) equal to 1,\n        # otherwise it is 0. Since we want int_part when diff is less than 0.5,\n        # and int_part+1 otherwise, we use a conditional selection.\n        cond = lt(diff, sfix(0.5))\n        # if_else(cond, a, b) returns a when cond is true and b otherwise.\n        ret[i] = if_else(cond, int_part, int_part + 1)\n    return ret\n", "response_1": "from Compiler.Library import sfix\n\ndef array_round(arr):\n    ret = [None for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # int_part approximates floor(arr[i]) for nonnegative values\n        int_part = arr[i].truncate()\n        diff = arr[i] - int_part\n        # if diff < 0.5 then add 0, else add 1. Use branchless if_else.\n        add = sfix.if_else(diff < sfix(0.5), sfix(0), sfix(1))\n        ret[i] = int_part + add\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    ret = [0 for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # In MP-SPDZ, the comparison (arr[i] >= brr[i]) produces a secret shared bit.\n        ret[i] = arr[i] >= brr[i]\n    return ret\n", "response_1": "from Compiler.types import sint\nfrom Compiler.Library import if_then_else\n\ndef array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr (of type sint), return an array ret with the same size.\n    For each index i, if arr[i] >= brr[i], ret[i] is set to 1, otherwise it is set to 0.\n    The two input arrays are assumed to be of equal length.\n    \"\"\"\n    n = len(arr)\n    ret = [sint(0)] * n\n    for i in range(n):\n        # Use the constant-time if_then_else operation to select 1 or 0.\n        ret[i] = if_then_else(arr[i] >= brr[i], sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "reverse", "response_0": "# Function to reverse an array of secret integers (sint)\ndef reverse(arr):\n    # Create a list of length equal to arr filled with zeros of type sint.\n    ret = [sint(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        ret[i] = arr[len(arr) - 1 - i]\n    return ret\n", "response_1": "def reverse(arr):\n    # Initialize a list of secret integers with zeros.\n    ret = [sint(0) for i in range(len(arr))]\n    n = len(arr)\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    # Create an output list to hold the results\n    ret = []\n    # Iterate over each secret integer in arr\n    for i in range(len(arr)):\n        # Compute the secret bit that is 1 if arr[i] < 0 and 0 otherwise.\n        # Note that comparisons of secret integers yield a secret bit.\n        cond = (arr[i] < 0)\n        # Instead of branching, we use arithmetic:\n        # ret_val will be cond * 1 + (1 - cond) * 0\n        ret_val = cond * sint(1) + (1 - cond) * sint(0)\n        ret.append(ret_val)\n    return ret\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given array of secret integers (sint),\n    return an array (of the same size) of secret integers,\n    where each position is 1 if the corresponding element of arr is negative,\n    and 0 otherwise.\n    \"\"\"\n    n = len(arr)\n    ret = [sint(0) for i in range(n)]\n    for i in range(n):\n        # Securely select 1 if arr[i] < 0, else 0.\n        ret[i] = if_else(arr[i] < 0, sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_sub_sequence", "response_0": "from Compiler.library import if_else\nfrom Compiler.types import sint\n\ndef max_sub_sequence(arr):\n    \"\"\"\n    Use dynamic programming to compute the maximum sum of a continuous\n    subsequence from the secret input array arr.\n    \"\"\"\n    n = len(arr)\n    # Initialize the arrays for dynamic programming.\n    partial_max = [None] * n  # partial_max[i] stores the best sum so far\n    suffix_max = [None] * n   # suffix_max[i] stores the maximum sum ending at index i\n\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n\n    # Loop over the array starting at index 1.\n    for i in range(1, n):\n        # Compute suffix_max[i]: if suffix_max[i-1]>=0 then add arr[i], otherwise restart at arr[i]\n        cond = suffix_max[i-1] >= 0  # cond is a secret bit (sbit)\n        sum_val = suffix_max[i-1] + arr[i]\n        suffix_max[i] = if_else(cond, sum_val, arr[i])\n        \n        # Compute partial_max[i]: choose the maximum of partial_max[i-1] and suffix_max[i]\n        cond2 = partial_max[i-1] >= suffix_max[i]\n        partial_max[i] = if_else(cond2, partial_max[i-1], suffix_max[i])\n\n    return partial_max[n-1]\n\n# Example usage inside main.\n# Typically, one would read secret inputs, call max_sub_sequence, and output the result.\ndef main():\n    # Suppose we read n (public) and then secret inputs.\n    n = sint.get_input_from(0)  # In practice, n can be made public or read from input.\n    arr = [0] * int(n.reveal())  # Converting n to a clear value for loop iteration.\n    for i in range(len(arr)):\n        arr[i] = sint.get_input_from(0)\n    res = max_sub_sequence(arr)\n    res.reveal()  # Output the result publicly.\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef max_sub_sequence(arr):\n    n = len(arr)\n    # Initialize the lists using list comprehensions so that each entry is a secret integer\n    partial_max = [sint(0) for _ in range(n)]\n    suffix_max = [sint(0) for _ in range(n)]\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    for i in range(1, n):\n        # Compute the new suffix maximum securely:\n        # If the previous suffix is nonnegative, add the current element;\n        # otherwise, just take the current element.\n        cond1 = suffix_max[i-1] >= 0\n        suffix_max[i] = if_else(cond1, suffix_max[i-1] + arr[i], arr[i])\n        # Compute the overall maximum so far securely:\n        # If the previous overall maximum is at least as large as the current suffix, keep it;\n        # otherwise, update it to the current suffix.\n        cond2 = partial_max[i-1] >= suffix_max[i]\n        partial_max[i] = if_else(cond2, partial_max[i-1], suffix_max[i])\n    return partial_max[n-1]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "compare_and_select", "response_0": "from Compiler import if_else\n\ndef compare_and_select(a, b):\n    # assume a and b are lists of secret integers (sint)\n    ret_array = []\n    for i in range(len(a)):\n        # The secure function if_else selects a[i] if the condition is true,\n        # or b[i] otherwise.\n        ret_array.append(if_else(a[i] > b[i], a[i], b[i]))\n    return ret_array\n", "response_1": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare two arrays elementwise, and save the larger (secret) value \n    into the returned array.\n    \"\"\"\n    ret_array = [sint(0)] * len(a)\n    for i in range(len(a)):\n        # The comparison produces a secret bit (1 if a[i] > b[i], else 0)\n        cond = a[i] > b[i]\n        ret_array[i] = a[i] * cond + b[i] * (1 - cond)\n    return ret_array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_element_frequency", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef count_element_frequency(l):\n    # l is expected to be a list of secret integers (sint)\n    n = len(l)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            # Compute a secret indicator that is 1 if l[i] equals l[j], and 0 otherwise.\n            # Note that the subtraction l[i] - l[j] is secret so the equality must be computed securely.\n            indicator = if_else(l[i] - l[j] == 0, sint(1), sint(0))\n            ret[i] = ret[i] + indicator\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef count_element_frequency(l):\n    # l is assumed to be a list of secret integers (sint)\n    n = len(l)  # Length of the list (public)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            # Instead of a secret-branching if-statement, we add the result of the equality\n            # operation (which is a secret bit: 1 if equal, 0 otherwise).\n            ret[i] += (l[j] == l[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_or", "response_0": "def array_or(a, b):\n    # Create a result vector of the same length as a.\n    ret = [0] * len(a)\n    for i in range(len(a)):\n        # Compute the elementwise OR using arithmetic expression.\n        ret[i] = a[i] + b[i] - a[i] * b[i]\n    return ret\n", "response_1": "def array_or(a, b):\n    # Compute the elementwise OR of two bit vectors.\n    # For bits (0/1), a OR b = a + b - a * b.\n    ret = [0] * len(a)\n    for i in range(len(a)):\n        ret[i] = a[i] + b[i] - a[i] * b[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "stock_predicator", "response_0": "# Import secret integer type from MP-SPDZ\nfrom Compiler.types import sint\n\n# Define the stock prediction function. It takes a list of stock prices (days)\n# and returns the maximum profit obtainable by buying on an earlier day\n# and selling on a later day.\ndef stock_predicator(days):\n    n = len(days)\n    # Allocate arrays for the lowest prices seen so far and for the best partial profits.\n    lowest = [sint(0)] * n\n    partial_max = [sint(0)] * n\n    \n    # Initialize the first day.\n    lowest[0] = days[0]\n    partial_max[0] = sint(0)  # no profit on the first day\n\n    # Process each subsequent day.\n    for i in range(1, n):\n        # Choose the smaller value between the lowest price so far and the current day's price.\n        if lowest[i-1] <= days[i]:\n            lowest[i] = lowest[i-1]\n        else:\n            lowest[i] = days[i]\n\n        # Compute profit if we sell on the current day using the best purchase price so far.\n        current_profit = days[i] - lowest[i-1]\n        \n        # Choose the maximum between the previous best profit and current profit.\n        if partial_max[i-1] >= current_profit:\n            partial_max[i] = partial_max[i-1]\n        else:\n            partial_max[i] = current_profit\n\n    return partial_max[n-1]\n\n# The main function for an MP-SPDZ program.\ndef main():\n    # Here one would typically read the secret input values (e.g., stock prices) into the 'days' list.\n    # For example, one could use: days = [sint.get_input_from(0) for _ in range(n)]\n    # The dynamic programming function is then called on the list.\n    # Result of the computation can be output using partial_max[...].reveal() if desired.\n    pass\n", "response_1": "from Compiler.types import sint, sbit\nfrom Compiler.library import if_else\n\ndef stock_predicator(days):\n    n = len(days)\n    # Allocate lists for the lowest prices seen so far and partial maximum profits.\n    lowest = [sint(0)] * n\n    partial_max = [sint(0)] * n\n\n    # Initialize the first day.\n    lowest[0] = days[0]\n    partial_max[0] = sint(0)  # profit is 0 on day 0\n\n    # Iterate from the second day onward.\n    for i in range(1, n):\n        # For the i-th day, choose the smallest price seen so far and compute\n        # the candidate profit if selling on day i.\n        # Use secure comparisons along with secure selection.\n        cond = lowest[i-1] <= days[i]  # cond is of type sbit\n        lowest[i] = if_else(cond, lowest[i-1], days[i])\n        \n        profit = days[i] - lowest[i-1]\n        cond2 = partial_max[i-1] >= profit\n        partial_max[i] = if_else(cond2, partial_max[i-1], profit)\n    \n    return partial_max[n-1]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "len5_inc_array", "response_0": "def len5_inc_array(init):\n    ret = []\n    for i in range(5):\n        ret.append(init + i)\n    return ret\n", "response_1": "def len5_inc_array(init):\n    # Initialize an array of length 5\n    ret = [None] * 5\n    for i in range(5):\n        # Adding a public integer i to a secret integer is allowed.\n        ret[i] = init + i\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cut_first_five", "response_0": "def cut_first_five(arr):\n    # Create a list of five zeros.\n    ret = [0 for i in range(5)]\n    \n    # Use the clear (public) length of the input list,\n    # and update ret with elements from arr up to the first five.\n    for i in range(min(5, len(arr))):\n        ret[i] = arr[i]\n        \n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef cut_first_five(arr):\n    # Initialize ret with 5 secret zeros.\n    ret = [sint(0) for i in range(5)]\n    # Loop over the minimum of 5 or the length of arr.\n    for i in range(min(5, len(arr))):\n        ret[i] = arr[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_pooling_1d", "response_0": "def max_pooling_1d(vec, step):\n    ret_length = len(vec) // step      # number of windows (ignore remainder)\n    ret = [0] * ret_length             # initialize result list\n    for i in range(ret_length):\n        max_val = vec[i * step]        # initial maximum is the first element of the window\n        for j in range(step):\n            # Use a secure comparison if using secret types.\n            if vec[i * step + j] > max_val:\n                max_val = vec[i * step + j]\n        ret[i] = max_val\n    return ret\n", "response_1": "def max_pooling_1d(vec, step):\n    # Compute the length of the output vector\n    ret_length = len(vec) // step\n    # Initialize the output vector\n    ret = [0 for i in range(ret_length)]\n    # Iterate over each pooling window\n    for i in range(ret_length):\n        # Set initial maximum value to the first element in the window.\n        current_max = vec[i * step]\n        # Iterate over elements in the pooling window.\n        for j in range(step):\n            # Here we use a secure comparison if necessary. \n            if vec[i * step + j] > current_max:\n                current_max = vec[i * step + j]\n        ret[i] = current_max\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater", "response_0": "def array_greater(arr, brr):\n    # Initialize a list of secret zeros with the same length as arr. \n    ret = [sint(0)] * len(arr)\n    for i in range(len(arr)):\n        # (arr[i] > brr[i]) returns a secret bit equal to 1 if the comparison holds and 0 otherwise.\n        ret[i] = (arr[i] > brr[i])\n    return ret\n", "response_1": "from Compiler.library import if_else\n\ndef array_greater(arr, brr):\n    # Create an array 'ret' of the same length as the inputs, initializing with secret 0.\n    ret = [sint(0)] * len(arr)\n    for i in range(len(arr)):\n        # The condition arr[i] > brr[i] is evaluated securely.\n        # if_else returns sint(1) if true and sint(0) otherwise.\n        ret[i] = if_else(arr[i] > brr[i], sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "dumb_concat", "response_0": "def dumb_concat(arr, brr):\n    # Calculate total length of the new array.\n    length = len(arr) + len(brr)\n    # Initialize ret as a list of zeros.\n    ret = [0 for i in range(length)]\n    # Copy all elements from arr.\n    for i in range(len(arr)):\n        ret[i] = arr[i]\n    # Copy all elements from brr.\n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n    return ret\n", "response_1": "def dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    # Calculate the total length and create a list of zeros.\n    length = len(arr) + len(brr)\n    ret = [0 for _ in range(length)]\n    \n    # Copy the first array.\n    for i in range(len(arr)):\n        ret[i] = arr[i]\n    \n    # Copy the second array.\n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n    \n    return ret\n\n# Main function (if needed for the MP-SPDZ program structure)\ndef main():\n    # Here you can call dumb_concat with appropriate arrays.\n    # For example, if you are working with public integers:\n    a = [1, 2, 3]\n    b = [4, 5]\n    c = dumb_concat(a, b)\n    # Use 'print_ln' to output values in MP-SPDZ.\n    for value in c:\n        print_ln('%s', value)\n\n# If you want this to run as the main program:\nif __name__ == '__main__':\n    main()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicator_if_else", "response_0": "def indicator_if_else(a, b, ind):\n    # Create an output array c with the same length as the indicator array.\n    c = [0] * len(ind)\n    for i in range(len(ind)):\n        # Using arithmetic selection to choose the element\n        c[i] = a[i] * ind[i] + b[i] * (1 - ind[i])\n    return c\n", "response_1": "def indicator_if_else(a, b, ind):\n    # Create an output list with the same length as the indicator list.\n    c = [0] * len(ind)\n    for i in range(len(ind)):\n        # Use arithmetic selection to choose between a[i] and b[i]\n        c[i] = a[i] * ind[i] + b[i] * (1 - ind[i])\n    return c\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "elementwise_multiplication", "response_0": "def elementwise_multiplication(a, b):\n    # Assuming 'a' and 'b' are lists of secret shared integers (e.g., sint)\n    ret = [0 for _ in range(len(a))]\n    for i in range(len(a)):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "def elementwise_multiplication(a, b):\n    # Initialize a list of secret integers (sint) with zeros.\n    ret = [sint(0) for i in range(len(a))]\n    for i in range(len(a)):\n        ret[i] = a[i] * b[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "get_subarr_by_indices", "response_0": "from Compiler.types import sint\n\ndef get_subarr_by_indices(a, indices):\n    # Build an empty list to accumulate the subarray elements.\n    ret = []\n    # Iterate over the public indices.\n    for i in range(len(indices)):\n        # Use the public index to access a's element.\n        ret.append(a[indices[i]])\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    # Pre-allocate the result array with zeros, its length being that of indices\n    ret = [0] * len(indices)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inc_array", "response_0": "def inc_array(num):\n    \"\"\"\n    Return an array with length num and elements 1 to num.\n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    arr = []\n    for i in range(num):\n        arr.append(i + 1)\n    return arr\n", "response_1": "def inc_array(num):\n    \"\"\"\n    Return an array with length num and elements from 1 to num.\n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    # Initialize an empty list.\n    res = []\n    # Loop from 0 to num-1 and append i+1 to the result list.\n    for i in range(num):\n        res.append(i + 1)\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cut_last_five", "response_0": "def cut_last_five(arr):\n    # Initialize a list of five zeros.\n    ret = [0, 0, 0, 0, 0]\n    # Determine how many elements to copy.\n    num = min(5, len(arr))\n    # For each element to copy, assign it to the proper slot.\n    for i in range(num):\n        ret[4 - i] = arr[len(arr) - 1 - i]\n    return ret\n", "response_1": "def cut_last_five(arr):\n    # Create a list of 5 zeros (as secure integers)\n    ret = [sint(0) for i in range(5)]\n    length = len(arr)\n    m = min(5, length)\n    # Fill the result with the last m elements of arr in reverse order.\n    for i in range(m):\n        ret[4 - i] = arr[length - 1 - i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "average_pooling_1d", "response_0": "def average_pooling_1d(vec, step):\n    # Determine the number of complete pooling windows\n    ret_length = len(vec) // step\n    # Allocate the result vector of sfix numbers initialized to 0\n    ret = [sfix(0)] * ret_length\n    # Pre-compute the multiplicative inverse of step (division by a constant implies multiplication by its inverse)\n    inv_step = sfix(1) / sfix(step)\n    # Loop over each pooling window\n    for i in range(ret_length):\n        avg = sfix(0)\n        # Sum up the elements in the current window. Division is done by multiplying with the inverse.\n        for j in range(step):\n            avg += vec[i * step + j] * inv_step\n        ret[i] = avg\n    return ret\n", "response_1": "# In MP-SPDZ, we assume that the vector consists of sfix values.\n# Make sure to compile with a protocol that supports sfix arithmetic.\n\nfrom Compiler.types import sfix\n\ndef average_pooling_1d(vec, step):\n    \"\"\"\n    Do 1-dimensional average pooling on vec with step.\n    Only complete pooling windows are averaged.\n    \"\"\"\n    ret_length = len(vec) // step\n    # Create a list initialized to sfix(0)\n    ret = [sfix(0) for _ in range(ret_length)]\n    # Compute the multiplicative inverse of step as sfix\n    inv_step = sfix(1) / sfix(step)\n    for i in range(ret_length):\n        s = sfix(0)\n        for j in range(step):\n            # Sum the elements in the pooling window\n            s += vec[i * step + j]\n        # Multiply by inverse to compute the average\n        ret[i] = s * inv_step\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_relu", "response_0": "# Define the array_relu function in MP-SPDZ\ndef array_relu(arr):\n    # Create a result array of the same length, initializing each element as sfix(0)\n    ret = [sfix(0) for i in range(len(arr))]\n    # Loop over every element and apply the secure ReLU\n    for i in range(len(arr)):\n        # Use secure selection: if arr[i] >= 0 then select arr[i], else 0.\n        ret[i] = if_else(arr[i] >= 0, arr[i], sfix(0))\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_relu(arr):\n    # Create a list of secret zeros with the same length as arr\n    ret = [sint(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # The secure if-statement below will obliviously select the value.\n        if arr[i] >= 0:\n            ret[i] = arr[i]\n        else:\n            ret[i] = sint(0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "move_to_end", "response_0": "from Compiler.types import sint\n\ndef move_to_end(arr, index):\n    # Save the element at the given index.\n    temp = arr[index]\n    # Shift all elements following the index one position to the left.\n    for i in range(index + 1, len(arr)):\n        arr[i - 1] = arr[i]\n    # Place the shifted-out element at the end.\n    arr[len(arr) - 1] = temp\n    return arr\n", "response_1": "def move_to_end(arr, index):\n    # Get the element at the given index.\n    temp = arr[index]\n    # Shift each subsequent element one position to the left.\n    for i in range(index + 1, len(arr)):\n        arr[i - 1] = arr[i]\n    # Place the saved element into the last position.\n    arr[len(arr) - 1] = temp\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "set_to_zero", "response_0": "from Compiler.types import sint\n\ndef set_to_zero(arr, index):\n    # Set the element at position 'index' in the array arr to a secret zero.\n    arr[index] = sint(0)\n    return arr\n", "response_1": "def set_to_zero(arr, index):\n    \"\"\"\n    Set the element in the input array with given index to zero.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = 0  # use sint(0) here if arr contains secret integers\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "last_partial_sum", "response_0": "def last_partial_sum(arr, n):\n    ret = sint(0)\n    for i in range(len(arr) - n, len(arr)):\n        ret = ret + arr[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef last_partial_sum(arr, n):\n    ret = sint(0)\n    for i in range(len(arr) - n, len(arr)):\n        ret = ret + arr[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "permute_by_indices", "response_0": "def permute_by_indices(a, indices):\n    # Allocate an output list of the same length as a.\n    ret = [0] * len(a)\n    for i in range(len(a)):\n        # The i-th element in ret is set to a[indices[i]].\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def permute_by_indices(a, indices):\n    # Assume that a is a list of secure integers (sint) and that indices is a list of public integers.\n    ret = [sint(0) for i in range(len(a))]\n    for i in range(len(a)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "get_rank", "response_0": "from Compiler.types import sint\n\ndef get_rank(arr, index):\n    \"\"\"\n    Get the rank in the array of the element (i.e. the number of elements\n    that are strictly smaller than the element at the given index).\n    \"\"\"\n    rank = sint(0)\n    for item in arr:\n        # The secure comparison (item < arr[index]) returns a secret Boolean.\n        # Converting it to sint gives 1 if true and 0 otherwise.\n        rank = rank + sint(item < arr[index])\n    return rank\n", "response_1": "def get_rank(arr, index):\n    # Assuming arr[i] are secure integers (sint) and index is an appropriate type.\n    rank = sint(0)\n    for item in arr:\n        if item < arr[index]:\n            rank = rank + 1\n    return rank\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "interchange_by_indices", "response_0": "def interchange_by_indices(arr, index1, index2):\n    # Temporarily store the element at index1\n    temp = arr[index1]\n    # Replace the element at index1 with the one at index2\n    arr[index1] = arr[index2]\n    # Replace the element at index2 with the stored temporary value\n    arr[index2] = temp\n    return arr\n", "response_1": "from Compiler.types import sint, cint\n\ndef interchange_by_indices(arr, index1, index2):\n    # Swap the two elements using a temporary variable.\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "increase_by", "response_0": "from Compiler.types import sint\n\ndef increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] + k\n    return arr\n", "response_1": "def increase_by(arr, index, k):\n    # Increase the element arr[index] in the array arr by k.\n    # Note: index must be public.\n    arr[index] = arr[index] + k\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "retrieve_by_index", "response_0": "def retrieve_by_index(arr, index):\n    # Retrieve the element in the array by index.\n    # The input index is guaranteed to be legal.\n    return arr[index]\n", "response_1": "def retrieve_by_index(arr, index):\n    # Retrieve the element in the array by index.\n    # Here arr is expected to be a list (for example, of secret integers, i.e. sint)\n    # and index is a public integer that is within bounds.\n    return arr[index]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "scale_by", "response_0": "# MP-SPDZ version of scale_by\ndef scale_by(arr, index, k):\n    # Multiply the element at position 'index' in arr by k.\n    arr[index] = arr[index] * k\n    return arr\n", "response_1": "def scale_by(arr, index, k):\n    # Multiply the element at position 'index' in the array 'arr' by k.\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "take_opposite_to", "response_0": "def take_opposite_to(arr, index):\n    \"\"\"\n    Take opposite to the element in the array with given index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = -arr[index]\n    return arr\n", "response_1": "from Compiler.Types import sint\n\ndef take_opposite_to(arr, index):\n    \"\"\"\n    Take opposite to the element in the array with given index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = -arr[index]\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_rank", "response_0": "from Compiler.types import sint\n\ndef array_rank(l):\n    \"\"\"\n    Return an array with the same size as l, where each position i records,\n    in a secret-shared manner, the number of elements in l that are smaller than l[i].\n    \"\"\"\n    n = len(l)\n    ret = [sint(0) for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            # (l[j] < l[i]) returns a secret bit (0 or 1) indicating the comparison result.\n            ret[i] = ret[i] + (l[j] < l[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_rank(l):\n    # Initialize an array of the same length with secret zeroes.\n    ret = [sint(0) for _ in range(len(l))]\n    for i in range(len(l)):\n        for j in range(len(l)):\n            # Comparison between secret integers yields a secret bit.\n            b = l[j] < l[i]\n            ret[i] = ret[i] + b\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "remove_by_index", "response_0": "from Compiler.types import sint\n\ndef remove_by_index(arr, index):\n    n = len(arr)\n    # Initialize the resulting array with n-1 secret integers\n    ret = [sint(0) for _ in range(n - 1)]\n    for i in range(n - 1):\n        if i < index:\n            ret[i] = arr[i]\n        else:\n            ret[i] = arr[i + 1]\n    return ret\n\n# In MP-SPDZ applications, you might later call remove_by_index as part\n# of a larger computation.\n", "response_1": "from Compiler.types import sint\n\ndef remove_by_index(arr, index):\n    # Create a list with (length-1) elements\n    ret = [0 for i in range(len(arr)-1)]\n    for i in range(len(arr)-1):\n        if i < index:\n            ret[i] = arr[i]\n        else:\n            ret[i] = arr[i+1]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "process_by_index", "response_0": "# Define a processing function.\n# In MP-SPDZ, you cannot pass a function as an argument,\n# so you define a fixed function to be applied.\ndef func(x: sint) -> sint:\n    # Example processing: increment the value by one.\n    # Replace this with the desired operation.\n    return x + 1\n\n# Define the process_by_index function.\ndef process_by_index(arr: list[sint], index: regint) -> list[sint]:\n    \"\"\"\n    Process the element in the input array at the given index using func.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    # Update the element at the specified index using the processing function.\n    arr[index] = func(arr[index])\n    return arr\n", "response_1": "from Compiler.types import sint\n\n# Define the function to be applied.\n# Replace the body of 'func' with your desired computation.\ndef func(x):\n    return x * x\n\n# Process the element in the input array with the given index.\n# In MP-SPDZ we cannot pass the function as an argument,\n# so the function 'func' is hardwired here.\ndef process_by_index(arr, index):\n    arr[index] = func(arr[index])\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_by_indices", "response_0": "from Compiler.types import sint\n\ndef sum_by_indices(arr, indices):\n    total = sint(0)\n    for idx in indices:\n        total = total + arr[idx]\n    return total\n", "response_1": "# Import arithmetic types if needed (typically handled automatically)\nfrom Compiler.types import sint, cint\n\ndef sum_by_indices(arr, indices):\n    # Initialize the sum as a secure integer\n    total = sint(0)\n    # Iterate over the given public indices\n    for i in range(len(indices)):\n        # Access the element from arr using the public index indices[i]\n        total = total + arr[indices[i]]\n    return total\n", "model_name": "azure-openai-o3-mini"}
