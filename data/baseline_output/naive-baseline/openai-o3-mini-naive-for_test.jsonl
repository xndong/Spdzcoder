{"test_name": "multiply_first_five", "response_0": "def multiply_first_five(array):\n    # Multiply the first five elements in the array (if len(array) < 5 then multiply all)\n    prod = sint(1)\n    for i in range(len(array)):\n        prod = prod * array[i]\n        if i >= 4:\n            break\n    return prod\n\ndef main():\n    # Example: we assume array is provided as a list of secret shared integers.\n    # For instance, one may use:\n    # array = [sint(a) for a in [2, 3, 4, 5, 6, 7]]  <-- if the inputs are public integers.\n    # Then compute the product of the first five elements:\n    result = multiply_first_five(array)\n    # Open the result (if needed) and print it.\n    print_all(result)\n", "response_1": "def multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array) < 5 then multiply all)\n    \"\"\"\n    prod = 1\n    # Loop over the first five elements or all elements if len(array) < 5\n    for i in range(min(5, len(array))):\n        prod *= array[i]\n    return prod\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef second_largest(arr):\n    # Initialize: compare the first two elements.\n    cond = arr[0] >= arr[1]\n    largest = if_else(cond, arr[0], arr[1])\n    second = if_else(cond, arr[1], arr[0])\n    \n    # Loop over the remainder of the array.\n    for i in range(2, len(arr)):\n        # cond1 = (arr[i] >= largest) as a secret boolean\n        cond1 = arr[i] >= largest\n        # if arr[i] is at least as large as the current largest, update:\n        new_largest = if_else(cond1, arr[i], largest)\n        # if we update largest then the previous largest becomes candidate for second;\n        # otherwise, if arr[i] is at least as large as second, update second\n        cond2 = arr[i] >= second\n        new_second = if_else(cond1, largest, if_else(cond2, arr[i], second))\n        largest = new_largest\n        second = new_second\n    \n    return second\n", "response_1": "from Compiler.types import sint\n\ndef second_largest(arr):\n    # Assume len(arr) >= 2.\n    # Initialize largest and second using secure selection.\n    b = arr[0] >= arr[1]       # b is a secure bit: 1 if arr[0]>=arr[1], else 0.\n    largest = b * arr[0] + (1 - b) * arr[1]\n    second = b * arr[1] + (1 - b) * arr[0]\n    \n    n = len(arr)\n    # Loop over the rest of the array elements (starting with index 2).\n    for i in range(2, n):\n        # cond1 is 1 if arr[i] >= largest.\n        cond1 = arr[i] >= largest\n        \n        # If cond1==1 then arr[i] becomes the new largest and previous largest becomes new second.\n        new_largest = arr[i]\n        new_second_if = largest\n        \n        # When cond1==0, update second if arr[i] >= second.\n        cond2 = arr[i] >= second\n        new_second_else = cond2 * arr[i] + (1 - cond2) * second\n        \n        # Now update: choose new_largest and new_second depending on cond1.\n        largest = cond1 * new_largest + (1 - cond1) * largest\n        second = cond1 * new_second_if + (1 - cond1) * new_second_else\n    return second\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "partial_sum", "response_0": "# Import the secret integer type\nfrom Compiler.types import sint\n\ndef partial_sum(arr):\n    # Initialize secret shared variable 'partial' to 0\n    partial = sint(0)\n    \n    # Loop over all indices of the array\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef partial_sum(arr):\n    # Initialize the secret accumulator to 0\n    partial = sint(0)\n    for i in range(len(arr)):\n        # Update the partial sum secret value\n        partial = partial + arr[i]\n        # Replace the element with the secret partial sum\n        arr[i] = partial\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_adjacent_product", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef max_adjacent_product(arr):\n    # Assume arr is a list of sint values, and its length is at least 2.\n    cur = arr[0] * arr[1]\n    n = len(arr)\n    for i in range(n - 1):\n        prod = arr[i] * arr[i+1]\n        # Use secure conditional selection: if prod > cur then update cur, else keep cur.\n        cur = if_else(prod > cur, prod, cur)\n    return cur\n", "response_1": "from Compiler.types import sint\nfrom Compiler.util import if_else\n\ndef max_adjacent_product(arr):\n    # arr is assumed to have length at least 2; its elements are of type sint.\n    cur = arr[0] * arr[1]\n    # Loop from i = 0 to len(arr)-2 (so that i+1 is valid)\n    for i in range(len(arr) - 1):\n        prod = arr[i] * arr[i + 1]\n        # Use a secure conditional selection instead of a direct if; this avoids branching on secret data.\n        cur = if_else(prod > cur, prod, cur)\n    return cur\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "argmax", "response_0": "from Compiler.library import if_else\nfrom Compiler.types import sint\n\ndef argmax(a):\n    # a is assumed to be a list of secret values (e.g., sint)\n    current = a[0]\n    index = sint(0)  # initialize index as secret integer 0\n    for i in range(len(a)):\n        # Compute a secret bit: 1 if current >= a[i], else 0.\n        # The comparison between secret integers is secure.\n        b = current >= a[i]\n        # Obliviously update index and current.\n        index = if_else(b, index, sint(i))\n        current = if_else(b, current, a[i])\n    return index\n", "response_1": "from Compiler.types import sint, sfix\n\ndef argmax(a):\n    # a is assumed to be a list of sfix secret numbers\n    current = a[0]\n    index = sint(0)\n    for i in range(1, len(a)):\n        # Compute a secret binary bit: b = 1 if a[i] > current, else 0.\n        b = a[i] > current\n        # Obliviously update the maximum value and its index\n        current = b * a[i] + (1 - b) * current\n        index = b * sint(i) + (1 - b) * index\n    return index\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_distinct", "response_0": "from Compiler.library import is_zero\nfrom Compiler.types import sint\n\ndef count_distinct(arr):\n    # arr is assumed to be a list of secret integers (sint)\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            # Compute a secret indicator that is 1 if arr[i] equals arr[j] \n            # and 0 otherwise, then update unique accordingly.\n            eq_val = is_zero(arr[i] - arr[j])\n            unique = unique * (1 - eq_val)\n        counter = counter + unique\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef count_distinct(arr):\n    counter = sint(0)\n    n = len(arr)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            # (arr[i] == arr[j]) returns a secure bit (0 or 1).\n            # Subtracting the bit from 1 gives 0 if they are equal,\n            # and 1 if they are not equal.\n            unique *= (1 - (arr[i] == arr[j]))\n        counter += unique\n    return counter\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    # ret is initialized to 0 (False)\n    ret = 0\n    for item in arr:\n        # Compute the OR of ret and item using the arithmetic formula:\n        # ret = ret + item - ret * item\n        ret = ret + item - ret * item\n    return ret\n", "response_1": "from Compiler.types import sbit\n\ndef exists_true(arr):\n    # Initialize ret to False (0 in secret-bit representation)\n    ret = sbit(0)\n    for item in arr:\n        # Compute logical OR with the arithmetic formula:\n        # ret OR item = ret + item - ret * item\n        ret = ret + item - ret * item\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "range", "response_0": "from Compiler.types import sint\n\ndef range_array(arr):\n    # Initialize max_value and min_value to the first element of the array.\n    max_value = arr[0]\n    min_value = arr[0]\n    \n    # Iterate over all items in the array.\n    for item in arr:\n        # Update max_value securely using if_else.\n        max_value = if_else(max_value >= item, max_value, item)\n        # Update min_value securely using if_else.\n        min_value = if_else(min_value <= item, min_value, item)\n    \n    # Return the computed range.\n    return max_value - min_value\n", "response_1": "from Compiler.library import if_else\n\ndef secure_range(arr):\n    # Initialize using the first element of the array.\n    max_value = arr[0]\n    min_value = arr[0]\n    \n    # Iterate over each secret-shared value in the array.\n    for item in arr:\n        # Compute a secret bit that is 1 when max_value >= item and 0 otherwise.\n        flag_max = max_value >= item\n        # Securely select the correct maximum value.\n        max_value = if_else(flag_max, max_value, item)\n        \n        # Similarly, compute a secret bit that is 1 when min_value <= item.\n        flag_min = min_value <= item\n        # Securely select the correct minimum value.\n        min_value = if_else(flag_min, min_value, item)\n    \n    # Return the range (difference) as a secret shared value.\n    return max_value - min_value\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_larger_than_5", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef count_larger_than_5(arr):\n    counter = sint(0)\n    for item in arr:\n        counter = counter + if_else(item > 5, sint(1), sint(0))\n    return counter\n", "response_1": "def count_larger_than_5(arr):\n    # Initialize a secret counter with 0.\n    counter = sint(0)\n    # Loop over each secret value in the input array.\n    for item in arr:\n        # The expression (item > 5) produces a secret boolean.\n        # Use if_ to select 1 if the condition is true, otherwise 0.\n        counter += if_(item > 5, sint(1), sint(0))\n    return counter\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr):\n    # Initialize max_val and sum_val to 0.\n    max_val = 0\n    sum_val = 0\n    for item in arr:\n        # Compute the absolute value.\n        a = abs(item)\n        # If 'a' is greater than the current max_val, then update max_val.\n        if a > max_val:\n            max_val = a\n        # Accumulate the sum of absolute values.\n        sum_val = sum_val + a\n    # Check if the maximum absolute value is strictly larger than the sum of all the other absolute values.\n    return (2 * max_val) > sum_val\n\n# The main function below can be used to call the above function.\ndef main():\n    # Example: Replace the following line with the actual input; they can\n    # be either public values or secret values (e.g. sint) as per your needs.\n    arr = [5, -2, 1, 0]\n    # Compute the dominator existence.\n    dominator_exists = exists_dominator(arr)\n    # Output the result.\n    print_ln(\"Dominator exists? %s\", dominator_exists)\n\n# When executed, the main function will run.\nif __name__ == '__main__':\n    main()\n", "response_1": "from Compiler.types import sint\nfrom Compiler.comparison import if_else\n\ndef sabs(x):\n    # Compute absolute value of x without leaking the sign.\n    return if_else(x >= 0, x, -x)\n\ndef exists_dominator(arr):\n    # Initialize max_val and total as secret integers.\n    max_val = sint(0)\n    total = sint(0)\n    # Iterate over all elements in the array.\n    for x in arr:\n        abs_x = sabs(x)\n        # Securely update max_val using if_else.\n        max_val = if_else(abs_x > max_val, abs_x, max_val)\n        total = total + abs_x\n    # Return the secret boolean: True if 2*max_val > total.\n    return 2 * max_val > total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "greedy_picker", "response_0": "from Compiler.types import sint, sbit\nfrom Compiler.comparison import lt\nfrom Compiler.library import print_ln\n\ndef main():\n    # Suppose that we have a fixed number of items.\n    # (In a real application, n may come as input or by other means.)\n    n = 5  \n    items = [sint.get_input_from(0) for _ in range(n)]\n    captivity = sint.get_input_from(0)\n    num = sint(0)\n    \n    for item in items:\n        # Since we want to check whether item <= captivity,\n        # we compute the secret bit b = (item < captivity+1)\n        b = lt(item, captivity + 1)\n        # If the condition holds, subtract item from captivity\n        captivity = b.if_else(captivity - item, captivity)\n        # And conditionally increase num by 1.\n        num = num + b.if_else(1, 0)\n    \n    print_ln(\"Number of items picked: %s\", num)\n", "response_1": "from Compiler.types import sint\n\ndef greedy_picker(items, captivity):\n    num = sint(0)\n    for item in items:\n        # Compute the secret condition: does the item fit in the remaining capacity?\n        cond = item.leq(captivity)  # cond is an sbit representing (item <= captivity)\n        # Securely update the count: add 1 if cond is true, otherwise add 0.\n        num = num + cond.if_else(1, 0)\n        # Securely update the capacity: subtract item if cond is true, otherwise leave it unchanged.\n        captivity = cond.if_else(captivity - item, captivity)\n    return num\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s, l):\n    # Add all the elements in the array (l) to the scalar (s)\n    for item in l:\n        s = s + item\n    return s\n", "response_1": "def scalar_add_array(s, l):\n    # s is a secret value and l is a list of secret values.\n    for item in l:\n        s = s + item\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_equidistant_seq", "response_0": "def is_equidistant_seq(arr):\n    # Get the length of the array.\n    n = len(arr)\n    if n < 2:\n        return True\n\n    # Compute the initial difference between the first two values.\n    d = arr[1] - arr[0]\n\n    # Iterate for all consecutive differences.\n    for i in range(1, n-1):\n        # If the difference is not equal to d, return False.\n        if arr[i+1] - arr[i] != d:\n            return False\n\n    # If no discrepancy was found, the sequence is equidistant.\n    return True\n", "response_1": "# Public version (no secure types needed)\ndef is_equidistant_seq(arr):\n    if len(arr) <= 1:\n        return True\n    d = arr[1] - arr[0]\n    for i in range(1, len(arr)-1):\n        if arr[i+1] - arr[i] != d:\n            return False\n    return True\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    # Compute the inner product (dot product) of two vectors.\n    # Here we assume that vec1 and vec2 contain secret shared values (e.g., sint)\n    # and that len(vec1) is known during compile-time.\n    result = 0\n    for i in range(len(vec1)):\n        result = result + vec1[i] * vec2[i]\n    return result\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret vectors.\n    \"\"\"\n    result = sint(0)\n    for i in range(len(vec1)):\n        result = result + vec1[i] * vec2[i]\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "more_distinct_nonnegative", "response_0": "def more_distinct_nonnegative(arr):\n    # Initialize counters for distinct nonnegative and negative elements.\n    nonnegative_counter = 0\n    negative_counter = 0\n    \n    # Loop over each element in the array.\n    for i in range(len(arr)):\n        unique = True\n        # Check for previous occurrences of arr[i].\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = False\n                break  # Once found duplicate no need to check further.\n        # If the element is unique, increment the appropriate counter.\n        if unique:\n            if arr[i] >= 0:\n                nonnegative_counter = nonnegative_counter + 1\n            else:\n                negative_counter = negative_counter + 1\n\n    # Return whether there are more distinct nonnegative than distinct negative elements.\n    return nonnegative_counter > negative_counter\n", "response_1": "from Compiler.types import sint\n\ndef more_distinct_nonnegative(arr):\n    \"\"\"\n    Returns a secret bit (of type sint) indicating whether the array has more distinct nonnegative\n    elements than distinct negative elements.\n    \"\"\"\n    n = len(arr)\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    # Iterate over every element of arr.\n    for i in range(n):\n        # Compute an indicator that is 1 if arr[i] is the first occurrence (unique) in arr[0..i]\n        unique = sint(1)\n        for j in range(i):\n            # If any previous element equals arr[i], the product becomes 0.\n            # Here (arr[i] == arr[j]) is a secret equality check giving 1 when true.\n            unique = unique * (1 - (arr[i] == arr[j]))\n        # Compute a secret indicator for nonnegative: since 0 is public,\n        # comparison arr[i] >= 0 yields a secret bit.\n        is_non_neg = (arr[i] >= 0)\n        is_neg = 1 - is_non_neg\n        # Only update the counters if arr[i] is unique.\n        nonnegative_counter += unique * is_non_neg\n        negative_counter += unique * is_neg\n    # Return the secret result of whether the nonnegative counter is greater than the negative counter.\n    return nonnegative_counter > negative_counter\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "flip_positives", "response_0": "from Compiler.library import if_else\nfrom Compiler.types import sint\n\ndef flip_positives(array):\n    n = len(array)\n    for i in range(n):\n        # Replace array[i] with -array[i] if it is positive; otherwise leave it unchanged.\n        array[i] = if_else(array[i] > 0, -array[i], array[i])\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef flip_positives(array):\n    n = len(array)\n    for i in range(n):\n        # Compute a secret bit b that equals 1 if array[i] > 0 and 0 otherwise.\n        b = array[i] > 0  \n        # Assign -array[i] if b==1, array[i] if b==0, using a branchless computation.\n        array[i] = array[i] - 2 * array[i] * b  \n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "divide_and_plus", "response_0": "from Compiler.types import sfix\n\ndef divide_and_plus(x):\n    for i in range(4):\n        # When dividing a secure fixed point by a clear constant, MP-SPDZ will perform the operation correctly.\n        x = x / 2\n        x = x + 1\n    return x\n", "response_1": "def divide_and_plus(x):\n    # Repeat the operation 4 times: divide by 2 then add 1\n    for i in range(4):\n        x = x / 2   # Division by a public constant\n        x = x + 1   # Addition of a public constant\n    return x\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_log2", "response_0": "from Compiler.types import sfix\n\ndef array_log2(arr):\n    # Compute ln(2) using sfix arithmetic.\n    ln2 = sfix.log(sfix(2))\n    # For each element in the array, compute log2(x) as ln(x)/ln(2)\n    for i in range(len(arr)):\n        arr[i] = sfix.log(arr[i]) / ln2\n    return arr\n", "response_1": "from Compiler.types import sfix\n\ndef array_log2(arr):\n    # constant for ln(2) as sfix\n    log2_const = sfix(0.69314718056)\n    # iterate over the array and update each element to be log2(element)\n    for i in range(len(arr)):\n        # Here arr[i].log() computes the natural log of the element\n        arr[i] = arr[i].log() / log2_const\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_to_ten", "response_0": "def sum_to_ten(array):\n    # Compute partial sum of the array until the sum becomes no smaller than 10.\n    s = 0\n    for i in range(len(array)):\n        s += array[i]\n        if s >= 10:\n            break\n    return s\n", "response_1": "def sum_to_ten(array):\n    # Compute the partial sum of array until the sum is at least 10.\n    s = 0\n    for i in range(len(array)):\n        s += array[i]\n        if s >= 10:  # public branch, safe if array elements are public integers\n            break\n    return s\n\nif __name__ == \"__main__\":\n    # The main block is empty here. In an actual MP-SPDZ program, you would\n    # typically obtain inputs (using, e.g., input_from), call sum_to_ten, and output results.\n    pass\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    # arr is assumed to be a list of secret integers (sint)\n    for i in range(len(arr)):\n        # i is public; we use it to determine whether to add or subtract 1\n        if i % 2:\n            arr[i] = arr[i] + 1  # addition with a public constant\n        else:\n            arr[i] = arr[i] - 1  # subtraction with a public constant\n    return arr\n", "response_1": "def choppy_plus_minus(arr):\n    # Iterate over each index in the array\n    for i in range(len(arr)):\n        # i is public so using the modulus operation is fine.\n        if i % 2:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "min_element", "response_0": "from Compiler.Library import if_else\n\ndef min_element(a):\n    # Assume 'a' is a list of secret shared integers (sint)\n    current = a[0]\n    for item in a:\n        # Securely compute a secret bit: 1 if current \u2264 item, else 0\n        condition = current.leq(item)\n        # Conditionally select: if condition==1, then current, else item\n        current = if_else(condition, current, item)\n    return current\n", "response_1": "def min_element(a):\n    # a is assumed to be a list of secret integers (sint) \n    current = a[0]\n    for item in a:\n        # Secure less-or-equal: returns a secret bit (0 or 1)\n        b = current.le(item)  \n        # Data-oblivious selection: if (current <= item) then keep current, else select item\n        current = current * b + item * (1 - b)\n    return current\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "soft_max", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sfix_exp\n\ndef soft_max(arr):\n    # Compute the denominator by summing the exponentials of all elements.\n    denominator = sfix(0)\n    exp_values = [None] * len(arr)\n    for i in range(len(arr)):\n        exp_values[i] = sfix_exp(arr[i])\n        denominator += exp_values[i]\n        \n    # Compute the soft-max values by normalizing the exponentials.\n    result = [None] * len(arr)\n    for i in range(len(arr)):\n        result[i] = exp_values[i] / denominator\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef soft_max(arr):\n    # Compute the denominator as the sum of exponentials of the elements.\n    denominator = sfix(0)\n    for item in arr:\n        denominator += exp(item)\n    \n    # Compute the soft-max values.\n    result = []\n    for item in arr:\n        result.append(exp(item) / denominator)\n    \n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_reverse_pair_with_break", "response_0": "def count_reverse_pair_with_break(arr):\n    # Count the number of reverse pairs before we find an element bigger than 10\n    count = 0\n    # We start the loop from the second element, as in Python (index 1 through len(arr)-1)\n    for i in range(1, len(arr)):\n        # if an element is greater than 10, then we break out of the loop\n        if arr[i] > 10:\n            break\n        for j in range(i):\n            # check if a previous element is greater than the current element\n            if arr[j] > arr[i]:\n                count += 1\n    return count\n\n# Example main where the input is defined (as clear integers)\n# and the function is called to compute the reverse pair count.\ndef main():\n    # Define a clear input array. In a real MP-SPDZ application these\n    # could be read from parties using, for example, read_from_<protocol>()\n    arr = [3, 2, 8, 5, 12, 4]\n    res = count_reverse_pair_with_break(arr)\n    # Output the result as a clear integer.\n    print_ln(\"The reverse pair count is %s\", res)\n", "response_1": "def count_reverse_pair_with_break(arr):\n    # Count the number of reverse pairs before encountering an element > 10.\n    count = 0\n    for i in range(1, len(arr)):\n        if arr[i] > 10:  # using public comparison with the constant 10\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count += 1\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_unique", "response_0": "from Compiler.types import sint\n\ndef sum_unique(arr):\n    # Initialize the secret integer sum to 0.\n    total = sint(0)\n    n = len(arr)\n    for i in range(n):\n        # Start with the assumption that the element is unique.\n        unique = sint(1)\n        for j in range(n):\n            # Only check other indices.\n            if j != i:\n                # Compute a secure equality bit: equals 1 if equal, 0 otherwise.\n                eq_bit = arr[i].eq(arr[j])\n                # If a duplicate is found, (1 - eq_bit) will be zero and unique becomes zero.\n                unique *= (1 - eq_bit)\n        # Only add arr[i] if unique equals 1.\n        total += arr[i] * unique\n    return total\n", "response_1": "from Compiler.types import sint\n\n# eqz(x) returns a secret bit equal to 1 if x==0, and 0 otherwise. \n# (MP-SPDZ provides such functionality; if not provided, one can use a Miller\u2013Rabin style zero testing.)\ndef eqz(x):\n    # The following is one common way to compute equality with zero.\n    # Here we use the fact that x==0 if and only if 1 - (|x|>0) == 1.\n    # In MP-SPDZ, a common implementation is via a bit decomposition based equality test.\n    # For our purposes we assume eqz(x) is available.\n    return x.eq_public(0)  # Use the provided function if x is public; see note below.\n    \n# The sum_unique function takes an array of secret integers and returns the sum of those\n# entries that are unique (appear exactly once in the array).\ndef sum_unique(arr):\n    n = len(arr)\n    total = sint(0)\n    for i in range(n):\n        count = sint(0)\n        for j in range(n):\n            # Compute a secret indicator (=1 if arr[i]==arr[j], 0 otherwise).\n            # Because the indices are public, the loop is unproblematic.\n            # (arr[i]-arr[j]) is secret; eqz returns a secret bit.\n            equal_bit = eqz(arr[i] - arr[j])\n            count = count + equal_bit\n        # Compute a secret bit that is 1 if count equals 1, and 0 otherwise.\n        unique_bit = eqz(count - 1)\n        total = total + arr[i] * unique_bit\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "check_sum", "response_0": "def check_sum(array, target):\n    # Initialize sum as a secure integer with value 0.\n    s = sint(0)\n    for num in array:\n        s = s + num\n    return s == target\n", "response_1": "from Compiler.types import sint\n\ndef check_sum(array, target):\n    sum_val = sint(0)\n    for num in array:\n        sum_val = sum_val + num\n    return sum_val == target\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "prod", "response_0": "def prod(array):\n    # Initialize the product as a common constant 1. In MP-SPDZ, this constant\n    # will be automatically converted to the corresponding secret type when multiplied.\n    result = 1\n    for num in array:\n        result = result * num\n    return result\n", "response_1": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    result = 1\n    for num in array:\n        result = result * num\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_till_negative", "response_0": "from Compiler.types import sint\n\ndef sum_till_negative(array):\n    # Initialize the running total and the flag. \n    # The flag starts at 1 (meaning \u201cadd values\u201d) and will be set to 0 as soon as a negative element appears.\n    tot = sint(0)\n    flag = sint(1)\n    \n    # Loop over all elements. (Note that we cannot break the loop in a secure manner.)\n    for a in array:\n        # Securely compute the indicator: 1 if a is nonnegative, 0 if it is negative.\n        is_nonnegative = (a >= 0)\n        \n        # Add the element only if the flag is still set and the current element is nonnegative.\n        tot = tot + flag * a * is_nonnegative\n        \n        # Update the flag: once it becomes 0 (a negative element encountered) it remains 0.\n        flag = flag * is_nonnegative\n        \n    return tot\n", "response_1": "from Compiler.types import sint\n\ndef sum_till_negative(array):\n    s = sint(0)\n    flag = sint(1)  # flag is 1 until a negative element is encountered, then becomes 0\n    for x in array:\n        # Compute the secure indicator for non-negativity.\n        # In MP-SPDZ, the expression (x >= 0) returns a secure boolean\n        cond = x >= 0  \n        # Only add x if flag is still 1 (i.e. no negative element seen so far)\n        s = s + flag * x\n        # Once a negative is seen, cond will be 0 and flag becomes 0 permanently.\n        flag = flag * cond  \n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_satisfied", "response_0": "# Example: count the number of elements in an array that satisfy a predicate.\n# If the array elements are public (clear) values and predicate returns a clear Boolean,\n# the standard \"if\" works.\n\ndef count_satisfied_public(arr, predicate):\n    count = 0\n    for i in range(len(arr)):\n        if predicate(arr[i]):\n            count = count + 1\n    return count\n\n# Alternatively, suppose arr is a list of secret integers (of type sint) and predicate returns \n# a secret value (1 if satisfied, 0 if not). In that case, you must update the counter obliviously.\n# (No secret-dependent branching is allowed.)\ndef count_satisfied_secret(arr, predicate):\n    count = sint(0)\n    for i in range(len(arr)):\n        # Here predicate(arr[i]) is assumed to yield a sint value (0 or 1).\n        count = count + predicate(arr[i])\n    return count\n\n# Note:\n# \u2022 In MP-SPDZ, higher-order functions are not as flexible as in Python.\n#   If you need to pass a predicate function, ensure that the predicate function is defined \n#   in the same file and that its behavior (public vs. secret) matches the rest of your code.\n# \u2022 The above functions illustrate two common cases:\n#   one with public data and one with secret-shared data.\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicate):\n    # Initialize the counter as a secret integer.\n    total = sint(0)\n    # Iterate over all elements in the array.\n    for i in range(len(arr)):\n        # Evaluate the predicate.\n        # Here, predicate(arr[i]) should return either sint(1) or sint(0)\n        total = total + predicate(arr[i])\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "standard_deviation", "response_0": "from Compiler.Types import sfix\n\ndef standard_deviation(arr):\n    # Compute the average of the array\n    total = sfix(0)\n    # Convert the length to an sfix value\n    n = sfix(len(arr))\n    for x in arr:\n        total = total + x\n    avg = total / n\n\n    # Compute the variance\n    variance = sfix(0)\n    for x in arr:\n        # We use multiplication instead of exponentiation since **2 may not be supported directly.\n        diff = x - avg\n        variance = variance + diff * diff\n    variance = variance / n\n\n    # Return the square root of the variance\n    return variance.sqrt()\n", "response_1": "from Compiler.library import sqrt\nfrom Compiler.types import sfix\n\ndef standard_deviation(arr):\n    n = len(arr)\n    average = sfix(0)\n    variance = sfix(0)\n    # Compute the average by accumulating each element divided by n\n    for item in arr:\n        average = average + item / sfix(n)\n    # Compute the variance by summing the squared difference from the average\n    for item in arr:\n        variance = variance + (item - average) * (item - average) / sfix(n)\n    # Return the square root of the variance\n    return sqrt(variance)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "dominate", "response_0": "from Compiler.types import sint\n\ndef dominate_sec(a, b):\n    \"\"\"\n    Return a secret bit (of type sint) indicating whether array a \"dominates\" array b,\n    which means every element in a is no smaller than the corresponding element in b.\n    This version performs no branching on secret data.\n    \"\"\"\n    result = sint(1)  # 1 indicates True in secure arithmetic\n    n = len(a)\n    for i in range(n):\n        # The expression (a[i] < b[i]) returns a secret bit (0 or 1).\n        # Then 1 - (a[i] < b[i]) equals 1 exactly when a[i] >= b[i].\n        # Multiplying these secure bits acts like a logical AND over all comparisons.\n        result *= (1 - (a[i] < b[i]))\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef dominate(a, b):\n    # Assumes a and b are lists of secret integers (sint)\n    ret = sint(1)  # secret boolean: 1 for True, 0 for False\n    for i in range(len(a)):\n        # (a[i] < b[i]) is a secret bit that is 1 if a[i] is less than b[i]\n        ret *= 1 - (a[i] < b[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    # Initialize max_abs with the absolute of the first element.\n    max_abs = abs(brr[0])\n    for item in brr:\n        # Compute the absolute value of item\n        temp = abs(item)\n        # Use if_else to securely update max_abs if temp is greater.\n        max_abs = if_else(temp > max_abs, temp, max_abs)\n    # Scale each element in brr by dividing it by max_abs.\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "response_1": "from Compiler.types import sfix\n\ndef rescale(brr):\n    # The variable max_abs is initialized as a secret fixed-point zero.\n    max_abs = sfix(0)\n    \n    # First pass: Calculate the maximum absolute value.\n    for item in brr:\n        # Determine the absolute value of item.\n        if item < 0:\n            abs_item = -item\n        else:\n            abs_item = item\n        \n        # Update max_abs if abs_item is larger.\n        if abs_item > max_abs:\n            max_abs = abs_item\n\n    # Second pass: Rescale each element in the array.\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n\n    return brr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_minus7", "response_0": "from Compiler.types import sint\n\ndef array_minus7(arr):\n    # Subtract 7 from each element of the array\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_minus7(arr: list) -> list:\n    \"\"\"\n    Subtract 7 from all secret elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    res = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            res = res + arr1[i] * arr2[j]\n    return res\n", "response_1": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    total = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            total = total + arr1[i] * arr2[j]\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler.types import cint\n\ndef longest_nondec_subseq(a):\n    # Returns the length of the longest non-decreasing subsequence in a.\n    max_length = 0\n    cur_length = 0\n    for i in range(len(a)):\n        if i == 0:\n            cur_length = 1\n        else:\n            if a[i] >= a[i-1]:\n                cur_length = cur_length + 1\n            else:\n                if max_length < cur_length:\n                    max_length = cur_length\n                cur_length = 1\n    if max_length < cur_length:\n        max_length = cur_length\n    return max_length\n\nif __name__ == '__main__':\n    # Input the number of elements (assumed public) from party 0.\n    n = cint.get_input_from(0)\n    # Input the array elements from party 0.\n    a = [cint.get_input_from(0) for _ in range(n)]\n    result = longest_nondec_subseq(a)\n    print_ln('Longest non-decreasing subsequence length: %s', result)\n", "response_1": "def longest_nondec_subseq(a):\n    # Returns the length of the longest non-decreasing contiguous subsequence in array a.\n    max_length = 0\n    cur_length = 0\n    for i in range(len(a)):\n        if i == 0:\n            cur_length = 1\n            continue\n        # For public integers, direct comparison is acceptable.\n        if a[i] >= a[i-1]:\n            cur_length = cur_length + 1\n        else:\n            if cur_length > max_length:\n                max_length = cur_length\n            cur_length = 1\n    if cur_length > max_length:\n        max_length = cur_length\n    return max_length\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_but_skip_biggest", "response_0": "from Compiler.types import cint\n\ndef sum_but_skip_biggest(array):\n    total = cint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        # If the element is at least as big as the current biggest,\n        # update the biggest value and skip summing it.\n        if array[i] >= biggest:\n            biggest = array[i]\n            continue\n        total = total + array[i]\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_but_skip_biggest(array):\n    # Initialize sum as a secret integer 0.\n    s = sint(0)\n    # Use the first element as the starting \"biggest\" value.\n    biggest = array[0]\n    # Loop over each element in the secret-shared array.\n    for i in range(len(array)):\n        # Compute a secret boolean: 1 if array[i] >= biggest, 0 otherwise.\n        cond = array[i] >= biggest\n        # Update the sum: only add array[i] if it is not the new biggest.\n        s = s + (1 - cond) * array[i]\n        # Update the biggest value in a data-oblivious manner.\n        biggest = cond * array[i] + (1 - cond) * biggest\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "second_test", "response_0": "from Compiler.types import sint\n\ndef second_test(arr):\n    # arr is assumed to be a list of secret integers (sint)\n    count = sint(0)\n    for i in range(1, len(arr)):\n        # The expression (arr[0] < arr[i]) returns a secret bit (also of type sint)\n        count += (arr[0] < arr[i])\n    # Instead of branching on a secret value, we return the secret boolean (as sint)\n    return (count == 1)\n", "response_1": "from Compiler.types import sint\n\ndef second_test(arr):\n    \"\"\"\n    Return (as a secret integer) whether or not the first element in the array\n    is smaller than exactly one element. The output is a secret 1 for True and 0 for False.\n    \"\"\"\n    count = sint(0)\n    one = sint(1)\n    zero = sint(0)\n    for i in range(1, len(arr)):\n        # The comparison arr[0] < arr[i] yields a secret bit, so we use if_else to add 1 or 0.\n        count = count + if_else(arr[0] < arr[i], one, zero)\n    # Instead of a normal if statement (which is not allowed on a secret condition),\n    # we use if_else to produce either 1 or 0 depending on whether count equals 1.\n    return if_else(count == one, one, zero)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "Manhattan_distance", "response_0": "def Manhattan_distance(a, b):\n    # Initialize the result as a secret integer zero.\n    ret = sint(0)\n    for i in range(len(a)):\n        diff = a[i] - b[i]\n        # The absolute value is computed securely using if_else.\n        ret += if_else(diff < 0, -diff, diff)\n    return ret\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef Manhattan_distance(a, b):\n    # Initialize the result as a secret integer 0.\n    ret = sint(0)\n    # Loop over the indices of the vectors.\n    for i in range(len(a)):\n        # Compute the difference between corresponding entries.\n        diff = a[i] - b[i]\n        # Securely compute the absolute value of diff:\n        # if diff < 0 then -diff else diff.\n        abs_diff = if_else(diff < 0, -diff, diff)\n        ret = ret + abs_diff\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "deal_with_only_positive", "response_0": "def deal_with_only_positive(array):\n    # Initialize the alternating sign and the sum.\n    sign = 1\n    total = 0\n    # Loop over the array by index.\n    for i in range(len(array)):\n        # If the current element is non-positive, skip it.\n        if array[i] <= 0:\n            continue\n        # Add/subtract the element using the current sign.\n        total = total + sign * array[i]\n        # Flip the sign.\n        sign = -sign\n    return total\n", "response_1": "from Compiler.library import if_else\nfrom Compiler.types import sint\n\ndef deal_with_only_positive(array):\n    # Initialize sign and partial sum as secret integers.\n    sign = sint(1)\n    total = sint(0)\n    for i in range(len(array)):\n        # Compute a bit (0 or 1) indicating if the element is positive.\n        cond = array[i] > 0\n        # If the element is positive, add sign*element to the total sum,\n        # else add 0. (This replaces \"continue\" in the Python code.)\n        total = total + if_else(cond, sign * array[i], sint(0))\n        # Update sign: flip sign only if the element is positive.\n        sign = if_else(cond, -sign, sign)\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import sint, sbit\n\ndef compare_and_return(arr, brr):\n    \"\"\"\n    Compare the elements in arrays arr and brr, and return the first index i with arr[i] == brr[i].\n    If no such index exists, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = sint(-1)\n    found = sbit(0)  # flag initially false (i.e. match not found)\n    for i in range(n):\n        # Compute a secret bit that is 1 if elements are equal, and 0 otherwise.\n        is_equal = (arr[i] - brr[i]).isZero()\n        # If not found previously and arr[i]==brr[i], update ret to i.\n        # (This arithmetic \"if\" works as:\n        #   ret = ret + (1 - found) * is_equal * (i - ret)\n        # so that once found is set, further updates cancel out.)\n        ret = ret + (1 - found) * is_equal * (sint(i) - ret)\n        # Update the \"found\" flag.\n        found = found + (1 - found) * is_equal\n    return ret\n", "response_1": "def compare_and_return(arr, brr):\n    # Initialize the return value as -1 (indicating \"not found\").\n    ret = -1\n    n = len(arr)\n    for i in range(n):\n        # Here we assume that arr[i]==brr[i] is a public condition.\n        if (arr[i] == brr[i]):\n            ret = i\n            break\n    return ret\n\ndef main():\n    # The main function can use compare_and_return as needed.\n    # For example, one could input arrays or assign values.\n    # Do not include any usage examples here.\n    pass\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_odd_positive", "response_0": "from Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    total = sint(0)\n    for item in arr:\n        # The condition (item % 2 != 0) returns 1 if odd, 0 otherwise;\n        # (item > 0) returns 1 if item is positive, 0 otherwise.\n        # Multiplying these with item adds item only if both conditions hold.\n        total += ((item % 2 != 0) * (item > 0)) * item\n    return total\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef sum_odd_positive(arr):\n    total = sint(0)\n    for a in arr:\n        # if (a > 0) and (a % 2 == 1) then flag is 1, else 0\n        flag = if_else((a > 0) & ((a % 2) == 1), sint(1), sint(0))\n        total = total + a * flag\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "two_sum", "response_0": "from Compiler.types import sint\n\ndef two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same)\n    whose sum equals the target value.\n    Both arr and target are secret inputs of type sint.  \n    \"\"\"\n    n = len(arr)\n    found = sint(0)\n    for i in range(n):\n        for j in range(n):\n            # (arr[i] + arr[j] - target) == 0 returns a secret bit (sint 1 if true, 0 otherwise).\n            found += (arr[i] + arr[j] - target) == 0\n    # If found > 0 the condition is satisfied; note that the comparison returns a secret bool.\n    return found > 0\n", "response_1": "from Compiler.types import sint\n\n# Function: two_sum\n# Returns a secret (sint) equal to 1 if there exists a pair (i,j) (possibly the same index)\n# such that arr[i] + arr[j] equals target, and 0 otherwise.\ndef two_sum(arr, target):\n    n = len(arr)\n    # found is a secret integer initially 0. It will become 1 if a matching pair is found.\n    found = sint(0)\n    for i in range(n):\n        for j in range(n):\n            # Compute the difference between the sum and the target.\n            diff = arr[i] + arr[j] - target\n            # diff.eq_zero() returns a secret bit (sbit) that is 1 if diff is zero, else 0.\n            is_equal = diff.eq_zero()\n            # Convert the secret bit into a sint (secret integer) to use in arithmetic.\n            found_bit = sint(is_equal)\n            # Combine with found using the OR logic.\n            # In arithmetic terms: a OR b = a + b - a*b; here a=found, b=found_bit.\n            found = found + found_bit - found * found_bit\n    # The function returns a secret integer that is 1 if a pair is found, and 0 otherwise.\n    return found\n\n# The remainder of your MP-SPDZ program would typically construct the secret inputs (arr and target),\n# call two_sum, and then reveal the result. This snippet focuses on the two_sum function translation.\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "seq_search", "response_0": "from Compiler.types import cint\n\ndef seq_search(arr, target):\n    # Performs a sequential search over the list arr for the target value.\n    # The array is assumed to have all distinct elements.\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\n# (The remainder of the MP-SPDZ program would call seq_search as required.)\n", "response_1": "from Compiler.types import sint\n\ndef seq_search(arr, target):\n    res = 0        # will hold the index if found\n    found = 0      # indicator: 1 if found, 0 otherwise\n    n = len(arr)\n    for i in range(n):\n        # eqz(arr[i]-target) returns a sint (1 if equal, 0 otherwise)\n        eq = eqz(arr[i] - target)\n        res += i * eq\n        found += eq\n    # If no match exists then found==0. We return -1 in that case.\n    # Since found is either 0 or 1, the following arithmetic selects the right value:\n    return res * found + (-1) * (1 - found)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "choppy_array", "response_0": "def choppy_array(arr):\n    \"\"\"\n    Returns 1 if 'arr' is a choppy array.\n    A \"choppy array\" is defined as:\n      - The first element is the smallest,\n      - The second element is the largest of the remaining,\n      - The third is the smallest of the remaining,\n      - The fourth is the largest of the remaining, etc.\n    In this implementation, we assume that 'arr' is a public or clear array.\n    If a violation of the pattern is found, returns 0.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # for each i, check the tail from i to n-1\n        for j in range(n - i):\n            # When i is odd, every value in the tail must not exceed arr[i]\n            if i % 2 == 1:\n                if arr[i + j] > arr[i]:\n                    return 0\n            # When i is even, every value in the tail must not be lower than arr[i]\n            else:\n                if arr[i + j] < arr[i]:\n                    return 0\n    return 1\n\n# The main part of the MP-SPDZ program would call this function\n# and reveal the result if desired. For instance, one might include:\n#\n# arr = [1, 5, 2, 4, 3]\n# result = choppy_array(arr)\n# print_ln(\"Result: %s\", result)\n#\n# However, the above usage snippet is not included in the code block.\n", "response_1": "from Compiler.types import regint\n\ndef choppy_array(arr):\n    n = len(arr)\n    # For each index i from 0 to n-1, we check that arr[i] is respectively\n    # the minimum (when i is even) or the maximum (when i is odd) over the remaining elements.\n    for i in range(n):\n        for j in range(n - i):\n            if (i % 2 == 1):\n                # When i is odd, arr[i] should be the maximum among arr[i:].\n                if arr[i + j] > arr[i]:\n                    return False\n            else:\n                # When i is even, arr[i] should be the minimum among arr[i:].\n                if arr[i + j] < arr[i]:\n                    return False\n    return True\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process", "response_0": "# In MP-SPDZ we work with secret types (for example, sint for secret integers).\n# Here we define a processing function. Adjust the code according to your application.\ndef process_element(x):\n    # Example processing: square the element.\n    return x * x\n\n# The array_process function applies a predefined process_element function to each element.\ndef array_process(arr):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = process_element(arr[i])\n    return arr\n\n# You would call array_process on an array of secret integers (sint) appropriately within your full MP-SPDZ program.\n", "response_1": "# MP-SPDZ does not support passing functions as arguments.\n# Instead, define the specific operation (e.g., square each element)\ndef array_process(arr):\n    # Assume arr is a list of secure integers (sint)\n    n = len(arr)\n    for i in range(n):\n        # Here, we square the element.\n        arr[i] = arr[i] * arr[i]\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "normalize", "response_0": "# Import the necessary secure types (sfix) and functions.\nfrom Compiler.types import sfix\n\ndef normalize(vec):\n    # Initialize the sum as a secure fixed-point number.\n    total = sfix(0)\n    # Sum the squares of the vector elements.\n    for x in vec:\n        total += x * x\n    # Compute the square root of the sum (the norm).\n    norm = sqrt(total)\n    # Normalize each component by dividing it by the norm.\n    for i in range(len(vec)):\n        vec[i] = vec[i] / norm\n    return vec\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef normalize(vec):\n    # Compute the sum of squares of the vector elements\n    s = sfix(0)\n    for item in vec:\n        s = s + item * item\n    # Compute the square root of the sum of squares\n    base = sqrt(s)\n    # Normalize each element by dividing by the base\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "impatient_merchant", "response_0": "from Compiler.types import cint\n\ndef impatient_merchant(days):\n    # 'days' is a list of public integers, each with type cint.\n    can_buy = 1    # using 1 for True\n    net = 0\n    orig_price = 0\n    for i in range(len(days)):\n        if can_buy:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = 0\n        else:\n            if days[i] > orig_price:\n                net = net + days[i]\n                can_buy = 1\n    return net\n", "response_1": "from Compiler.types import cint\n\ndef impatient_merchant(days):\n    net = cint(0)\n    can_buy = True\n    orig_price = cint(0)\n    for price in days:\n        if can_buy:\n            net = net - price\n            orig_price = price\n            can_buy = False\n        else:\n            if price > orig_price:\n                net = net + price\n                can_buy = True\n    return net\n\ndef main():\n    # read the number of days (assumed public)\n    n = cint.get_input_from(0)\n    # read the prices for n days as clear integers\n    days = [cint.get_input_from(0) for _ in range(n)]\n    \n    profit = impatient_merchant(days)\n    print_ln(\"Net profit: %s\", profit)\n\nmain()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_shift", "response_0": "from Compiler.types import sint\n\ndef array_shift(a):\n    # Assume that the length of a is known at compile time.\n    n = len(a)\n    # Save the last element into a temporary variable.\n    temp = a[n - 1]\n    # Shift all the other elements one position to the right.\n    for i in range(n - 1):\n        a[n - i - 1] = a[n - i - 2]\n    # Place the saved element into the first position.\n    a[0] = temp\n    return a\n", "response_1": "# In MP-SPDZ, we assume a is a list of secret integers (sint)\ndef array_shift(a):\n    # Save the last element of the array in temporary variable.\n    temp = a[len(a) - 1]\n    \n    # Loop from 0 to len(a)-2; in each iteration, shift elements one to the right.\n    for i in range(len(a)-1):\n        a[len(a)-i-1] = a[len(a)-i-2]\n    \n    # Place the saved element into the first slot.\n    a[0] = temp\n    return a\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_double", "response_0": "from Compiler.types import sint\n\ndef array_double(arr):\n    # Double each secret integer element in the input array.\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "def array_double(arr):\n    # Loop through each index of the array and double the element\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.types import sint\n\ndef stop_at_zero(array):\n    # Initially, updates are active (flag = 1)\n    flag = 1\n    for i in range(len(array)):\n        # Only update the element if flag is still active\n        if flag:\n            # Check if the element equals zero\n            if array[i] == 0:\n                flag = 0  # Disable further updates\n            else:\n                array[i] = array[i] + 1\n    return array\n", "response_1": "def stop_at_zero(array):\n    # Calculate the length of the array\n    n = len(array)\n    # Iterate over the array indices\n    for i in range(n):\n        # If the current element equals 0 then break out of the loop.\n        # Note: if array[i] is secret then branching may leak information.\n        if array[i] == 0:\n            break\n        # Otherwise, add 1 to the element.\n        array[i] = array[i] + 1\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_not", "response_0": "# Import the secret integer type (or secret bit type if appropriate).\nfrom Compiler.types import sint\n\ndef array_not(arr):\n    \"\"\"\n    Compute the logical NOT for each element in the input array.\n    \n    In MP-SPDZ, if the secret boolean is encoded as 0 or 1,\n    the NOT operation can be implemented as 1 - x.\n    \"\"\"\n    for i in range(len(arr)):\n        # Here, 1 - arr[i] gives the logical negation.\n        arr[i] = 1 - arr[i]\n    return arr\n", "response_1": "# MP-SPDZ code (e.g., in a file with extension .mpc)\ndef array_not(arr):\n    \"\"\"\n    Takes the opposite (logical NOT) of all elements in the input array.\n    Assumes that each element is a secret-shared Boolean represented as 0 or 1.\n    \"\"\"\n    for i in range(len(arr)):\n        # Replace not operation with 1 - x, for secret-shared Boolean x.\n        arr[i] = 1 - arr[i]\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process_then_clip", "response_0": "def array_process_then_clip(arr, func):\n    # Process each element with func, then clip to range [-10, 10]\n    for i in range(len(arr)):\n        # Compute the function on the element\n        arr[i] = func(arr[i])\n        # Securely clip the value: if arr[i] > 10 then 10 else arr[i]\n        arr[i] = if_else(arr[i] > sfix(10), sfix(10), arr[i])\n        # Similarly clip the lower bound: if arr[i] < -10 then -10 else arr[i]\n        arr[i] = if_else(arr[i] < sfix(-10), sfix(-10), arr[i])\n    return arr\n", "response_1": "from Compiler.library import if_then_else\n\ndef array_process_then_clip(arr, func):\n    # Process all elements in arr with a specified function,\n    # then clip the outcome to the range [-10, 10].\n    for i in range(len(arr)):\n        # Process the element with the given function.\n        x = func(arr[i])\n        # Clip x to a maximum of 10.\n        x = if_then_else(x > 10, 10, x)\n        # Clip x to a minimum of -10.\n        x = if_then_else(x < -10, -10, x)\n        # Store the clipped result.\n        arr[i] = x\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "add_and_count_positive", "response_0": "from Compiler.types import sint\n\ndef add_and_count_positive(array, k):\n    # Initialize the count as a secret integer.\n    count = sint(0)\n    # For each index, add k to the element.\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        # Instead of a branch on the secret value, add the secure bit\n        # resulting from (array[i] > 0) (which is 1 when true, 0 otherwise).\n        count = count + (array[i] > 0)\n    return array, count\n", "response_1": "from Compiler.types import sint\n\ndef add_and_count_positive(array, k):\n    count = sint(0)\n    # len(array) is public even if the elements are secret\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        # The comparison (array[i] > 0) produces a secret bit (of type sint)\n        count = count + (array[i] > 0)\n    return array, count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    if len(a) > len(b):\n        ret = [0 for i in range(len(a))]\n        for i in range(len(b)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(a) - len(b)):\n            ret[len(b) + i] = a[len(b) + i]\n        return ret\n    else:\n        ret = [0 for i in range(len(b))]\n        for i in range(len(a)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(b) - len(a)):\n            ret[len(a) + i] = -b[len(a) + i]\n        return ret\n", "response_1": "def array_subtract(a, b):\n    # When the arrays are of different length, the shorter one is padded with zeros.\n    if len(a) > len(b):\n        ret = [0] * len(a)\n        # Subtract element-wise on the common indices.\n        for i in range(len(b)):\n            ret[i] = a[i] - b[i]\n        # For the remaining indices, use the value of a.\n        for i in range(len(a) - len(b)):\n            ret[len(b) + i] = a[len(b) + i]\n        return ret\n    else:\n        ret = [0] * len(b)\n        # Subtract element-wise on the common indices.\n        for i in range(len(a)):\n            ret[i] = a[i] - b[i]\n        # For the remaining indices, use the negation of b.\n        for i in range(len(b) - len(a)):\n            ret[len(a) + i] = -b[len(a) + i]\n        return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "lower_bound", "response_0": "from Compiler.types import sint, regint\n\ndef lower_bound(arr, x):\n    # ret is the index of the best candidate found so far. Initially -1 means none was found.\n    ret = -1  \n    # distance will store x - arr[i] for the candidate with \n    # arr[i] <= x that is closest to x.\n    distance = 0  \n    # found flag: 0 means no candidate found yet; 1 means we have found at least one candidate.\n    found = 0  \n    \n    # Loop over all elements in the array.\n    for i in range(len(arr)):\n        # Here we assume arr[i] and x are public integers so that the <= operator works as in ordinary Python.\n        if arr[i] <= x:\n            # Check if no candidate has been found yet or if the new candidate is closer to x.\n            if found == 0 or (x - arr[i] < distance):\n                ret = i\n                distance = x - arr[i]\n                found = 1\n    return ret\n", "response_1": "from Compiler.types import sint, sbit\nfrom Compiler.library import if_else\n\n# Given an array \"arr\" of secret integers and a secret integer \"x\",\n# returns the index (as a secret integer) of the largest element not above x.\n# If such an element does not exist, returns -1.\ndef lower_bound(arr, x):\n    ret = sint(-1)\n    # \u201cdistance\u201d will hold the value x - arr[i] for the chosen candidate.\n    # Its initial value is irrelevant, since we update it when no candidate has been found.\n    distance = sint(0)\n    # \"found\" is stored as 0 (false) or 1 (true).\n    found = sint(0)\n    for i in range(len(arr)):\n        # cond is a secret bit (sbit) that is 1 if arr[i] \u2264 x and 0 otherwise.\n        cond = (arr[i] <= x)\n        # Compute the candidate's distance as x - arr[i]. (This is a sint.)\n        new_dist = x - arr[i]\n        # We now want to update the candidate if:\n        #   (a) arr[i] \u2264 x (i.e. cond == 1) and\n        #   (b) either no candidate has yet been chosen (found==0)\n        #       or this candidate is strictly \u201ccloser\u201d (new_dist < distance).\n        #\n        # Since found is stored as a sint (0 or 1), we \u201csimulate\u201d the if:\n        #   if found == 0 then candidate = 1, else candidate = (new_dist < distance).\n        candidate = if_else(found == sint(0), sbit(1), (new_dist < distance))\n        # Combine with cond (since we must have arr[i] \u2264 x) using multiplication,\n        # which acts as logical AND on secret bits.\n        update_flag = cond * candidate\n        # Update ret and distance using if_else; note that the public value i is cast to sint.\n        ret = if_else(update_flag, sint(i), ret)\n        distance = if_else(update_flag, new_dist, distance)\n        # Update found: once a valid candidate is found (cond==1), found becomes 1.\n        # Note that a secret \u201cOR\u201d for bits a and b is given by a + b \u2013 a*b.\n        found = found + if_else(cond, sint(1), sint(0)) - found * if_else(cond, sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "argmin", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_else\n\ndef argmin(a):\n    current = a[0]\n    index = sint(0)\n    for i in range(1, len(a)):\n        # less is a secret bit: 1 if a[i] < current, 0 otherwise.\n        less = a[i] < current\n        # Update the running minimum and the corresponding index\n        current = if_else(less, a[i], current)\n        index = if_else(less, sint(i), index)\n    return index\n", "response_1": "def argmin(a):\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        cond = (a[i] < current)  # cond is a secret bit (sbit)\n        current = if_else(cond, a[i], current)\n        index = if_else(cond, sint(i), index)\n    return index\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "independent_robbery", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef independent_robbery(houses):\n    n = len(houses)\n    # Initialize dp as a list of secret integers.\n    dp = [sint(0) for _ in range(n)]\n    dp[0] = houses[0]\n    # Set dp[1] to the greater of houses[0] and houses[1].\n    dp[1] = if_else(houses[1] >= houses[0], houses[1], houses[0])\n    for i in range(2, n):\n        option1 = dp[i-2] + houses[i]\n        option2 = dp[i-1]\n        dp[i] = if_else(option1 >= option2, option1, option2)\n    return dp[n-1]\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef if_then_else(b, x, y):\n    # b is expected to be a secret bit: 1 if the condition is true, 0 otherwise.\n    return x * b + y * (1 - b)\n\ndef independent_robbery(houses, n):\n    # Create a dp list of secret integers\n    dp = [sint(0) for _ in range(n)]\n    dp[0] = houses[0]\n    # Use a secret if-then-else expression: choose houses[1] if houses[1]>=houses[0] else houses[0]\n    dp[1] = if_then_else(houses[1] >= houses[0], houses[1], houses[0])\n    # Compute dp values for remaining houses\n    for i in range(2, n):\n        candidate1 = dp[i - 2] + houses[i]\n        candidate2 = dp[i - 1]\n        dp[i] = if_then_else(candidate1 >= candidate2, candidate1, candidate2)\n    return dp[n - 1]\n\ndef main():\n    # The input length n; ensure n>=3.\n    # You can change n as required.\n    n = 5  \n    # Read n secret integers from party 0.\n    houses = [sint.get_input_from(0) for _ in range(n)]\n    result = independent_robbery(houses, n)\n    # Reveal the result to all parties.\n    result.reveal()\n\nmain()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_odd_and_odd", "response_0": "from Compiler.types import sint\n\ndef sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function in MP-SPDZ.\n    \"\"\"\n    s = sint(0)\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            s += arr[j]\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_odd_and_odd(arr):\n    # Initialize the result as a secret integer value.\n    res = sint(0)\n    n = len(arr)\n    # Loop over i, which is public so control flow is allowed.\n    for i in range(n):\n        # Skip even indices.\n        if i % 2 == 0:\n            continue\n        # For odd i, iterate from 0 to i-1.\n        for j in range(i):\n            # Only add when j is odd.\n            if j % 2 == 0:\n                continue\n            res += arr[j]\n    return res\n\n# Main block to run the function. Modify the input as needed.\n# Normally arr would be provided/initialized via MPC input routines.\nif __name__ == '__main__':\n    # For illustration, we assume a fixed size array of secret integers.\n    # Replace the following input routine with a method suitable for your application.\n    arr = [sint.get_input_from(0) for _ in range(10)]\n    result = sum_odd_and_odd(arr)\n    result.reveal()  # Output the result.\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_monotonous", "response_0": "from Compiler.types import cint\n\ndef is_monotonous(arr):\n    # Here we return 1 (true) if arr is strictly monotonic,\n    # and 0 (false) otherwise.\n    d = 0\n    n = len(arr)\n    for i in range(n - 1):\n        diff = arr[i+1] - arr[i]\n        if i > 0:\n            # For iterations beyond the first, check that the new\n            # difference times the previous d is positive.\n            if diff * d <= 0:\n                return 0   # not strictly monotonous\n        d = diff\n    return 1\n", "response_1": "from Compiler.types import sint\n\ndef is_monotonous(arr):\n    n = len(arr)\n    # If the array has 0 or 1 element, it is trivially monotonous.\n    if n <= 1:\n        return 1  # True represented as 1.\n    # Compute the initial difference.\n    d = arr[1] - arr[0]\n    is_mono = 1  # Use 1 to represent True.\n    # Loop from the second difference onward.\n    for i in range(1, n-1):\n        diff = arr[i+1] - arr[i]\n        # Check that the product of the current and previous differences is > 0.\n        # The '>' operator returns a secret bit.\n        is_positive = diff * d > 0\n        # Multiply the flag with the returned secret boolean.\n        is_mono = is_mono * is_positive\n        d = diff\n    return is_mono\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef positive_count_negative_sum(arr):\n    count = sint(0)\n    neg_sum = sint(0)\n    for item in arr:\n        is_positive = if_else(item > 0, sint(1), sint(0))\n        is_negative = if_else(item < 0, sint(1), sint(0))\n        count = count + is_positive\n        neg_sum = neg_sum + item * is_negative\n    return count, neg_sum\n", "response_1": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    # Initialize secret integers for count and negative sum.\n    count = sint(0)\n    neg_sum = sint(0)\n    \n    # Loop over all elements in arr.\n    for item in arr:\n        # Compute secret indicator bits for positive and negative values.\n        # Note: (item > 0) and (item < 0) yield a secret bit (1 if true, 0 otherwise).\n        pos_indicator = item > 0\n        neg_indicator = item < 0\n        \n        count = count + pos_indicator\n        # When the element is negative, we add its value.\n        neg_sum = neg_sum + item * neg_indicator\n        \n    return count, neg_sum\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_even", "response_0": "# In MP-SPDZ, secret integers are of type \"sint\".\ndef sum_even(arr):\n    s = sint(0)\n    # Loop over all secret numbers in the array.\n    for a in arr:\n        # Decompose the secret 'a' into 1 bit; the least-significant bit (LSB)\n        # will be 0 if a is even and 1 if a is odd.\n        lsb = a.bit_decompose(1)[0]\n        # Compute an indicator: even_indicator is 1 when a is even, 0 if odd.\n        even_indicator = 1 - lsb\n        # Accumulate the value if it is even.\n        s = s + a * even_indicator\n    return s\n", "response_1": "def sum_even(arr):\n    res = 0\n    for item in arr:\n        # Check if the item is even.\n        # For clear integers, we can use a simple if\n        if (item % 2) == 0:\n            res = res + item\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "one_norm", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef one_norm(vec):\n    s = sfix(0)\n    for item in vec:\n        s = s + if_else(item >= 0, item, -item)\n    return s\n", "response_1": "def one_norm(vec):\n    # Initialize s with 0 in the same type as vec elements.\n    s = vec[0].__class__(0)\n    for item in vec:\n        # Use the built-in abs function which is defined for secret types.\n        s = s + abs(item)\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_floor", "response_0": "from Compiler.math import floor\n\ndef array_floor(arr):\n    # Initialize a new list to store the floor of each element.\n    ret = [0 for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # Compute the secure floor of arr[i].\n        ret[i] = floor(arr[i])\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\n\ndef array_floor(arr):\n    \"\"\"\n    Apply the Gaussian floor function to all elements in the input array.\n    Assumes each element is an sfix number, and returns a list of sint numbers.\n    \"\"\"\n    ret = [None] * len(arr)\n    for i in range(len(arr)):\n        x = arr[i]\n        trunc_val = x.trunc()              # Secure truncation (round toward 0) -> sint\n        # Convert the truncated integer back to sfix for subtraction.\n        trunc_as_sfix = sfix(trunc_val)\n        # Compute the difference; for nonnegative numbers this is >=0,\n        # while for negative non-integers it is negative.\n        frac = x - trunc_as_sfix          \n        # Compare fraction with 0 securely; the result is a secret bit (0/1).\n        # If frac < 0 then correction = 1, otherwise 0.\n        correction = frac < 0              \n        # Subtract the correction (which is a secret value) from the truncated value.\n        ret[i] = trunc_val - correction  \n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "three_five", "response_0": "# MP-SPDZ version of the three_five function.\n# We use 0 for False and 1 for True.\n\ndef three_five(arr):\n    has3 = 0   # initialize as 0 (False)\n    has5 = 0   # initialize as 0 (False)\n    for item in arr:\n        if item == 3:\n            has3 = 1\n        if item == 5:\n            has5 = 1\n\n    # Return True (represented as 1) if either:\n    #   - both 3 and 5 appear, OR\n    #   - neither 3 nor 5 appears.\n    if (has3 and has5) or ((not has3) and (not has5)):\n        return 1\n    else:\n        return 0\n", "response_1": "from Compiler.types import sint\n\ndef three_five(arr):\n    # Initialize our secret Boolean flags as sint(0) (i.e. False)\n    has3 = sint(0)\n    has5 = sint(0)\n    \n    # Process each element in the array.\n    for item in arr:\n        # Compute secret equality checks.\n        # (item == 3) returns a secret bit (0 or 1).\n        cond3 = (item == 3)\n        cond5 = (item == 5)\n        \n        # Update the flags using secure OR:\n        # OR(a, b) = a + b - a * b.\n        has3 = has3 + cond3 - has3 * cond3\n        has5 = has5 + cond5 - has5 * cond5\n\n    # Compute the final result:\n    # (has3 and has5) is simply has3 * has5.\n    # (not has3 and not has5) is (1 - has3) * (1 - has5).\n    # Since these two events are mutually exclusive, we add them.\n    both = has3 * has5\n    neither = (1 - has3) * (1 - has5)\n    \n    result = both + neither\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "num_above_average", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef num_above_average(arr):\n    \"\"\"\n    Returns the number of elements in the secret array 'arr' that are greater than or equal\n    to the average value.\n    \"\"\"\n    total = sfix(0)\n    count = 0\n    n = len(arr)\n    # Compute the sum of all elements.\n    for i in range(n):\n        total = total + arr[i]\n    # Compute the average as a secret fixed\u2010point number.\n    avg = total / sfix(n)\n    # For each element, add 1 to count if it is at least as large as the average.\n    # Note: Direct secret\u2010dependent branching is avoided by using if_else.\n    for item in arr:\n        count = count + if_else(item.ge(avg), 1, 0)\n    return count\n\ndef main():\n    # Here you would typically obtain 'arr' as secret input.\n    # For example, if you need to read secret sfix values from party 0,\n    # you might do something like:\n    #\n    #   n = int(input(\"Enter number of elements: \"))\n    #   arr = [sfix.get_input_from(0) for _ in range(n)]\n    #\n    # and then call:\n    #\n    #   result = num_above_average(arr)\n    #   print_ln(\"Number of elements >= average: %s\", result)\n    #\n    # The above code is commented out to avoid using a usage example directly.\n    pass\n", "response_1": "from Compiler.types import sfix, sint\n\ndef num_above_average(arr):\n    # Compute the sum of the array elements\n    total = sfix(0)\n    n = len(arr)  # this is a public (clear) integer\n    for i in range(n):\n        total = total + arr[i]\n    \n    # Compute the average (note: n is converted to sfix)\n    avg = total / sfix(n)\n    \n    # Count the number of elements that are greater than or equal to the average.\n    count = sint(0)\n    for item in arr:\n        # (item>=avg) returns a secret bit (sbit). The sint cast converts it to 0 or 1.\n        count = count + sint(item >= avg)\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    n = len(arr)\n    for i in range(n):\n        # If arr[i] < lower_bound, replace it with lower_bound.\n        arr[i] = if_else(arr[i] < lower_bound, lower_bound, arr[i])\n        # Now, if arr[i] > upper_bound, replace it with upper_bound.\n        arr[i] = if_else(arr[i] > upper_bound, upper_bound, arr[i])\n    return arr\n", "response_1": "def clip(arr, upper_bound=1, lower_bound=-1):\n    # For each element in arr, clip it between lower_bound and upper_bound.\n    n = len(arr)\n    for i in range(n):\n        # secure clip using min and max functions\n        arr[i] = min(upper_bound, max(lower_bound, arr[i]))\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "from Compiler.types import sint, sbit\nfrom Compiler.library import if_else\n\ndef sum_with_certain_element_skipped(array):\n    total = sint(0)\n    for a in array:\n        candidate = total + a\n        # Compute secret booleans: candidate >= 5 and candidate <= 10\n        cond_low = candidate.ge(5)\n        cond_high = candidate.le(10)\n        # The condition for skipping is that both conditions hold.\n        skip = cond_low & cond_high\n        # Obliviously select: add 0 if skip is True, otherwise add a.\n        total = total + if_else(skip, sint(0), a)\n    return total\n", "response_1": "# In MP-SPDZ, we work with secret types (sint).\n# The function below expects 'array' to be a list of secret integers (sint).\ndef sum_with_certain_element_skipped(array: list) -> sint:\n    s = sint(0)\n    # Loop over the array indices.\n    for i in range(len(array)):\n        # Compute the prospective new value of s.\n        t = s + array[i]\n        # Evaluate the condition securely. Comparisons between a secret\n        # and a public integer produce a secure bit (sbit). We combine the\n        # lower and upper bound using a bitwise AND.\n        cond_lower = t >= 5\n        cond_upper = t <= 10\n        cond = cond_lower & cond_upper  # cond is an sbit: True if t is in [5,10]\n        # Update s by securely selecting: If cond is true, add 0, else add array[i].\n        s = s + if_else(cond, sint(0), array[i])\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr):\n    # initialize secret sums\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    one = sint(1)\n    # For each secret integer in the array...\n    for item in arr:\n        # compute an indicator for an odd number.\n        # Note: The computation item % 2 works correctly here if item is small\n        # and the modulus does not cause an overflow. In more general settings \n        # you might need to perform a bit decomposition.\n        odd_bit = item % 2\n        # Add item to odd_sum if it is odd, and to even_sum if it is even.\n        odd_sum = odd_sum + item * odd_bit\n        even_sum = even_sum + item * (one - odd_bit)\n    return odd_sum, even_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        # Decompose 'item' as a 32-bit number. The result is a list of secret bits\n        bits = item.bit_decompose(32)\n        last_bit = bits[0]  # lowest bit: 1 if odd, 0 if even\n        odd_sum = odd_sum + item * last_bit\n        even_sum = even_sum + item * (1 - last_bit)\n    return odd_sum, even_sum\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "distance", "response_0": "def distance(vec1, vec2):\n    total = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        total = total + diff * diff\n    return total.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef distance(vec1, vec2):\n    s = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        s = s + diff * diff\n    return sfix.sqrt(s)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "num_occurrence", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrences of the target in arr.\n    Both arr and target are assumed to be secret shared (sint) values.\n    \"\"\"\n    count = sint(0)\n    for x in arr:\n        # if_else returns 1 when x equals target and 0 otherwise,\n        # without introducing a secret-dependent branch.\n        count = count + if_else(x == target, sint(1), sint(0))\n    return count\n", "response_1": "from Compiler import sint, eqz\n\ndef num_occurrence(arr, target):\n    count = sint(0)\n    for item in arr:\n        # eqz(item - target) returns a secret 1 if equal, else 0\n        count = count + eqz(item - target)\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "palindrome", "response_0": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    flag = 1       # using 1 for True, 0 for False\n    n = len(arr)\n    for i in range(n):\n        if arr[i] != arr[n - 1 - i]:\n            flag = 0\n    return flag\n", "response_1": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    flag = True\n    for i in range(len(arr)):\n        flag = flag and (arr[i] == arr[len(arr) - 1 - i])\n    return flag\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    # Initialize count as a secret integer value.\n    num = sint(0)\n    n = len(arr)\n    # Double nested loop to check every pair (i,j) as in the Python version.\n    for i in range(n):\n        for j in range(i+1, n):\n            # Securely check if arr[i] > arr[j].\n            # The result of the comparison is a secret bit (0 or 1).\n            bit = arr[i] > arr[j]\n            # Add the secret bit to our secret counter.\n            num = num + bit\n    return num\n", "response_1": "def reverse_order_pair(arr):\n    # Count the number of reverse order pairs in the array\n    num = 0\n    # Iterate over the array indices\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # For public values, the usual > comparison is allowed.\n            if arr[i] > arr[j]:\n                num = num + 1\n    return num\n\n# The main part of the program would call reverse_order_pair with an array.\n# Additional testing or usage code should be placed outside this code block.\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_of_cubes", "response_0": "def sum_of_cubes(arr):\n    ret = sint(0)\n    for item in arr:\n        ret = ret + item * item * item\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_cubes(arr):\n    # Compute the sum of cubes of elements in the array.\n    ret = sint(0)\n    for item in arr:\n        # Use multiplication to compute the cube.\n        ret = ret + item * item * item\n    return ret\n\ndef main():\n    # For demonstration, we assume an array of 3 secret inputs from party 0.\n    arr = [sint.get_input_from(0) for _ in range(3)]\n    res = sum_of_cubes(arr)\n    # Reveal the result to all parties.\n    print_ln(\"Sum of cubes: %s\", res.reveal())\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_element", "response_0": "def max_element(a):\n    \"\"\"\n    Return the maximum value of a secret array a.\n    The array a is assumed to contain secret integers (e.g., sint).\n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = if_else(current >= item, current, item)\n    return current\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef max_element(a):\n    \"\"\"\n    Return the maximum element in a list of secret integers.\n    \"\"\"\n    current = a[0]\n    for item in a:\n        # Using if_else to choose current if current>=item, else item.\n        current = if_else(current >= item, current, item)\n    return current\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_if_else", "response_0": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input secret array, \n    if the predicator returns True (represented as a secret bit),\n    then apply the if-function to the element,\n    otherwise apply the else-function to the element.\n    \"\"\"\n    for i in range(len(arr)):\n        # Compute the secret predicate (should yield 1 for True, 0 for False)\n        b = predicator(arr[i])\n        # Secure selection: both branches are computed and then combined\n        arr[i] = b * if_func(arr[i]) + (1 - b) * else_func(arr[i])\n    return arr\n", "response_1": "def array_if_else(arr, predicator, if_func, else_func):\n    # Process each element in the input array.\n    for i in range(len(arr)):\n        # Compute the predicate on the i'th element.\n        # Here, p is assumed to be a secret bit (i.e. either of type sbit or a secret-shared 0 or 1)\n        p = predicator(arr[i])\n        # Compute \"if\" and \"else\" branch outputs for arr[i]\n        t = if_func(arr[i])\n        f = else_func(arr[i])\n        # Securely select between t and f.\n        # This arithmetic selection uses: result = p * t + (1-p) * f.\n        arr[i] = p * t + (1 - p) * f\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inf_norm", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef abs_val(x):\n    # Secure absolute value of a secret integer x:\n    return if_else(x >= 0, x, -x)\n\ndef inf_norm(vec):\n    # Initialize result as a secure integer 0.\n    s = sint(0)\n    for a in vec:\n        t = abs_val(a)\n        # Secure selection: if current max s >= t, then s remains;\n        # otherwise update s to t.\n        s = if_else(s >= t, s, t)\n    return s\n", "response_1": "from Compiler.library import if_\n\ndef inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector over secret values.\n    The function uses a secure multiplexer to choose between values.\n    \"\"\"\n    max_value = 0\n    for item in vec:\n        abs_val = abs(item)\n        max_value = if_(max_value >= abs_val, max_value, abs_val)\n    return max_value\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    # arr is assumed to be an array of secret integers (sint)\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "response_1": "# This function increments each element of an array of secret integers (sint) by 1.\ndef array_inc(arr):\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    # Initialize count as a secret integer (sint) assuming arr elements are secret.\n    count = sint(0)\n    # Loop over all indices from 0 to len(arr)-2.\n    for i in range(len(arr) - 1):\n        # (arr[i] < arr[i+1]) evaluates to a secret bit (1 if true, 0 otherwise).\n        count = count + (arr[i] < arr[i+1])\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_rises(arr):\n    # Initialize count as a secret integer equal to 0.\n    count = sint(0)\n    # Loop through the array up to the second-to-last element.\n    for i in range(len(arr) - 1):\n        # The expression arr[i] < arr[i+1] yields a secret bit.\n        # Convert that bit to a secret integer and add to count.\n        count += sint(arr[i] < arr[i+1])\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "skip_at_zero", "response_0": "def skip_at_zero(array):\n    for i in range(len(array)):\n        # Here, (array[i] == 0) will return a secure bit.\n        # Subtract this secure bit from 1 to obtain a mask that equals 1 when array[i] != 0.\n        mask = 1 - (array[i] == 0)\n        array[i] = array[i] + mask\n    return array\n", "response_1": "# If you are working with secret integers, you might need to import the desired type:\n# from Compiler.types import sint\n\ndef skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip the element if it is equal to 0.\n    Note: If working with secret values, branching may need to be avoided.\n    \"\"\"\n    for i in range(len(array)):\n        if array[i] == 0:\n            continue\n        array[i] = array[i] + 1\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_intersect", "response_0": "def array_intersect(p, q):\n    n = len(p)\n    m = len(q)\n    # Initialize result to 0. (Here 0 means \"no common element found.\")\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            # The comparison (p[i] == q[j]) returns a secret 0/1 value.\n            res = res + (p[i] == q[j])\n    # If at least one equality occurred, then (res > 0) returns a secret 1/0.\n    return (res > 0)\n", "response_1": "def array_intersect(p, q):\n    # p and q are assumed to be lists/arrays of secret integers (sint)\n    # We compute a secret flag \u201cfound\u201d that is 1 if any common element exists.\n    found = sint(0)\n    for i in range(len(p)):\n        for j in range(len(q)):\n            # The expression (p[i] == q[j]) yields a secret bit (0 or 1).\n            # We add these up, so that found > 0 if any equality is true.\n            found += (p[i] == q[j])\n    # Return a secret Boolean given by (found > 0).\n    # This comparison returns a secret bit which will be 1 if found is positive.\n    return (found > 0)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix\n\ndef two_norm(vec):\n    # Initialize sum as an sfix zero\n    s = sfix(0)\n    # Sum the squares of the vector elements\n    for item in vec:\n        s = s + item * item\n    # Return the square root of the sum\n    return s.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef two_norm(vec):\n    # Start with a secure fixed-point zero.\n    total = sfix(0)\n    # Sum the squares of the vector items.\n    for item in vec:\n        total = total + item * item\n    # Return the secure square root of the total.\n    return total.sqrt()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_between", "response_0": "def sum_between(arr, l, u):\n    # initialize the running sum as a secret integer (sint)\n    s = sint(0)\n    # iterate through the secret array\n    for i in range(len(arr)):\n        # first check: if arr[i] >= l\n        cond_lower = if_else(arr[i] >= l, 1, 0)\n        # second check: if arr[i] <= u\n        cond_upper = if_else(arr[i] <= u, 1, 0)\n        # compute the indicator as the product of the two conditions\n        indicator = cond_lower * cond_upper\n        # add the value only if inside the range\n        s = s + arr[i] * indicator\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_between(arr, l, u):\n    s = sint(0)\n    for a in arr:\n        indicator = (a >= l) * (a <= u)\n        s += a * indicator\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "largest_gap", "response_0": "from Compiler.types import sint\n\ndef sabs(x):\n    # Compute the absolute value of a secret integer.\n    # We use a secure conditional: if x >= 0 then return x else return -x.\n    return if_(x >= 0, x, -x)\n\ndef largest_gap(arr):\n    \"\"\"\n    Return the largest gap of consecutive elements in a secret-shared array arr.\n    It is assumed that len(arr) >= 2.\n    \"\"\"\n    # Initialize current max gap as a secret integer 0.\n    cur = sint(0)\n    \n    # Loop over consecutive pairs.\n    for i in range(len(arr) - 1):\n        diff = sabs(arr[i+1] - arr[i])\n        # Use secure conditional selection:\n        cur = if_(diff > cur, diff, cur)\n    return cur\n", "response_1": "from Compiler.types import cint\n\ndef largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    # use the absolute difference between the first two elements as the initial gap\n    cur = abs(arr[1] - arr[0])\n    for i in range(len(arr) - 1):\n        gap = abs(arr[i+1] - arr[i])\n        if gap > cur:\n            cur = gap\n    return cur\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "totally_dominate", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef totally_dominate(a, b):\n    # a and b are lists of secret integers (sint)\n    amin = a[0]\n    bmax = b[0]\n    \n    # Compute the minimum element of a using secure conditional selection.\n    for i in range(1, len(a)):\n        # c is a secret boolean that is true if a[i] is less than the current amin.\n        c = a[i] < amin\n        # Securely update amin without leaking any secret bits.\n        amin = if_else(c, a[i], amin)\n        \n    # Compute the maximum element of b using secure conditional selection.\n    for i in range(1, len(b)):\n        c = b[i] > bmax\n        bmax = if_else(c, b[i], bmax)\n        \n    # Return whether the minimum of a is at least the maximum of b.\n    # (This is a secure comparison that yields a secret bit.)\n    return amin >= bmax\n", "response_1": "# totally_dominate.mpc\n# Assumes that the arrays a and b are provided as lists of secret integers (sint).\n\ndef totally_dominate(a, b):\n    # Initialize amin to the first element of a and bmax to the first element of b.\n    amin = a[0]\n    bmax = b[0]\n    \n    # Compute the minimum element of array a.\n    for i in range(len(a)):\n        # cond is a secret bit that is 1 if a[i] < amin, 0 otherwise.\n        cond = a[i] < amin\n        # Update amin using the secure multiplexer:\n        amin = cond * a[i] + (1 - cond) * amin\n        \n    # Compute the maximum element of array b.\n    for i in range(len(b)):\n        # cond is 1 if b[i] > bmax and 0 otherwise.\n        cond = b[i] > bmax\n        bmax = cond * b[i] + (1 - cond) * bmax\n        \n    # Return a secret boolean (sbit) indicating whether amin >= bmax.\n    return amin >= bmax\n\n# In an MP-SPDZ setting, you would typically read arrays a and b from input,\n# call the totally_dominate function, and then output the result.\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "element_count", "response_0": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    ret = sint(0)\n    for item in arr:\n        # Instead of using an if-statement (which would require a public condition),\n        # we add (item == target) directly. The equality returns a secret value (1 if true, 0 otherwise).\n        ret = ret + (item == target)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    # Count the number of times target occurs in arr.\n    ret = sint(0)\n    for i in range(len(arr)):\n        # The equality operator returns a secret number (1 if equal, 0 otherwise).\n        ret = ret + (arr[i] == target)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_subarray", "response_0": "def is_subarray(c, d):\n    n = len(d)\n    m = len(c)\n    # Only iterate through indices where a continuous subarray of length m fits inside d.\n    for i in range(n - m + 1):\n        flag = 1  # Using 1 for true and 0 for false.\n        for j in range(m):\n            # If the corresponding element in d and c differ, mark flag as false and break.\n            if d[i + j] != c[j]:\n                flag = 0\n                break\n        if flag:\n            return 1\n    return 0\n", "response_1": "def is_subarray(c, d):\n    \"\"\"\n    Return whether the first array c is a continuous subarray of the second array d.\n    \"\"\"\n    # iterate over possible starting indices in d\n    for i in range(len(d)):\n        # check if enough elements remain for a potential match\n        if len(c) <= len(d) - i:\n            flag = True\n            # compare each element of c with the corresponding subarray of d\n            for j in range(len(c)):\n                flag = flag and (d[i + j] == c[j])\n            if flag:\n                return True\n    return False\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import cint\n\n# This function checks whether the clear value array contains 5 or 7.\ndef exists_5_or_7(arr):\n    for item in arr:\n        if item == 5 or item == 7:\n            return 1\n    return 0\n\ndef main():\n    # Suppose we expect an array of 5 integers.\n    n = 5\n    # Read clear input from party 0. (All parties can change the input party as needed.)\n    arr = [cint.get_input_from(0) for _ in range(n)]\n    res = exists_5_or_7(arr)\n    print_ln(\"Result: %s\", res)\n", "response_1": "from Compiler.types import sint, sbit\n\n# Helper function to compute logical OR for secret bits.\ndef sbit_or(a, b):\n    return a + b - a * b\n\n# Function that checks whether the array 'arr' (a list of sint values)\n# contains either the public constant 5 or 7.\ndef exists_5_or_7(arr):\n    # Initialize flag as false (using sbit(0))\n    flag = sbit(0)\n    # Iterate over each secret integer in arr\n    for item in arr:\n        # Compute if the current item equals 5 or 7\n        # The expression (item == 5) and (item == 7) return secret bits.\n        flag = sbit_or(flag, sbit_or(item == 5, item == 7))\n    return flag\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "variance", "response_0": "from Compiler.types import sfix\n\ndef variance(arr):\n    \"\"\"\n    Compute the variance of a secret array using fixed\u2010point arithmetic.\n    \"\"\"\n    m = len(arr)  # m is public (the length of the array)\n    # Initialize secret fixed-point values for average and variance.\n    average = sfix(0)\n    variance_val = sfix(0)\n    \n    # Compute the average\n    for item in arr:\n        average = average + item / m\n        \n    # Compute the variance\n    for item in arr:\n        diff = item - average\n        variance_val = variance_val + (diff * diff) / m\n        \n    return variance_val\n", "response_1": "def variance(arr):\n    n = len(arr)          # n is a public integer (length of the array)\n    avg = sfix(0)\n    for x in arr:\n        avg += x / sfix(n)\n    var = sfix(0)\n    for x in arr:\n        diff = x - avg\n        var += (diff * diff) / sfix(n)\n    return var\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_ascending", "response_0": "from Compiler.types import sint\n\ndef is_ascending(arr):\n    # If the array length is 0 or 1, then we consider it ascending.\n    n = len(arr)\n    ret = sint(1)\n    # In MP-SPDZ we cannot branch on secret values, so we do a secure multiplication\n    # to combine all the bits representing the check arr[i] < arr[i+1].\n    for i in range(n-1):\n        # Note: (arr[i] < arr[i+1]) returns a secret 0/1 value.\n        ret = ret * (arr[i] < arr[i+1])\n    return ret\n", "response_1": "def is_ascending(arr):\n    # If the array has only 1 element (or less), it is ascending.\n    n = len(arr)\n    # Loop through adjacent elements and compare them.\n    for i in range(n - 1):\n        # If an element is not less than its following element, the list is not strictly ascending.\n        if arr[i] >= arr[i + 1]:\n            return 0  # MP-SPDZ typically uses 0 for False.\n    return 1  # Return 1 for True.\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "xor_all", "response_0": "def xor_all(arr):\n    # arr is a list of secret shared bits (with values 0 or 1).\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret + arr[i] - 2 * ret * arr[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef xor_all(arr):\n    # arr is expected to be a list of sint values (0's and 1's)\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        # Update ret to be the XOR of ret and arr[i] using the arithmetic equivalent:\n        # XOR(a,b) = a + b - 2*a*b\n        ret = ret + arr[i] - 2 * ret * arr[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "upper_bound", "response_0": "from Compiler.types import cint\n\ndef upper_bound(arr, x):\n    # ret will be the index of the smallest element in arr that is > x,\n    # or -1 if no such element exists.\n    ret = -1       # initially, no valid index has been found\n    distance = 0   # placeholder for the difference arr[i]-x\n    found = 0      # using 0 for False, 1 for True\n\n    for i in range(len(arr)):\n        # The following comparison is valid if arr[i] and x are public.\n        if arr[i] > x:\n            # Either we have not found a valid element before (found==0)\n            # or the current element is closer to x than the previous candidate.\n            if (found == 0) or ((arr[i] - x) < distance):\n                ret = i\n                distance = arr[i] - x\n                found = 1\n\n    return ret\n\ndef main():\n    # The main function can call upper_bound with an array and x.\n    # No usage example is included here.\n    pass\n", "response_1": "#!/usr/bin/env python3\nfrom Compiler.types import regint\n\ndef upper_bound(arr, x):\n    # ret stores the index of the result, initially -1\n    ret = -1\n    # distance is used to store the difference arr[i] - x for the best candidate\n    distance = 0\n    # found indicates whether we have found any candidate so far\n    found = False\n    for i in range(len(arr)):\n        # Check if the current array element is bigger than x.\n        if arr[i] > x:\n            # If no candidate has been found yet, or if the current candidate is closer to x,\n            # update our result.\n            if not found or (arr[i] - x) < distance:\n                ret = i\n                distance = arr[i] - x\n                found = True\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler.types import sint, regint  # regint is used for public integers if needed\n\n# Define the transformation function.\n# In MP-SPDZ you cannot pass functions as arguments,\n# so you must define the processing function you want to use.\ndef process_func(x: sint) -> sint:\n    # Replace the following with any processing you need.\n    return x * 2\n\n# Process all elements in the array with the given function,\n# then sum up the processed elements.\ndef array_process_then_sum(arr: list[sint]) -> sint:\n    total: sint = 0\n    # Here, we use the range function for iteration.\n    for i in range(len(arr)):\n        # Update the array element with the processed value.\n        arr[i] = process_func(arr[i])\n        total = total + arr[i]\n    return total\n", "response_1": "def array_process_then_sum(arr, func):\n    # Initialize the sum as a secret integer; change to int(0) if dealing with public values.\n    s = sint(0)\n    # Iterate over all indices of the array\n    for i in range(len(arr)):\n        # Process the element at index i using func and update the array element\n        arr[i] = func(arr[i])\n        # Add the processed value to the sum\n        s = s + arr[i]\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the secret-shared array.\n    \"\"\"\n    sum_val = sfix(0)\n    length = len(arr)  # public value: length of the array\n    for i in range(length):\n        sum_val = sum_val + arr[i]\n    # Convert public length to sfix before performing division\n    return sum_val / sfix(length)\n", "response_1": "from Compiler.types import sfix\n\ndef average(arr):\n    # arr is a list of sfix secret values\n    total = sfix(0)\n    length = len(arr)\n    for i in range(length):\n        total = total + arr[i]\n    ret = total / sfix(length)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_filter", "response_0": "from Compiler.types import sint\n\ndef array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then preserve the element; \n    otherwise set the element to 0.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Get secret boolean flag (or 0/1) from the predicate.\n        cond = predicator(arr[i])\n        # Use the secure multiplexer: if cond is true, choose arr[i], else 0.\n        arr[i] = cond.if_else(arr[i], 0)\n    return arr\n", "response_1": "def array_filter(arr, predicator):\n    # For each element in the input array,\n    # if the predicator returns True then preserve the element,\n    # otherwise set the element to 0.\n    for i in range(len(arr)):\n        cond = predicator(arr[i])\n        # Use a secure selection: if cond returns true, we keep arr[i],\n        # else we set it to 0.\n        arr[i] = if_else(cond, arr[i], 0)\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_up", "response_0": "def sum_up(array):\n    # Initialize the sum to a secure integer value of 0.\n    total = sint(0)\n    for num in array:\n        total += num\n    return total\n", "response_1": "def sum_up(array):\n    # Initialize the secure sum as a secret-shared integer \"0\"\n    res = sint(0)\n    for num in array:\n        res = res + num\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "negative_to_zero", "response_0": "from Compiler.types import sfix\n\ndef negative_to_zero(array):\n    # Iterate over each element using its index.\n    for i in range(len(array)):\n        # For secret value comparison, use the branchless if_else,\n        # which takes a secret boolean (here, array[i] \u2265 0)\n        # and returns array[i] (if true) or 0 (if false)\n        array[i] = (array[i] >= 0).if_else(array[i], 0)\n    return array\n", "response_1": "def negative_to_zero(array):\n    # Loop through the array indices.\n    for i in range(len(array)):\n        # If the element is negative, set it to 0.\n        if array[i] < 0:\n            array[i] = 0\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_only_positive_to_ten", "response_0": "from Compiler.types import sint\n\ndef sum_only_positive_to_ten(array):\n    # Initialize the secret accumulator and an activity flag.\n    s = sint(0)\n    active = sint(1)  # active will be 1 until s >= 10, then 0.\n\n    n = len(array)\n    for i in range(n):\n        # Check if the current element is positive.\n        # (The comparison returns a secret 0/1 value.)\n        pos = (array[i] > 0)\n        # Only add the element if it is positive and if we are still active.\n        add_flag = active * pos\n        s = s + array[i] * add_flag\n        # Update active so that once s >= 10 further additions are suppressed.\n        active = active * (s < 10)\n    return s\n\ndef main():\n    # Example: The input array should be provided as a list of secret integers.\n    # In an actual MP-SPDZ protocol you would obtain secret inputs, e.g. by:\n    #   a = sint.get_input_from(0)\n    # Here we assume that 'array' is already of type [sint, sint, ...].\n    #\n    # To test, replace the following line with proper secret input assignments.\n    array = [sint(3), sint(-1), sint(4), sint(2), sint(6)]\n    s = sum_only_positive_to_ten(array)\n    # Reveal the result for output.\n    print_ln(\"%s\", s.reveal())\n", "response_1": "from Compiler.types import sint, cint\n\ndef sum_only_positive_to_ten(array):\n    # Initialize the secret sum to 0.\n    s = sint(0)\n    # Loop through every secret element in the array.\n    for a in array:\n        # Compute two secret bits:\n        #   positive_flag is 1 if a > 0 (and 0 otherwise),\n        #   threshold_flag is 1 if the current sum is less than 10.\n        # Their product is 1 only if both conditions are met.\n        positive_flag = a > 0\n        threshold_flag = s < cint(10)\n        cond = positive_flag * threshold_flag\n        # Add a to s only if cond is 1.\n        s = s + a * cond\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "bubble_sort", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_then_else\n\ndef bubble_sort(arr):\n    # n is the length of the array\n    n = len(arr)\n    # Outer loop: iterate over passes.\n    for i in range(n - 1):\n        # Inner loop: compare adjacent entries.\n        for j in range(n - 1 - i):\n            # Instead of a branch, compute a secret flag that is 1 if arr[j] >= arr[j+1] and 0 otherwise.\n            # We note that if arr[j] < arr[j+1] then no swap is needed.\n            flag = if_then_else(arr[j] < arr[j+1], 0, 1)\n            # Conditionally swap the two entries using arithmetic.\n            new_j    = if_then_else(flag, arr[j+1], arr[j])\n            new_jp1 = if_then_else(flag, arr[j],   arr[j+1])\n            arr[j]   = new_j\n            arr[j+1] = new_jp1\n    return arr\n", "response_1": "def bubble_sort(arr):\n    # Perform bubble sort with a data-independent conditional swap.\n    for i in range(len(arr) - 1):\n        for j in range(len(arr) - 1 - i):\n            # When comparing secret integers in MP-SPDZ, the \">=\"\n            # operator returns a secret bit (0/1)\n            swap_bit = (arr[j] >= arr[j+1])\n            # Compute the new values for arr[j] and arr[j+1] without secret branching.\n            new_first  = swap_bit * arr[j+1] + (1 - swap_bit) * arr[j]\n            new_second = swap_bit * arr[j]   + (1 - swap_bit) * arr[j+1]\n            arr[j]   = new_first\n            arr[j+1] = new_second\n    return arr\n", "model_name": "azure-openai-o3-mini"}
