{"test_name": "sin_or_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef sin_or_cos(x):\n    # Returns sin(x) if x is nonnegative, otherwise returns cos(x)\n    return if_else(x >= 0, sfix.sin(x), sfix.cos(x))\n", "response_1": "from Compiler.library import sin, cos\n# x is assumed to be of type sfix (a secure fixed\u2010point number).\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Compute sine and cosine of x (with secure approximations)\n    sin_val = sin(x)\n    cos_val = cos(x)\n    # Securely compare x with 0. The comparison (x >= 0) yields a secret bit.\n    condition = (x >= 0)\n    # Securely select the result:\n    # If condition equals 1 then result = sin_val, otherwise result = cos_val.\n    result = condition * sin_val + (1 - condition) * cos_val\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "negative_relu", "response_0": "def negative_relu(x):\n    return if_else(x < 0, x, 0)\n", "response_1": "def negative_relu(x):\n    # Negative ReLU: if x < 0, return x; otherwise, return 0.\n    # When x is a secret value (e.g. of type sfix), the below\n    # computes an indicator bit for (x < 0) in a secure (branchless) way.\n    return (x < 0) * x\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    # compute the difference\n    diff = a - b\n    # compute the absolute difference; MP-SPDZ overloads abs for secret types\n    abs_diff = abs(diff)\n    # return a secret boolean (0 or 1) representing whether the difference is no larger than 1\n    return abs_diff <= 1\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import eqz\n\ndef is_close(a: sint, b: sint) -> sint:\n    # Compute the difference between a and b\n    diff = a - b\n    # The product is zero if and only if diff is -1, 0, or 1:\n    prod = diff * (diff - 1) * (diff + 1)\n    # eqz(prod) returns 1 if prod is zero, and 0 otherwise.\n    return eqz(prod)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "hardswish", "response_0": "def hardswish(x):\n    return (x < sfix(-3)).if_else(sfix(0), \n           (x > sfix(3)).if_else(x, x * (x + sfix(3)) / sfix(6)))\n", "response_1": "from Compiler.types import sfix\n\ndef hardswish(x):\n    # Ensure that the constants are also of type sfix.\n    if x < sfix(-3):\n        return sfix(0)\n    elif x > sfix(3):\n        return x\n    else:\n        return (x * (x + sfix(3))) / sfix(6)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "clip_at_6", "response_0": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    # Compare x with sfix constants.\n    if x > sfix(6):\n        return sfix(6)\n    if x < sfix(-6):\n        return sfix(-6)\n    return x\n", "response_1": "def clip_at_6(x):\n    # Compute a branchless maximum and minimum\n    # First, compute max(x, -6)\n    clipped_low = if_else(x < -6, -6, x)\n    # Then, clip the upper bound: min(clipped_low, 6)\n    clipped = if_else(clipped_low > 6, 6, clipped_low)\n    return clipped\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "piecewise_function", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef piecewise_function(x):\n    # The argument x is expected to be an sfix (secure fixed\u2013point type)\n    # The function returns:\n    #   x if x > 1 or x < -1,\n    #   1 if x is positive (but not >1),\n    #  -1 if x is negative (but not < -1),\n    #   0 otherwise.\n    return if_else(x > sfix(1),\n                   x,\n                   if_else(x < sfix(-1),\n                           x,\n                           if_else(x > sfix(0),\n                                   sfix(1),\n                                   if_else(x < sfix(0),\n                                           sfix(-1),\n                                           sfix(0)))))\n", "response_1": "# Import the secret fixed-point type. In MP-SPDZ the library \u2018sfix\u2019 is used.\nfrom Compiler.types import sfix\n\n# The secure if_else function is available by default.\ndef piecewise_function(x: sfix) -> sfix:\n    # x is assumed to be a secret fixed-point number.\n    # The function returns:\n    #   x           if x > 1 or x < -1,\n    #   1           if 0 < x <= 1,\n    #  -1           if -1 <= x < 0,\n    #   0           if x == 0.\n    #\n    # We use nested if_else calls which select the result without revealing secret control flow.\n    return if_else(x > sfix(1),\n             x,\n             if_else(x < sfix(-1),\n                 x,\n                 if_else(x > sfix(0),\n                     sfix(1),\n                     if_else(x < sfix(0),\n                         sfix(-1),\n                         sfix(0)\n                     )\n                 )\n             )\n         )\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "middle", "response_0": "from Compiler.program import *\n\n# Secure swap: returns (x,y) such that if x>=y then (x,y) become (y,x) and otherwise remain unchanged.\ndef swap(x, y):\n    # Compute the secure bit; this bit is 1 if x>=y and 0 otherwise.\n    cond = x >= y\n    # if_else(cond, then_value, else_value) returns then_value if cond==1, else else_value.\n    new_x = if_else(cond, y, x)\n    new_y = if_else(cond, x, y)\n    return new_x, new_y\n\ndef middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three secret inputs a, b, c.\n    The function performs three secure swaps to ensure that after sorting,\n    the middle value is in b.\n    \"\"\"\n    a, b = swap(a, b)\n    b, c = swap(b, c)\n    a, b = swap(a, b)\n    return b\n", "response_1": "def middle(a, b, c):\n    # Return the value in the middle among the three inputs.\n    if a >= b:\n        temp = a\n        a = b\n        b = temp\n    if b >= c:\n        temp = b\n        b = c\n        c = temp\n    if a >= b:\n        temp = a\n        a = b\n        b = temp\n    return b\n\n# Example of how one might call the function in an MP-SPDZ main function,\n# assuming a, b, and c are provided (e.g., as clear integers).\ndef main():\n    a = 7\n    b = 2\n    c = 5\n    m = middle(a, b, c)\n    print_ln('The middle value is %s', m)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler.library import sin, cos\n\ndef indicated_sin_or_cos(x, ind):\n    # If the indicator is True, returns the sine of x;\n    # otherwise returns the cosine of x.\n    if ind:\n        return sin(x)\n    else:\n        return cos(x)\n", "response_1": "from Compiler.types import sfix\n\ndef indicated_sin_or_cos(x, ind):\n    # if the indicator is True, return the sine approximation,\n    # otherwise return the cosine approximation.\n    if ind:\n        return x.sin()  # call the secure sine method on sfix\n    return x.cos()      # call the secure cosine method on sfix\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "minus2_if_else", "response_0": "# Define the function minus2_if_else for secret integers\ndef minus2_if_else(x):\n    # Compute s = x - 2\n    s = x - 2\n    # Securely compute a bit b which is 1 if s is nonnegative and 0 otherwise.\n    # (This comparison is done without revealing any information about s.)\n    b = s.geq_zero()\n    # Use secure multiplexer: if b is 1 then use s, else use x.\n    return s * b + x * (1 - b)\n", "response_1": "def minus2_if_else(x):\n    # Compute x-2\n    diff = x - 2\n    # Instead of a branch on a secret value, note that x-2 >= 0 <=> x >= 2.\n    # In MP-SPDZ, comparisons on secret integers return a secret bit.\n    b = (x >= 2)\n    # If b is 1 then result is diff, if b is 0 then result is x.\n    # This is computed securely without branching.\n    return diff * b + x * (1 - b)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    # ReLU6 for a secret input using branchless arithmetic.\n    max_x = (x + abs(x)) / 2     # Computes max(x, 0)\n    return 6 - (((6 - max_x) + abs(6 - max_x)) / 2)   # Computes min(max_x, 6)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef relu6(x):\n    # Make sure x is interpreted as a secret fixed-point value.\n    x = sfix(x)\n    # Replace negative x with 0.\n    tmp = if_else(x < sfix(0), sfix(0), x)\n    # Cap any values above 6 to 6.\n    return if_else(tmp > sfix(6), sfix(6), tmp)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exp_slide", "response_0": "def exp_slide(x):\n    # Compute the value for the case x >= 0\n    exp_val = exp(x)  # using the built-in exponential for sfix values\n    # Compute the alternative value\n    add_val = x + 1\n    # Compute a secure bit which is 1 when x >= 0 and 0 otherwise.\n    cond = (x >= 0)  \n    # Return exp(x) when cond is 1, or (x+1) when cond is 0.\n    return cond * exp_val + (1 - cond) * add_val\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.if_else import if_else\n\ndef exp_slide(x):\n    # If x is nonnegative, return e^x; otherwise, return x+1.\n    # Using if_else to securely select between the two branches.\n    return if_else(x >= 0, sfix.exp(x), x + sfix(1))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "pass_or_not", "response_0": "from Compiler.library import if_else\nfrom Compiler.types import sint\n\ndef pass_or_not(score):\n    # 'score' is assumed to be a secret integer (sint)\n    # 'passed' is a secret boolean (sbit) that is True if score >= 60\n    passed = score >= 60\n    # New score is the actual score if passed, otherwise 59.\n    new_score = if_else(passed, score, sint(59))\n    return new_score, passed\n", "response_1": "from Compiler.types import sint\n\ndef pass_or_not(score: sint):\n    # Compute the secret comparison bit.\n    # Since 60 is public, the operation score >= 60 returns a secret bit.\n    passed = score >= 60  \n    # Use the secret bit to select between score and 59.\n    output_score = passed * score + (1 - passed) * 59\n    return output_score, passed\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    # Given coefficients a, b, c of a quadratic function,\n    # return the number of its roots.\n    # a, b, c can be zero, but they will not all be zero.\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    d = b * b - 4 * a * c\n    if d > 0:\n        return 2\n    elif d == 0:\n        return 1\n    else:\n        return 0\n\n# Main routine\na = read_int()\nb = read_int()\nc = read_int()\n\nroots = how_many_roots(a, b, c)\nprint_ln(\"Number of roots: %s\", roots)\n", "response_1": "from Compiler.types import sint\n\ndef how_many_roots(a, b, c):\n    # a, b, c are expected to be of type sint\n    if a == 0:\n        if b == 0:\n            r = sint(0)\n        else:\n            r = sint(1)\n    else:\n        disc = b * b - 4 * a * c\n        if disc > 0:\n            r = sint(2)\n        elif disc == 0:\n            r = sint(1)\n        else:\n            r = sint(0)\n    return r\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "elu", "response_0": "from Compiler.types import sfix\n\ndef elu(x: sfix) -> sfix:\n    # Instead of branching on secret data, we compute the secure bit for x>0.\n    # The expression (x > 0) is interpreted as a secure boolean value.\n    # Using the bit, we select x if x>0, or sfix.exp(x)-1 otherwise.\n    bit = x > 0\n    return bit * x + (1 - bit) * (sfix.exp(x) - 1)\n", "response_1": "from Compiler.types import sfix\n\ndef elu(x):\n    # Securely select x if x > 0, otherwise select exp(x)-1.\n    # The condition (x > 0) is evaluated securely.\n    return sfix.if_else(x > 0, x, sfix.exp(x) - 1)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "relu", "response_0": "def relu(x):\n    # Here, x > 0 is interpreted as a secure bit which is 1 if x > 0 and 0 otherwise.\n    return x * (x > 0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function for secure computation.\n    If x > 0 returns x; otherwise returns 0.\n    \"\"\"\n    # Compute the secure bit b, which is 1 if x > 0, else 0.\n    b = x > 0\n    # Return x multiplied by b. When x<=0, b==0 so result is 0.\n    return b * x\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    # Compute a secret bit 'b' which is 1 if x > 0 else 0.\n    b = x.gt(0)\n    # Compute and return x when b is 1, and alpha*x when b is 0.\n    return x * b + (x * alpha) * (1 - b)\n", "response_1": "def leaky_relu(x, alpha):\n    # Securely compute b = 1 if x > 0, else b = 0.\n    b = x > 0\n    # Return b * x + (1 - b) * (alpha * x)\n    return b * x + (1 - b) * (alpha * x)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max", "response_0": "def mmax(a, b):\n    if a >= b:\n        return a\n    else:\n        return b\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    # 'a >= b' performs a secure comparison and returns a secret bit.\n    # 'if_else' uses that bit to select 'a' if true, and 'b' if false.\n    return if_else(a >= b, a, b)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    return if_else(x > 1, x - 1, if_else(x < -1, -x - 1, 0))\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef bowl_shape(x):\n    # Compute: if x > 1 then x-1, elif x < -1 then -x-1, else 0.\n    return if_else(x > 1, x - 1, if_else(x < -1, -x - 1, 0))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "rounded_kinetic_energy", "response_0": "from Compiler.library import sfix, sint\n\ndef rounded_kinetic_energy(m, v):\n    # Compute kinetic energy: k = m*v^2/2\n    k = m * (v * v) / sfix(2)\n    # Truncate to obtain the integer part\n    k_int = k.to_sint()      \n    # Compute the fractional part\n    frac = k - sfix(k_int)\n    # Round to the nearest integer: if fractional part < 0.5 round down, else round up.\n    # Note: conditional expression can be written with a Python if-else.\n    if frac < sfix(0.5):\n        return k_int\n    else:\n        return k_int + 1\n", "response_1": "from Compiler.types import sfix, sint\n\ndef rounded_kinetic_energy(m, v):\n    # Compute kinetic energy as m*v^2/2 using sfix arithmetic.\n    k = m * (v * v) / sfix(2)\n    # Truncate k: converting an sfix to sint gives the floor (for nonnegative values).\n    k_int = sint(k)\n    # Compute the fractional part securely.\n    diff = k - sfix(k_int)\n    # Securely compare the fractional part with 0.5.\n    # The function .ge returns a secret bit (0 or 1) that is 1 if diff >= 0.5.\n    b = diff.ge(sfix(0.5))\n    # Return k_int + b: if the fraction was at least 0.5, add 1.\n    return k_int + b\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "danger_test", "response_0": "def danger_test(origin, damage):\n    # Compute the remaining health (origin - damage) and compare it to 10.\n    # If the health is less than or equal to 10, the situation is considered dangerous.\n    return (origin - damage) <= 10\n", "response_1": "from Compiler.types import sint\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy!\n    Given the Dragon Warrior's initial health (origin) and the damage he receives,\n    decide whether the situation is dangerous.\n    (If the health left is no more than 10, we say that the situation is dangerous.)\n    \"\"\"\n    # Compute the remaining health as a secret value and compare with 10.\n    return origin - damage <= 10\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    return ind * (x + y) + (1 - ind) * (x * y)\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    # Compute sum and product\n    s = x + y\n    p = x * y\n    # Use arithmetic selection to avoid branching on secret bits:\n    return ind * s + (1 - ind) * p\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "median", "response_0": "from Compiler.types import sfix\n\ndef median(arr):\n    # Check if the array is empty\n    if len(arr) == 0:\n        print_ln(\"The length of the array is 0!\")\n        exit(1)\n\n    # Sorting the array\n    arr.sort()\n\n    # Compute median: if odd-length, take middle element; if even, average the two center values.\n    if len(arr) % 2 == 1:\n        ret = arr[len(arr) // 2]\n    else:\n        ret = (arr[len(arr) // 2] + arr[len(arr) // 2 - 1]) / sfix(2)\n    \n    return ret\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import print_ln, exit\n\ndef median(arr):\n    # arr is assumed to be a list of sfix objects.\n    n = len(arr)\n    if n == 0:\n        print_ln(\"Error: The length of the array is 0!\")\n        exit(1)\n    # Securely sort the array. Depending on your use-case,\n    # you might need to implement a sorting network if the data\n    # is secret.\n    sorted_arr = sorted(arr)\n    \n    if n % 2 == 1: \n        ret = sorted_arr[n // 2]\n    else:\n        # Division must be done in an MPC-friendly way.\n        ret = (sorted_arr[n // 2] + sorted_arr[n // 2 - 1]) / sfix(2)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "add_upto_10", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_then_else\n\ndef add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, but if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    s = a + b\n    # The condition s > 10 is secret; use if_then_else to compute securely.\n    return if_then_else(s > 10, 10, s)\n", "response_1": "from Compiler.types import sint\n\ndef add_upto_10(a: sint, b: sint) -> sint:\n    s = a + b\n    # if_else(condition, value_if_true, value_if_false) returns 10 if s > 10, else returns s.\n    return if_else(s > 10, 10, s)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "taxi_fare", "response_0": "from Compiler.types import sfix\n\ndef taxi_fare(m):\n    # Compute the taxi fare given the miles (m).\n    # Base fare for up to 5 miles, charge 1.2 per mile for [5,10],\n    # and 1.5 per mile for miles above 10.\n    if m <= sfix(5):\n        return sfix(5)\n    elif m <= sfix(10):\n        return sfix(5) + sfix(1.2) * (m - sfix(5))\n    else:\n        return sfix(11) + sfix(1.5) * (m - sfix(10))\n\n# Input can be provided by party 0.\nm = sfix.get_input_from(0)\nfare = taxi_fare(m)\nprint_ln(\"%s\", fare.reveal())\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef taxi_fare(m):\n    # m is assumed to be an sfix representing a publicly known value.\n    # Rules:\n    #   If miles <= 5, fare is 5.\n    #   If 5 < miles <= 10, fare is 5 + 1.2*(m - 5).\n    #   Otherwise, fare is 11 + 1.5*(m - 10).\n    if m <= sfix(5):\n        return sfix(5)\n    elif m <= sfix(10):\n        return sfix(5) + sfix(1.2) * (m - sfix(5))\n    else:\n        return sfix(11) + sfix(1.5) * (m - sfix(10))\n\nif __name__ == '__main__':\n    # Read the mile value from party 0 (as public input).\n    # If a secret input is desired, an appropriate secure selection (without branches)\n    # would need to be implemented.\n    m_val = sfix.get_input_from(0)\n    fare = taxi_fare(m_val)\n    # Reveal and print the computed taxi fare.\n    print_ln('Taxi fare: %s', fare.reveal())\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "round", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_then_else\n\ndef round(x):\n    # Compute the floor of x (that is, the largest integer <= x).\n    # sfix.floor returns the floor as a secret integer (sint).\n    x_int = sfix.floor(x)\n    \n    # Compute the secret-shared fractional part:\n    x_frac = x - sfix(x_int)\n    \n    # Compare the fractional part with 0.5 in a branchless (secure) way.\n    # If x_frac is at least 0.5 then if_then_else returns 1; otherwise 0.\n    delta = if_then_else(x_frac < sfix(0.5), 0, 1)\n    \n    # Return the rounded result (floor + delta).\n    return x_int + delta\n", "response_1": "def round(x):\n    # x is assumed to be an sfix representing a nonnegative number.\n    # Compute the integer part of x. For nonnegative numbers, truncation equals floor.\n    x_int = x.truncate()  # x_int becomes a secret integer (sint)\n    \n    # Compute the remaining fractional part.\n    frac = x - sfix(x_int)\n    \n    # Securely check whether the fractional part is less than 0.5.\n    # If it is less than 0.5, then no increment is needed.\n    # Otherwise, add 1.\n    add = if_else(frac < 0.5, 0, 1)\n    \n    return x_int + add\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "gpa_calculator", "response_0": "from Compiler.types import sfix\n\ndef gpa_calculator(score: sfix) -> sfix:\n    if score >= 90:\n        return sfix(4.0)\n    elif score >= 85:\n        return sfix(3.6)\n    elif score >= 80:\n        return sfix(3.3)\n    elif score >= 75:\n        return sfix(3.0)\n    elif score >= 70:\n        return sfix(2.6)\n    else:\n        return sfix(2.3)\n", "response_1": "from Compiler.types import sfix\n\ndef gpa_calculator(score):\n    # score is assumed to be an sfix value in the range [0,100]\n    if score >= sfix(90):\n        return sfix(4.0)\n    elif score >= sfix(85):\n        return sfix(3.6)\n    elif score >= sfix(80):\n        return sfix(3.3)\n    elif score >= sfix(75):\n        return sfix(3.0)\n    elif score >= sfix(70):\n        return sfix(2.6)\n    else:\n        return sfix(2.3)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sign", "response_0": "def sign(x):\n    # if_then_else(condition, value_if_true, value_if_false)\n    return if_then_else(x == 0, 0, if_then_else(x > 0, 1, -1))\n", "response_1": "def sign(x):\n    pos = (x > 0)   # secure boolean: 1 when true, 0 otherwise\n    neg = (x < 0)\n    return pos - neg\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    # Here a and b are assumed to be of type sint (secure integers)\n    # The secure comparison produces a secret bit (0 or 1)\n    c = a <= b\n    # The result is computed as: if c==1 then a+b, else a-b.\n    return c * (a + b) + (1 - c) * (a - b)\n", "response_1": "def sum_or_difference(a, b):\n    # Compute the secure condition: if a <= b then cond becomes the secret bit 1,\n    # otherwise it is 0. Note: this secure comparison does not reveal any information.\n    cond = a <= b\n    # Compute both possible values: the sum and the difference.\n    s = a + b\n    d = a - b\n    # Select the result securely: if cond==1 select s, else select d.\n    # The expression cond * s + (1-cond) * d does not branch on secret data.\n    return cond * s + (1 - cond) * d\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    if control_bit:\n        return 1 - flip_bit\n    else:\n        return flip_bit\n", "response_1": "def CNOT(control_bit: sint, flip_bit: sint) -> sint:\n    # Compute the CNOT operation in a branchless fashion.\n    return flip_bit + control_bit - 2 * control_bit * flip_bit\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "negative_plus1", "response_0": "from Compiler.types import sint\n\ndef negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y.\n    \"\"\"\n    # The expression (y < 0) evaluates to a secret bit: 1 if y is negative, 0 otherwise.\n    return y + (y < 0)\n", "response_1": "from Compiler.library import if_else\n\ndef negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y.\n    Assumes y is of type sint.\n    \"\"\"\n    return if_else(y < 0, y + 1, y)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler.types import sint\n\n# The helper function 'same' returns 1 if the two vertices are identical; 0 otherwise.\ndef same(x, y):\n    # x and y are assumed to have two coordinates: x[0], x[1]\n    return (x[0] == y[0]) * (x[1] == y[1])\n\n# Function to check whether the four vertices can form a parallelogram.\ndef is_a_parallelogram(a, b, c, d):\n    # Check if any two vertices are the same.\n    dup_flag = same(a, b) + same(a, c) + same(a, d) + same(b, c) + same(b, d) + same(c, d)\n    # Compute the three candidate conditions:\n    # Condition 1: a+b and c+d have the same coordinate-sum.\n    cond1 = (a[0] + b[0] == c[0] + d[0]) * (a[1] + b[1] == c[1] + d[1])\n    # Condition 2: a+c and b+d.\n    cond2 = (a[0] + c[0] == b[0] + d[0]) * (a[1] + c[1] == b[1] + d[1])\n    # Condition 3: a+d and b+c.\n    cond3 = (a[0] + d[0] == b[0] + c[0]) * (a[1] + d[1] == b[1] + c[1])\n    # Combine the three conditions by ORing them: the OR\n    # of Boolean values (represented as 0 or 1) can be computed as:\n    #    OR(cond1, cond2, cond3) = 1 - (1-cond1)*(1-cond2)*(1-cond3)\n    parallelogram_cond = 1 - ((1 - cond1) * (1 - cond2) * (1 - cond3))\n    # Now, if any duplicate was found then we force the result to be 0.\n    # The check (dup_flag == 0) returns 1 if there were no duplicates, else 0.\n    no_duplicates = (dup_flag == 0)\n    return no_duplicates * parallelogram_cond\n\n# (The rest of your MP-SPDZ program would call is_a_parallelogram with input vertices.)\n", "response_1": "# In MP-SPDZ we assume clear integers (for example, cint) for the vertices.\n# If needed, change the type annotations to secret types (sint) and adjust the conditionals accordingly.\n\ndef same(x, y):\n    # Compare two vertices (lists or tuples of two coordinates)\n    return (x[0] == y[0]) and (x[1] == y[1])\n\ndef is_a_parallelogram(a, b, c, d):\n    # First, ensure no two vertices coincide.\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return 0  # Use 0 to indicate False.\n    \n    # Check the three candidate pairings by comparing the sums of the coordinates.\n    if ( (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1]) ) or \\\n       ( (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1]) ) or \\\n       ( (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1]) ):\n        return 1  # Return 1 for True.\n    \n    return 0  # Otherwise, return False.\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "min", "response_0": "def min(a, b):\n    # a and b are assumed to be secret-shared values (e.g., cint or sint)\n    # Compute a secret bit: 1 if a is less than or equal to b, else 0.\n    bit = a.le(b)\n    # Return the minimum value: if a \u2264 b then result is a, else result is b.\n    return b + (a - b) * bit\n", "response_1": "def min_val(a, b):\n    \"\"\"\n    Return the minimum of the two inputs a and b.\n    This code assumes that a and b are secret values,\n    so it uses secure conditional selection.\n    \"\"\"\n    return if_else(a <= b, a, b)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "choice_of_the_knight", "response_0": "def legal(a, b):\n    return 0 <= a and a <= 7 and 0 <= b and b <= 7\n\ndef choice_of_the_knight(x, y):\n    counter = 0\n    if legal(x + 1, y + 2):\n        counter = counter + 1\n    if legal(x - 1, y + 2):\n        counter = counter + 1\n    if legal(x + 1, y - 2):\n        counter = counter + 1\n    if legal(x - 1, y - 2):\n        counter = counter + 1\n    if legal(x + 2, y + 1):\n        counter = counter + 1\n    if legal(x - 2, y + 1):\n        counter = counter + 1\n    if legal(x + 2, y - 1):\n        counter = counter + 1\n    if legal(x - 2, y - 1):\n        counter = counter + 1\n    return counter\n\n# Optionally, if you need a main routine to use these functions in MP-SPDZ,\n# you can get clear inputs as follows (these will be public values):\n\ndef main():\n    # Obtain x and y as clear integers (for example, using the built-in input functionality)\n    x = int(input(\"Enter the row position (0-7): \"))\n    y = int(input(\"Enter the column position (0-7): \"))\n    result = choice_of_the_knight(x, y)\n    print_ln(\"The knight can move to %s positions on the chess board.\", result)\n\nmain()\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef legal(a, b):\n    # Each comparison returns a secure bit (1 for true, 0 for false).\n    # Multiply the secure bits together to compute the secure \u201cand\u201d\n    return ( (a >= 0) * (a <= 7) ) * ( (b >= 0) * (b <= 7) )\n\ndef choice_of_the_knight(x, y):\n    # x and y are of type sint representing positions on an 8x8 chess board.\n    counter = 0\n    counter += if_else(legal(x + 1, y + 2), 1, 0)\n    counter += if_else(legal(x - 1, y + 2), 1, 0)\n    counter += if_else(legal(x + 1, y - 2), 1, 0)\n    counter += if_else(legal(x - 1, y - 2), 1, 0)\n    counter += if_else(legal(x + 2, y + 1), 1, 0)\n    counter += if_else(legal(x - 2, y + 1), 1, 0)\n    counter += if_else(legal(x + 2, y - 1), 1, 0)\n    counter += if_else(legal(x - 2, y - 1), 1, 0)\n    return counter\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_sum_difference", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else, gt\n\ndef max_sum_different(a: sint, b: sint) -> sint:\n    # Compute a+b and a-b.\n    sum_val = a + b\n    diff_val = a - b\n    # Securely check if (a+b) > (a-b)\n    cond = gt(sum_val, diff_val)\n    # Return sum_val if cond is true, and diff_val otherwise.\n    return if_else(cond, sum_val, diff_val)\n", "response_1": "from Compiler.library import if_else\n\ndef max_sum_different(a, b):\n    # Compute the two candidate values.\n    c = a + b\n    d = a - b\n\n    # Use secure multiplexer: if c > d then choose c; else choose d.\n    return if_else(c > d, c, d)\n", "model_name": "azure-openai-o3-mini"}
