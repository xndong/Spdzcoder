{"test_name": "next_integer", "response_0": "def next_integer(t):\n    # Return the minimum integer strictly bigger than the input value.\n    #\n    # Note: In Python, int(t) truncates toward zero.\n    # Thus if t is negative and not already an integer, int(t) gives the ceiling,\n    # so we adjust accordingly to compute the floor.\n    \n    i = int(t)            # Truncate t toward zero.\n    if t < 0 and t != i:   # For negative, non-integer values, int(t) is too high.\n        floor_t = i - 1\n    else:\n        floor_t = i\n    return floor_t + 1    # Return the smallest integer strictly greater than t.\n", "response_1": "from Compiler.sfix import sfix\nfrom Compiler.sint import sint\n\ndef next_integer(t):\n    # Here t is assumed to be of type sfix (a secret fixed-point number).\n    # We want to compute floor(t) + 1, i.e. the smallest integer strictly greater than t.\n    #\n    # One approach is to convert t to a secret integer that truncates toward zero.\n    # For nonnegative t, truncation equals floor(t), but for t<0 we need to adjust.\n    #\n    # Let i be the truncated integer part and let d = t - i. Then:\n    #   if t is nonnegative: floor(t)=i.\n    #   if t is negative and not an integer, then floor(t)=i-1.\n    #\n    # We use a secure less-than test on d and 0.\n    \n    i = t.to_sint()       # truncated conversion: rounds toward 0.\n    d = t - i             # d is of type sfix\n    # secure test: phi is 1 if d < 0, else 0.\n    phi = d < 0\n    floor_t = i - phi     # adjust if t is negative and has nonzero fractional part\n    return floor_t + 1\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "father_and_son", "response_0": "from Compiler.comparison import lt\nfrom Compiler.library import if_else\nfrom Compiler.types import sint\n\ndef father_and_son(father_age: sint, son_age: sint) -> sint:\n    # Compute diff = father_age - 2 * son_age\n    diff = father_age - 2 * son_age\n    # If diff is negative, return -diff; otherwise, return diff.\n    # lt(diff, 0) returns a secret bit (1 if diff < 0, else 0).\n    return if_else(lt(diff, 0), -diff, diff)\n", "response_1": "from Compiler.types import sint\n\ndef father_and_son(father_age, son_age):\n    # Compute the difference between father's age and twice the son's age.\n    diff = father_age - son_age * 2\n    # Securely compute the absolute value using if_else.\n    # The expression (diff < 0) is a secure comparison.\n    return if_else(diff < 0, -diff, diff)\n\n# Obtain secret inputs from party 0.\n# (Adjust the party index as needed; here we assume both inputs come from party 0.)\nfather_age = sint.get_input_from(0)\nson_age = sint.get_input_from(0)\n\n# Compute the result.\nresult = father_and_son(father_age, son_age)\n\n# Print the result.\n# print_ln is used for outputting within MP-SPDZ.\nprint_ln(\"The number of years before/after which the father's age is twice the son's age is %s\", result)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "triangle_area", "response_0": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the size of the triangle.\n    Assumes that side and height are of a secret type that supports *, / operators (e.g. sfix).\n    \"\"\"\n    return side * height / 2\n", "response_1": "from Compiler.types import sfix\n\ndef triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the area of the triangle.\n    \"\"\"\n    # Multiply the side by the height and divide by 2 to compute the area.\n    return side * height / 2\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sin_plus_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.math import sin, cos\n\ndef sin_plus_cos(a: sfix) -> sfix:\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    return sin(a) + cos(a)\n", "response_1": "from Compiler.library import sin, cos\n\ndef sin_plus_cos(a):\n    # Returns sin(a)+cos(a) using SPDZ\u2019s fixed\u2010point math functions.\n    return sin(a) + cos(a)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sigmoid", "response_0": "from Compiler.types import sfix\n\ndef sigmoid(x):\n    # Compute the sigmoid function securely:\n    # sigmoid(x) = 1 / (1 + exp(-x))\n    return sfix(1) / (sfix(1) + sfix.exp(-x))\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef sigmoid(x):\n    # Compute 1/(1+exp(-x)) on a secret fixed-point number\n    return sfix(1) / (sfix(1) + exp(-x))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "self_exponent", "response_0": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    Assumes k is a nonnegative public integer.\n    \"\"\"\n    result = 1\n    for _ in range(k):\n        result = result * k\n    return result\n", "response_1": "def self_exponent(k):\n    # This function computes the self-exponent k^k.\n    # Here, k is assumed to be a public (clear) integer.\n    result = 1\n    for i in range(k):\n        result *= k\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "silu", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef silu(x: sfix) -> sfix:\n    # Compute the SiLU activation: x / (1 + exp(-x))\n    return x / (1 + exp(-x))\n", "response_1": "from Compiler.library import exp\nfrom Compiler.types import sfix\n\ndef silu(x):\n    # x is assumed to be of type sfix.\n    return x / (sfix(1) + exp(-x))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "Gaussian_bracket", "response_0": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the value of the Gaussian large bracket of x,\n    i.e. the fractional part of x.\n    Note: Assumes x is public (or is a nonnegative sfix).\n    \"\"\"\n    # Compute the integer part of x.\n    # For nonnegative numbers, int(x) is equivalent to floor(x).\n    x_int = int(x)\n    # Return the fractional part.\n    return x - x_int\n", "response_1": "from Compiler.types import sfix\n\ndef Gaussian_bracket(x):\n    # Here we assume x is of type sfix.\n    # Note: the int(x) conversion here must be used with care. For instance,\n    # if x can be negative, then int(x) truncates toward 0 rather than taking the floor.\n    # For nonnegative numbers this yields the floor.\n    x_int = int(x)\n    return x - sfix(x_int)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "asin_and_square", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt, atan\n\ndef asin_and_square(x):\n    # Compute asin(x) using the identity:\n    # arcsin(x) = 2 * arctan(x/(1+sqrt(1-x*x)))\n    one = sfix(1)\n    s = sqrt(one - x * x)\n    t = 2 * atan(x / (one + s))\n    # Return the square of the computed arcsin value.\n    return t * t\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt, atan2\n\ndef asin_and_square(x):\n    # x is assumed to be an sfix secure fixed-point number\n    one = sfix(1)\n    # Compute \u221a(1 \u2013 x^2)\n    sqrt_term = sqrt(one - x * x)\n    # Compute arcsine via the identity: asin(x) = atan2(x, \u221a(1-x\u00b2))\n    asin_val = atan2(x, sqrt_term)\n    # Return the square of the computed arcsine value\n    return asin_val * asin_val\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cylinder_surface", "response_0": "from Compiler.types import sfix\n\npi = sfix(3.141592653589793)\n\ndef cylinder_surface(r, h):\n    # Given the radius and the height of a cylinder, return its surface area.\n    return 2 * pi * (r * r) + 2 * pi * r * h\n", "response_1": "from Compiler.types import sfix\n\ndef cylinder_surface(r, h):\n    # Define \u03c0 as an sfix constant.\n    pi = sfix(3.141592653589793)\n    # Compute the surface area: 2*\u03c0*r^2 + 2*\u03c0*r*h.\n    return 2 * pi * (r * r) + 2 * pi * r * h\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "radian_to_degree", "response_0": "from Compiler.types import sfix\n\n# Define the constant \u03c0 as an sfix value.\nPI = sfix(3.141592653589793)\n\ndef radian_to_degree(r):\n    # Convert a radian value r to degrees by computing (r/\u03c0)*180.\n    return (r * sfix(180)) / PI\n", "response_1": "def radian_to_degree(r: sfix) -> sfix:\n    pi = sfix(3.141592653589793)\n    return r * sfix(180) / pi\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "square_root", "response_0": "from Compiler.types import sfix\n\ndef square_root(a: sfix) -> sfix:\n    \"\"\"\n    Return the square root of the secret fixed\u2010point number a.\n    \"\"\"\n    return a.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef square_root(a):\n    \"\"\"\n    Return the square root of the input a using Newton's method.\n    Note: a is assumed to be an sfix (secret fixed-point) value and a > 0.\n    \"\"\"\n    # Initial guess: here we simply use a; for a near 0 value, modifications might be needed.\n    x = a\n    # Perform a fixed number of iterations (e.g., 10 iterations) for improvement.\n    for i in range(10):\n        x = (x + a/x) / 2\n    return x\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cosine_theorem", "response_0": "from Compiler.types import sfix\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad (in radians) between them,\n    use the cosine theorem to compute the length of the third edge:\n        c = sqrt(a^2 + b^2 - 2*a*b*cos(rad))\n    \"\"\"\n    # Compute a^2 + b^2 - 2*a*b*cos(rad)\n    expr = a * a + b * b - 2 * a * b * sfix.cos(rad)\n    # Compute the square root of the expression using sfix.sqrt.\n    return sfix.sqrt(expr)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt, cos\n\ndef cosine_theorem(a: sfix, b: sfix, rad: sfix) -> sfix:\n    # Computes the third edge via the cosine theorem.\n    return sqrt(a * a + b * b - 2 * a * b * cos(rad))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "lights_states", "response_0": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number \n    of possible states. (Each light has two states: on/off)\n    \n    In MP-SPDZ we assume 'num' is public.\n    \"\"\"\n    res = 1\n    for _ in range(num):\n        res = res * 2\n    return res\n", "response_1": "from Compiler.types import regint\nfrom Compiler.library import print_ln\n\ndef lights_states(num):\n    # Each light has two states (on/off). Thus, for num lights the total\n    # number of states is 2**num.\n    return 2 ** num\n\ndef main():\n    # Read the number of lights from party 0.\n    num = regint.get_input_from(0)\n    # Compute the total states.\n    total_states = lights_states(num)\n    print_ln(\"Total number of possible states: %s\", total_states)\n\nif __name__ == '__main__':\n    main()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "degree_to_radian", "response_0": "from Compiler.types import sfix\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian (assuming d is of type sfix)\n    \"\"\"\n    # Here, 180 and \u03c0 are converted to sfix constants.\n    return d / sfix(180) * sfix(3.141592653589793)\n", "response_1": "def degree_to_radian(d):\n    # Multiply d by \u03c0 and divide by 180, using sfix for the constants.\n    return d * sfix(3.141592653589793) / sfix(180)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "Fah_to_Cel", "response_0": "from Compiler.sfix import sfix\n\ndef Fah_to_Cel(F):\n    # F is expected to be a secret fixed-point number (sfix)\n    return (F - sfix(32)) / sfix(1.8)\n", "response_1": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    # Convert Fahrenheit temperature (F) to Celsius.\n    # F is expected to be of type sfix (secret fixed-point number).\n    return (F - sfix(32)) / sfix(1.8)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "elliptic_area", "response_0": "from Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of an ellipse, return its area.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return pi * a * b\n", "response_1": "from Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    # Define \u03c0 as an sfix constant\n    PI = sfix(3.141592653589793)\n    return PI * a * b\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "floor", "response_0": "from Compiler.types import sfix, regint\nfrom Compiler.library import if_else\nimport math\n\n# 1. For clear (public) inputs, we can simply use Python's math.floor.\ndef floor_clear(z):\n    \"\"\"\n    Return the maximum integer no bigger than the public input.\n    \"\"\"\n    return math.floor(z)\n\n# 2. For secret fixed\u2010point inputs, we implement floor as follows:\ndef floor_secret(z: sfix) -> regint:\n    \"\"\"\n    Return the maximum integer no bigger than the secret input z.\n    Note: This function assumes that z is of type sfix.\n    \n    The idea is to compute y = trunc(z) (i.e. conversion toward 0), then adjust:\n      \u2022 If z is nonnegative, truncation coincides with floor.\n      \u2022 If z is negative and not an integer, then floor(z) = trunc(z) \u2013 1.\n    \"\"\"\n    # Convert z to an integer by truncation (round toward 0)\n    y = z.to_regint()  \n    \n    # Compute the difference between z and its truncated version.\n    # Since z is secret, we must subtract sfix(y) to get the fractional part.\n    diff = z - sfix(y)\n    \n    # For negative z, if diff is nonzero then we need to subtract 1.\n    # (Notice that for a negative z, diff will be negative if z is not an integer,\n    #  and exactly 0 if z is an integer.)\n    adjustment = if_else(z < 0, if_else(diff < 0, 1, 0), 0)\n    \n    return y - adjustment\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_else\n\ndef floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input z.\n    Assumes z is of type sfix.\n    \"\"\"\n    # Convert z to an integer via truncation (which rounds toward 0).\n    t = z.to_sint()\n    # For negative noninteger inputs, t is greater than z.\n    # We subtract 1 in that case using a secure if_else.\n    return t - if_else(z < t, 1, 0)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "log_and_cube", "response_0": "from Compiler.library import sfix\n\ndef log_and_cube(x):\n    # Compute the base-2 logarithm of x using the sfix method.\n    l = x.log2()  \n    # Cube the logarithm result.\n    return l * l * l\n", "response_1": "from Compiler.types import sfix\n\ndef log_and_cube(x):\n    # Compute the logarithm of x (natural logarithm).\n    # Convert to log base 2: log2(x) = ln(x) / ln(2)\n    log2_x = sfix.log(x) / sfix.log(2)\n    # Compute the cube of log base 2 of x.\n    return log2_x * log2_x * log2_x\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "floor_and_square", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.helpers import if_else\n\ndef floor_and_square(z):\n    # Compute the integer part by truncation.\n    z_int = z.int()   # This gives a sint, truncating toward zero.\n    \n    # Since truncation rounds toward zero, we need to subtract 1 when z is negative\n    # and not an exact integer. Compute the difference between z and its truncated version.\n    diff = z - sfix(z_int)\n    \n    # If diff is negative then z was non-integral and negative.\n    correction = if_else(diff < 0, 1, 0)  # if diff < 0, then correction=1; else, correction=0.\n    \n    # Adjust the truncated integer to obtain the floor.\n    floor_value = z_int - correction\n    \n    # Return the square of the floor value.\n    return floor_value * floor_value\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_\n\ndef floor_and_square(z):\n    \"\"\"\n    Compute floor(z) for z of type sfix, i.e. the largest integer not larger than z.\n    Then return the square of that integer.\n    \"\"\"\n    # Get the truncated integer part of z.\n    t = sfix.to_sint(z)  # truncation toward zero\n\n    # Convert t back to sfix for an exact comparison with z.\n    t_as_sfix = sfix(t)\n    # Check if an adjustment is needed:\n    # For negative z with a nonzero fractional part, truncation is larger than floor.\n    # (i.e. for a negative z, if z != truncated value then floor(z) = t - 1)\n    cond = (z < 0) & (z != t_as_sfix)\n    # Use branchless selection: if cond is true, subtract 1; else subtract 0.\n    floor_val = t - if_(cond, 1, 0)\n    \n    # Return the square of the floor.\n    return floor_val * floor_val\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "meters_to_feet", "response_0": "from Compiler.types import sfix\n\ndef meters_to_feet(m: sfix) -> sfix:\n    return m * sfix(3.2808)\n", "response_1": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    # Convert the length in meters (as an sfix) to the length in feet.\n    return m * sfix(3.2808)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sphere_area", "response_0": "from Compiler.types import sfix\n\ndef sphere_area(r):\n    # Return the area of a sphere surface with given radius r.\n    pi = sfix(3.141592653589793)\n    return sfix(4) * pi * (r * r)\n", "response_1": "def sphere_area(r):\n    pi = sfix(3.141592653589793)\n    return 4 * pi * r * r\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "coarse_abs", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_val = if_else(x < 0, -x, x)\n    return abs_val.trunc()\n", "response_1": "def coarse_abs(x):\n    # x is assumed to be of type sfix.\n    return (x.abs()).floor()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "how_many_chickens", "response_0": "from Compiler.types import sint\n\ndef how_many_chickens(heads, legs):\n    # Compute the number of chickens in the rabbit-chicken problem.\n    # heads and legs are assumed to be of type sint.\n    return heads - ((legs - heads * 2) // 2)\n", "response_1": "from Compiler.types import sint\n\ndef how_many_chickens(heads: sint, legs: sint) -> sint:\n    # In the rabbit-chicken problem, the number of chickens is calculated as:\n    # heads - (legs - 2 * heads) // 2.\n    # Since the number 2 is a public constant, secure division (//) is safe.\n    return heads - ((legs - heads * 2) // 2)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "interest_calculator", "response_0": "from Compiler.types import sfix\n\ndef interest_calculator(capital, ratio, months):\n    # capital and ratio are expected to be of type sfix,\n    # and months is an ordinary Python integer.\n    one_plus_ratio = ratio + sfix(1)\n    power = sfix(1)\n    for i in range(months):\n        power = power * one_plus_ratio\n    return (power - sfix(1)) * capital\n", "response_1": "from Compiler.sfix import sfix\n\ndef interest_calculator(capital, ratio, months):\n    # Compute compound interest: ((1 + ratio)^months - 1) * capital\n    return ((sfix(1) + ratio) ** months - sfix(1)) * capital\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "circle_area", "response_0": "from Compiler.types import sfix\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    # Define \u03c0 as an sfix constant\n    pi = sfix(3.141592653589793)\n    return pi * r * r\n", "response_1": "from Compiler.types import sfix\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    r : input radius of type sfix\n    \"\"\"\n    # Define the constant pi as a fixed-point number\n    pi = sfix(3.141592653589793)\n    # Compute and return the area\n    return pi * (r * r)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler import sfix, mpc_math, print_ln\n\ndef cube_and_square_root(x):\n    # Compute the cube of x: x^3 = x * x * x\n    cube = x * x * x\n    # Compute the square root of the cube\n    return mpc_math.sqrt(cube)\n\nif __name__ == '__main__':\n    # Read a secret input from party 0 of type sfix\n    x = sfix.get_input_from(0)\n    res = cube_and_square_root(x)\n    print_ln('The result is: %s', res)\n", "response_1": "from Compiler.library import sqrt\n\ndef cube_and_square_root(x):\n    # Compute the cube of x\n    cube = x * x * x\n    # Compute the square root of the cube\n    result = sqrt(cube)\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "round", "response_0": "from Compiler.types import sfix, sint, sbit\nfrom Compiler.library import if_else\n\ndef round_x(x: sfix) -> sint:\n    # Convert x to an integer (this acts as floor for nonnegative x).\n    x_int = sfix.to_sint(x)\n    # Compute the fractional part: x - floor(x)\n    diff = x - sfix(x_int)\n    # Securely compare: condition is true when diff < 0.5.\n    condition: sbit = diff < sfix(0.5)\n    # If diff < 0.5, we return floor(x); otherwise, we add one.\n    # The if_else function selects 0 if condition holds, else 1.\n    return x_int + if_else(condition, sint(0), sint(1))\n", "response_1": "def round_x(x):\n    # Compute the integer part of x.\n    # Here, sfix.trunc(x) returns the truncated (i.e. floor) value.\n    x_int = sfix.trunc(x)\n    # Set the threshold 0.5 as an sfix constant.\n    half = sfix(0.5)\n    # Compute the fractional part.\n    frac = x - x_int\n    # Use if_else to conditionally select:\n    # if the fractional part < 0.5 then return x_int,\n    # else return x_int + 1.\n    return if_else(frac < half, x_int, x_int + 1)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cryptic_adjustment", "response_0": "from Compiler.library import sqrt\n\ndef cryptic_adjustment(origin):\n    # The 'origin' should be an sfix value.\n    return 10 * sqrt(10 * sqrt(origin))\n", "response_1": "from Compiler.library import sqrt\n\ndef cryptic_adjustment(origin):\n    # The professor wants to adjust the pessimistic score of his students mid-term exam.\n    # The adjustment formula is 10*sqrt(10*sqrt(origin))\n    return 10 * sqrt(10 * sqrt(origin))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "specific_pow", "response_0": "from Compiler.types import sfix\n\ndef specific_pow(x: sfix) -> sfix:\n    # Compute x^(2.5) as exp(2.5 * log(x)).\n    # Here, x.log() computes the logarithm of x and (sfix(2.5)*x.log()).exp() computes the exponent.\n    return (sfix(2.5) * x.log()).exp()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef specific_pow(x):\n    # Compute x^5 by multiplying x five times.\n    x5 = x * x * x * x * x\n    # Take the square root to obtain x^(5/2), which equals x^(2.5).\n    return sqrt(x5)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "soft_plus", "response_0": "from Compiler.types import sfix\n\ndef soft_plus(x):\n    # Compute the softplus function: log(1 + exp(x))\n    return (1 + x.exp()).log()\n", "response_1": "from Compiler.library import ln, exp\nfrom Compiler.types import sfix\n\ndef soft_plus(x: sfix) -> sfix:\n    # Compute softplus: ln(1 + exp(x))\n    return ln(1 + exp(x))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "ball_volume", "response_0": "from Compiler.types import sfix\n\ndef ball_volume(r):\n    # r is assumed to be an sfix representing the radius.\n    # Define \u03c0 as an sfix constant.\n    pi = sfix(3.141592653589793)\n    # Compute the ball volume: (4/3) * \u03c0 * r^3.\n    return (4 * pi * r * r * r) / sfix(3)\n", "response_1": "def ball_volume(r):\n    # r is assumed to be of type sfix (secure fixed-point)\n    pi = sfix(3.141592653589793)\n    return pi * r * r * r * (sfix(4) / sfix(3))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "Heron", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef Heron(a, b, c):\n    p = (a + b + c) / sfix(2)\n    return sqrt(p * (p - a) * (p - b) * (p - c))\n", "response_1": "def Heron(a, b, c):\n    # Compute the semi-perimeter p.\n    p = (a + b + c) / 2\n    # Compute the area based on Heron's formula using the sfix.sqrt function.\n    return sfix.sqrt(p * (p - a) * (p - b) * (p - c))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "next_perfect_square", "response_0": "from Compiler.types import sint, cint\nfrom Compiler.library import print_ln\n\n# Computes the floor of the square root of x using a binary search.\ndef floor_sqrt(x):\n    lo = 0\n    hi = x\n    ans = 0\n    # The loop is controlled by public integers since x is public/semi-public.\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        # mid*mid and x are public if x had been opened for control flow.\n        if mid * mid <= x:\n            ans = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return ans\n\n# Returns the smallest perfect square number greater than x.\ndef next_perfect_square(x):\n    fsqrt = floor_sqrt(x)\n    return (fsqrt + 1) * (fsqrt + 1)\n\nif __name__ == '__main__':\n    # Read a secret integer input from party 0.\n    x = sint.get_input_from(0)\n    result = next_perfect_square(x)\n    print_ln('Next perfect square: %s', result)\n", "response_1": "def next_perfect_square(x):\n    # Initialize the binary search variables.\n    low = 0\n    high = x\n    ans = 0\n    # We search for the largest integer t such that t*t <= x.\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid <= x:\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    # The smallest perfect square larger than x is (ans+1)**2.\n    return (ans + 1) * (ans + 1)\n\n# Main entry point. For example, reading an input value x.\nif __name__ == '__main__':\n    # Here we assume x is provided as a public integer. \n    # Use the MP-SPDZ input reading method to obtain x.\n    x = sint.get_input_from(0)  # If x is secret; replace sint by cint if public.\n    res = next_perfect_square(x)\n    # Output the result.\n    print_ln('Next perfect square: %s', res.reveal())\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "pi_to_the_x", "response_0": "from Compiler.types import sfix\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x computed as exp(x * log(pi)).\n    \"\"\"\n    # Define pi as an sfix constant\n    pi = sfix(3.141592653589793)\n    # Compute pi^x = exp(x * log(pi))\n    return sfix.exp(x * sfix.log(pi))\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import ln, exp\n\ndef pi_to_the_x(x):\n    PI = sfix(3.141592653589793)\n    return exp(x * ln(PI))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "spring_rocket", "response_0": "from Compiler.types import sfix\n\ndef spring_rocket(height, m, k):\n    g = sfix(9.8)\n    # The expression inside sqrt is computed with secret fixed\u2013point arithmetic.\n    return (2 * m * g * height / k).sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef spring_rocket(height, m, k):\n    g = sfix(9.8)\n    # Compute 2*m*g*height/k as an sfix value, and then call .sqrt() to get the square-root.\n    return (2 * m * g * height / k).sqrt()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cone_volume", "response_0": "from Compiler.types import sfix\n\n# Define the \u03c0 constant as a secret fixed\u2013point number\npi = sfix(3.141592653589793)\n\ndef cone_volume(r: sfix, h: sfix):\n    \"\"\"\n    Given the secret fixed-point radius (r) and height (h),\n    compute and return the cone volume.\n    \"\"\"\n    return pi * r * r * h / sfix(3)\n", "response_1": "from Compiler.types import sfix\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius (r) and height (h), compute the volume of the cone.\n    \"\"\"\n    # Approximating pi\n    pi = sfix(3.141592653589793)\n    # Compute volume: V = (pi * r^2 * h) / 3\n    return (pi * r * r * h) / 3\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "how_many_rabbits", "response_0": "from Compiler.types import sint\n\ndef how_many_rabbits(heads: sint, legs: sint) -> sint:\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    Each head accounts for 2 legs (from the chickens), and the remainder\n    of the legs belong to rabbits (2 legs each).\n    \"\"\"\n    # Compute (legs - 2*heads) and then divide by 2.\n    return (legs - heads * 2) // 2\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import print_ln\n\n# Define a function that computes the number of rabbits given heads and legs.\n# It assumes that the number of legs is exactly enough to have two legs per chicken,\n# and the extra legs belong to rabbits (each with 4 legs).\ndef how_many_rabbits(heads, legs):\n    # Compute (legs - heads*2) // 2.\n    # The subtraction and multiplication are done in the secret domain.\n    # Integer division by a public constant is allowed.\n    return (legs - heads * 2) // 2\n\nif __name__ == '__main__':\n    # For example, we obtain the inputs from party 0.\n    # The inputs are secret shared among all parties.\n    heads = sint.get_input_from(0)\n    legs  = sint.get_input_from(0)\n    \n    # Compute the number of rabbits.\n    rabbits = how_many_rabbits(heads, legs)\n    \n    # Reveal the result (all parties learn the value) and print it.\n    print_ln(\"Number of rabbits: %s\", rabbits.reveal())\n", "model_name": "azure-openai-o3-mini"}
