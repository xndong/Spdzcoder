{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler.types import sfix\n\n# Define secure fixed point values for start and end\nstart = sfix(0)\nend = sfix(99)\nnum = 10\n\n# Compute the spacing between two consecutive points.\n# Note that we use num-1 because linspace considers the line interval divided into (num-1) segments.\nstep = (end - start) / (num - 1)\n\n# Create a list 'a' with linearly spaced values.\na = [start + i * step for i in range(num)]\n", "response_1": "def main():\n    # Define the start, end, and number of points.\n    start = 0\n    end = 99\n    num = 10\n\n    # Compute the step size. (If num==1, we handle it by setting step=0.)\n    if num > 1:\n        step = (end - start) / (num - 1)\n    else:\n        step = 0\n\n    # Build the array a with linearly spaced values.\n    a = [start + i * step for i in range(num)]\n    \n    # Print the resulting array.\n    print_ln(\"a =\", a)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "more_positive", "response_0": "def more_positive(arr):\n    # Initialize the total as a secret integer.\n    total = 0\n    # Loop over each secret-shared number in arr.\n    for a in arr:\n        # Securely compute if a is positive or negative.\n        pos = a > 0       # pos will be 1 if true, 0 otherwise (secret-shared)\n        neg = a < 0       # neg will be 1 if true, 0 otherwise (secret-shared)\n        # Compute the sign of a: 1 if positive, -1 if negative, 0 if zero.\n        sign = pos - neg\n        total += sign\n    # Return whether the total (i.e. the difference between count of positives and negatives) is greater than 0.\n    return total > 0\n", "response_1": "from Compiler.types import sint\n\ndef more_positive(arr):\n    # Initialize a secure integer variable to accumulate the sign sum.\n    count = sint(0)\n    # Loop over the elements of the array.\n    for a in arr:\n        # Compute the sign of a by using secure if_else:\n        # If a > 0, then sign is 1; else, if a < 0 then sign is -1; otherwise, sign is 0.\n        sign_val = if_else(a > 0, sint(1),\n                     if_else(a < 0, sint(-1), sint(0)))\n        count += sign_val\n    # Return whether the sum of the signs is greater than 0.\n    return count > 0\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "select", "response_0": "def select(ind, a, b):\n    # This function performs an element\u2010wise selection.\n    # For each index i, if ind[i] (interpreted as 1 for True and 0 for False)\n    # Then select a[i], otherwise select b[i].\n    #\n    # Note: If ind contains secret booleans of type sbit, you may need to convert\n    # them to sfix (or an appropriate numeric type) so that arithmetic operations work.\n    # For simplicity, we assume here that the conversion has been done already if needed.\n    n = len(a)\n    res = [0] * n  # initialize result list\n    for i in range(n):\n        # Compute element-wise: a[i] if ind[i] == 1 else b[i].\n        res[i] = ind[i] * a[i] + (1 - ind[i]) * b[i]\n    return res\n", "response_1": "def select(ind, a, b):\n    # We assume that ind, a, and b are lists of the same length.\n    # Each element of ind is a secret boolean (or an object that can serve as a condition).\n    # Each element a[i] and b[i] is of type sfix representing a secret floating point number.\n    res = []\n    for i in range(len(ind)):\n        res.append(if_else(ind[i], a[i], b[i]))\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    # Compute the ReLU of y without branching by\n    # multiplying y by the secret bit (y >= 0).\n    # That is, if y is secret-shared (for example as an sfix),\n    # then (y >= 0) yields a secret (0/1) value.\n    return y * (y >= 0)\n", "response_1": "def relu(y):\n    # Compute element-wise the ReLU function for a list of sfix values.\n    result = []\n    for x in y:\n        if x > 0:\n            result.append(x)\n        else:\n            result.append(0)\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cost_matrix", "response_0": "from Compiler.types import sint\n\ndef cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    In this setting the cost matrix is computed as\n      cost = max_val - profit,\n    where max_val is the maximum element in the profit_matrix.\n    \"\"\"\n    m = len(profit_matrix)\n    # Assume at least one row exists.\n    n = len(profit_matrix[0])\n    \n    # Compute the maximum element in profit_matrix.\n    max_val = profit_matrix[0][0]\n    for i in range(m):\n        for j in range(n):\n            # Here profit_matrix[i][j] and max_val are secret shared values.\n            if profit_matrix[i][j] > max_val:\n                max_val = profit_matrix[i][j]\n    \n    # Compute cost_matrix = offset_matrix - profit_matrix,\n    # where each element is given by: cost = max_val - profit.\n    cost_mat = []\n    for i in range(m):\n        row = []\n        for j in range(n):\n            row.append(max_val - profit_matrix[i][j])\n        cost_mat.append(row)\n    \n    return cost_mat\n\ndef main():\n    # The main function is provided here as a placeholder.\n    # You may call cost_matrix() and build profit matrices as needed.\n    pass\n", "response_1": "def cost_matrix(profit_matrix):\n    # Determine the number of rows and columns.\n    rows = len(profit_matrix)\n    cols = len(profit_matrix[0])\n    \n    # Compute the maximum profit.\n    # We assume profit_matrix is non-empty.\n    offset = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            # If using secret-shared values, replace this branch with a secure selection.\n            if profit_matrix[i][j] > offset:\n                offset = profit_matrix[i][j]\n    \n    # Build the cost matrix by subtracting the profit from the offset.\n    cost_mat = [[offset - profit_matrix[i][j] for j in range(cols)] for i in range(rows)]\n    return cost_mat\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_zeros", "response_0": "n = 10\na = [0] * n\n", "response_1": "from Compiler.types import sint\n\nn = 10\na = [sint(0) for _ in range(n)]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler.types import sint, regint\n\ndef array_dimensional_indexing(matrix: list, row_index: regint) -> list:\n    # Directly index the matrix to extract the desired row.\n    row = matrix[row_index]\n    return row\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    # Assume ndarray is a list of lists representing a 2-D array.\n    # Index the row_index-th row using standard list indexing.\n    array = ndarray[row_index][:]\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    res = [0 for i in range(n)]\n    return res\n", "response_1": "def zeros(n):\n    ret = []\n    for i in range(n):\n        ret.append(0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_slicing_stride", "response_0": "# In MP-SPDZ, we can define our function as follows:\ndef array_concate(ndarrayA, ndarrayB):\n    # Obtain even-index elements from ndarrayA.\n    viewA = [ndarrayA[i] for i in range(0, len(ndarrayA), 2)]\n    \n    # For ndarrayB, we skip the first element and then take every 2nd element.\n    viewB = [ndarrayB[i] for i in range(1, len(ndarrayB), 2)]\n    \n    # Concatenate the two lists.\n    array = viewA + viewB\n    return array\n\n# Note: This function assumes that ndarrayA and ndarrayB are Python lists (or similar)\n# of MP-SPDZ secret types. Depending on whether the array elements are secret (sint) or clear (cint),\n# additional type conversions or use of vectorized operations may be necessary.\n", "response_1": "def array_concate(ndarrayA, ndarrayB):\n    # Collect even-indexed elements from ndarrayA\n    viewA = []\n    for i in range(0, len(ndarrayA), 2):\n        viewA.append(ndarrayA[i])\n    \n    # Collect odd-indexed elements from ndarrayB\n    viewB = []\n    for i in range(1, len(ndarrayB), 2):\n        viewB.append(ndarrayB[i])\n    \n    # Concatenate the two views into a new list\n    concatenated_array = viewA + viewB\n    return concatenated_array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "QR_decomposition", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\n# QR_decomposition: Compute the Q matrix from the QR decomposition of \"mat\"\n# mat is assumed to be a list of rows, where each row is a list of sfix values.\ndef QR_decomposition(mat):\n    m = len(mat)        # number of rows\n    n = len(mat[0])     # number of columns\n    \n    # Initialize Q as an m x n matrix with sfix(0) entries.\n    Q = [[sfix(0) for j in range(n)] for i in range(m)]\n    \n    # For each column j, perform Gram-Schmidt orthogonalization.\n    for j in range(n):\n        # u will hold the j-th column from mat (as a vector of length m).\n        u = [ mat[i][j] for i in range(m) ]\n        \n        # Subtract projections onto previously computed Q columns.\n        for i in range(j):\n            # Compute the dot product, projection coefficient.\n            dot_prod = sfix(0)\n            for k in range(m):\n                dot_prod = dot_prod + Q[k][i] * u[k]\n            # Subtract the projection (for each component).\n            for k in range(m):\n                u[k] = u[k] - dot_prod * Q[k][i]\n        \n        # Compute the norm of the vector u; note that we compute the sum of squares.\n        norm_sq = sfix(0)\n        for k in range(m):\n            norm_sq = norm_sq + u[k] * u[k]\n        norm = sqrt(norm_sq)\n        \n        # Normalize u and store as the j-th column of Q.\n        for k in range(m):\n            Q[k][j] = u[k] / norm\n            \n    return Q\n", "response_1": "from Compiler.types import sfix\n\ndef QR_decomposition(mat):\n    # mat is assumed to be a list of lists representing an m x n matrix.\n    # We assume that each element in the matrix is of type sfix.\n    m = len(mat)\n    n = len(mat[0])\n    # Initialize Q as an m x n matrix filled with sfix(0) values\n    Q = [[sfix(0) for _ in range(n)] for _ in range(m)]\n    \n    # For each column j of the matrix:\n    for j in range(n):\n        # Start with the j-th column of the input matrix as our vector v.\n        v = [mat[i][j] for i in range(m)]\n        \n        # Subtract projections on previously computed Q columns.\n        for k in range(j):\n            # Compute the inner product (dot product) between column j and Q column k.\n            dot = sfix(0)\n            for i in range(m):\n                dot += Q[i][k] * mat[i][j]\n            # Subtract the projection from the vector v\n            for i in range(m):\n                v[i] = v[i] - dot * Q[i][k]\n                \n        # Compute the norm of v.\n        norm_sq = sfix(0)\n        for i in range(m):\n            norm_sq += v[i] * v[i]\n        # Use the square root to get the norm.\n        norm = norm_sq.sqrt()\n        \n        # Normalize v to obtain the Q column.\n        for i in range(m):\n            Q[i][j] = v[i] / norm\n    \n    return Q\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "find_nearest_index", "response_0": "# For secret shared types, one may write:\n    cond = diff < min_diff\n    min_diff = if_else(cond, diff, min_diff)\n    min_index = if_else(cond, i, min_index)\n", "response_1": "def find_nearest_index(array, value):\n    # Assume array is a list of numbers (e.g., sfix or sint) and value is a number\n    res = 0\n    min_diff = abs(array[0] - value)\n    n = len(array)\n    for i in range(1, n):\n        current_diff = abs(array[i] - value)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            res = i\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_concat_simple_row", "response_0": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    # In MP-SPDZ we assume that the arrays are represented as lists of rows.\n    # Concatenating along axis 0 means simply appending the rows\n    concatenated = ndarrayA + ndarrayB\n    return concatenated\n", "response_1": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    # Create an empty list to hold the resulting array.\n    concatenated = []\n    \n    # Append every row in the first array.\n    for row in ndarrayA:\n        concatenated.append(row)\n    \n    # Append every row in the second array.\n    for row in ndarrayB:\n        concatenated.append(row)\n    \n    return concatenated\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    array = []\n    for i in range(len(ndarray)):\n        array.append(ndarray[i])\n    return array\n", "response_1": "def array_copy(ndarray):\n    n = len(ndarray)\n    array = [None] * n\n    for i in range(n):\n        array[i] = ndarray[i]\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_pooling", "response_0": "from Compiler.types import sfix\n\n# Define a helper function to compute the maximum between two sfix values.\ndef m_max(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n\n# Note: we assume x is a three-dimensional list of sfix values with dimensions:\n#        [batch][height][width]\ndef max_pooling(x, stride):\n    # Determine the public dimensions of the tensor\n    batch = len(x)\n    height = len(x[0])\n    width = len(x[0][0])\n    \n    # Compute the output dimensions (using integer division)\n    new_height = height // stride\n    new_width = width // stride\n    \n    # Initialize the output as a 3D list with zeros of type sfix.\n    out = [[[sfix(0) for _ in range(new_width)] for _ in range(new_height)] for _ in range(batch)]\n    \n    # For each example in the batch\n    for b in range(batch):\n        # For each patch along the height and width\n        for i in range(new_height):\n            for j in range(new_width):\n                # Initialize the maximum using the first element of the current patch.\n                current_max = x[b][i * stride][j * stride]\n                # Go over the patch to compute the maximum value.\n                for di in range(stride):\n                    for dj in range(stride):\n                        current = x[b][i * stride + di][j * stride + dj]\n                        current_max = m_max(current_max, current)\n                out[b][i][j] = current_max\n    return out\n", "response_1": "def max_pooling(x, stride):\n    # Get dimensions: assume x is a 3D list: [batch][height][width]\n    batch = len(x)\n    height = len(x[0])\n    width = len(x[0][0])\n    \n    # Compute output dimensions using integer division.\n    out_height = height // stride\n    out_width = width // stride\n\n    # Initialize output as a 3D list filled with 0's.\n    out = [[[0 for _ in range(out_width)] for _ in range(out_height)] for _ in range(batch)]\n\n    # Loop over batches.\n    for b in range(batch):\n        # Loop with step-size equal to the stride over the height.\n        for i in range(0, height, stride):\n            # Loop with step-size equal to the stride over the width.\n            for j in range(0, width, stride):\n                # Initialize the current maximum in the pooling window.\n                cur_max = x[b][i][j]\n                # Loop over the stride window in the row dimension.\n                for di in range(stride):\n                    # Loop over the stride window in the column dimension.\n                    for dj in range(stride):\n                        cur_val = x[b][i+di][j+dj]\n                        # Compare and update (if needed).\n                        if cur_val > cur_max:\n                            cur_max = cur_val\n                # Assign the computed maximum to the corresponding output position.\n                out[b][i // stride][j // stride] = cur_max\n    return out\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_reshape", "response_0": "# Create a list with values 0, 1, ..., 14\na = list(range(15))\n\n# Reshape the list into a 3x5 matrix (a list of three lists, each with five integers)\na = [a[i*5:(i+1)*5] for i in range(3)]\n", "response_1": "from Compiler.types import sint\n\n# Preallocate a 3x5 matrix\na = [[sint(0) for j in range(5)] for i in range(3)]\n# Fill the matrix with the numbers 0 ... 14 in row-major order\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = sint(5 * i + j)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_concat_simple_column", "response_0": "def array_simple_concate_column(ndarrayA, ndarrayB):\n    # Determine the dimensions\n    m = len(ndarrayA)              # number of rows\n    n = len(ndarrayA[0])           # number of columns in A\n    k = len(ndarrayB[0])           # number of columns in B\n\n    # Initialize a new 2-D list with m rows and n+k columns.\n    # MP-SPDZ does not provide automatic deep-copy semantics,\n    # so we allocate a new list and fill it in element-by-element.\n    result = [[None for _ in range(n + k)] for _ in range(m)]\n\n    # Copy elements from A into the result.\n    for i in range(m):\n        for j in range(n):\n            result[i][j] = ndarrayA[i][j]\n\n    # Copy elements from B into the result.\n    for i in range(m):\n        for j in range(k):\n            result[i][n + j] = ndarrayB[i][j]\n\n    return result\n", "response_1": "def array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ version: Given two 2-D lists (representing matrices) with the\n    same number of rows, concatenates them along columns.\n    \"\"\"\n    # Assumes both matrices have the same number of rows.\n    num_rows = len(ndarrayA)\n    concatenated_array = []\n    for i in range(num_rows):\n        # Concatenates row i from both input matrices\n        concatenated_array.append(ndarrayA[i] + ndarrayB[i])\n    return concatenated_array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "def array_dimensional_indexing(ndarray, column_index):\n    result = []\n    for row in ndarray:\n        result.append(row[column_index])\n    return result\n", "response_1": "def array_dimensional_indexing(ndarray, column_index):\n    # Assume that ndarray is a list of lists (i.e. a 2-D array)\n    result = []\n    for row in ndarray:\n        result.append(row[column_index])\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_diagonal", "response_0": "def diag(matrix):\n    n = len(matrix)\n    result = [0] * n\n    for i in range(n):\n        result[i] = matrix[i][i]\n    return result\n", "response_1": "def diag(array):\n    # Determine the number of diagonal elements,\n    # which is the minimum between the number of rows and columns.\n    n = min(len(array), len(array[0]))\n    d = []\n    for i in range(n):\n        d.append(array[i][i])\n    return d\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_concat_special", "response_0": "# Import MP-SPDZ\u2019s standard library (if needed)\n# Here we assume that the elements are of type sfix. Adjust as needed.\n# No usage examples are shown.\n\ndef array_special_concate(A, B):\n    \"\"\"\n    MP-SPDZ program to collect all the even columns from the first (2-D) array A \n    and all the odd columns from the second array B, concatenating them along axis 1.\n    A and B are assumed to be lists of lists (representing matrices) with equal number of rows.\n    \"\"\"\n    # Get number of rows; assume both matrices have the same number of rows.\n    n_rows = len(A)\n    result = []  # will hold the concatenated matrix\n    for i in range(n_rows):\n        new_row = []  # build the i-th row of the result\n        # Append even-indexed columns from A (i.e. columns 0, 2, 4, ...)\n        # Note: In Python indexing, even indices are used.\n        ncols_A = len(A[i])\n        for j in range(0, ncols_A, 2):\n            new_row.append(A[i][j])\n        # Append odd-indexed columns from B (i.e. columns 1, 3, 5, ...)\n        ncols_B = len(B[i])\n        for j in range(1, ncols_B, 2):\n            new_row.append(B[i][j])\n        # Add the new row to the result\n        result.append(new_row)\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    # number of rows is taken as the length of the outer list.\n    nrows = len(ndarrayA)\n    # Get the number of columns in each array (assumed nonempty and rectangular)\n    ncols_A = len(ndarrayA[0])\n    ncols_B = len(ndarrayB[0])\n\n    # In 0-indexing, even-numbered columns of ndarrayA are those with indices 0, 2, 4, ...\n    # In ndarrayB the odd-numbered columns (by 0-indexing) are those with indices 1, 3, 5, ...\n    # Determine how many columns will be taken from each matrix.\n    viewA_cols = (ncols_A + 1) // 2  # integer division: counts columns 0,2,4,...\n    viewB_cols = ncols_B // 2        # counts columns 1,3,5,...\n    res_cols = viewA_cols + viewB_cols\n\n    # Allocate the output array as a 2-D Python list.\n    result = [[0 for _ in range(res_cols)] for _ in range(nrows)]\n\n    # For each row, pick the even-indexed column from A and odd-indexed column from B.\n    for i in range(nrows):\n        pos = 0\n        # Take even columns from first array.\n        for j in range(0, ncols_A, 2):\n            result[i][pos] = ndarrayA[i][j]\n            pos += 1\n        # Take odd columns from second array.\n        for j in range(1, ncols_B, 2):\n            result[i][pos] = ndarrayB[i][j]\n            pos += 1\n\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_arange", "response_0": "def arange(start, stop=None, step=1):\n    # if stop is not provided, treat start as stop and start = 0\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Create an empty list for the result.\n    result = []\n    \n    # For positive step, append until start < stop.\n    if step > 0:\n        while start < stop:\n            result.append(start)\n            start += step\n    # For negative step, append until start > stop.\n    elif step < 0:\n        while start > stop:\n            result.append(start)\n            start += step\n    # When step == 0, one could raise an exception as in NumPy\n    else:\n        raise ValueError(\"step must not be zero\")\n    \n    return result\n", "response_1": "def arange(start, stop=None, step=1):\n    # When only one argument is provided, it is treated as the stop value.\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Make sure step is nonzero.\n    if step == 0:\n        raise ValueError(\"step must not be zero\")\n\n    # Create an empty list to accumulate the elements.\n    result = []\n    \n    # For a positive step, accumulate until i < stop.\n    if step > 0:\n        i = start\n        while i < stop:\n            result.append(i)\n            i = i + step\n    # For a negative step, accumulate until i > stop.\n    else:\n        i = start\n        while i > stop:\n            result.append(i)\n            i = i + step\n\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_eye_2", "response_0": "m = 3\nn = 5\n\n# Initialize a 2-D array (list of lists) with all zeros.\na = [[0 for j in range(n)] for i in range(m)]\n\n# Set the diagonal elements to 1 (only if the index falls within the number of columns)\nfor i in range(m):\n    if i < n:\n        a[i][i] = 1\n\n# Optionally, print out the resulting matrix.\nfor row in a:\n    print_ln(\"%s\", row)\n", "response_1": "m = 3\nn = 5\na = []  # will be a list of m rows, each with n entries\nfor i in range(m):\n    row = []\n    for j in range(n):\n        if i == j:\n            row.append(1)\n        else:\n            row.append(0)\n    a.append(row)\n\nprint_ln(\"a: {}\", a)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "third_smallest", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef third_smallest(arr):\n    # Get the length of the array\n    n = len(arr)\n    \n    # Perform a secure bubble sort (all comparisons and swaps are done in a branchless manner)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            # Compute a secret boolean: 1 if arr[j] > arr[j+1], else 0.\n            cond = arr[j] > arr[j+1]\n            # Use if_else to securely choose the smaller and larger value, respectively.\n            small_val = if_else(cond, arr[j+1], arr[j])\n            large_val = if_else(cond, arr[j], arr[j+1])\n            arr[j] = small_val\n            arr[j+1] = large_val\n\n    # Return the third smallest element (index 2 after sorting)\n    return arr[2]\n", "response_1": "from Compiler.types import sint\n\ndef third_smallest(arr):\n    \"\"\"\n    Returns the third smallest element from the secret shared array.\n    Uses a bubble sort implemented in a data-oblivious manner.\n    \"\"\"\n    n = len(arr)\n    # Bubble sort: iterate over every pair and swap if arr[j] > arr[j+1]\n    for i in range(n):\n        for j in range(n - 1):\n            # Compute a secret bit: 1 if arr[j] > arr[j+1] else 0\n            swap_bit = arr[j].greater(arr[j+1])\n            # Conditionally swap without branching, using arithmetic operations.\n            x = swap_bit * arr[j+1] + (1 - swap_bit) * arr[j]\n            y = swap_bit * arr[j] + (1 - swap_bit) * arr[j+1]\n            arr[j] = x\n            arr[j+1] = y\n    return arr[2]\n\n\nif __name__ == '__main__':\n    # For example, we assume a fixed length input array of size 5.\n    n = 5\n    arr = []\n    # Read secret shared inputs from party 0\n    for i in range(n):\n        arr.append(sint.get_input_from(0))\n    third = third_smallest(arr)\n    # Reveal the result to all parties and print it.\n    print_ln(\"The third smallest element: %s\", third.reveal())\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    # In MP-SPDZ we assume that the 2-D array is represented as a list\n    # where each element (i.e. each row) is also a list.\n    return ndarray[row_index]\n", "response_1": "# This function indexes the i-th row from a 2-D array represented as a list-of-lists.\n# We assume that the array 'ndarray' is a 2-D list of secret-shared elements (e.g., sint or sfix)\n# and that 'row_index' is public.\ndef array_dimensional_indexing(ndarray, row_index):\n    # In MP-SPDZ, a 2-D array can be represented as a list of lists.\n    # As the row_index is public, we can safely index the list.\n    return ndarray[row_index]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_from_intrinsic_arange", "response_0": "# Define the array length\nn = 10\n\n# Create a list of integers from 0 to n-1\na = [i for i in range(n)]\n", "response_1": "n = 10\na = [i for i in range(n)]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    # Assume ndarray is a 2-D list (list of lists)\n    # and that row_index is a public integer.\n    num_columns = len(ndarray[0])\n    result = [None] * num_columns\n    for j in range(num_columns):\n        result[j] = ndarray[row_index][j]\n    return result\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    ncols = len(ndarray[0])\n    row = [ndarray[row_index][j] for j in range(ncols)]\n    return row\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler.types import sint\n\n# Create a built-in Python list of integers\na_l = [0, 10, 20, 30, 40]\n\n# In MP-SPDZ, you can directly use the list as an array.\n# If secure operations are needed, convert each entry to a secure integer.\na = [sint(x) for x in a_l]\n", "response_1": "from Compiler.types import sint\n\n# Create a Python list with 5 elements\na_l = [0, 10, 20, 30, 40]\n\n# Convert the Python list into a list of secret integers\na = [sint(x) for x in a_l]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_reshape", "response_0": "def array_reshape(array, m, n):\n    \"\"\"\n    Reshape a flat array into a 2D array of shape (m, n).\n\n    In MP-SPDZ we do not have a built-in multidimensional array type.\n    Here we assume that 'array' is a flat list of secure types, and we\n    return a list of lists where each inner list represents a row.\n    \"\"\"\n    # Ensure that the total number of elements equals m*n.\n    assert len(array) == m * n, \"The number of elements does not match m*n\"\n    \n    new_array = []\n    for i in range(m):\n        row = []\n        for j in range(n):\n            row.append(array[i * n + j])\n        new_array.append(row)\n    return new_array\n", "response_1": "def array_reshape(arr, m, n):\n    # Check if the input list length matches the required dimensions.\n    if len(arr) != m * n:\n        print_ln(\"Error: Incorrect array length. Expected\", m*n, \"but got\", len(arr))\n        # Exit if the dimensions do not match.\n        exit()\n    \n    res = []  # This will be a list of rows.\n    for i in range(m):\n        row = []  # Create a new row.\n        for j in range(n):\n            # Compute the flat index in the input array.\n            row.append(arr[i * n + j])\n        res.append(row)\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_ones", "response_0": "from Compiler.types import sint\n\nn = 10\na = [sint(1) for _ in range(n)]\n", "response_1": "n = 10\na = [1] * n\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "set_one_to_zero", "response_0": "from Compiler.library import if_\nfrom Compiler.types import sint\n\ndef set_one_to_zero(y):\n    # Assuming y is a list of secret integers (sint)\n    for i in range(len(y)):\n        # Securely set y[i] to 0 if it is 1, otherwise keep y[i] unchanged.\n        y[i] = if_(y[i] == 1, 0, y[i])\n    return y\n", "response_1": "def set_one_to_zero(y):\n    # Set the ones in the array to zeros.\n    for i in range(len(y)):\n        if y[i] == 1:\n            y[i] = 0\n    return y\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_eye", "response_0": "n = 10\n\n# Initialize a 2D array (list of lists) with zeros\na = [[0 for j in range(n)] for i in range(n)]\n\n# Fill the diagonal with ones\nfor i in range(n):\n    a[i][i] = 1\n", "response_1": "# Import the secret integer type if needed\nfrom Compiler.types import sint\n\nn = 10\n\n# Create a matrix \"a\" where the (i, j)-th element is sint(1) if i==j, otherwise sint(0)\na = [[sint(1) if i == j else sint(0) for j in range(n)] for i in range(n)]\n\n# (The matrix 'a' is now available for further computation.)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_diag", "response_0": "a_l = [1, 3, 5, 2, 4, 6]\nn = len(a_l)\n# Create an n by n matrix filled with zeros.\na = [[0 for j in range(n)] for i in range(n)]\n# Set diagonal entries to the corresponding list elements.\nfor i in range(n):\n    a[i][i] = a_l[i]\n", "response_1": "from Compiler.types import sint\n\ndef main():\n    # Define the secret-shared list\n    a_l = [sint(1), sint(3), sint(5), sint(2), sint(4), sint(6)]\n    n = len(a_l)\n    \n    # Create an n x n matrix initialized to 0 (using sint(0))\n    a = [[sint(0) for j in range(n)] for i in range(n)]\n    \n    # Set the diagonal entries to the corresponding values in a_l\n    for i in range(n):\n        a[i][i] = a_l[i]\n        \n    # (Further code can proceed to use the matrix 'a')\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_advanced_integer_indexing", "response_0": "def integer_array_indexing(array, indices):\n    # Create an empty result array.\n    ret_array = []\n    # Loop over each index in the provided indices list.\n    for idx in indices:\n        # Append the element in 'array' at the position idx to the result.\n        ret_array.append(array[idx])\n    return ret_array\n", "response_1": "def integer_array_indexing(array, indices):\n    ret_array = []\n    for idx in indices:\n        ret_array.append(array[idx])\n    return ret_array\n", "model_name": "azure-openai-o3-mini"}
