{"test_name": "move_to_end", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    arr_len = arr.length\n    new_arr = sint.Array(arr_len)\n    \n    # Take the part before the index\n    part_before = arr.get_vector(0, index)\n    new_arr.assign_vector(part_before, 0)\n    \n    # Take the part after the index\n    part_after = arr.get_vector(index + 1, arr_len - (index + 1))\n    new_arr.assign_vector(part_after, index)\n    \n    # Place the removed element at the end\n    new_arr[arr_len - 1] = arr[index]\n    \n    return new_arr\n", "model_name": "azure-openai-o1"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array (secret-shared).\n    \"\"\"\n    # Loop from the third element to the end\n    for i in range(2, len(arr)):\n        # (arr[i] > arr[0]) or (arr[i] > arr[1])\n        cond = (arr[i] > arr[0]).bit_or(arr[i] > arr[1])\n        # Determine which of arr[0] or arr[1] is smaller\n        is_first_smaller = (arr[0] < arr[1])\n        # Then figure out which element to replace by arr[i]\n        replace_first = cond.bit_and(is_first_smaller)\n        replace_second = cond.bit_and(is_first_smaller.bit_not())\n\n        # Conditionally replace\n        new_first = replace_first.if_else(arr[i], arr[0])\n        new_second = replace_second.if_else(arr[i], arr[1])\n\n        arr[0] = new_first\n        arr[1] = new_second\n\n    # Finally, return the smaller of the two for the second largest\n    return (arr[0] < arr[1]).if_else(arr[0], arr[1])\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef second_largest(arr):\n    # Assume arr is an Array of sint with a known compile-time length\n    n = arr.length\n    # Iterate from index 2 to n-1\n    for i in for_range(2, n):\n        cond1 = arr[i] > arr[0]\n        cond2 = arr[i] > arr[1]\n        # Logical OR in MP-SPDZ uses .bit_or()\n        cond = cond1.bit_or(cond2)\n        # Determine which of arr[0] or arr[1] is smaller\n        idxCond = arr[0] < arr[1]\n        # Convert that comparison to index 0 or 1\n        idx = idxCond.if_else(0, 1)\n        # Update the chosen index if cond is true\n        arr[idx].update(cond.if_else(arr[i], arr[idx]))\n    # Return the smaller of the two, which is the second largest overall\n    return (arr[0] < arr[1]).if_else(arr[0], arr[1])\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_true", "response_0": "from Compiler.types import sint\n\ndef exists_true(arr):\n    # arr is assumed to be an Array or list of secret bits (sint), each 0 or 1.\n    # We compute the 'OR' across all entries to check if there's any \"True\".\n    length = len(arr)\n    ret = arr[0]\n    for i in range(1, length):\n        ret = ret.bit_or(arr[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    Assume arr is an array of secret bits (sint) in {0, 1}.\n    \"\"\"\n    n = len(arr)\n    ret = sint(0)\n    for i in range(n):\n        ret = ret.bit_or(arr[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_indicator", "response_0": "from Compiler.types import sint\n\ndef array_indicator(arr, predicator):\n    length = len(arr)\n    # Create a new array to store results. \n    # Adjust type if predicator returns another type (e.g., sfix) instead of sint.\n    ret = sint.Array(length)\n    for i in range(length):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_indicator(arr, predicator):\n    # Create a new array with the same shape as 'arr'\n    ret = arr.same_shape()\n    # Iterate over each element of 'arr' and apply the 'predicator' function\n    for i in range(arr.length):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef inner_product(vec1, vec2):\n    n = len(vec1)\n    product_arr = sfix.Array(n)\n    for i in for_range(n):\n        product_arr[i] = vec1[i] * vec2[i]\n    summation = sfix(0)\n    for i in for_range(n):\n        summation += product_arr[i]\n    return summation\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef inner_product(vec1, vec2, length):\n    \"\"\"\n    Compute the inner product of the two sfix Arrays.\n    \"\"\"\n    result = sfix(0)\n    for i in range(length):\n        result = result + (vec1[i] * vec2[i])\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift_2", "response_0": "from Compiler.types import sint\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    # Create an output array of the same shape and type\n    shifted_array = a.same_shape()\n    for i in range(n):\n        shifted_array[i] = a[(i - 1) % n]\n    return shifted_array\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)  # compile-time integer indicating the array length\n    shifted_array = a.same_shape()\n    for i in for_range(n):\n        idx = (i + n - 1) % n\n        shifted_array[i] = a[idx]\n    return shifted_array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.types import sint, sintbit\n\ndef array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = sintbit.Array(n)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "from Compiler.types import sintbit\n\ndef array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = sintbit.Array(n)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises_2", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef count_rises(arr):\n    # arr is assumed to be an Array or list-like of secret integers (sint).\n    length = arr.get_length()\n    sum_flag = sint(0)\n    for i in range(length - 1):\n        # Comparison returns a bit in arithmetic circuits (sintbit).\n        is_rise_bit = arr[i] < arr[i + 1]\n        # Convert the bit to a standard sint (0 or 1).\n        is_rise_sint = is_rise_bit.if_else(sint(1), sint(0))\n        sum_flag += is_rise_sint\n    return sum_flag\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    new_arr = sint.Array(arr.length)\n    for i in range(arr.length):\n        if i % 2 == 1:\n            new_arr[i] = arr[i] + 1\n        else:\n            new_arr[i] = arr[i] - 1\n    return new_arr\n", "response_1": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    # Assume arr is a sint.Array or similar container of known compile-time length\n    length = len(arr)\n    for i in range(length):\n        # i is public, so (i % 2) == 1 is also public\n        if (i % 2) == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sint\n\ndef how_many_roots(a: sint, b: sint, c: sint):\n    # Check whether a == 0\n    is_a_zero = a == 0\n    # Check whether b == 0\n    is_b_zero = b == 0\n    # Case: a == 0\n    roots_if_a_zero = is_b_zero.if_else(sint(0), sint(1))\n    # Discriminant\n    disc = b * b - 4 * a * c\n    # Check whether disc > 0\n    is_positive = disc > 0\n    # Check whether disc == 0\n    is_zero = disc == 0\n    # Case: a != 0\n    roots_if_a_nonzero = is_positive.if_else(sint(2), is_zero.if_else(sint(1), sint(0)))\n    # Combine the two cases\n    return is_a_zero.if_else(roots_if_a_zero, roots_if_a_nonzero)\n", "response_1": "from Compiler.types import sint\n\ndef how_many_roots(a, b, c):\n    is_a_zero = (a == 0)\n    is_b_zero = (b == 0)\n    discriminant = b * b - sint(4) * a * c\n    is_disc_pos = (discriminant > 0)\n    is_disc_zero = (discriminant == 0)\n    n_roots_if_a_zero = is_b_zero.if_else(sint(0), sint(1))\n    n_roots_if_a_not_zero = is_disc_pos.if_else(sint(2), is_disc_zero.if_else(sint(1), sint(0)))\n    return is_a_zero.if_else(n_roots_if_a_zero, n_roots_if_a_not_zero)\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef count_satisfied(arr, predicator):\n    # 'arr' is assumed to be an MP-SPDZ Array of a type compatible\n    # with the 'predicator' function such that 'predicator(arr[i])'\n    # returns 0 or 1 in 'sint'.\n    length = arr.length  # compile-time integer\n    summation = sint(0)\n    for i in for_range(length):\n        summation = summation + predicator(arr[i])\n    return summation\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfying the predicator.\n    \"\"\"\n    sum_val = sint(0)\n    for i in range(arr.length):\n        # predicator(e) should return 0 or 1\n        flag = predicator(arr[i])\n        sum_val += flag\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sint\nimport Compiler.library as lib\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    products = arr1[:] * arr2[:]\n    result = lib.tree_reduce(lambda x, y: x + y, products)\n    return result\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    products = arr1[:] * arr2[:]   # element-wise multiplication\n    return tree_reduce(lambda x, y: x + y, products)\n", "model_name": "azure-openai-o1"}
{"test_name": "array_round", "response_0": "from Compiler.types import sfix, sint, cfix\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(n)\n\n    zero = sfix(0)\n    half = sfix(0.5)\n\n    for i in range(n):\n        sign = arr[i] < zero\n        # Add or subtract 0.5 depending on sign\n        candidate_pos = arr[i] + half\n        candidate_neg = arr[i] - half\n\n        # Convert to an integer (floor/truncate)\n        int_pos = sint(candidate_pos)\n        int_neg = sint(candidate_neg)\n\n        # If sign is 1 => negative => use int_neg, else use int_pos\n        ret[i] = sign.if_else(int_neg, int_pos)\n\n    return ret\n", "response_1": "from Compiler.types import sfix, sint, cfix\n\ndef array_round(arr):\n    # arr is assumed to be an Array of sfix\n    n = arr.length  # compile-time length of the array\n    ret = sint.Array(n)\n    for i in range(n):\n        x = arr[i]\n        # Decide offset based on sign of x\n        offset = (x >= 0).if_else(cfix(0.5), cfix(-0.5))\n        tmp = x + offset\n        # Convert to sint by shifting out the fractional part\n        ret[i] = tmp.v >> sfix.f\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_eq", "response_0": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    length = len(arr)\n    ret = sint.Array(length)\n    for i in range(length):\n        ret[i] = (arr[i] >= brr[i]).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    n = len(arr)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        ret[i] = (arr[i] >= brr[i]).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # (arr[i] < 0) produces a secret bit, which we map to 1 or 0 via if_else\n        ret[i] = (arr[i] < 0).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    size = len(arr)\n    ret = sint.Array(size)\n    for i in range(size):\n        # arr[i] < 0 will yield a secret bit,\n        # we utilize if_else() to convert it to a secret integer 0/1\n        ret[i] = (arr[i] < 0).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract_2", "response_0": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    len_a = len(a)\n    len_b = len(b)\n    ret_len = len_a if (len_a > len_b) else len_b\n    ret = sint.Array(ret_len)\n    ret.assign_all(0)\n\n    # Compute the elementwise difference up to the smaller length.\n    min_len = len_a if (len_a < len_b) else len_b\n    for i in range(min_len):\n        ret[i] = a[i] - b[i]\n\n    # If one array is longer, fill in the leftover.\n    if len_a < len_b:\n        for i in range(len_a, ret_len):\n            ret[i] = -b[i]\n    elif len_a > len_b:\n        for i in range(len_b, ret_len):\n            ret[i] = a[i]\n\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n\n    # Determine length of padding\n    pad_length = len_a - len_b if len_a >= len_b else len_b - len_a\n\n    # Determine length for overlapping subtraction\n    ret_len = len_a if len_a >= len_b else len_b\n    min_len = len_a if len_a <= len_b else len_b\n\n    # Create an array for the overlapping result\n    ret = sint.Array(ret_len)\n    ret.assign_all(0)\n    for i in range(min_len):\n        ret[i] = a[i] - b[i]\n\n    # Create an array for the pad\n    pad = sint.Array(pad_length)\n    pad.assign_all(0)\n    if len_a < len_b:\n        # If 'a' is shorter, pad is the negative leftover from 'b'\n        for i in range(pad_length):\n            pad[i] = -b[min_len + i]\n    elif len_a > len_b:\n        # If 'b' is shorter, pad is the leftover from 'a'\n        for i in range(pad_length):\n            pad[i] = a[min_len + i]\n\n    # Combine the overlapping result with the pad\n    final_len = ret_len + pad_length\n    result = sint.Array(final_len)\n    result.assign_all(0)\n\n    for i in range(ret_len):\n        result[i] = ret[i]\n    for i in range(pad_length):\n        result[ret_len + i] = pad[i]\n\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process", "response_0": "from Compiler.types import Array\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input Array with a given function.\n    \"\"\"\n    result_arr = arr.same_shape()\n    for i in range(len(arr)):\n        result_arr[i] = func(arr[i])\n    return result_arr\n", "response_1": "from Compiler.types import sint\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    result = arr.same_shape()\n    n = len(arr)\n    for i in range(n):\n        result[i] = func(arr[i])\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift", "response_0": "from Compiler.types import Array\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = a.length\n    original_vector = a.get_vector()\n    last_element = original_vector[n-1 : n]\n    initial_part = original_vector[: n-1]\n    shifted_vector = last_element + initial_part\n    result_array = a.create_from(shifted_vector)\n    return result_array\n", "response_1": "from Compiler.types import sint\n\ndef array_shift(a):\n    n = len(a)\n    shifted = a.same_shape()\n    shifted[0] = a[n - 1]\n    for i in range(1, n):\n        shifted[i] = a[i - 1]\n    return shifted\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_select", "response_0": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    n = len(a)\n    ret_array = sint.Array(n)\n    for i in range(n):\n        ret_array[i] = a[i].max(b[i])\n    return ret_array\n", "response_1": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    length = len(a)\n    ret = a.same_shape()\n    for i in range(length):\n        ret[i] = a[i].max(b[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract", "response_0": "from Compiler.types import sfix\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine compile-time sizes.\n    size_a = len(a)\n    size_b = len(b)\n    # Maximum length for result array.\n    n = size_a if size_a > size_b else size_b\n\n    # Create a new array for the result.\n    ret = sfix.Array(n)\n\n    # Elementwise subtraction, padding with 0 if out of range.\n    for i in range(n):\n        x = sfix(0)\n        y = sfix(0)\n        if i < size_a:\n            x = a[i]\n        if i < size_b:\n            y = b[i]\n        ret[i] = x - y\n\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.0 (secret fixed-point).\n    Both 'a' and 'b' should be sfix.Array with known compile-time length.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    diff = len_b - len_a\n\n    # Pad with zero if needed\n    if diff > 0:\n        pad = sfix.Array(diff)\n        pad.assign_all(0)\n        a = a.concat(pad)\n    elif diff < 0:\n        pad = sfix.Array(-diff)\n        pad.assign_all(0)\n        b = b.concat(pad)\n\n    # Now both a and b have the same length\n    ret_len = len(a)\n    ret = sfix.Array(ret_len)\n    for i in range(ret_len):\n        ret[i] = a[i] - b[i]\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "repeat_array", "response_0": "from Compiler.types import Array, sint, cfix, sfix\n\ndef repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c.concat(c)\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "zeros", "response_0": "from Compiler.types import sfix\n\ndef zeros(num):\n    \"\"\"\n    Return an all-zero array with length num.\n    \"\"\"\n    array = sfix.Array(num)\n    array.assign_all(0)\n    return array\n", "response_1": "from Compiler.types import cfix\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    arr = cfix.Array(num)\n    arr.assign_all(0)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    \"\"\"\n    Clip the elements of 'arr' to the range [lower_bound, upper_bound].\n    \"\"\"\n    size = len(arr)\n    for i in for_range(size):\n        cond_upper = arr[i] >= upper_bound\n        cond_lower = arr[i] > lower_bound\n        arr[i] = cond_upper.if_else(upper_bound, cond_lower.if_else(arr[i], lower_bound))\n    return arr\n", "response_1": "from Compiler.types import sfix\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    \"\"\"\n    For the given Array 'arr', clip its elements to the range [lower_bound, upper_bound].\n    \"\"\"\n    length = len(arr)\n    for i in range(length):\n        ge_upper = (arr[i] >= upper_bound)  # Comparison returns a bit\n        gt_lower = (arr[i] > lower_bound)   # Comparison returns a bit\n        mid_val = gt_lower.if_else(arr[i], lower_bound)\n        clipped_val = ge_upper.if_else(upper_bound, mid_val)\n        arr[i].update(clipped_val)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied_2", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef count_satisfied(arr, predicator):\n    length = arr.length\n    result = sint(0)\n    for i in for_range(length):\n        result += predicator(arr[i])\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    n = len(arr)\n    flags = sint.Array(n)\n    for i in range(n):\n        flags[i] = predicator(arr[i])\n    s = sint(0)\n    for i in range(n):\n        s += flags[i]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    # arr is assumed to be a sint.Array or similar\n    n = arr.length\n    count = sint(0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # (arr[i] > arr[j]) yields a binary secret value of type sintbit,\n            # multiplying by 1 (a sint) converts it to sint for accumulation\n            count = count + ((arr[i] > arr[j]) * 1)\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            count += (arr[i] > arr[j])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_inc", "response_0": "from Compiler.types import sint\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    # Detect value type from first element for flexibility\n    value_type = type(arr[0])\n    # Create a new array of the same type and size\n    arr_out = value_type.Array(n)\n    # Increment each element\n    for i in range(n):\n        arr_out[i] = arr[i] + 1\n    return arr_out\n", "response_1": "from Compiler.types import sint\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    # Convert the array to a vector, add 1 element-wise, and create a new array.\n    incremented_vector = arr.get_vector() + 1\n    new_arr = arr.create_from(incremented_vector)\n    return new_arr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr, length):\n    brr = arr.get_part(1, length - 1)\n    count = sint(0)\n    for i in range(length - 1):\n        cond = arr[i] < brr[i]\n        count += cond * 1\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = arr.length\n    count = sint(0)\n    for i in range(n - 1):\n        # (arr[i] < arr[i+1]) returns a secret bit (sintbit)\n        # We convert it to 0/1 by if_else(1, 0) before adding.\n        count += (arr[i] < arr[i+1]).if_else(sint(1), sint(0))\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_2", "response_0": "from Compiler.types import sint, Array\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    length = len(arr)\n    for i in range(length):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "from Compiler.types import Array\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    length = arr.length\n    new_arr = arr.same_shape()  # Create an Array with the same shape/type as arr\n    for i in range(length):\n        new_arr[i] = func(arr[i])  # Apply the function to each element\n    return new_arr\n", "model_name": "azure-openai-o1"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef two_norm(vec):\n    length = len(vec)\n    squares = sfix.Array(length)\n    squares.assign_vector(vec[:])\n    # element-wise squaring\n    for i in range(length):\n        squares[i] = squares[i] * squares[i]\n    # summation\n    total = squares[0]\n    for i in range(1, length):\n        total = total + squares[i]\n    # square root\n    return mpc_math.sqrt(total)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef two_norm(vec):\n    squares = [item * item for item in vec]\n    return mpc_math.sqrt(sum(squares))\n", "model_name": "azure-openai-o1"}
{"test_name": "totally_dominate", "response_0": "from Compiler.types import sint\nfrom Compiler.library import tree_reduce\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Compute the minimum element of array a\n    a_min = tree_reduce(lambda x, y: x.min(y), a.get_vector())\n    # Compute the maximum element of array b\n    b_max = tree_reduce(lambda x, y: x.max(y), b.get_vector())\n    # Compare and return the result as secret bit (1 or 0)\n    return a_min >= b_max\n", "response_1": "from Compiler.types import sint\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Find the minimum element in array a\n    amin = a[0]\n    for i in range(1, len(a)):\n        amin = amin.min(a[i])\n\n    # Find the maximum element in array b\n    bmax = b[0]\n    for i in range(1, len(b)):\n        bmax = bmax.max(b[i])\n\n    # Return a secret bit (sintbit) indicating if amin >= bmax\n    return amin >= bmax\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product_2", "response_0": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    summation = sint(0)\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "response_1": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of two MP-SPDZ arrays (e.g., sint.Array).\n    \"\"\"\n    length = len(vec1)\n    summation = sint(0)\n    for i in range(length):\n        summation += vec1[i] * vec2[i]\n    return summation\n", "model_name": "azure-openai-o1"}
{"test_name": "get_subarr_by_indices", "response_0": "from Compiler.types import sint\n\ndef get_subarr_by_indices(a, indices):\n    # Create an Array suitable for holding the result.\n    # Here we assume 'a' holds secret integers (sint).\n    ret_size = len(indices)\n    ret = sint.Array(ret_size)\n\n    # Assign each specified element from 'a' into 'ret'.\n    for j in range(ret_size):\n        ret[j] = a[indices[j]]\n    return ret\n", "response_1": "from Compiler.types import sint, cint, sfix, cfix\n\ndef get_subarr_by_indices(a, indices):\n    length = len(indices)\n    ret = a[0].type.Array(length)\n    for i in range(length):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint, sintbit\nfrom Compiler.library import tree_reduce\n\ndef exists_5_or_7(arr):\n    comparison_5 = [(arr[i] == 5) for i in range(len(arr))]\n    comparison_7 = [(arr[i] == 7) for i in range(len(arr))]\n    flags = [comparison_5[i].bit_or(comparison_7[i]) for i in range(len(arr))]\n    return tree_reduce(lambda x, y: x.bit_or(y), flags)\n", "response_1": "from Compiler.types import sint, Array\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    length = len(arr)\n    eq5 = Array(length, sint)\n    eq7 = Array(length, sint)\n    for i in range(length):\n        eq5[i] = (arr[i] == 5)\n        eq7[i] = (arr[i] == 7)\n    flag = Array(length, sint)\n    for i in range(length):\n        flag[i] = eq5[i].bit_or(eq7[i])\n    total = sint(0)\n    for i in range(length):\n        total = total + flag[i]\n    return (total > 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "remove_by_index", "response_0": "from Compiler.types import sint, Array\n\ndef remove_by_index(arr, index, arr_length):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    left_part = arr.get_part(0, index)\n    right_part = arr.get_part(index + 1, arr_length - (index + 1))\n    ret = left_part.concat(right_part)\n    return ret\n", "response_1": "from Compiler.types import Array, sint, cint\n\ndef remove_by_index(arr, index):\n    length = len(arr)  # compile-time known length\n    part1 = arr.get_part(0, index)\n    part2 = arr.get_part(index + 1, length - (index + 1))\n    result = part1.concat(part2)\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "average", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    length = len(arr)  # compile-time integer\n    summation = sfix(0)\n    for i in range(length):\n        summation += arr[i]\n    ret = summation / length\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summation = sfix(0)\n    for i in range(arr.length):\n        summation += arr[i]\n    length = arr.length\n    ret = summation / length\n    return ret\n", "model_name": "azure-openai-o1"}
