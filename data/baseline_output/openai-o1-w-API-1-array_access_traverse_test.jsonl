{"test_name": "indicate_positive", "response_0": "from Compiler.types import sint\n\ndef indicate_positive(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is positive,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    length = len(arr)\n    ret = sint.Array(length)\n    for i in range(length):\n        ret[i] = (arr[i] > 0).if_else(sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_positive(arr):\n    size = arr.length  # compile-time length of the array\n    ret = sint.Array(size)\n    for i in range(size):\n        ret[i] = (arr[i] > 0).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_xor", "response_0": "from Compiler.types import sint, cint\n\ndef array_xor(a, b):\n    \"\"\"\n    Compute the elementwise XOR of the two input arrays in MP-SPDZ.\n    \"\"\"\n    n = len(a)\n    ret = a.same_shape()\n    for i in range(n):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "response_1": "from Compiler.types import cint\n\ndef array_xor(a, b):\n    n = len(a)\n    ret = cint.Array(n)\n    for i in range(n):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "interlaced_placement", "response_0": "from Compiler.types import sint, Array\n\ndef interlaced_placement(a, b):\n    \"\"\"\n    Interleave the elements in two sequences.\n    The two input arrays are guaranteed to have the same length. \n    \"\"\"\n    length = len(a)  # compile-time integer\n    ret = sint.Array(2 * length)\n    ret.assign_all(0)\n    for i in range(2 * length):\n        if i % 2 == 1:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "response_1": "from Compiler.types import Array, sint\nfrom Compiler.library import for_range\n\ndef interlaced_placement(a, b):\n    n = a.length\n    ret = Array(2 * n, a.value_type)\n    for i in for_range(2 * n):\n        if (i % 2) == 1:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_and", "response_0": "from Compiler.types import sint\n\ndef array_and(a, b):\n    # Compute the elementwise AND of two input vectors (containing bits).\n    ret = sint.Array(len(a))\n    ret.assign_all(sint(0))\n    for i in range(len(a)):\n        ret[i] = a[i].bit_and(b[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_and(a, b):\n    n = len(a)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = a[i].bit_and(b[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_indicator", "response_0": "from Compiler.types import sint\n\ndef array_indicator(arr, predicator):\n    size = len(arr)\n    ret = sint.Array(size)\n    ret.assign_all(0)\n    for i in range(size):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_indicator(arr, predicator):\n    n = len(arr)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.types import sintbit\n\ndef array_greater_than_scalar(arr, bound):\n    length = len(arr)\n    ret = sintbit.Array(length)\n    for i in range(length):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = (arr[i] > bound).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_no_greater_than_scalar", "response_0": "from Compiler.types import sint\n\ndef array_no_greater_than_scalar(arr, bound):\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        # (arr[i] <= bound) yields a secret bit. We convert it to a secret integer 0/1 with if_else().\n        ret[i] = (arr[i] <= bound).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint, sintbit\n\ndef array_no_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is no greater than the bound.\n    \"\"\"\n    length = len(arr)\n    ret = sintbit.Array(length)\n    for i in range(length):\n        ret[i] = arr[i] <= bound\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_and_concat", "response_0": "from Compiler.types import sint\n\ndef reverse_and_concat(a):\n    # Create an empty array b with the same shape as a\n    b = a.same_shape()\n    # Assign the reversed vector of a to b\n    b.assign_vector(a.get_reverse_vector())\n    # Concatenate and return\n    return a.concat(b)\n", "response_1": "from Compiler.types import *\n\ndef reverse_and_concat(a):\n    reversed_vec = a.get_reverse_vector()\n    b = type(a).create_from(reversed_vec)\n    return a.concat(b)\n", "model_name": "azure-openai-o1"}
{"test_name": "array_round", "response_0": "from Compiler.types import sfix, sint\n\ndef array_round(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # Standard round for non-negative values: add 0.5 and truncate\n        ret[i] = (arr[i] + sfix(0.5)).to_sint()\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array of sfix to the nearest integer (sint).\n    \"\"\"\n    length = arr.length\n    ret = sint.Array(length)\n    for i in for_range(length):\n        # Obtain the integer part by converting (truncating) the sfix value to sint\n        int_part = sint(arr[i])\n        \n        # Compute the fractional part\n        fraction = arr[i] - sfix(int_part)\n        \n        # Compare the fractional part with 0.5\n        cond = fraction < 0.5\n        \n        # If fractional part < 0.5, keep int_part, else add 1\n        ret[i] = cond.if_else(int_part, int_part + 1)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_eq", "response_0": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # (arr[i] >= brr[i]) is a sintbit, we use if_else to convert it into a sint of 0 or 1\n        ret[i] = (arr[i] >= brr[i]).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = (arr[i] >= brr[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse", "response_0": "", "response_1": "from Compiler.types import sint, cfix, sfix\n\ndef reverse(arr):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    n = arr.length\n    ret = arr.same_shape()\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    ret = sint.Array(len(arr))\n    ret.assign_all(0)\n    for i in range(len(arr)):\n        cond = (arr[i] < 0)         # Comparison yields a sintbit\n        ret[i] = cond.if_else(1, 0) # Convert the sintbit to a sint by choosing 1 if negative, else 0\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        ret[i] = (arr[i] < 0)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "max_sub_sequence", "response_0": "from Compiler.types import sint\n\ndef max_sub_sequence(arr):\n    n = len(arr)\n    partial_max = sint.Array(n)\n    suffix_max = sint.Array(n)\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    for i in range(1, n):\n        cond_suffix = (suffix_max[i-1] >= 0)\n        suffix_max[i] = cond_suffix.if_else(suffix_max[i-1] + arr[i], arr[i])\n\n        cond_partial = (partial_max[i-1] >= suffix_max[i])\n        partial_max[i] = cond_partial.if_else(partial_max[i-1], suffix_max[i])\n    return partial_max[n - 1]\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef max_sub_sequence(arr):\n    length = len(arr)\n    partial_max = sint.Array(length)\n    suffix_max = sint.Array(length)\n    partial_max.assign_all(0)\n    suffix_max.assign_all(0)\n\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n\n    for i in for_range(1, length):\n        cond = suffix_max[i - 1] >= 0\n        suffix_max[i] = cond.if_else(suffix_max[i - 1] + arr[i], arr[i])\n\n        cond2 = partial_max[i - 1] >= suffix_max[i]\n        partial_max[i] = cond2.if_else(partial_max[i - 1], suffix_max[i])\n\n    return partial_max[length - 1]\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_select", "response_0": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    # Assume 'a' and 'b' are Arrays of sint with the same length\n    ret_array = sint.Array(a.length)\n    for i in range(a.length):\n        ret_array[i] = a[i].max(b[i])\n    return ret_array\n", "response_1": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    Assume a and b are Arrays of the same type and length.\n    \"\"\"\n    ret_array = a.same_shape()\n    for i in range(len(a)):\n        # a[i].max(b[i]) returns the larger value between a[i] and b[i].\n        ret_array[i] = a[i].max(b[i])\n    return ret_array\n", "model_name": "azure-openai-o1"}
{"test_name": "count_element_frequency", "response_0": "from Compiler.types import sint\n\ndef count_element_frequency(l):\n    n = len(l)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n\n    for i in range(n):\n        for j in range(n):\n            ret[i].update(ret[i] + (l[i] == l[j]))\n\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef count_element_frequency(l):\n    n = len(l)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        for j in range(n):\n            equality_result = (l[i] == l[j])\n            ret[i] = ret[i] + equality_result\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_or", "response_0": "from Compiler.types import sint\n\ndef array_or(a, b):\n    \"\"\"\n    Compute the elementwise OR of the two input arrays a and b (both are assumed\n    to be arrays of sint in MP-SPDZ).\n    \"\"\"\n    length = len(a)\n    ret = sint.Array(length)\n    ret.assign_all(0)\n    for i in range(length):\n        ret[i] = a[i].bit_or(b[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_or(a, b):\n    \"\"\"\n    Compute the elementwise OR of the two input vectors.\n    \"\"\"\n    length = len(a)\n    ret = sint.Array(length)\n    for i in range(length):\n        ret[i] = a[i].bit_or(b[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "stock_predicator", "response_0": "from Compiler.types import sint, Array\n\ndef stock_predicator(days, n):\n    \"\"\"\n    Given an Array 'days' of length n (each entry of type sint).\n    Use dynamic programming to find two days, such that buying on the earlier day \n    and selling on the later day is the most profitable.\n    If all choices cause negative profits, the result remains 0.\n    \"\"\"\n    lowest = sint.Array(n)\n    partial_max = sint.Array(n)\n\n    lowest[0] = days[0]\n    partial_max[0] = sint(0)\n\n    for i in range(1, n):\n        lowest[i] = lowest[i-1].min(days[i])\n        partial_max[i] = partial_max[i-1].max(days[i] - lowest[i-1])\n\n    return partial_max[n-1]\n", "response_1": "from Compiler.types import sint, Array, for_range\n\ndef stock_predicator(days):\n    length = days.length  # compile-time known length\n    lowest = sint.Array(length)\n    partial_max = sint.Array(length)\n    # Initialize arrays\n    lowest.assign_all(sint(0))\n    partial_max.assign_all(sint(0))\n    # Base cases\n    lowest[0] = days[0]\n    # Fill arrays using dynamic programming\n    for i in for_range(1, length):\n        cond1 = (lowest[i - 1] <= days[i])\n        lowest[i] = cond1.if_else(lowest[i - 1], days[i])\n\n        diff = days[i] - lowest[i - 1]\n        cond2 = (partial_max[i - 1] >= diff)\n        partial_max[i] = cond2.if_else(partial_max[i - 1], diff)\n\n    # Return the final result\n    return partial_max[length - 1]\n", "model_name": "azure-openai-o1"}
{"test_name": "len5_inc_array", "response_0": "from Compiler.types import sint\n\ndef len5_inc_array(init):\n    ret = sint.Array(5)\n    for i in range(5):\n        ret[i] = init + i\n    return ret\n", "response_1": "from Compiler.types import sint, Array\n\ndef len5_inc_array(init):\n    \"\"\"\n    Return an increase-by-one array with given initial element and length 5.\n    \"\"\"\n    ret = sint.Array(5)\n    for i in range(5):\n        ret[i] = init + i\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "cut_first_five", "response_0": "from Compiler.types import sint\n\ndef cut_first_five(arr):\n    \"\"\"\n    Return the array composed of the first 5 elements of the input array. \n    If the input array does not have 5 elements, pad with 0.\n    \"\"\"\n    # Create an Array of length 5 using the same basic type as arr\n    ret = arr.value_type.Array(5)\n    # Initialize all elements in ret to 0\n    ret.assign_all(0)\n\n    # Copy elements from arr up to 5\n    # If arr has fewer than 5 elements, the remainder stays 0\n    arr_len = len(arr)\n    end = 5 if arr_len > 5 else arr_len\n    for i in range(end):\n        ret[i] = arr[i]\n\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef cut_first_five(arr):\n    arr_len = len(arr)  # compile-time length if 'arr' is an MP-SPDZ Array\n    ret = sint.Array(5)\n    ret.assign_all(0)\n    for i in range(min(5, arr_len)):\n        ret[i] = arr[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "max_pooling_1d", "response_0": "from Compiler.types import sint\nfrom Compiler.program import for_range\n\ndef max_pooling_1d(vec, step):\n    ret_length = len(vec) // step\n    ret = sint.Array(ret_length)\n    for i in for_range(ret_length):\n        cur_max = vec[i * step]\n        for j in for_range(step):\n            cond = vec[i * step + j] > cur_max\n            cur_max = cond.if_else(vec[i * step + j], cur_max)\n        ret[i] = cur_max\n    return ret\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef max_pooling_1d(vec, step):\n    # Assume vec is an sfix.Array with a known compile-time length LEN_VEC.\n    LEN_VEC = <COMPILE_TIME_LENGTH_OF_VEC>  # Replace with the actual compile-time length\n    ret_length = LEN_VEC // step\n    ret = sfix.Array(ret_length)\n    ret.assign_all(0)\n\n    for i in for_range(ret_length):\n        local_max = vec[i * step]\n        for j in for_range(step):\n            local_max = local_max.max(vec[i * step + j])\n        ret[i] = local_max\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater", "response_0": "from Compiler.types import sint\n\ndef array_greater(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i]>brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # (arr[i] > brr[i]) returns an sintbit, multiplying by 1 converts it to sint (0 or 1).\n        ret[i] = (arr[i] > brr[i]) * 1\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i]>brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # The comparison arr[i] > brr[i] yields a secret bit (0 or 1).\n        # We use if_else(1, 0) to convert that bit to a secret integer.\n        ret[i] = (arr[i] > brr[i]).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "dumb_concat", "response_0": "from Compiler.types import sint, Array, for_range\n\ndef dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    length = len(arr) + len(brr)\n    ret = sint.Array(length)\n    ret.assign_all(0)\n    for i in for_range(len(arr)):\n        ret[i] = arr[i]\n    for j in for_range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef dumb_concat(arr, brr):\n    length = len(arr) + len(brr)\n    ret = sint.Array(length)\n    ret.assign_all(0)\n    for i in range(len(arr)):\n        ret[i] = arr[i]\n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "indicator_if_else", "response_0": "from Compiler.types import sint\n\ndef indicator_if_else(a, b, ind):\n    length = len(a)\n    c = sint.Array(length)\n    for i in range(length):\n        c[i] = ind[i].if_else(a[i], b[i])\n    return c\n", "response_1": "from Compiler.types import sint\n\ndef indicator_if_else(a, b, ind):\n    \"\"\"\n    Return an array c with the same length of a and b.\n    The element of c is set to be the corresponding element of a if the indicator is 1,\n    and is set to be the corresponding element of b if the indicator is 0.\n    \"\"\"\n    length = len(ind)\n    c = a.same_shape()\n    for i in range(length):\n        # \"if_else\" returns 'a[i]' if 'ind[i]' is 1, and 'b[i]' if 'ind[i]' is 0\n        c[i] = ind[i].if_else(a[i], b[i])\n    return c\n", "model_name": "azure-openai-o1"}
{"test_name": "elementwise_multiplication", "response_0": "from Compiler.types import sint, Array\n\ndef elementwise_multiplication(a, b):\n    \"\"\"\n    Compute the elementwise multiplication of the two input arrays (of sint).\n    \"\"\"\n    n = len(a)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef elementwise_multiplication(a, b):\n    \"\"\"\n    Compute the elementwise multiplication of the two input vectors.\n    \"\"\"\n    length = a.length\n    ret = sint.Array(length)\n    ret.assign_all(0)\n    for i in range(length):\n        ret[i] = a[i] * b[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "get_subarr_by_indices", "response_0": "from Compiler.types import sint, cint\n\ndef get_subarr_by_indices(a, indices):\n    length = len(indices)\n    ret = sint.Array(length)\n    ret.assign_all(0)\n    for i in range(length):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "from Compiler.types import sint, cint, Array\n\ndef get_subarr_by_indices(a, indices):\n    n = len(indices)  # compile-time length of indices\n    ret = a.value_type.Array(n)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "inc_array", "response_0": "from Compiler.types import cint\n\ndef inc_array(num):\n    arr = cint.Array(num)\n    for i in range(num):\n        arr[i] = i + 1\n    return arr\n", "response_1": "from Compiler.types import cint\n\ndef inc_array(num):\n    arr = cint.Array(num)\n    tmp_list = [cint(i + 1) for i in range(num)]\n    arr.assign_vector(tmp_list)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "cut_last_five", "response_0": "from Compiler.types import sint\n\ndef cut_last_five(arr):\n    \"\"\"\n    Return the array composed of the last 5 elements of the input array.\n    If the input array does not have 5 elements, pad with 0 (at the beginning).\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(5)\n    ret.assign_all(0)\n    limit = min(5, n)\n    for i in range(limit):\n        ret[4 - i] = arr[n - 1 - i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef cut_last_five(arr):\n    ret = sint.Array(5)\n    ret.assign_all(0)\n    arr_len = len(arr)  # compile-time length of arr\n    limit = 5 if arr_len >= 5 else arr_len\n    for i in range(limit):\n        ret[4 - i] = arr[arr_len - 1 - i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "average_pooling_1d", "response_0": "from Compiler.types import sfix, cfix\n\ndef average_pooling_1d(vec, step):\n    ret_length = vec.length // step\n    ret = sfix.Array(ret_length)\n    ret.assign_all(sfix(0))\n    for i in range(ret_length):\n        avg = sfix(0)\n        for j in range(step):\n            avg = avg + vec[i*step + j] / cfix(step)\n        ret[i] = avg\n    return ret\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef average_pooling_1d(vec, step):\n    ret_length = len(vec) // step\n    ret = sfix.Array(ret_length)\n    ret.assign_all(sfix(0))\n    for i in range(ret_length):\n        avg = sfix(0)\n        for j in range(step):\n            avg = avg + vec[i * step + j] / cfix(step)\n        ret[i] = avg\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_relu", "response_0": "from Compiler.types import sfix, cfix\n\ndef array_relu(arr):\n    length = arr.length\n    ret = sfix.Array(length)\n    for i in range(length):\n        ret[i] = arr[i].max(cfix(0))\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef array_relu(arr):\n    length = arr.length\n    ret = sfix.Array(length)\n    for i in range(length):\n        cond = arr[i] >= 0\n        ret[i] = cond.if_else(arr[i], sfix(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "move_to_end", "response_0": "from Compiler.types import sint, Array\nfrom Compiler.program import for_range\n\ndef move_to_end(arr, index):\n    tmpLen = arr.length\n    temp = arr[index]\n    for i in for_range(index + 1, tmpLen):\n        arr[i - 1].update(arr[i])\n    arr[tmpLen - 1].update(temp)\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is assumed to be public and within range.\n    \"\"\"\n    n = arr.length\n    temp = arr[index]\n    for i in range(index + 1, n):\n        arr[i - 1] = arr[i]\n    arr[n - 1] = temp\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "set_to_zero", "response_0": "from Compiler.types import sint\n\ndef set_to_zero(arr, index):\n    \"\"\"\n    Set the element in the input array with given index to zero.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = 0\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef set_to_zero(arr, index):\n    # Here we assume \"index\" is public (cint or an integer) because array indexing in MP-SPDZ\n    # requires a public integer. Also assume \"arr\" is an Array of sint or another numeric type\n    # that can be assigned zero.\n    arr[index] = 0\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "last_partial_sum", "response_0": "from Compiler.types import sint\n\ndef last_partial_sum(arr, n):\n    arr_len = len(arr)\n    ret = sint(0)\n    for i in range(arr_len - n, arr_len):\n        ret = ret + arr[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef last_partial_sum(arr, n):\n    \"\"\"\n    Return the sum of the last n elements in the input secure array 'arr'.\n    n is guaranteed to be legal.\n    \"\"\"\n    size = len(arr)\n    ret = sint(0)\n    for i in range(size - n, size):\n        ret = ret + arr[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "permute_by_indices", "response_0": "from Compiler.types import Array, sint, cint\n\ndef permute_by_indices(a, indices):\n    n = len(a)\n    ret = a.same_shape()\n    for i in range(n):\n        # Here we assume indices[i] is a public index\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "get_rank", "response_0": "from Compiler.types import sint\n\ndef get_rank(arr, index):\n    \"\"\"\n    Get the rank in the array of the element (how many elements are smaller than the element) with given index.\n    \"\"\"\n    rank = sint(0)\n    ref_val = arr[index]  # The reference value we compare to\n    # Iterate over each element in the array\n    for i in range(len(arr)):\n        # Compare item with the reference value, yielding 1 (sint) if item < ref_val else 0\n        rank = rank + (arr[i] < ref_val)\n    return rank\n", "response_1": "from Compiler.types import sint\n\ndef get_rank(arr, index):\n    # arr is assumed to be an Array of sint\n    # index is assumed to be a public or compile-time integer\n    n = arr.length\n    rank = sint(0)\n    for i in range(n):\n        condition = (arr[i] < arr[index])  # Comparison yields an sint bit\n        rank = rank + condition\n    return rank\n", "model_name": "azure-openai-o1"}
{"test_name": "interchange_by_indices", "response_0": "from Compiler.types import sint\n\ndef interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange the two elements in the array with given indices.\n    The input indices are guaranteed to be legal.\n    \"\"\"\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef interchange_by_indices(arr, index1, index2):\n    \"\"\"\n    Interchange the two elements in the array with given indices. \n    The input indices are guaranteed to be legal. \n    \"\"\"\n    temp = arr[index1]\n    arr[index1].update(arr[index2])\n    arr[index2].update(temp)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "increase_by", "response_0": "from Compiler.types import sint, cint\n\ndef increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] + k\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef increase_by(arr, index, k):\n    \"\"\"\n    Increase the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] + k\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "retrieve_by_index", "response_0": "from Compiler.types import sint\n\ndef retrieve_by_index(arr, index):\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is assumed to be public and within valid range.\n    \"\"\"\n    return arr[index]\n", "response_1": "from Compiler.types import sint, Array\n\ndef retrieve_by_index(arr, index):\n    return arr[index]\n", "model_name": "azure-openai-o1"}
{"test_name": "scale_by", "response_0": "from Compiler.types import sint, regint\n\ndef scale_by(arr, index, k):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n", "response_1": "from Compiler.types import sint, cint\n\ndef scale_by(arr, index, k):\n    \"\"\"\n    Multiply the element arr[index] in the array arr by k.\n    arr: sint.Array(...)  \n    index: cint (public)  \n    k: sint\n    \"\"\"\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "take_opposite_to", "response_0": "from Compiler.types import sint\n\ndef take_opposite_to(arr, index):\n    \"\"\"\n    Take opposite to the element in the array with given index.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = -arr[index]\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef take_opposite_to(arr, index):\n    arr[index] = -arr[index]\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_rank", "response_0": "", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_rank(l):\n    n = len(l)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in for_range(n):\n        tmp = sint(0)\n        for j in for_range(n):\n            cmp_result = (l[j] < l[i])\n            tmp = tmp + cmp_result\n        ret[i] = tmp\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "remove_by_index", "response_0": "from Compiler.types import sint\n\ndef remove_by_index(arr, index):\n    size = arr.length\n    ret_size = size - 1\n    ret = sint.Array(ret_size)\n    ret.assign_all(0)\n    for i in range(ret_size):\n        if i < index:\n            ret[i] = arr[i]\n        else:\n            ret[i] = arr[i + 1]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef remove_by_index(arr, index):\n    # arr is assumed to be an Array of a compatible type (e.g., sint).\n    # index is assumed to be a public compile-time integer.\n    n = arr.length\n    # create a new array of length n-1 with the same element type\n    ret = arr.value_type.Array(n - 1)\n    # initialize all elements\n    ret.assign_all(arr.value_type(0))\n    # fill the new array by skipping the element at 'index'\n    for i in range(n - 1):\n        if i < index:\n            ret[i] = arr[i]\n        else:\n            ret[i] = arr[i + 1]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "process_by_index", "response_0": "from Compiler.types import Array\n\ndef process_by_index(arr, index, func):\n    # arr is an Array with a compatible value type\n    # index is assumed public (cint/regint) for direct array access\n    arr[index] = func(arr[index])\n    return arr\n", "response_1": "from Compiler.types import Array, sint\nimport mpc_math\n\ndef process_by_index(arr, index, func):\n    arr[index] = func(arr[index])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_by_indices", "response_0": "from Compiler.types import sint, cint\nfrom Compiler.library import for_range\n\ndef sum_by_indices(arr, indices):\n    s = sint(0)\n    for i in for_range(indices.length):\n        s = s + arr[indices[i]]\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_by_indices(arr, indices):\n    s = sint(0)\n    for i in indices:\n        s = s + arr[i]\n    return s\n", "model_name": "azure-openai-o1"}
