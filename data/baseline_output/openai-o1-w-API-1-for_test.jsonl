{"test_name": "multiply_first_five", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef multiply_first_five(array):\n    # Assume 'array' is a sint.Array with known compile-time length\n    n = array.length  # compile-time integer\n    loop_len = 5 if n > 5 else n\n\n    prod = sint(1)\n    for i in range(loop_len):\n        prod *= array[i]\n    return prod\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sint(1)\n    array_length = len(array)\n\n    limit = 5 if array_length >= 5 else array_length\n    for i in range(limit):\n        prod *= array[i]\n\n    return prod\n", "model_name": "azure-openai-o1"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array (arr is an Array of sint).\n    \"\"\"\n    length = len(arr)\n    init_bit = arr[0] >= arr[1]\n    largest = init_bit.if_else(arr[0], arr[1])\n    second = init_bit.if_else(arr[1], arr[0])\n\n    for i in range(2, length):\n        bit_largest = arr[i] >= largest\n        temp_largest = largest\n        largest = bit_largest.if_else(arr[i], largest)\n        second = bit_largest.if_else(temp_largest, second)\n\n        bit_second = bit_largest.bit_not() & (arr[i] >= second)\n        second = bit_second.if_else(arr[i], second)\n\n    return second\n", "response_1": "from Compiler.types import sint\ndef second_largest(arr, n):\n    # Compare the first two elements\n    cond_init = (arr[0] >= arr[1])\n    largest = cond_init.if_else(arr[0], arr[1])\n    second = cond_init.if_else(arr[1], arr[0])\n\n    # Iterate over the remaining elements\n    for i in range(2, n):\n        cond_larger = (arr[i] >= largest)\n        new_largest = cond_larger.if_else(arr[i], largest)\n        new_second_if_larger = cond_larger.if_else(largest, second)\n\n        cond_second = (arr[i] >= second)\n        new_second = cond_larger.if_else(new_second_if_larger, cond_second.if_else(arr[i], second))\n\n        largest = new_largest\n        second = new_second\n\n    return second\n", "model_name": "azure-openai-o1"}
{"test_name": "partial_sum", "response_0": "from Compiler.types import sint\n\ndef partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array.\n    \"\"\"\n    partial = sint(0)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef partial_sum(arr):\n    partial = sint(0)\n    n = len(arr)\n    for i in range(n):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "max_adjacent_product", "response_0": "from Compiler.types import sint\n\ndef max_adjacent_product(arr):\n    # Initialize the current maximum to the product of the first two adjacent elements\n    cur = arr[0] * arr[1]\n    \n    # Loop through the array, updating the current maximum if a larger product is found\n    for i in range(len(arr) - 1):\n        product = arr[i] * arr[i + 1]\n        is_bigger = (product > cur)    # returns a sintbit\n        cur = is_bigger.if_else(product, cur)\n    \n    # Return the maximum product of adjacent elements\n    return cur\n", "response_1": "from Compiler.types import sint\ndef max_adjacent_product(arr):\n    # arr is a sint.Array with length >= 2\n    length = len(arr)\n    cur = arr[0] * arr[1]\n    for i in range(length - 1):\n        product = arr[i] * arr[i + 1]\n        condition = product > cur\n        cur = condition.if_else(product, cur)\n    return cur\n", "model_name": "azure-openai-o1"}
{"test_name": "argmax", "response_0": "from Compiler.types import sint\n\ndef argmax(a):\n    length = len(a)\n    current = a[0]\n    index = sint(0)\n    for i in range(1, length):\n        cond = (current >= a[i])\n        index = cond.if_else(index, sint(i))\n        current = cond.if_else(current, a[i])\n    return index\n", "response_1": "from Compiler.types import sint\n\ndef argmax(a):\n    current = a[0]\n    index = sint(0)\n    length = len(a)\n    for i in range(length):\n        cond = (current >= a[i])\n        index = cond.if_else(index, sint(i))\n        current = cond.if_else(current, a[i])\n    return index\n", "model_name": "azure-openai-o1"}
{"test_name": "count_distinct", "response_0": "from Compiler.types import sint\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            eq = (arr[j] == arr[i])\n            # eq is 1 if arr[j] == arr[i], else 0\n            unique = unique * (1 - eq)\n        # Add 1 if unique is still 1, else add 0\n        counter = counter + unique\n    return counter\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the secret array arr.\n    \"\"\"\n    n = len(arr)\n    counter = sint(0)\n    for i in for_range(n):\n        unique = sint(1)\n        for j in for_range(i):\n            eq_bit = (arr[j] == arr[i])            # Comparison returns a 'sintbit'\n            eq_sint = eq_bit.to_sint()            # Convert to 'sint'\n            unique = unique * (1 - eq_sint)       # If arr[j] == arr[i], unique becomes 0\n        counter = counter + unique\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_true", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef exists_true(arr):\n    ret = sint(0)\n    n = arr.length  # compile-time known length\n    for i in range(n):\n        ret = ret.bit_or(arr[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "range", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    @for_range(len(arr))\n    def _(i):\n        item = arr[i]\n        max_value.update(max_value.max(item))\n        min_value.update(min_value.min(item))\n    return max_value - min_value\n", "response_1": "from Compiler.types import sint\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = max_value.max(item)\n        min_value = min_value.min(item)\n    return max_value - min_value\n", "model_name": "azure-openai-o1"}
{"test_name": "count_larger_than_5", "response_0": "from Compiler.types import sint\n\ndef count_larger_than_5(arr):\n    counter = sint(0)\n    for i in range(len(arr)):\n        is_greater = arr[i] > 5\n        counter = counter + is_greater.if_else(sint(1), sint(0))\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef count_larger_than_5(arr, length):\n    counter = sint(0)\n    for i in range(length):\n        comp = arr[i] > 5\n        counter = counter + comp.if_else(sint(1), sint(0))\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_dominator", "response_0": "from Compiler.types import sint\n\ndef exists_dominator(arr):\n    max_val = sint(0)\n    sum_val = sint(0)\n    arr_length = len(arr)\n    for i in range(arr_length):\n        item_abs = arr[i].abs()\n        bigger = item_abs > max_val\n        max_val = bigger.if_else(item_abs, max_val)\n        sum_val += item_abs\n    return (2 * max_val) > sum_val\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "greedy_picker", "response_0": "from Compiler.types import sint\n\ndef greedy_picker(items, captivity):\n    num = sint(0)\n    # items is assumed to be an array/list of sints\n    # captivity is a single sint\n    for i in range(len(items)):\n        cond = items[i] <= captivity\n        captivity = cond.if_else(captivity - items[i], captivity)\n        num = num + cond\n    return num\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef greedy_picker(items, captivity):\n    num = sint(0)\n    length = len(items)\n    for i in range(length):\n        item = items[i]\n        cond = item <= captivity\n        captivity = cond.if_else(captivity - item, captivity)\n        num = num + cond\n    return num\n", "model_name": "azure-openai-o1"}
{"test_name": "scalar_add_array", "response_0": "from Compiler.types import sint\n\ndef scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    for i in range(l.length):\n        s = s + l[i]\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result. \n    \"\"\"\n    length = len(l)  # compile-time integer size of l\n    for i in range(length):\n        s = s + l[i]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "is_equidistant_seq", "response_0": "", "response_1": "from Compiler.types import cint\n\ndef is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence.\n    If the array has length 1 or 0, return True (represented as cint(1)).\n    \"\"\"\n    arr_len = arr.length\n    d = cint(0)\n    for i in range(arr_len - 1):\n        current_diff = arr[i + 1] - arr[i]\n        if i > 0:\n            if current_diff != d:\n                return cint(0)\n        d = current_diff\n    return cint(1)\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product", "response_0": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays using MP-SPDZ.\n    \"\"\"\n    result = sint(0)\n    n = len(vec1)\n    for i in range(n):\n        result += vec1[i] * vec2[i]\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of two arrays of sints.\n    \"\"\"\n    sum_val = sint(0)\n    for i in range(len(vec1)):\n        sum_val = sum_val + vec1[i] * vec2[i]\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "more_distinct_nonnegative", "response_0": "from Compiler.types import sint\n\ndef more_distinct_nonnegative(arr):\n    # Initialize counters as secret integers.\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n\n    # Obtain the array length (compile-time known).\n    length = arr.length\n\n    # Outer loop.\n    for i in range(length):\n        current_val = arr[i]\n\n        # Track uniqueness with a secret bit; start assumed unique.\n        unique = sint(1)\n        for j in range(i):\n            # Check for equality and update uniqueness.\n            eq_bit = (current_val == arr[j])\n            unique = unique * (1 - eq_bit)\n\n        # Check sign (>= 0), then update corresponding counter only if unique.\n        ge_bit = (current_val >= 0)\n        increment_nonneg = unique * ge_bit\n        increment_neg = unique * (1 - ge_bit)\n\n        nonnegative_counter = nonnegative_counter + increment_nonneg\n        negative_counter = negative_counter + increment_neg\n\n    # Compare counters for final result; returns a secret bit.\n    return nonnegative_counter > negative_counter\n", "response_1": "from Compiler.types import sint\n\ndef more_distinct_nonnegative(arr):\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    length = len(arr)\n    for i in range(length):\n        unique = sint(1)\n        for j in range(i):\n            eq_bit = (arr[j] == arr[i])\n            unique = unique * (sint(1) - eq_bit)\n        ge0_bit = (arr[i] >= 0)\n        nonnegative_counter = nonnegative_counter + (unique * ge0_bit)\n        negative_counter = negative_counter + (unique * (sint(1) - ge0_bit))\n    return (nonnegative_counter > negative_counter)\n", "model_name": "azure-openai-o1"}
{"test_name": "flip_positives", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef flip_positives(array):\n    length = len(array)\n    for i in for_range(length):\n        is_positive = (array[i] > 0)\n        flipped_value = -array[i]\n        array[i].update(is_positive.if_else(flipped_value, array[i]))\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    length = len(array)\n    for i in range(length):\n        is_positive = array[i] > 0\n        array[i] = is_positive.if_else(-array[i], array[i])\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "divide_and_plus", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for _ in for_range(4):\n        x = x / sfix(2)\n        x = x + sfix(1)\n    return x\n", "response_1": "from Compiler.types import sfix\n\ndef divide_and_plus(x: sfix) -> sfix:\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for _ in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n", "model_name": "azure-openai-o1"}
{"test_name": "array_log2", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = mpc_math.log_fx(arr[i], 2)\n    return arr\n", "response_1": "from Compiler.library import for_range\nimport mpc_math\n\ndef array_log2(arr):\n    length = len(arr)\n    for i in for_range(length):\n        arr[i] = mpc_math.log_fx(arr[i], 2)\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_to_ten", "response_0": "from Compiler.types import sint\n\ndef sum_to_ten(array):\n    n = len(array)\n    partial_sum = sint(0)\n    carry_on = sint(1)\n    for i in range(n):\n        to_add = carry_on.if_else(array[i], sint(0))\n        partial_sum = partial_sum + to_add\n        carry_on = carry_on.bit_and(partial_sum < 10)\n    return partial_sum\n", "response_1": "from Compiler.types import sint, cint\nfrom Compiler.library import for_range\n\ndef sum_to_ten(array):\n    total = sint(0)\n    keep_going = sint(1)\n    n = len(array)\n    for i in for_range(n):\n        total = total + array[i] * keep_going\n        cond = (total < cint(10))\n        keep_going = keep_going.bit_and(cond)\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    for i in range(len(arr)):\n        # i is a compile-time public integer, so we can do a normal Python check\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    arr_len = arr.length\n    for i in range(arr_len):\n        # Here 'i' is public (compile-time) since we're using Python's range.\n        # We use a simple Python if statement on the public value.\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "min_element", "response_0": "from Compiler.types import sint\n\ndef min_element(a):\n    \"\"\"\n    Return the max value of an array. (Per original code comment, but function is computing the minimum.)\n    \"\"\"\n    # Assume 'a' is a 'sint.Array' and its length is a known compile-time integer 'size'.\n    # Replace 'size' with the actual length of 'a'.\n    size = 10  # for illustration only; this must be the compile-time length of 'a'\n\n    current = a[0]\n    for i in range(1, size):\n        cond = current <= a[i]\n        current = cond.if_else(current, a[i])\n    return current\n", "response_1": "from Compiler.types import sint\n\ndef min_element(a):\n    \"\"\"\n    Return the max value of an array. \n    (Note: This actually returns the minimum value based on the code logic.)\n    \"\"\"\n    n = a.length\n    current = a[0]\n    for i in range(1, n):\n        current = current.min(a[i])\n    return current\n", "model_name": "azure-openai-o1"}
{"test_name": "soft_max", "response_0": "from Compiler.library import mpc_math\nfrom Compiler.types import sfix\n\ndef soft_max(arr):\n    e = sfix(2.718281828459045)\n    denominator = sfix(0)\n    for item in arr:\n        denominator = denominator + mpc_math.pow_fx(e, item)\n    brr = arr.same_shape()\n    for i in range(len(arr)):\n        brr[i] = mpc_math.pow_fx(e, arr[i]) / denominator\n    return brr\n", "response_1": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input sfix array.\n    \"\"\"\n    size = len(arr)  # Assumes a compile-time length\n    denominator = sfix(0)\n    base = sfix(2.718281828459045)  # Approximation of math.e\n\n    # Calculate denominator by summing exponentials\n    for i in range(size):\n        denominator += mpc_math.pow_fx(base, arr[i])\n\n    # Reuse arr as brr for in-place result\n    brr = arr\n    # Compute each entry of soft-max\n    for i in range(size):\n        brr[i] = mpc_math.pow_fx(base, arr[i]) / denominator\n\n    return brr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_reverse_pair_with_break", "response_0": "from Compiler.types import sint\n\ndef count_reverse_pair_with_break(arr):\n    # Assume arr is a sint.Array with a compile-time known length\n    n = arr.length\n    count = sint(0)\n    break_condition = sint(0)\n    one = sint(1)\n    for i in range(1, n):\n        # Skip further processing if we have already encountered an element > 10\n        skip_i = one - break_condition\n        arr_i_gt_10 = (arr[i] > 10)\n        # Only count reverse pairs for this i if skip_i is 1\n        for j in range(i):\n            count += skip_i * (arr[j] > arr[i])\n        # Update break_condition to 1 if arr[i] > 10 has been encountered\n        break_condition = break_condition.bit_or(arr_i_gt_10)\n    return count\n", "response_1": "from Compiler.types import cint\n\ndef count_reverse_pair_with_break(arr):\n    count = cint(0)\n    length = len(arr)\n    for i in range(1, length):\n        if arr[i] > 10:\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count = count + 1\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_unique", "response_0": "from Compiler.types import sint\n\ndef sum_unique(arr):\n    n = len(arr)\n    sum_val = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(n):\n            if j != i:\n                eq_sbit = (arr[j] == arr[i])\n                # Convert sbit (result of comparison) into sint for arithmetic:\n                eq_sint = eq_sbit.if_else(sint(1), sint(0))\n                unique = unique * (sint(1) - eq_sint)\n        sum_val = sum_val + arr[i] * unique\n    return sum_val\n", "response_1": "from Compiler.types import sint, cint\n\ndef sum_unique(arr, n):\n    \"\"\"\n    Return the sum of unique elements in the secret integer array arr.\n    n is the compile-time length of arr.\n    \"\"\"\n    sum_val = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(n):\n            # Compare arr[j] and arr[i] in the secure domain\n            eq = (arr[j] == arr[i])  # returns a secret bit\n            # j != i is public\n            j_ne_i = cint(1 if j != i else 0)\n            # If both conditions hold, set unique to 0\n            cond = eq * j_ne_i\n            unique = unique * (1 - cond)\n        sum_val += arr[i] * unique\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "check_sum", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value.\n    \"\"\"\n    sum_val = sint(0)\n    for num in array:\n        sum_val = sum_val + num\n    return sum_val == target\n", "model_name": "azure-openai-o1"}
{"test_name": "prod", "response_0": "from Compiler.types import sfix\n\ndef prod(array):\n    # array is assumed to be an sfix.Array or similar container\n    length = array.length\n    product_value = sfix(1)\n    for i in range(length):\n        product_value = product_value * array[i]\n    return product_value\n", "response_1": "from Compiler.types import sint\n\ndef prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    product = sint(1)\n    for i in range(array.length):\n        product = product * array[i]\n    return product\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_till_negative", "response_0": "from Compiler.types import sint\ndef sum_till_negative(array):\n    sum_val = sint(0)\n    carryon = sint(1)\n    arr_len = len(array)\n    for i in range(arr_len):\n        is_negative = (array[i] < 0)\n        sum_val = sum_val + array[i] * carryon\n        carryon = carryon.bit_and(is_negative.bit_not())\n    return sum_val\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_till_negative(arr):\n    s = sint(0)\n    flag = sint(0)\n    n = arr.length\n    for i in for_range(n):\n        cond = arr[i] < 0\n        new_flag = flag.bit_or(cond)\n        # Only add arr[i] if we haven't encountered a negative so far\n        s = s + arr[i] * (flag.bit_not()) * (cond.bit_not())\n        flag = new_flag\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    The predicator is expected to return an sint (0 or 1).\n    \"\"\"\n    s = sint(0)\n    n = len(arr)\n    for i in range(n):\n        s += predicator(arr[i])\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    # Count how many elements satisfy predicator\n    arr_length = arr.length\n    total = sint(0)\n    for i in range(arr_length):\n        total = total + predicator(arr[i])\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "standard_deviation", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef standard_deviation(arr):\n    length = len(arr)\n    average = sfix(0)\n    variance = sfix(0)\n    for i in range(length):\n        average += arr[i] / length\n    for i in range(length):\n        diff = arr[i] - average\n        variance += (diff * diff) / length\n    return mpc_math.sqrt(variance)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    length = len(arr)\n    average = sfix(0)\n    variance = sfix(0)\n\n    # Compute average\n    for i in range(length):\n        average = average + arr[i] / length\n    \n    # Compute variance\n    for i in range(length):\n        diff = arr[i] - average\n        variance = variance + (diff * diff) / length\n    \n    # Return the square root of variance\n    return mpc_math.sqrt(variance)\n", "model_name": "azure-openai-o1"}
{"test_name": "dominate", "response_0": "from Compiler.types import sint\n\ndef dominate(a, b):\n    # We'll assume a and b are Arrays (or lists) of secret values \n    # where comparisons produce sintbit results.\n    dominates = a[0] >= b[0]\n    for i in range(1, len(a)):\n        dominates = dominates.bit_and(a[i] >= b[i])\n    return dominates\n", "response_1": "from Compiler.types import sint\n\ndef dominate(a, b):\n    \"\"\"\n    Return 1 if array a \"dominates\" array b (every element in a is\n    no smaller than the corresponding element in b). Otherwise return 0.\n    \"\"\"\n    length = len(a)\n    ret = sint(1)\n    for i in range(length):\n        # (a[i] < b[i]) returns a secret bit (0 or 1) as sint\n        less_than = a[i] < b[i]\n        # If a[i] < b[i], this is 1 and we set ret to 0 by multiplying with (1 - 1) = 0\n        # otherwise, it remains unchanged by multiplying with (1 - 0) = 1\n        ret = ret * (1 - less_than)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "rescale", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef rescale(brr):\n    n = brr.length\n    max_abs = sfix(0)\n    for i in for_range(n):\n        item_abs = brr[i].abs()\n        cond = item_abs > max_abs\n        max_abs = cond.if_else(item_abs, max_abs)\n    for i in for_range(n):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "array_minus7", "response_0": "from Compiler.types import sint, Array\n\ndef array_minus7(arr):\n    n = arr.length\n    for i in range(n):\n        arr[i] = arr[i] - 7\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    length = arr.length\n    for i in range(length):\n        arr[i] = arr[i] - 7\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    total = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            total = total + (arr1[i] * arr2[j])\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    sum_val = sint(0)\n    for i in range(arr1.length):\n        for j in range(arr2.length):\n            sum_val += arr1[i] * arr2[j]\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef longest_nondec_subseq(a):\n    # Assume a is an Array of sint\n    n = len(a)  # compile-time length\n    max_length = sint(0)\n    cur_length = sint(0)\n    for i in for_range(n):\n        if i == 0:\n            cur_length = sint(1)\n            continue\n        cond = (a[i] >= a[i - 1])  # This comparison returns a sintbit\n        not_cond = sint(1) - cond\n\n        # Update max_length only when cond == 0\n        candidate_max = max_length.max(cur_length)\n        max_length = not_cond.if_else(candidate_max, max_length)\n\n        # Update cur_length\n        new_cur_length = cur_length + sint(1)\n        cur_length = cond.if_else(new_cur_length, sint(1))\n\n    max_length = max_length.max(cur_length)\n    return max_length\n", "response_1": "from Compiler.types import sint\n\ndef longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    max_length = sint(0)\n    cur_length = sint(0)\n    # Loop over all elements (public loop index).\n    # 'a.length' is the compile-time length of 'a'.\n    for i in range(a.length):\n        if i == 0:\n            # First element: start counting at 1\n            cur_length = sint(1)\n        else:\n            # Compare a[i] and a[i-1] in secret\n            bit = (a[i] >= a[i - 1])  # returns sintbit\n            # If the subsequence is non-decreasing, increase length;\n            # otherwise, reset to 1\n            increase_cur = cur_length + sint(1)\n            reset_cur = sint(1)\n            new_cur_length = bit.if_else(increase_cur, reset_cur)\n\n            # Only update max_length on the decreasing branch\n            bit_not = bit.bit_not()\n            bigger_than_max = (cur_length > max_length)\n            condition = bit_not & bigger_than_max\n            max_length = condition.if_else(cur_length, max_length)\n\n            cur_length = new_cur_length\n\n    # After the loop, check once more if we need to update\n    bigger_than_max = (cur_length > max_length)\n    max_length = bigger_than_max.if_else(cur_length, max_length)\n    return max_length\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_but_skip_biggest", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element so far each time.\n    \"\"\"\n    s = sint(0)\n    biggest = array[0]\n    for i in range(array.length):\n        cond = (array[i] >= biggest)\n        biggest = cond.if_else(array[i], biggest)\n        s = s + (1 - cond) * array[i]\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_but_skip_biggest(array):\n    result_sum = sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        cond = (array[i] >= biggest)\n        biggest = cond.if_else(array[i], biggest)\n        result_sum = cond.if_else(result_sum, result_sum + array[i])\n    return result_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "second_test", "response_0": "from Compiler.types import sint\n\ndef second_test(arr):\n    length = len(arr)\n    count = sint(0)\n    for i in range(1, length):\n        # Comparison returns a 'sintbit', convert it to 'sint' for arithmetic\n        count = count + (arr[0] < arr[i]).if_else(sint(1), sint(0))\n    # 'count == 1' returns a 'sintbit' which can be interpreted as a boolean\n    return count == 1\n", "response_1": "from Compiler.types import sint\n\ndef second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    for i in range(1, len(arr)):\n        is_less = (arr[0] < arr[i])  # produces sintbit\n        count = count + is_less.if_else(sint(1), sint(0))\n    return (count == 1)  # returns sintbit\n", "model_name": "azure-openai-o1"}
{"test_name": "Manhattan_distance", "response_0": "from Compiler.types import sint\n\ndef Manhattan_distance(a, b):\n    # 'a' and 'b' are assumed to be Arrays of the same length\n    ret = sint(0)\n    for i in range(a.length):\n        ret = ret + (a[i] - b[i]).abs()\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors using sfix.\n    \"\"\"\n    result = sfix(0)\n    length = len(a)\n    for i in range(length):\n        difference = a[i] - b[i]\n        result = result + difference.abs()\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "deal_with_only_positive", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef deal_with_only_positive(array):\n    n = len(array)\n    sign = sint(1)\n    s = sint(0)\n    for i in for_range(n):\n        cond = (array[i] <= 0)\n        skip = cond  # 1 if we skip, 0 otherwise\n        not_skip = 1 - skip\n        s = s + (not_skip * (sign * array[i]))\n        sign = skip.if_else(sign, -sign)\n    return s\n", "response_1": "from Compiler.types import sint, cint\nfrom Compiler.library import for_range\n\ndef deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to/from the partial sum.\n    Non-positive elements are skipped.\n    \"\"\"\n    sum_val = sint(0)\n    sign = sint(1)\n    n = len(array)\n    for i in range(n):\n        skipBit = (array[i] <= cint(0))\n        sum_val = sum_val + (cint(1) - skipBit) * (sign * array[i])\n        sign = skipBit.if_else(sign, -sign)\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import sint\n\ndef compare_and_return(arr, brr):\n    n = len(arr)\n    ret = sint(-1)\n    found = sint(0)\n    for i in range(n):\n        eq = (arr[i] == brr[i])               # eq is a 'sintbit'\n        cond = eq.bit_and(found == 0)        # only update if not found yet\n        ret = cond.if_else(sint(i), ret)     # set ret = i if cond is 1\n        found = found.bit_or(eq)             # once found, keep it\n    return ret\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "sum_odd_positive", "response_0": "from Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    s = sint(0)\n    arr_len = len(arr)\n    for i in range(arr_len):\n        item = arr[i]\n        odd_condition = (item % 2 == 1)\n        positive_condition = (item > 0)\n        condition = odd_condition.bit_and(positive_condition)\n        s = s + condition.if_else(item, 0)\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    s = sint(0)\n    length = len(arr)  # arr is presumably a sint.Array or similar\n    for i in range(length):\n        item = arr[i]\n        odd = (item % 2) == 1\n        pos = item > 0\n        cond = odd.bit_and(pos)\n        s = s + cond.if_else(item, 0)\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "two_sum", "response_0": "", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef two_sum(arr, target):\n    # Initialize 'found' as a secret bit set to 0 by comparing 0 == 1 (which is false).\n    found = (sint(0) == 1)\n    # 'arr' is assumed to be an Array of known compile-time length.\n    length = arr.length\n\n    for i in for_range(length):\n        for j in for_range(length):\n            # Compare arr[i] + arr[j] against target; this yields a sintbit (0 or 1).\n            eq = (arr[i] + arr[j]) == target\n            # Accumulate via bitwise OR to see if any pair adds up to target.\n            found = found.bit_or(eq)\n\n    # 'found' is a single-bit secret (0 or 1). Returning it indicates whether such a pair exists.\n    return found\n", "model_name": "azure-openai-o1"}
{"test_name": "seq_search", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef seq_search(arr, target):\n    n = len(arr)\n    found = sint(-1)\n    for i in range(n):\n        eq = (arr[i] == target)\n        found = eq.if_else(sint(i), found)\n    return found\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_array", "response_0": "from Compiler.types import sint\n\ndef choppy_array(arr):\n    arr_len = arr.length\n    result = sint(1)\n    for i in range(arr_len):\n        parity_flag = i % 2\n        for j in range(arr_len - i):\n            comparison_bit = arr[i + j] > arr[i] if parity_flag == 1 else arr[i + j] < arr[i]\n            result = result * (1 - comparison_bit)\n    return result\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef choppy_array(arr):\n    # arr is assumed to be an Array of sint with compile-time known length\n    n = arr.length\n    result = sint(1)\n    for i in for_range(n):\n        if i % 2 == 1:\n            # i is odd\n            for j in for_range(n - i):\n                c = arr[i + j] > arr[i]\n                # If c == 1, this violates the \"choppy\" pattern\n                result = result.bit_and(1 - c)\n        else:\n            # i is even\n            for j in for_range(n - i):\n                c = arr[i + j] < arr[i]\n                # If c == 1, this violates the \"choppy\" pattern\n                result = result.bit_and(1 - c)\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process", "response_0": "from Compiler.types import for_range\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for i in for_range(arr.length):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "from Compiler.types import Array\nfrom Compiler.library import for_range\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    array_length = len(arr)\n    for i in for_range(array_length):\n        arr[i] = func(arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "normalize", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef normalize(vec):\n    \"\"\"\n    Normalize the vector.\n    \"\"\"\n    sum_val = sfix(0)\n    for item in vec:\n        sum_val = sum_val + item**2\n\n    base = mpc_math.sqrt(sum_val)\n\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n\n    return vec\n", "response_1": "import mpc_math\nfrom Compiler.types import sfix\n\ndef normalize(vec):\n    sum_val = sfix(0)\n    for i in range(len(vec)):\n        sum_val += vec[i]**2\n    base = mpc_math.sqrt(sum_val)\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "model_name": "azure-openai-o1"}
{"test_name": "impatient_merchant", "response_0": "from Compiler.types import sint\n\ndef impatient_merchant(days):\n    # days is assumed to be an Array of sint with a known compile-time length\n    length = len(days)\n    can_buy = sint(1)       # 1 means 'True', can buy\n    net = sint(0)\n    orig_price = sint(0)\n    for i in range(length):\n        # Store the old can_buy to handle the \"else\" logic\n        old_can_buy = can_buy\n\n        # Corresponds to: if old_can_buy:\n        #     net = net - days[i]\n        #     orig_price = days[i]\n        #     can_buy = 0\n        net_buy = net - days[i]\n        net = old_can_buy.if_else(net_buy, net)\n        orig_price = old_can_buy.if_else(days[i], orig_price)\n        can_buy = old_can_buy.if_else(sint(0), can_buy)\n\n        # Corresponds to: else: if days[i] > orig_price:\n        #     net = net + days[i]\n        #     can_buy = 1\n        cond_sell = (old_can_buy == 0).bit_and(days[i] > orig_price)\n        net_sell = net + days[i]\n        net = cond_sell.if_else(net_sell, net)\n        can_buy = cond_sell.if_else(sint(1), can_buy)\n\n    return net\n", "response_1": "from Compiler.types import cint\n\ndef impatient_merchant(days):\n    # days is assumed to be an Array (or list) of cint, and its length is known at compile time.\n    length_days = days.length  # compile-time length of the Array\n    can_buy = True\n    net = cint(0)\n    orig_price = cint(0)\n    for i in range(length_days):\n        if can_buy:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = False\n        else:\n            if days[i] > orig_price:\n                net = net + days[i]\n                can_buy = True\n    return net\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift", "response_0": "import Compiler.types as t\n\ndef array_shift(a):\n    n = a.length\n    temp = a[n - 1]\n    for i in range(n - 1):\n        a[n - i - 1] = a[n - i - 2]\n    a[0] = temp\n    return a\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef array_shift(a):\n    n = len(a)\n    temp = a[n - 1]\n    for i in for_range(n - 1):\n        a[n - 1 - i] = a[n - 2 - i]\n    a[0] = temp\n    return a\n", "model_name": "azure-openai-o1"}
{"test_name": "array_double", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_double(arr):\n    # Assuming 'arr' is an Array of sint\n    length = arr.length\n    for i in for_range(length):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_double(arr):\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.types import sint\n\ndef stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    length = len(array)\n    stopped = sint(0)\n    for i in range(length):\n        eq0_bit = (array[i] == 0)                  # 1 if array[i] is 0, else 0\n        not_stopped_bit = (stopped == 0)           # 1 if we haven't stopped yet, else 0\n        array[i] = array[i] + not_stopped_bit.bit_and(eq0_bit.bit_not())\n        stopped = stopped.bit_or(not_stopped_bit.bit_and(eq0_bit))\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef stop_at_zero(array):\n    length = len(array)\n    stop = sint(0)\n    for i in range(length):\n        eq_zero = (array[i] == 0)\n        # Only add 1 if we haven't stopped and current element isn't zero\n        do_add = (1 - stop) * (1 - eq_zero)\n        array[i] = array[i] + do_add\n        # Once we find zero, we set stop to 1 to prevent further additions\n        stop = stop.bit_or(eq_zero)\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_not", "response_0": "from Compiler.types import sint\n\ndef array_not(arr):\n    \"\"\"\n    Take opposite (bitwise NOT) of all single-bit elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i].bit_not()\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        # Perform single-bit NOT in arithmetic circuits\n        arr[i] = arr[i].bit_not()\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_then_clip", "response_0": "from Compiler.types import sfix\n\ndef array_process_then_clip(arr, func):\n    for i in range(arr.length):\n        arr[i] = func(arr[i])\n        cond_upper = arr[i] > 10\n        arr[i] = cond_upper.if_else(sfix(10), arr[i])\n        cond_lower = arr[i] < -10\n        arr[i] = cond_lower.if_else(sfix(-10), arr[i])\n    return arr\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "add_and_count_positive", "response_0": "from Compiler.types import sint\n\ndef add_and_count_positive(array, k):\n    size = len(array)\n    count = sint(0)\n    for i in range(size):\n        array[i].update(array[i] + k)\n        is_positive = (array[i] > 0).if_else(sint(1), sint(0))\n        count.update(count + is_positive)\n    return array, count\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef add_and_count_positive(array, k):\n    length = array.length\n    count = sint(0)\n    for i in for_range(length):\n        array[i].update(array[i] + k)\n        count = count + (array[i] > 0)\n    return array, count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract", "response_0": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    lenA = len(a)\n    lenB = len(b)\n    if lenA > lenB:\n        ret = sint.Array(lenA)\n        ret.assign_all(0)\n        for i in range(lenB):\n            ret[i] = a[i] - b[i]\n        for i in range(lenB, lenA):\n            ret[i] = a[i]\n    else:\n        ret = sint.Array(lenB)\n        ret.assign_all(0)\n        for i in range(lenA):\n            ret[i] = a[i] - b[i]\n        for i in range(lenA, lenB):\n            ret[i] = -b[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    Padded with 0 if lengths differ.\n    \"\"\"\n    la = len(a)\n    lb = len(b)\n    if la > lb:\n        ret = sint.Array(la)\n        ret.assign_all(0)\n        ret[:lb] = a[:lb] - b[:lb]\n        ret[lb:la] = a[lb:la]\n        return ret\n    else:\n        ret = sint.Array(lb)\n        ret.assign_all(0)\n        ret[:la] = a[:la] - b[:la]\n        ret[la:lb] = -b[la:lb]\n        return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "lower_bound", "response_0": "", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\ndef lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = sint(-1)\n    distance = sfix(0)\n    found = sint(0)\n    n = len(arr)  # public length\n    for i in for_range(n):\n        # Condition 1: arr[i] <= x\n        cond1 = (arr[i] <= x).to_sint()\n\n        # Condition 2: not found or (x - arr[i] < distance)\n        diff_comp = (x - arr[i] < distance).to_sint()\n        cond2 = found.bit_not().bit_or(diff_comp)\n\n        cond = cond1.bit_and(cond2)\n        ret = cond.if_else(sint(i), ret)\n        distance = cond.if_else(x - arr[i], distance)\n        found = cond.if_else(sint(1), found)\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "argmin", "response_0": "from Compiler.types import sint\n\ndef argmin(a):\n    \"\"\"\n    Return the index of the min value of an array.\n    \"\"\"\n    length = len(a)\n    current = a[0]\n    index = sint(0)\n    for i in range(length):\n        cond = (current <= a[i])\n        index = cond.if_else(index, sint(i))\n        current = cond.if_else(current, a[i])\n    return index\n", "response_1": "from Compiler.types import sint\n\ndef argmin(a):\n    index = sint(0)\n    current = a[0]\n    for i in range(a.length):\n        cond = (current <= a[i])\n        index = cond.if_else(index, sint(i))\n        current = cond.if_else(current, a[i])\n    return index\n", "model_name": "azure-openai-o1"}
{"test_name": "independent_robbery", "response_0": "from Compiler.types import sint, Array\n\ndef independent_robbery(houses, house_count):\n    # Initialize dp array with zeros\n    dp = sint.Array(house_count)\n    dp.assign_all(0)\n\n    # dp[0] = houses[0]\n    dp[0] = houses[0]\n\n    # dp[1] = dp[1] if dp[1]>=dp[0] else dp[0]\n    cond_1 = (dp[1] - dp[0]) >= 0\n    dp[1] = cond_1.if_else(dp[1], dp[0])\n\n    # for i in range(2, house_count):\n    #     if dp[i-2] + houses[i] >= dp[i-1]:\n    #         dp[i] = dp[i-2] + houses[i]\n    #     else:\n    #         dp[i] = dp[i-1]\n    for i in range(2, house_count):\n        cond = (dp[i - 2] + houses[i] - dp[i - 1]) >= 0\n        dp[i] = cond.if_else(dp[i - 2] + houses[i], dp[i - 1])\n\n    # return dp[house_count - 1]\n    return dp[house_count - 1]\n", "response_1": "from Compiler.types import sfix\n\ndef independent_robbery(houses):\n    n = houses.length\n    dp = sfix.Array(n)\n    dp.assign_all(0)\n    # dp[0] = houses[0]\n    dp[0] = houses[0]\n\n    # dp[1] = dp[1] if dp[1]>=dp[0] else dp[0]\n    cond_1 = (dp[1] >= dp[0])\n    dp[1] = cond_1.if_else(dp[1], dp[0])\n\n    # for i in range(2,len(houses)):\n    #     if dp[i-2]+houses[i] >= dp[i-1]:\n    #         dp[i] = dp[i-2]+houses[i]\n    #     else:\n    #         dp[i] = dp[i-1]\n    for i in range(2, n):\n        cond_i = (dp[i-2] + houses[i] >= dp[i-1])\n        dp[i] = cond_i.if_else(dp[i-2] + houses[i], dp[i-1])\n\n    return dp[n - 1]\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_odd_and_odd", "response_0": "from Compiler.types import sint\n\ndef sum_odd_and_odd(arr):\n    n = arr.length\n    total_sum = sint(0)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            total_sum += arr[j]\n    return total_sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_odd_and_odd(arr):\n    result = sint(0)\n    n = arr.length\n    for i in range(n):\n        if (i % 2) == 0:\n            continue\n        for j in range(i):\n            if (j % 2) == 0:\n                continue\n            result += arr[j]\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "is_monotonous", "response_0": "from Compiler.types import cfix\n\ndef is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    d = cfix(0)\n    n = len(arr)\n    for i in range(n - 1):\n        # i is a compile-time integer index.\n        if i > 0:\n            if (arr[i+1] - arr[i]) * d <= cfix(0):\n                return 0  # False\n        d = arr[i+1] - arr[i]\n    return 1  # True\n", "response_1": "from Compiler.types import sint\n\ndef is_monotonous(arr):\n    n = arr.length  # compile-time length of the array\n    res = sint(1)   # 1 represents True in MP-SPDZ\n    d = sint(0)\n    for i in range(n - 1):\n        delta = arr[i + 1] - arr[i]\n        if i > 0:  # public condition\n            tmp = delta * d\n            cond = (tmp <= 0)          # this yields an sbitint\n            cond_sint = cond.if_else(sint(1), sint(0)) \n            # if cond is true, we set res to 0\n            res = res * (sint(1) - cond_sint)\n        d = delta\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "positive_count_negative_sum", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    count = sint(0)\n    neg_sum = sint(0)\n    arr_length = len(arr)\n    for i in range(arr_length):\n        item = arr[i]\n        is_pos = (item > sint(0))\n        count = count + is_pos\n        is_neg = (item < sint(0))\n        neg_sum = neg_sum + (item * is_neg)\n    return count, neg_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_even", "response_0": "from Compiler.types import sint\nfrom Compiler.program import for_range\n\ndef sum_even(arr):\n    s = sint(0)\n    n = len(arr)  # compile-time length\n    for i in for_range(n):\n        # Check if arr[i] is even by checking arr[i] % 2\n        is_even = 1 - (arr[i] % 2)\n        s += arr[i] * is_even\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    s = sint(0)\n    for i in range(len(arr)):\n        is_even = (arr[i] % 2 == 0)\n        s = s + arr[i] * is_even\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "one_norm", "response_0": "from Compiler.types import sfix\n\ndef one_norm(vec):\n    sum_val = sfix(0)\n    for item in vec:\n        sum_val = sum_val + abs(item)\n    return sum_val\n", "response_1": "from Compiler.types import sfix\n\ndef one_norm(vec):\n    total = sfix(0)\n    for i in range(len(vec)):\n        total = total + abs(vec[i])\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "array_floor", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.types import Array\n\ndef array_floor(arr):\n    \"\"\"\n    Apply floor to each element of a secret fixed-point array (similar to math.floor).\n    \"\"\"\n    length = len(arr)\n    ret = sint.Array(length)\n    for i in range(length):\n        truncated = arr[i].Trunc()\n        is_integer = (arr[i] == truncated)\n        is_not_integer = is_integer.bit_not()\n        is_negative = (arr[i] < 0)\n        subtract_one = is_negative.bit_and(is_not_integer)\n        # Convert truncated sfix to sint and subtract if needed for negatives\n        ret[i] = truncated.to_sint() - subtract_one\n    return ret\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "three_five", "response_0": "from Compiler.types import sint\n\ndef three_five(arr):\n    has3 = sint(0)\n    has5 = sint(0)\n    # Use a compile-time known length for the loop\n    length = len(arr)\n    for i in range(length):\n        eq3 = (arr[i] == 3)  # returns a single-bit (0 or 1)\n        eq5 = (arr[i] == 5)\n        has3 = has3.bit_or(eq3)\n        has5 = has5.bit_or(eq5)\n    return (has3.bit_and(has5)).bit_or(has3.bit_not().bit_and(has5.bit_not()))\n", "response_1": "from Compiler.types import sint\n\ndef three_five(arr):\n    has3 = sint(0)\n    has5 = sint(0)\n    for i in range(len(arr)):\n        eq3 = (arr[i] == 3)\n        eq5 = (arr[i] == 5)\n        has3 = has3.bit_or(eq3)\n        has5 = has5.bit_or(eq5)\n\n    return has3.bit_and(has5).bit_or(has3.bit_not().bit_and(has5.bit_not()))\n", "model_name": "azure-openai-o1"}
{"test_name": "num_above_average", "response_0": "from Compiler.types import sfix, sint, for_range\n\ndef num_above_average(arr, length):\n    # arr is an Array of sfix\n    # length is a public integer (e.g., Python int or cint)\n    sum_val = sfix(0)\n    count = sint(0)\n    \n    # Compute sum\n    for i in for_range(length):\n        sum_val += arr[i]\n    \n    # Compute average\n    avg = sum_val / length\n    \n    # Count how many elements >= average\n    for i in for_range(length):\n        comparison_bit = (arr[i] >= avg)  # sbitint\n        count += comparison_bit.if_else(sint(1), sint(0))\n    \n    return count\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix\n\ndef clip(arr, upper_bound, lower_bound):\n    length = len(arr)\n    for i in range(length):\n        arr[i] = (arr[i] < lower_bound).if_else(lower_bound, arr[i])\n        arr[i] = (arr[i] > upper_bound).if_else(upper_bound, arr[i])\n    return arr\n", "response_1": "from Compiler.types import sfix\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound].\n    Assumes arr is an array of sfix or a type supporting comparisons and if_else.\n    \"\"\"\n    for i in range(arr.length):\n        arr[i] = (arr[i] < lower_bound).if_else(lower_bound, arr[i])\n        arr[i] = (arr[i] > upper_bound).if_else(upper_bound, arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "from Compiler.types import sint\n\ndef sum_with_certain_element_skipped(array):\n    total = sint(0)\n    length = len(array)\n    for i in range(length):\n        candidate_sum = total + array[i]\n        cond_lower = candidate_sum >= 5\n        cond_upper = candidate_sum <= 10\n        skip = cond_lower.bit_and(cond_upper)\n        total = skip.if_else(total, candidate_sum)\n    return total\n", "response_1": "from Compiler.types import sint, cint\n\ndef sum_with_certain_element_skipped(a):\n    s = sint(0)\n    length = len(a)\n    for i in range(length):\n        cond_min = (s + a[i]) >= cint(5)\n        cond_max = (s + a[i]) <= cint(10)\n        cond = cond_min & cond_max\n        s = cond.if_else(s, s + a[i])\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    n = len(arr)\n    for i in for_range(n):\n        item = arr[i]\n        is_odd = item % 2\n        odd_sum = odd_sum + is_odd * item\n        even_sum = even_sum + (sint(1) - is_odd) * item\n    return odd_sum, even_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are secret/sint integers.\n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    # Loop over each item in the array\n    for i in range(len(arr)):\n        item = arr[i]\n        bit_is_odd = item & 1\n        # Accumulate in odd_sum if odd, else even_sum\n        odd_sum += item * bit_is_odd\n        even_sum += item * (1 - bit_is_odd)\n    return odd_sum, even_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "distance", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef distance(vec1, vec2):\n    # Compute the Euclidean distance between the two vectors.\n    sum_val = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        sum_val += diff * diff\n    return mpc_math.sqrt(sum_val)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    total = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        total += diff * diff\n    return mpc_math.sqrt(total)\n", "model_name": "azure-openai-o1"}
{"test_name": "num_occurrence", "response_0": "from Compiler.types import sint\n\ndef num_occurrence(arr, target, arr_size):\n    count = sint(0)\n    for i in range(arr_size):\n        eq_res = (arr[i] == target)\n        count = count + eq_res\n    return count\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef num_occurrence(arr, target):\n    count = sint(0)\n    # Assuming 'arr' is a fixed-length Array of sint\n    # and its length is known at compile time.\n    for i in for_range(len(arr)):\n        eq = (arr[i] == target)\n        count = count + eq\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "palindrome", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef palindrome(arr):\n    flag = sint(1)\n    n = arr.length\n    for i in for_range(n):\n        flag = flag.bit_and(arr[i] == arr[n - 1 - i])\n    return flag\n", "response_1": "from Compiler.types import sint\n\ndef palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    length = arr.length\n    # Initialize flag as 1 (true) in the secret integer domain.\n    flag = sint(1)\n    for i in range(length):\n        # arr[i] == arr[length-1-i] yields a 'sintbit', so convert it to 'sint' (0 or 1).\n        cond_bit = (arr[i] == arr[length - 1 - i])\n        cond_sint = cond_bit.if_else(sint(1), sint(0))\n        # Update flag by multiplying with cond_sint, replicating logical AND.\n        flag = flag * cond_sint\n    return flag\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    num = sint(0)\n    length = arr.length  # compile-time integer\n    for i in range(length):\n        for j in range(i + 1, length):\n            cond = arr[i] > arr[j]  # returns an sintbit\n            num = num + cond\n    return num\n", "response_1": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    length = len(arr)\n    num = sint(0)\n    for i in range(length):\n        for j in range(i+1, length):\n            cond = arr[i] > arr[j]\n            num = num + cond\n    return num\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_of_cubes", "response_0": "from Compiler.types import sint\n\ndef sum_of_cubes(arr, size):\n    \"\"\"\n    Return the sum of cubes of elements in the array.\n    'arr' is assumed to be a sint.Array,\n    and 'size' is its compile-time length.\n    \"\"\"\n    ret = sint(0)\n    for i in range(size):\n        ret += arr[i] ** 3\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array.\n    \"\"\"\n    ret = sint(0)\n    for i in range(len(arr)):\n        ret = ret + arr[i] ** 3\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "max_element", "response_0": "from Compiler.types import sint\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array of secret integers.\n    \"\"\"\n    current = a[0]\n    arr_length = len(a)\n    for i in range(1, arr_length):\n        current = current.max(a[i])\n    return current\n", "response_1": "from Compiler.types import sint\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array 'a' of 'sint'.\n    \"\"\"\n    current = a[0]\n    n = len(a)\n    for i in range(1, n):\n        current = current.max(a[i])\n    return current\n", "model_name": "azure-openai-o1"}
{"test_name": "array_if_else", "response_0": "from Compiler.types import sint\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    n = len(arr)\n    for i in range(n):\n        condition_bit = predicator(arr[i])\n        arr[i] = condition_bit.if_else(if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "inf_norm", "response_0": "from Compiler.types import sfix\n\ndef inf_norm(vec):\n    res = sfix(0)\n    for item in vec:\n        current_abs = item.abs()\n        res = res.max(current_abs)\n    return res\n", "response_1": "def inf_norm(vec):\n    from Compiler.types import sfix\n    result = sfix(0)\n    length = len(vec)\n    for i in range(length):\n        tmp = abs(vec[i])\n        result = result.max(tmp)\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_inc", "response_0": "", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array (arr is assumed to be a sint.Array).\n    \"\"\"\n    n = arr.length\n    count = sint(0)\n    for i in range(n - 1):\n        is_rise_bit = (arr[i] < arr[i + 1]).if_else(sint(1), sint(0))\n        count = count + is_rise_bit\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    length = len(arr)\n    count = sint(0)\n    for i in range(length - 1):\n        cond = arr[i] < arr[i + 1]  # This produces a sintbit (0 or 1)\n        count += cond\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "skip_at_zero", "response_0": "from Compiler.types import sint\n\ndef skip_at_zero(array):\n    size = len(array)\n    for i in range(size):\n        skip = (array[i] == 0)\n        array[i] = skip.if_else(array[i], array[i] + 1)\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef skip_at_zero(array):\n    n = len(array)\n    for i in range(n):\n        is_zero = (array[i] == 0)\n        # If is_zero is 1, pick array[i], else pick array[i] + 1\n        array[i].update(is_zero.if_else(array[i], array[i] + 1))\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_intersect", "response_0": "from Compiler.types import sint\n\ndef array_intersect(p, q):\n    # Return 1 if the two arrays share any common element, 0 otherwise.\n    # Assume p and q are arrays of sint with compile-time known lengths.\n    \n    lenp = len(p)\n    lenq = len(q)\n    found = sint(0)\n    \n    for i in range(lenp):\n        for j in range(lenq):\n            eq = (p[i] == q[j])          # eq is a single-bit (sintbit)\n            found = found.bit_or(eq)     # Accumulate into found (also treated as single-bit)\n    \n    return found  # Returns sint(1) if intersection is found, else sint(0)\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element as a secret 0/1 value.\n    \"\"\"\n    found = sint(0)\n    for i in for_range(len(p)):\n        for j in for_range(len(q)):\n            eq_bit = (p[i] == q[j])  # comparison yields a sintbit\n            eq_sint = eq_bit * 1     # convert sintbit to sint\n            # Implement logical OR in arithmetic:\n            # new_found = found OR eq_sint = found + eq_sint - found * eq_sint\n            found = found + eq_sint - found * eq_sint\n    return found\n", "model_name": "azure-openai-o1"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef two_norm(vec):\n    sum_val = sfix(0)\n    for item in vec:\n        sum_val += item * item\n    return mpc_math.sqrt(sum_val)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef two_norm(vec):\n    # vec is expected to be an iterable of sfix\n    sum_val = sfix(0)\n    for item in vec:\n        sum_val += item**2\n    return mpc_math.sqrt(sum_val)\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_between", "response_0": "def sum_between(arr, l, u):\n    from Compiler.types import sint\n    s = sint(0)\n    for i in range(arr.length):\n        cond_low = (arr[i] >= l)\n        cond_high = (arr[i] <= u)\n        cond = cond_low.bit_and(cond_high)\n        s = s + arr[i] * cond\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_between(arr, l, u):\n    s = sint(0)\n    length = arr.length\n    for i in range(length):\n        item = arr[i]\n        cond1 = (item >= l)\n        cond2 = (item <= u)\n        cond = cond1.bit_and(cond2)\n        s = s + cond.if_else(item, sint(0))\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "largest_gap", "response_0": "from Compiler.types import sfix\n\ndef largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    n = len(arr)\n    cur = sfix(0)\n    for i in range(n - 1):\n        diff_abs = abs(arr[i+1] - arr[i])\n        if diff_abs > cur:\n            cur = diff_abs\n    return cur\n", "response_1": "from Compiler.types import sint\n\ndef largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = sint(0)\n    for i in range(len(arr) - 1):\n        diff = arr[i + 1] - arr[i]\n        gap = diff.abs()\n        is_bigger = gap > cur\n        cur = is_bigger.if_else(gap, cur)\n    return cur\n", "model_name": "azure-openai-o1"}
{"test_name": "totally_dominate", "response_0": "from Compiler.library import for_range\nfrom Compiler.types import sint\n\ndef totally_dominate(a, b):\n    # a and b are assumed to be Arrays of sint\n    amin = a[0]\n    bmax = b[0]\n\n    # Find the minimum element of a\n    for i in range(1, a.length):\n        cond = a[i] < amin\n        amin = cond.if_else(a[i], amin)\n\n    # Find the maximum element of b\n    for i in range(1, b.length):\n        cond = b[i] > bmax\n        bmax = cond.if_else(b[i], bmax)\n\n    # Return whether the minimum of a is >= the maximum of b\n    return amin >= bmax\n", "response_1": "from Compiler.types import sfix\n\ndef totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    amin = a[0]\n    # Find min of array a\n    for i in range(1, a.length):\n        amin = a[i].min(amin)\n\n    bmax = b[0]\n    # Find max of array b\n    for j in range(1, b.length):\n        bmax = b[j].max(bmax)\n\n    # Compare the results\n    return amin >= bmax\n", "model_name": "azure-openai-o1"}
{"test_name": "element_count", "response_0": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    ret = sint(0)\n    length = len(arr)  # compile-time length\n    for i in range(length):\n        ret = ret + (arr[i] == target)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    # Initialize the return value as a secret integer\n    ret = sint(0)\n    # Loop over the array using a public-range iteration\n    for i in range(len(arr)):\n        # Compare each element with the target and convert\n        # the comparison result (sintbit) to sint\n        eq = (arr[i] == target).if_else(sint(1), sint(0))\n        ret = ret + eq\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "is_subarray", "response_0": "from Compiler.types import sint\n\ndef is_subarray(c, d):\n    c_len = c.length\n    d_len = d.length\n    result = sint(0)\n    for i in range(d_len):\n        # Check if there's enough space in d starting at i to fit c\n        if c_len <= (d_len - i):\n            flag = sint(1)\n            for j in range(c_len):\n                eq = (c[j] == d[i + j])\n                flag = flag.bit_and(eq)\n            # Accumulate result if we found a matching segment\n            result = result.bit_or(flag)\n    return result\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef is_subarray(c, d, len_c, len_d):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    c and d are arrays of type sint, while len_c and len_d are public integer lengths.\n    The result is returned as a secret integer (0 or 1).\n    \"\"\"\n    result = sint(0)\n    # Only positions up to (len_d - len_c) can start a subarray\n    for i in for_range(len_d - len_c + 1):\n        flag = sint(1)\n        for j in for_range(len_c):\n            flag = flag.bit_and(d[i + j] == c[j])\n        result = result.bit_or(flag)\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    # 'arr' is assumed to be an Array of 'sint'.\n    # We use a secret integer (sint) to store whether 5 or 7 has been found.\n    found = sint(0)\n    for i in range(len(arr)):\n        # Each comparison returns a secret bit (sintbit).\n        eq5 = (arr[i] == 5)\n        eq7 = (arr[i] == 7)\n        # Combine the two bits with bitwise OR.\n        found = found.bit_or(eq5.bit_or(eq7))\n    # 'found' will be 1 (true) if any element is 5 or 7, 0 (false) otherwise.\n    return found\n", "response_1": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array 'arr' contains 5 or 7.\n    Returns 1 (as secret integer) if it does, and 0 otherwise.\n    \"\"\"\n    array_length = arr.length\n    # Initialize a secret bit to 0\n    found = (sint(0) == sint(1))  # This yields an sintbit with value 0\n\n    for i in range(array_length):\n        # Each comparison returns an sintbit\n        eq_5 = (arr[i] == 5)\n        eq_7 = (arr[i] == 7)\n        # Combine them with bitwise OR\n        found = found.bit_or(eq_5.bit_or(eq_7))\n\n    # Convert final bit to sint 1/0\n    return found.if_else(1, 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "variance", "response_0": "from Compiler.types import sfix\n\ndef variance(arr):\n    \"\"\"\n    Return the variance of the array. \n    \"\"\"\n    length = len(arr)\n    average = sfix(0)\n    variance_val = sfix(0)\n\n    # First pass: compute average\n    for i in range(length):\n        average += arr[i] / sfix(length)\n\n    # Second pass: compute variance\n    for i in range(length):\n        diff = arr[i] - average\n        variance_val += (diff * diff) / sfix(length)\n\n    return variance_val\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "is_ascending", "response_0": "from Compiler.types import sint\n\ndef is_ascending(arr):\n    \"\"\"\n    Return a secret bit (0 or 1), indicating whether or not the secret\n    integer array 'arr' is in strictly ascending order.\n    If the length of input array is 1, it returns 1 (True).\n    \"\"\"\n    n = len(arr)  # compile-time public length\n    # Handle single-element case\n    if n == 1:\n        # This yields a secret bit set to 1\n        return arr[0] == arr[0]\n\n    # Initialize the result as a secret bit of 1 by comparing arr[0] with itself\n    result = (arr[0] == arr[0])\n\n    # Loop to check if each pair is in ascending order\n    for i in range(n - 1):\n        # Compare arr[i] and arr[i+1] and combine into 'result' via AND\n        comparison_bit = (arr[i] < arr[i + 1])\n        result = result.bit_and(comparison_bit)\n\n    # 'result' is 1 if the array is strictly ascending, 0 otherwise\n    return result\n", "response_1": "from Compiler.types import sint, sintbit\n\ndef is_ascending(arr):\n    n = arr.length\n    if n <= 1:\n        # If array length <= 1, return True (as 1).\n        return sint(1)\n    # Initialize a secret bit to 1 (True).\n    ascending_bit = sintbit(1)\n    # Loop through adjacent pairs and check strict ascending property.\n    for i in range(n - 1):\n        # (arr[i] < arr[i+1]) results in a secret bit (sintbit).\n        ascending_bit = ascending_bit & (arr[i] < arr[i + 1])\n    # Convert the final bit to an sint: 1 if True, 0 otherwise.\n    return ascending_bit.if_else(1, 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "xor_all", "response_0": "from Compiler.types import sint\n\ndef xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret.bit_xor(arr[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef xor_all(arr):\n    # arr is an array of secret bits (sint) containing only 0's and 1's\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret.bit_xor(arr[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "upper_bound", "response_0": "from Compiler.types import sint\n\ndef upper_bound(arr, x):\n    n = arr.length\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n\n    for i in range(n):\n        cond_arr_gt_x = (arr[i] > x)\n        cond_not_found = (found == 0)\n        cond_smaller_distance = ((arr[i] - x) < distance)\n        cond_update = cond_arr_gt_x.bit_and(cond_not_found.bit_or(cond_smaller_distance))\n\n        ret = cond_update.if_else(i, ret)\n        distance = cond_update.if_else(arr[i] - x, distance)\n        found = cond_update.if_else(sint(1), found)\n\n    return ret\n", "response_1": "from Compiler.types import sint, regint\n\ndef upper_bound(arr, x):\n    # arr is assumed to be an Array of sint (arr[i] in sint).\n    # x is a sint.\n    # This returns a secret integer (sint) index, or -1 if no element is greater than x.\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n    for i in range(len(arr)):\n        cond = arr[i] > x  # secret bit\n        cond2 = (arr[i] - x) < distance  # secret bit\n        not_found = (found == 0)  # secret bit\n        cond3 = not_found.bit_or(cond2)  # secret bit\n        cond_all = cond.bit_and(cond3)   # secret bit\n        # If cond_all is 1, update; otherwise keep old values\n        ret = cond_all.if_else(sint(i), ret)\n        distance = cond_all.if_else(arr[i] - x, distance)\n        found = cond_all.if_else(sint(1), found)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler.types import sint\n\ndef array_process_then_sum(arr, func):\n    # Here, arr is assumed to be an Array of sint (or another MP-SPDZ type).\n    # Get the compile-time length (e.g., if arr was defined with a known length).\n    n = len(arr)\n\n    total_sum = sint(0)\n    for i in range(n):\n        # Apply the given function to arr[i].\n        arr[i] = func(arr[i])\n        # Accumulate the result into total_sum.\n        total_sum = total_sum + arr[i]\n\n    return total_sum\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.instructions import for_range\n\ndef array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input sfix Array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    n = len(arr)\n    sum_val = sfix(0)\n    for i in for_range(n):\n        arr[i] = func(arr[i])\n        sum_val = sum_val + arr[i]\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "average", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the sfix array.\n    \"\"\"\n    sum_val = sfix(0)\n    length = len(arr)\n    for i in for_range(length):\n        sum_val += arr[i]\n    ret = sum_val / length\n    return ret\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    length = len(arr)\n    sum_ = sfix(0)\n    for i in for_range(length):\n        sum_ += arr[i]\n    ret = sum_ / sfix(length)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_filter", "response_0": "from Compiler.types import sint\n\ndef array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array,\n    if the predicator returns True (1), then preserve the element,\n    otherwise set the element to 0.\n    \"\"\"\n    for i in range(len(arr)):\n        condition = predicator(arr[i])    # This should produce a single-bit (sint) indicating True or False\n        arr[i] = condition.if_else(arr[i], sint(0))\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_filter(arr, predicator):\n    length = len(arr)\n    for i in range(length):\n        condition = predicator(arr[i])  # should return 0 or 1 in MP-SPDZ\n        arr[i] = condition.if_else(arr[i], sint(0))\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_up", "response_0": "from Compiler.types import sint\n\ndef sum_up(array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    result = sint(0)\n    for num in array:\n        result = result + num\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef sum_up(array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    s = sint(0)\n    for i in range(len(array)):\n        s = s + array[i]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_to_zero", "response_0": "from Compiler.types import sint\n\ndef negative_to_zero(arr):\n    length = len(arr)\n    for i in range(length):\n        cond = arr[i] >= 0\n        arr[i].update(cond.if_else(arr[i], sint(0)))\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(array.length):\n        cond = (array[i] >= 0)\n        array[i] = cond.if_else(array[i], 0)\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_only_positive_to_ten", "response_0": "from Compiler.types import sint\n\ndef sum_only_positive_to_ten(array):\n    # Initialize the partial sum and a \"mask\" indicating we haven't reached 10 yet\n    partial_sum = sint(0)\n    mask = sint(1)\n\n    # Iterate through the array in a data-oblivious manner\n    array_length = len(array)\n    for i in range(array_length):\n        # Condition for being positive\n        cond_pos = array[i] > 0\n        # Only add if positive and we haven't yet reached sum >= 10\n        to_add = array[i] * cond_pos * mask\n        partial_sum = partial_sum + to_add\n\n        # If partial_sum >= 10, we update mask to 0 so that no further additions occur\n        cond_done = partial_sum >= 10\n        mask = mask * (1 - cond_done)\n\n    return partial_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements\n    until the sum becomes no smaller than 10.\n    \"\"\"\n    sum_val = sint(0)\n    stop = sint(0)  # 0 means we haven't reached 10 yet\n    l = len(array)\n    for i in range(l):\n        # Check if array[i] is positive\n        cond_pos = array[i] > 0\n        # Only add if array[i] is positive and we haven't stopped\n        cond_add = cond_pos.bit_and(stop.bit_not())\n        sum_val = sum_val + (array[i] * cond_add)\n        # Update stop if sum_val >= 10\n        done_cond = sum_val >= 10\n        stop = stop.bit_or(done_cond)\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "bubble_sort", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array 'arr' using MP-SPDZ.\n    Each element of 'arr' is assumed to be a secret integer (sint).\n    \"\"\"\n    n = arr.length\n    for i in for_range(n - 1):\n        for j in for_range(n - 1 - i):\n            if arr[j] >= arr[j + 1]:\n                temp = arr[j]\n                arr[j].update(arr[j + 1])\n                arr[j + 1].update(temp)\n    return arr\n", "response_1": "from Compiler.types import sint, for_range\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in for_range(n - 1):\n        for j in for_range(n - 1 - i):\n            cond = arr[j] >= arr[j + 1]\n            swapped_j, swapped_jp1 = cond.cond_swap(arr[j], arr[j + 1])\n            arr[j].update(swapped_j)\n            arr[j + 1].update(swapped_jp1)\n    return arr\n", "model_name": "azure-openai-o1"}
