{"test_name": "sin_or_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef sin_or_cos(x):\n    zero = sfix(0)\n    cond = x >= zero\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n    return cond.if_else(sin_val, cos_val)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef sin_or_cos(x):\n    cond = x >= 0\n    return cond.if_else(mpc_math.sin(x), mpc_math.cos(x))\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_relu", "response_0": "from Compiler.types import sfix\n\ndef negative_relu(x):\n    # Negative ReLU: if x < 0, return x; else return 0.\n    return (x < 0).if_else(x, sfix(0))\n", "response_1": "from Compiler.types import sfix\n\ndef negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    negative_bit = (input < 0)\n    return negative_bit.if_else(input, sfix(0))\n", "model_name": "azure-openai-o1"}
{"test_name": "is_close", "response_0": "from Compiler.types import sint\n\ndef is_close(a: sint, b: sint):\n    \"\"\"\n    Return whether or not the two secret integer inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    diff = a - b\n    return diff.abs() <= 1\n", "response_1": "from Compiler.types import sfix\n\ndef is_close(a: sfix, b: sfix):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    return abs(a - b) <= 1\n", "model_name": "azure-openai-o1"}
{"test_name": "hardswish", "response_0": "from Compiler.types import sfix, cfix\n\ndef hardswish(x):\n    cond1 = x < cfix(-3)\n    cond2 = x > cfix(3)\n    middle_val = (x * (x + cfix(3))) / cfix(6)\n    return cond1.if_else(cfix(0), cond2.if_else(x, middle_val))\n", "response_1": "from Compiler.types import sfix\n\ndef hardswish(x: sfix):\n    cond_lt_neg3 = (x < -3)\n    cond_gt_3 = (x > 3)\n    val_in_between = (x * (x + 3)) / 6\n    tmp_result = cond_gt_3.if_else(x, val_in_between)\n    return cond_lt_neg3.if_else(0, tmp_result)\n", "model_name": "azure-openai-o1"}
{"test_name": "clip_at_6", "response_0": "from Compiler.types import sfix, cfix\n\ndef clip_at_6(x):\n    cond1 = x > cfix(6)\n    clipped1 = cond1.if_else(sfix(6), x)\n    cond2 = x < cfix(-6)\n    clipped2 = cond2.if_else(sfix(-6), clipped1)\n    return clipped2\n", "response_1": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    is_greater_than_6 = (x > sfix(6))\n    x_clipped_top = is_greater_than_6.if_else(sfix(6), x)\n    is_less_than_minus_6 = (x_clipped_top < sfix(-6))\n    return is_less_than_minus_6.if_else(sfix(-6), x_clipped_top)\n", "model_name": "azure-openai-o1"}
{"test_name": "piecewise_function", "response_0": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    cond1 = (x > sfix(1))\n    cond2 = (x < sfix(-1))\n    cond3 = (x > sfix(0))\n    cond4 = (x < sfix(0))\n    return cond1.if_else(\n        x,\n        cond2.if_else(\n            x,\n            cond3.if_else(\n                sfix(1),\n                cond4.if_else(sfix(-1), sfix(0))\n            )\n        )\n    )\n", "response_1": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    cond1 = (x > 1)       # returns an sbitint\n    cond2 = (x < -1)      # returns an sbitint\n    cond3 = (x > 0)       # returns an sbitint\n    cond4 = (x < 0)       # returns an sbitint\n    return cond1.if_else(\n        x,\n        cond2.if_else(\n            x,\n            cond3.if_else(\n                sfix(1),\n                cond4.if_else(sfix(-1), sfix(0))\n            )\n        )\n    )\n", "model_name": "azure-openai-o1"}
{"test_name": "middle", "response_0": "from Compiler.types import sint\n\ndef middle(a, b, c):\n    swap_bit1 = (a >= b)\n    a, b = swap_bit1.cond_swap(a, b)\n\n    swap_bit2 = (b >= c)\n    b, c = swap_bit2.cond_swap(b, c)\n\n    swap_bit3 = (a >= b)\n    a, b = swap_bit3.cond_swap(a, b)\n\n    return b\n", "response_1": "from Compiler.types import sint\n\ndef middle(a, b, c):\n    # Compare a, b and swap if a >= b\n    cond1 = (a >= b)  # This produces an sintbit\n    a, b = cond1.cond_swap(a, b)\n\n    # Compare b, c and swap if b >= c\n    cond2 = (b >= c)\n    b, c = cond2.cond_swap(b, c)\n\n    # Compare a, b again and swap if a >= b\n    cond3 = (a >= b)\n    a, b = cond3.cond_swap(a, b)\n\n    return b\n", "model_name": "azure-openai-o1"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler.types import sfix, sint\nimport Compiler.mpc_math as mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input,\n    otherwise return the cosine value of the input.\n\n    Both x and ind are expected to be secret values in MP-SPDZ, with x as sfix and\n    ind being 0 or 1 in an sint register.\n    \"\"\"\n    return ind.if_else(mpc_math.sin(x), mpc_math.cos(x))\n", "response_1": "/// Import necessary modules\nfrom Compiler.types import sfix, sint\nimport mpc_math\n\ndef indicated_sin_or_cos(x: sfix, ind: sint):\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n    return ind.if_else(sin_val, cos_val)\n", "model_name": "azure-openai-o1"}
{"test_name": "minus2_if_else", "response_0": "from Compiler.types import sint\n\ndef minus2_if_else(x):\n    cond = (x - 2) >= 0\n    return cond.if_else(x - 2, x)\n", "response_1": "from Compiler.types import sint\n\ndef minus2_if_else(x: sint) -> sint:\n    diff = x - 2\n    cond = diff >= 0\n    return cond.if_else(diff, x)\n", "model_name": "azure-openai-o1"}
{"test_name": "relu6", "response_0": "from Compiler.types import sfix\n\ndef relu6(x):\n    cond_neg = (x < 0)\n    tmp = cond_neg.if_else(sfix(0), x)\n    cond_hi = (tmp > 6)\n    res = cond_hi.if_else(sfix(6), tmp)\n    return res\n", "response_1": "from Compiler.types import sfix\n\ndef relu6(x):\n    zero = sfix(0)\n    six = sfix(6)\n    less_than_zero = x < zero\n    temp_result = less_than_zero.if_else(zero, x)\n    greater_than_six = x > six\n    return greater_than_six.if_else(six, temp_result)\n", "model_name": "azure-openai-o1"}
{"test_name": "exp_slide", "response_0": "from Compiler.types import sfix, cfix\nfrom Compiler import mpc_math\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    cond = x >= sfix(0)\n    base_e = cfix(2.718281828459045)  # approximate value of e\n    positive_val = mpc_math.pow_fx(base_e, x)\n    negative_val = x + sfix(1)\n    return cond.if_else(positive_val, negative_val)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef exp_slide(x: sfix) -> sfix:\n    cond = (x >= 0)\n    return cond.if_else(mpc_math.pow_fx(mpc_math.e, x), x + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "pass_or_not", "response_0": "from Compiler.types import sint, cint\n\ndef pass_or_not(score):\n    # Comparison yields a boolean-like sintbit\n    # (score >= 60) => 1 else 0\n    cond = (score >= cint(60))\n\n    # If cond is 1 (score>=60) => score, else 59\n    updated_score = cond.if_else(score, cint(59))\n\n    # If cond is 1 (score>=60) => 1, else 0\n    passed = cond.if_else(sint(1), sint(0))\n\n    return updated_score, passed\n", "response_1": "from Compiler.types import sint\n\ndef pass_or_not(score):\n    cmp_score = (score >= 60)\n    adjusted_score = cmp_score.if_else(score, 59)\n    passed = cmp_score\n    return adjusted_score, passed\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sint\n\ndef how_many_roots(a, b, c):\n    # Compare a with 0\n    a_eq_0 = (a == 0)\n\n    # Compare b with 0\n    b_eq_0 = (b == 0)\n\n    # Branch A: a == 0\n    #   if b == 0 -> 0\n    #   else -> 1\n    branchA = b_eq_0.if_else(sint(0), sint(1))\n\n    # Discriminant\n    disc = b * b - sint(4) * a * c\n    disc_gt_0 = (disc > 0)\n    disc_eq_0 = (disc == 0)\n\n    # Branch B: a != 0\n    #   if disc > 0 -> 2\n    #   elif disc == 0 -> 1\n    #   else -> 0\n    branchB = disc_gt_0.if_else(sint(2), disc_eq_0.if_else(sint(1), sint(0)))\n\n    # Select between branchA and branchB based on whether a == 0\n    return a_eq_0.if_else(branchA, branchB)\n", "response_1": "from Compiler.types import sfix, sint\n\ndef how_many_roots(a, b, c):\n    # a, b, c assumed to be sfix. The function returns an sint\n    # for the number of roots.\n\n    is_a_zero = (a == 0)\n    is_b_zero = (b == 0)\n\n    # Case 1: if a == 0\n    #   if b == 0 => return 0\n    #   else => return 1\n    branch_a = is_b_zero.if_else(sint(0), sint(1))\n\n    # Case 2: if a != 0\n    #   compute discriminant\n    disc = b * b - sfix(4) * a * c\n    gt0 = (disc > 0)\n    eq0 = (disc == 0)\n\n    # if disc > 0 => return 2\n    # elif disc == 0 => return 1\n    # else => return 0\n    branch_disc = gt0.if_else(sint(2), eq0.if_else(sint(1), sint(0)))\n\n    # if (a == 0) => branch_a, else => branch_disc\n    return is_a_zero.if_else(branch_a, branch_disc)\n", "model_name": "azure-openai-o1"}
{"test_name": "elu", "response_0": "from Compiler.types import sfix, cfix\nfrom mpc_math import pow_fx\n\ndef elu(x: sfix) -> sfix:\n    e_approx = cfix(2.718281828459045)  # approximate value of e\n    is_positive = (x > 0)\n    return is_positive.if_else(x, pow_fx(e_approx, x) - cfix(1))\n", "response_1": "from Compiler.types import sfix, cfix\nfrom Compiler.library import mpc_math\n\n# Define a constant for e\nE = cfix(2.718281828459045)\n\ndef elu(x: sfix):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    condition = x > cfix(0)\n    return condition.if_else(x, mpc_math.pow_fx(E, x) - cfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "relu", "response_0": "from Compiler.types import sfix\n\ndef relu(x):\n    is_positive = (x > 0)\n    return is_positive.if_else(x, 0)\n", "response_1": "from Compiler.types import sfix\n\ndef relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    mask = (x > sfix(0))\n    return mask.if_else(x, sfix(0))\n", "model_name": "azure-openai-o1"}
{"test_name": "leaky_relu", "response_0": "from Compiler.types import sfix\n\ndef leaky_relu(x: sfix, alpha: sfix):\n    condition = x > 0\n    return condition.if_else(x, x * alpha)\n", "response_1": "from Compiler.types import sfix\n\ndef leaky_relu(x, alpha):\n    cond = x > sfix(0)\n    return cond.if_else(x, x * alpha)\n", "model_name": "azure-openai-o1"}
{"test_name": "max", "response_0": "from Compiler.types import sint, cfix, sfix\n\ndef max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "response_1": "from Compiler.types import sint, sfix\n\ndef max_spdz(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs in MP-SPDZ.\n    \"\"\"\n    # '>=', when used on secret types, produces a secret bit (sintbit).\n    # 'if_else(cond, x, y)' returns x if cond==1 else y.\n    cond = (a >= b)\n    return cond.if_else(a, b)\n", "model_name": "azure-openai-o1"}
{"test_name": "bowl_shape", "response_0": "from Compiler.types import sfix\n\ndef bowl_shape(x):\n    cond1 = (x > 1)\n    cond2 = (x < -1)\n    return cond1.if_else(x - 1, cond2.if_else(-x - 1, 0))\n", "response_1": "from Compiler.types import sfix\n\ndef bowl_shape(x):\n    cond_gt_1 = (x > 1)\n    cond_lt_neg_1 = (x < -1)\n    part_gt_1 = cond_gt_1.if_else(x - 1, sfix(0))\n    part_lt_neg_1 = cond_lt_neg_1.if_else((-x) - 1, sfix(0))\n    return part_gt_1 + part_lt_neg_1\n", "model_name": "azure-openai-o1"}
{"test_name": "rounded_kinetic_energy", "response_0": "from Compiler.types import sfix, sint\nimport mpc_math\n\ndef rounded_kinetic_energy(m, v):\n    k = m * (v * v) / sfix(2)\n    k_int = sint(k)  # This truncates k to an integral value.\n    cond = (k - sfix(k_int)) < sfix(0.5)\n    return cond.if_else(k_int, k_int + 1)\n", "response_1": "from Compiler.types import sfix, sint\n\ndef rounded_kinetic_energy(m, v):\n    k = m * (v ** 2) / sfix(2)\n    k_int = sint(k)  # Truncation of k to integer part (assuming k >= 0)\n    fractional_part = k - sfix(k_int)\n    condition = fractional_part < sfix(0.5)\n    return condition.if_else(k_int, k_int + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "danger_test", "response_0": "from Compiler.types import sint\n\ndef danger_test(origin: sint, damage: sint):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy!\n    Given the Dragon Warrior's initial health and the damage he receives,\n    decide whether the situation is dangerous.\n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return (origin - damage) <= 10\n", "response_1": "from Compiler.types import sint, cint\n\ndef danger_test(origin, damage):\n    # Calculate final health\n    health_left = origin - damage\n    \n    # Define threshold as a public constant\n    threshold = cint(10)\n    \n    # Return comparison as a secret boolean (sintbit)\n    return health_left <= threshold\n", "model_name": "azure-openai-o1"}
{"test_name": "indicated_sum_or_multiply", "response_0": "from Compiler.types import sint\n\ndef indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True (interpreted as 1), return the sum of the two inputs;\n    otherwise (indicator is 0), return the product.\n    \"\"\"\n    sum_val = x + y\n    product_val = x * y\n    return ind.if_else(sum_val, product_val)\n", "response_1": "from Compiler.types import sint\n\ndef indicated_sum_or_multiply(x, y, ind):\n    # x, y, and ind are assumed to be sint (with ind being 0 or 1).\n    return ind.if_else(x + y, x * y)\n", "model_name": "azure-openai-o1"}
{"test_name": "median", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import print_str\n\ndef median(arr):\n    n = len(arr)\n    if n == 0:\n        print_str(\"The length of the array is 0!\\n\")\n        return sfix(0)\n    arr.sort()\n    if n % 2 == 1:\n        return arr[n // 2]\n    else:\n        return (arr[n // 2] + arr[n // 2 - 1]) / 2\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.types import Array\n\ndef median(arr):\n    # Check if the array is empty\n    if arr.length == 0:\n        # In MP-SPDZ, you cannot directly raise a Python exception,\n        # so here we just print an error message and return a default.\n        print_str(\"The length of the array is 0!\\n\")\n        return sfix(0)\n    \n    # Sort in place\n    arr.sort()\n\n    # Initialize return value as sfix\n    ret = sfix(0)\n\n    # If array length is odd, pick the middle element\n    if arr.length % 2 == 1:\n        ret = arr[arr.length // 2]\n    else:\n        # Otherwise, pick the average of the two middle elements\n        ret = (arr[arr.length // 2] + arr[arr.length // 2 - 1]) / sfix(2)\n    \n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "add_upto_10", "response_0": "", "response_1": "from Compiler.types import sint, cint\n\ndef add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    exceed_bit = sum_ab > cint(10)\n    return exceed_bit.if_else(cint(10), sum_ab)\n", "model_name": "azure-openai-o1"}
{"test_name": "taxi_fare", "response_0": "from Compiler.types import sfix\n\ndef taxi_fare(m):\n    cond_first_part = (m <= 5)\n    cond_second_part = (m <= 10)\n    return cond_first_part.if_else(\n        sfix(5),\n        cond_second_part.if_else(\n            sfix(5) + sfix(1.2)*(m - 5),\n            sfix(11) + sfix(1.5)*(m - 10)\n        )\n    )\n", "response_1": "from Compiler.types import sfix\n\ndef taxi_fare(m):\n    cond1 = (m <= sfix(5))\n    cond2 = (m >= sfix(5)).bit_and(m <= sfix(10))\n\n    cost_if_m_lte_5 = sfix(5)\n    cost_if_5_m_10 = sfix(5) + sfix(1.2) * (m - sfix(5))\n    cost_if_m_gt_10 = sfix(11) + sfix(1.5) * (m - sfix(10))\n\n    cost_if_not_cond1 = cond2.if_else(cost_if_5_m_10, cost_if_m_gt_10)\n    return cond1.if_else(cost_if_m_lte_5, cost_if_not_cond1)\n", "model_name": "azure-openai-o1"}
{"test_name": "round", "response_0": "", "response_1": "# Reimplementation of the Python \"round\" function in MP-SPDZ,\n# rounding to the nearest integer (ties half up).\n# This code assumes x \u2265 0 for simplicity.\n\nfrom Compiler.types import sfix, cfix\n\ndef floor_sfix_non_negative(x):\n    \"\"\"\n    Returns the floor of x assuming x is an sfix \u2265 0.\n    floor(x) is taken by right-shifting the underlying integer\n    representation by the fixed-point precision.\n    \"\"\"\n    return sfix(x.v >> x.f)\n\ndef round_sfix(x):\n    \"\"\"\n    Round x (sfix) to the nearest integer with half rounding up.\n    \"\"\"\n    x_int = floor_sfix_non_negative(x)\n    frac_part = x - x_int\n    cond = frac_part < cfix(0.5)\n    return cond.if_else(x_int, x_int + cfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "gpa_calculator", "response_0": "from Compiler.types import sfix, cfix\n\ndef gpa_calculator(score):\n    cond1 = score >= cfix(90)\n    cond2 = score >= cfix(85)\n    cond3 = score >= cfix(80)\n    cond4 = score >= cfix(75)\n    cond5 = score >= cfix(70)\n\n    return cond1.if_else(\n        cfix(4.0),\n        cond2.if_else(\n            cfix(3.6),\n            cond3.if_else(\n                cfix(3.3),\n                cond4.if_else(\n                    cfix(3.0),\n                    cond5.if_else(\n                        cfix(2.6),\n                        cfix(2.3)\n                    )\n                )\n            )\n        )\n    )\n", "response_1": "from Compiler.types import sfix\n\ndef gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    cond1 = (score >= sfix(90))\n    cond2 = (score >= sfix(85))\n    cond3 = (score >= sfix(80))\n    cond4 = (score >= sfix(75))\n    cond5 = (score >= sfix(70))\n    return cond1.if_else(sfix(4.0),\n             cond2.if_else(sfix(3.6),\n               cond3.if_else(sfix(3.3),\n                 cond4.if_else(sfix(3.0),\n                   cond5.if_else(sfix(2.6),\n                     sfix(2.3))))))\n", "model_name": "azure-openai-o1"}
{"test_name": "sign", "response_0": "from Compiler.types import sint, cint\n\ndef sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0.\n    If x is zero, return 0.\n    \"\"\"\n    zero_bit = (x == 0)\n    positive_bit = (x > 0)\n    return zero_bit.if_else(cint(0), positive_bit.if_else(cint(1), cint(-1)))\n", "response_1": "from Compiler.types import sint\n\ndef sign(x: sint) -> sint:\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    is_zero = (x == 0)\n    is_positive = (x > 0)\n    return is_zero.if_else(0, is_positive.if_else(1, -1))\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_or_difference", "response_0": "from Compiler.types import sint\n\ndef sum_or_difference(a: sint, b: sint):\n    \"\"\"\n    If the first input is less than or equal to the second input,\n    return their sum, otherwise return their difference.\n    \"\"\"\n    condition = (a <= b)  # This produces an sintbit\n    return condition.if_else(a + b, a - b)\n", "response_1": "from Compiler.types import sint\n\ndef sum_or_difference(a: sint, b: sint):\n    comparison_result = (a <= b)\n    return comparison_result.if_else(a + b, a - b)\n", "model_name": "azure-openai-o1"}
{"test_name": "CNOT", "response_0": "from Compiler.types import sint\n\ndef CNOT(control_bit: sint, flip_bit: sint):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit in MP-SPDZ.\n    \"\"\"\n    # If control_bit is 1, return NOT(flip_bit); otherwise return flip_bit.\n    return control_bit.if_else(flip_bit.bit_not(), flip_bit)\n", "response_1": "from Compiler.types import sint\n\ndef CNOT(control_bit: sint, flip_bit: sint) -> sint:\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    control_bit and flip_bit are assumed to be secret bits represented by sint.\n    \"\"\"\n    not_flip_bit = flip_bit.bit_not()\n    return control_bit.if_else(not_flip_bit, flip_bit)\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_plus1", "response_0": "from Compiler.types import sint\n\ndef negative_plus1(y: sint):\n    # Return y+1 if y is negative, otherwise return y\n    cond = (y < 0)\n    return cond.if_else(y + 1, y)\n", "response_1": "from Compiler.types import sint\n\ndef negative_plus1(y):\n    is_negative = (y < 0)\n    return is_negative.if_else(y + 1, y)\n", "model_name": "azure-openai-o1"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler.types import sint\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices (each an Array or list-like of length 2 holding sint),\n    return an sintbit indicating whether they can form a parallelogram.\n    \"\"\"\n    def same(x, y):\n        eq0 = (x[0] == y[0])  # returns an sintbit\n        eq1 = (x[1] == y[1])  # returns an sintbit\n        return eq0.bit_and(eq1)\n    \n    # Check if any pair of vertices is the same\n    same_any = same(a,b).bit_or(same(a,c)).bit_or(same(a,d))\n    same_any = same_any.bit_or(same(b,c)).bit_or(same(b,d)).bit_or(same(c,d))\n    \n    # Check parallelogram conditions\n    left_expr_1 = ((a[0] + b[0]) == (c[0] + d[0])).bit_and((a[1] + b[1]) == (c[1] + d[1]))\n    left_expr_2 = ((a[0] + c[0]) == (b[0] + d[0])).bit_and((a[1] + c[1]) == (b[1] + d[1]))\n    left_expr_3 = ((a[0] + d[0]) == (b[0] + c[0])).bit_and((a[1] + d[1]) == (b[1] + c[1]))\n    parallelogram_bit = left_expr_1.bit_or(left_expr_2).bit_or(left_expr_3)\n    \n    # If any pair of vertices is the same, return 0, else return parallelogram_bit\n    return same_any.bit_not().bit_and(parallelogram_bit)\n", "response_1": "from Compiler.types import sint\n\ndef eq(x, y):\n    # Convert comparison (x == y) to a secret bit in arithmetic circuits.\n    return sint(x == y)\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices a, b, c, d (each a pair of secret integers),\n    determine whether they can form a parallelogram.\n    Returns a secret bit (0 or 1).\n    \"\"\"\n\n    def same(x, y):\n        # Check if two coordinates are equal in both dimensions.\n        return eq(x[0], y[0]) * eq(x[1], y[1])\n\n    # Check if any pair of distinct points is actually equal\n    common = same(a,b).bit_or(same(a,c)).bit_or(same(a,d)) \\\n             .bit_or(same(b,c)).bit_or(same(b,d)).bit_or(same(c,d))\n\n    # Conditions for parallelogram: sum of opposite sides equals\n    cond1 = eq(a[0] + b[0], c[0] + d[0]) * eq(a[1] + b[1], c[1] + d[1])\n    cond2 = eq(a[0] + c[0], b[0] + d[0]) * eq(a[1] + c[1], b[1] + d[1])\n    cond3 = eq(a[0] + d[0], b[0] + c[0]) * eq(a[1] + d[1], b[1] + c[1])\n    condition = cond1.bit_or(cond2).bit_or(cond3)\n\n    # If any pair is the same, return 0; otherwise return the parallelogram condition\n    return common.if_else(sint(0), condition)\n", "model_name": "azure-openai-o1"}
{"test_name": "min", "response_0": "from Compiler.types import sint, cfix, sfix\n\ndef mpc_min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    condition = (a <= b)\n    return condition.if_else(a, b)\n", "response_1": "from Compiler.types import sint, sfix, cint, cfix\n\ndef min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "model_name": "azure-openai-o1"}
{"test_name": "choice_of_the_knight", "response_0": "from Compiler.types import sint, sintbit\n\ndef choice_of_the_knight(x, y):\n    def legal(a, b):\n        cond_a_lower = (a >= 0)  # returns sintbit\n        cond_a_upper = (a <= 7)  # returns sintbit\n        cond_b_lower = (b >= 0)  # returns sintbit\n        cond_b_upper = (b <= 7)  # returns sintbit\n        # Combine them with bitwise AND\n        return cond_a_lower.bit_and(cond_a_upper).bit_and(cond_b_lower.bit_and(cond_b_upper))\n\n    counter = sint(0)\n    counter = counter + legal(x + 1, y + 2).to_sint()\n    counter = counter + legal(x - 1, y + 2).to_sint()\n    counter = counter + legal(x + 1, y - 2).to_sint()\n    counter = counter + legal(x - 1, y - 2).to_sint()\n    counter = counter + legal(x + 2, y + 1).to_sint()\n    counter = counter + legal(x - 2, y + 1).to_sint()\n    counter = counter + legal(x + 2, y - 1).to_sint()\n    counter = counter + legal(x - 2, y - 1).to_sint()\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef choice_of_the_knight(x, y):\n    def legal(a, b):\n        # Each comparison returns a single-bit result (secret bit),\n        # which must be combined using .bit_and().\n        return (a >= 0).bit_and(a <= 7).bit_and(b >= 0).bit_and(b <= 7)\n\n    counter = sint(0)\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "max_sum_difference", "response_0": "from Compiler.types import sint\n\ndef max_sum_different(a: sint, b: sint):\n    sum_ab = a + b\n    sub_ab = a - b\n    cond = sum_ab > sub_ab\n    return cond.if_else(sum_ab, sub_ab)\n", "response_1": "from Compiler.types import sint\n\ndef max_sum_different(a: sint, b: sint):\n    c = a + b\n    d = a - b\n    comparison_result = c > d\n    return comparison_result.if_else(c, d)\n", "model_name": "azure-openai-o1"}
