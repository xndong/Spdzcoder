{"test_name": "next_integer", "response_0": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return mpc_math.floor_fx(t) + 1\n", "response_1": "from Compiler.types import cfix\n\ndef next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value t (public fixed-point).\n    \"\"\"\n    return (t // 1) + 1\n", "model_name": "azure-openai-o1"}
{"test_name": "father_and_son", "response_0": "from Compiler.types import sint\n\ndef father_and_son(father_age: sint, son_age: sint):\n    return (father_age - son_age * 2).abs()\n", "response_1": "from Compiler.types import sint\n\ndef father_and_son(father_age: sint, son_age: sint) -> sint:\n    \"\"\"\n    Given the age of father and son (secret integers),\n    return before how many years or after how many years,\n    the age of father is twice as the age of son.\n    \"\"\"\n    return (father_age - son_age * 2).abs()\n", "model_name": "azure-openai-o1"}
{"test_name": "triangle_area", "response_0": "from Compiler.types import sfix\n\ndef triangle_area(side: sfix, height: sfix) -> sfix:\n    return (side * height) / sfix(2)\n", "response_1": "from Compiler.types import sfix\n\ndef triangle_area(side: sfix, height: sfix) -> sfix:\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the size of the triangle.\n    \"\"\"\n    return side * height / sfix(2)\n", "model_name": "azure-openai-o1"}
{"test_name": "sin_plus_cos", "response_0": "from Compiler.types import sfix\nfrom mpc_math import sin, cos\n\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    return sin(a) + cos(a)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef sin_plus_cos(a: sfix):\n    \"\"\"\n    Return sin(a) + cos(a)\n    \"\"\"\n    return mpc_math.sin(a) + mpc_math.cos(a)\n", "model_name": "azure-openai-o1"}
{"test_name": "sigmoid", "response_0": "from Compiler.types import sfix, cfix\nimport mpc_math\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    e_approx = cfix(2.718281828459045)\n    return sfix(1) / (sfix(1) + mpc_math.pow_fx(e_approx, -x))\n", "response_1": "from Compiler.types import sfix, cfix\nimport mpc_math\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function\n    \"\"\"\n    e = cfix(2.718281828459045)\n    return sfix(1) / (sfix(1) + mpc_math.pow_fx(e, -x))\n", "model_name": "azure-openai-o1"}
{"test_name": "self_exponent", "response_0": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef self_exponent(k):\n    # Return the self-exponent k^k using MP-SPDZ's pow_fx\n    return mpc_math.pow_fx(k, k)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k using MP-SPDZ's pow_fx.\n    \"\"\"\n    return mpc_math.pow_fx(k, k)\n", "model_name": "azure-openai-o1"}
{"test_name": "silu", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    return x / (sfix(1) + mpc_math.pow_fx(sfix(2.718281828459045), -x))\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "Gaussian_bracket", "response_0": "from Compiler.types import sfix\nfrom Compiler.mpc_math import floor_fx\n\ndef Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = floor_fx(x)\n    return x - x_int\n", "response_1": "from Compiler.types import cfix\n\ndef Gaussian_bracket(x):\n    x_int = x // 1  # cfix supports floor division\n    return x - x_int\n", "model_name": "azure-openai-o1"}
{"test_name": "asin_and_square", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef asin_and_square(x: sfix):\n    arc_sin_val = mpc_math.asin(x)\n    return arc_sin_val * arc_sin_val\n", "response_1": "from Compiler.types import sfix\nimport Compiler.mpc_math as mpc_math\n\ndef asin_and_square(x):\n    # Convert input to secret fixed-point type\n    x_sfix = sfix(x)\n    # Compute arcsin\n    val_asin = mpc_math.asin(x_sfix)\n    # Square the result\n    return val_asin * val_asin\n", "model_name": "azure-openai-o1"}
{"test_name": "cylinder_surface", "response_0": "from Compiler.types import sfix, cfix\n\ndef cylinder_surface(r, h):\n    # Approximate value for \u03c0\n    pi = cfix(3.141592653589793)\n    return (sfix(2) * pi * (r ** 2)) + (sfix(2) * pi * r * h)\n", "response_1": "from Compiler.types import sfix, cfix\nfrom Compiler import mpc_math\n\ndef cylinder_surface(r, h):\n    PI = cfix(3.141592653589793)\n    return cfix(2) * PI * mpc_math.pow_fx(r, cfix(2)) + cfix(2) * PI * r * h\n", "model_name": "azure-openai-o1"}
{"test_name": "radian_to_degree", "response_0": "from Compiler.types import sfix, cfix\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree in MP-SPDZ\n    \"\"\"\n    pi_val = cfix(3.141592653589793)\n    return r / pi_val * cfix(180)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    pi = cfix(3.141592653589793)\n    return r * cfix(180) / pi\n", "model_name": "azure-openai-o1"}
{"test_name": "square_root", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef square_root(a):\n    \"\"\"\n    return the square root of the input a (secret fixed-point number).\n    \"\"\"\n    return mpc_math.sqrt(a)\n", "response_1": "from Tools import mpc_math\nfrom Compiler.types import sfix\n\ndef square_root(a):\n    \"\"\"\n    Return the square root of the input.\n    \"\"\"\n    return mpc_math.sqrt(a)\n", "model_name": "azure-openai-o1"}
{"test_name": "cosine_theorem", "response_0": "import mpc_math\nfrom Compiler.types import sfix\n\ndef cosine_theorem(a: sfix, b: sfix, rad: sfix):\n    # Use sfix as secret fixed-point type. \n    # Leverage mpc_math.cos() and mpc_math.sqrt().\n    return mpc_math.sqrt(a * a + b * b - 2 * a * b * mpc_math.cos(rad))\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them,\n    use the cosine theorem to compute the length of the third edge.\n    \"\"\"\n    return mpc_math.sqrt(a * a + b * b - sfix(2) * a * b * mpc_math.cos(rad))\n", "model_name": "azure-openai-o1"}
{"test_name": "lights_states", "response_0": "from Compiler.types import cint\n\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return 2 ** num\n", "response_1": "from Compiler.types import cint\n\ndef lights_states(num: cint):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    return 2 ** num\n", "model_name": "azure-openai-o1"}
{"test_name": "degree_to_radian", "response_0": "", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "Fah_to_Cel", "response_0": "from Compiler.types import sfix, cfix\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature in MP-SPDZ.\n    \"\"\"\n    return (F - cfix(32)) / cfix(1.8)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - cfix(32)) / cfix(1.8)\n", "model_name": "azure-openai-o1"}
{"test_name": "elliptic_area", "response_0": "from Compiler.types import sfix, cfix\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic,\n    return its area.\n    \"\"\"\n    PI = cfix(3.141592653589793)\n    return PI * a * b\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the ellipse, return its area.\n    \"\"\"\n    pi = cfix(3.141592653589793)\n    return pi * a * b\n", "model_name": "azure-openai-o1"}
{"test_name": "floor", "response_0": "from Compiler.types import sfix\n\ndef floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # z.trunc() removes the fractional part towards zero, producing a sint\n    int_part = z.trunc()\n    # Check if z is negative\n    is_negative = (z < 0)\n    # Check if there's any fractional part\n    has_fraction = (z != int_part)\n    # We need to correct by one if z is negative and has fractional part\n    correction = is_negative.bit_and(has_fraction)\n    return int_part - correction\n", "response_1": "from Compiler.types import sint, sfix\n\ndef floor(z):\n    # This function returns the floor of a secret fixed-point number z\n    # by extracting its integer part and adjusting for negative values\n    # with a fractional component.\n    scale = 1 << z.f\n    truncated_toward_zero = z.v >> z.f            # Truncate toward zero\n    fraction_part_nonzero = (z.v & (scale - 1)) != 0\n    is_neg = z < 0\n    adjustment = is_neg.bit_and(fraction_part_nonzero)\n    return truncated_toward_zero - adjustment\n", "model_name": "azure-openai-o1"}
{"test_name": "log_and_cube", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    log_val = mpc_math.log_fx(x, 2)\n    return mpc_math.pow_fx(log_val, 3)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    log_val = mpc_math.log_fx(x, 2)\n    return mpc_math.pow_fx(log_val, 3)\n", "model_name": "azure-openai-o1"}
{"test_name": "floor_and_square", "response_0": "from Compiler.types import cfix\n\ndef floor_and_square(z):\n    # Use integer floor division by 1 to emulate floor on a cfix value\n    floor_z = z // cfix(1)\n    # Square the floored result\n    return floor_z * floor_z\n", "response_1": "from Compiler.types import sfix, sint\n\ndef floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    # Truncate toward zero (returns a secret integer)\n    truncated_value = z.to_sint()\n    \n    # Check whether the original number is negative\n    # and has a fractional part\n    is_negative = (z < 0)\n    has_fraction = (z != truncated_value)\n\n    # We only need to subtract 1 if z is negative and not an integer\n    correction = is_negative.bit_and(has_fraction)\n\n    # floor_value is the greatest integer not greater than z\n    floor_value = truncated_value - correction\n\n    # Return its square\n    return floor_value * floor_value\n", "model_name": "azure-openai-o1"}
{"test_name": "meters_to_feet", "response_0": "from Compiler.types import sfix, cfix\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * cfix(3.2808)\n", "response_1": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * sfix(3.2808)\n", "model_name": "azure-openai-o1"}
{"test_name": "sphere_area", "response_0": "from Compiler.types import sfix, cfix\n\n# Define a convenient approximation for \u03c0 as a clear fixed-point number\nPI = cfix(3.141592653589793)\n\ndef sphere_area(r):\n    \"\"\"\n    Return the surface area of a sphere with radius r (sfix or cfix).\n    \"\"\"\n    # r**2 is valid directly in MP-SPDZ for sfix/cfix,\n    # yielding sfix/cfix respectively.\n    return cfix(4) * PI * (r * r)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    pi = cfix(3.141592653589793)\n    return cfix(4) * pi * (r * r)\n", "model_name": "azure-openai-o1"}
{"test_name": "coarse_abs", "response_0": "from Compiler.types import sfix, sint\n\ndef coarse_abs(x):\n    # Return the absolute value of x (sfix) and floor it (round down to integer).\n    # abs(x) remains sfix. Its internal representation is a secret integer v\n    # scaled by 2^f. Shifting right by f bits produces the integer part.\n    temp = abs(x)         # sfix\n    return temp.v >> temp.f  # sint (floor of absolute value)\n", "response_1": "from Compiler.types import sfix\n\ndef coarse_abs(x):\n    y = x.abs()\n    return y.v >> sfix.f\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_chickens", "response_0": "", "response_1": "from Compiler.types import sint\n\ndef how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - (legs - heads * 2)//2\n", "model_name": "azure-openai-o1"}
{"test_name": "interest_calculator", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank,\n    calculate the interest you can get.\n    \"\"\"\n    return (mpc_math.pow_fx(sfix(1) + ratio, months) - sfix(1)) * capital\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank,\n    calculate the interest you can get.\n    \"\"\"\n    return (mpc_math.pow_fx(sfix(1) + ratio, months) - sfix(1)) * capital\n", "model_name": "azure-openai-o1"}
{"test_name": "circle_area", "response_0": "from Compiler.types import sfix, cfix\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = cfix(3.141592653589793)\n    return pi * (r * r)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = cfix(3.141592653589793)\n    return pi * (r ** 2)\n", "model_name": "azure-openai-o1"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    return mpc_math.sqrt(mpc_math.pow_fx(x, 3))\n", "response_1": "from Compiler.library import mpc_math\n\ndef cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    temp = mpc_math.pow_fx(x, 3)\n    return mpc_math.sqrt(temp)\n", "model_name": "azure-openai-o1"}
{"test_name": "round", "response_0": "from Compiler.types import sfix\n\ndef round_sfix(x):\n    \"\"\"\n    Round x (sfix) to the nearest integer (sint).\n    Replicates: x_int = floor(x); return x_int if (x - x_int) < 0.5 else x_int + 1\n    \"\"\"\n    x_trunc = x.to_sint()                               # truncate toward zero\n    x_floor = ((x < 0) & (x != x_trunc)).if_else(x_trunc - 1, x_trunc) \n    fraction = x - x_floor\n    return (fraction < 0.5).if_else(x_floor, x_floor + 1)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef floor_sfix(x):\n    # x is stored as x.v, the fixed-point value shifted by x.f bits\n    x_int_raw = x.v >> x.f\n    return sfix(x_int_raw)\n\ndef round_fx(x):\n    x_int = floor_sfix(x)\n    frac_part = x - x_int\n    is_less_than_half = frac_part < cfix(0.5)\n    return is_less_than_half.if_else(x_int, x_int + sfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "cryptic_adjustment", "response_0": "from Compiler.types import sfix, cfix\nimport mpc_math\n\ndef cryptic_adjustment(origin):\n    # The professor wants to adjust the pessimistic score of his students mid-term exam.\n    # The adjustment formula is 10*sqrt(10*sqrt(origin))\n    return cfix(10) * mpc_math.sqrt(cfix(10) * mpc_math.sqrt(origin))\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef cryptic_adjustment(origin: sfix) -> sfix:\n    \"\"\"\n    The professor wants to adjust the pessimistic score of his students' mid-term exam.\n    The adjustment formula is 10 * sqrt(10 * sqrt(origin))\n    \"\"\"\n    return sfix(10) * mpc_math.sqrt(sfix(10) * mpc_math.sqrt(origin))\n", "model_name": "azure-openai-o1"}
{"test_name": "specific_pow", "response_0": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5).\n    \"\"\"\n    return mpc_math.pow_fx(x, 2.5)\n", "response_1": "", "model_name": "azure-openai-o1"}
{"test_name": "soft_plus", "response_0": "# Import necessary modules\nimport mpc_math\nfrom Compiler.types import sfix, cfix\n\n# Define a constant for e (Euler's number)\nE = cfix(2.718281828459045)\n\ndef soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    # Compute 1 + e^x\n    temp = 1 + mpc_math.pow_fx(E, x)\n    # Return ln(1 + e^x) by taking log base e\n    return mpc_math.log_fx(temp, E)\n", "response_1": "from Compiler.types import sfix, cfix\nimport mpc_math\n\ndef soft_plus(x: sfix):\n    e = cfix(2.718281828459045)\n    return mpc_math.log_fx(1 + mpc_math.pow_fx(e, x), e)\n", "model_name": "azure-openai-o1"}
{"test_name": "ball_volume", "response_0": "from Compiler.types import sfix, cfix\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    pi = cfix(3.141592653589793)\n    return pi * (r ** 3) * cfix(4.0) / cfix(3.0)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef ball_volume(r):\n    pi = cfix(3.141592653589793)\n    return pi * (r ** 3) * cfix(4) / cfix(3)\n", "model_name": "azure-openai-o1"}
{"test_name": "Heron", "response_0": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef Heron(a, b, c):\n    p = (a + b + c) / sfix(2)\n    return mpc_math.sqrt(p * (p - a) * (p - b) * (p - c))\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef Heron(a, b, c):\n    p = (a + b + c) / sfix(2)\n    return mpc_math.sqrt(p * (p - a) * (p - b) * (p - c))\n", "model_name": "azure-openai-o1"}
{"test_name": "next_perfect_square", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler import mpc_math\n\ndef next_perfect_square(x):\n    # Convert to secret fixed-point for sqrt computation\n    x_sfix = sfix(x)\n    # Compute approximate square root\n    approximate_sqrt = mpc_math.sqrt(x_sfix)\n    # Floor by shifting out fractional parts\n    floor_sqrt = approximate_sqrt.v >> sfix.f\n    # Add one and square\n    next_val = floor_sqrt + 1\n    return next_val * next_val\n", "response_1": "from Compiler.types import sint, sfix\nfrom Compiler.library import mpc_math\n\ndef next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x.\n    The input x is assumed to be a positive secret integer (sint).\n    \"\"\"\n    # Convert x to secret fixed-point.\n    xf = sfix(x)\n    \n    # Compute approximate square root in sfix.\n    approx_sqrt = mpc_math.sqrt(xf)\n    \n    # Convert approximate square root to a secret integer by rounding.\n    # (This uses the internal representation: .v is the underlying secret integer,\n    # and sfix.f is the fractional precision.)\n    scale_factor = (1 << sfix.f)\n    rounded_sqrt = (approx_sqrt.v + (scale_factor // 2)) >> sfix.f\n    \n    # Adjust if the rounded value is too large.\n    # \"too_big\" is a secret bit: 1 if (rounded_sqrt)^2 > x, else 0.\n    too_big = (rounded_sqrt * rounded_sqrt > x)\n    floor_sqrt = rounded_sqrt - too_big\n    \n    # The next perfect square bigger than x is (floor_sqrt + 1)^2.\n    return (floor_sqrt + 1) * (floor_sqrt + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "pi_to_the_x", "response_0": "", "response_1": "from Compiler.types import sfix, cfix\nimport mpc_math\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    pi_val = cfix(3.141592653589793)\n    return mpc_math.pow_fx(pi_val, x)\n", "model_name": "azure-openai-o1"}
{"test_name": "spring_rocket", "response_0": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef spring_rocket(height, m, k):\n    g = sfix(9.8)\n    return mpc_math.sqrt(sfix(2) * m * g * height / k)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height.\n    You should return the minimum length the spring should be compressed.\n    Assume g = 9.8\n    \"\"\"\n    g = sfix(9.8)\n    return mpc_math.sqrt((2 * m * g * height) / k)\n", "model_name": "azure-openai-o1"}
{"test_name": "cone_volume", "response_0": "from Compiler.types import sfix, cfix\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = cfix(3.141592653589793)\n    return (pi * r * r * h) / cfix(3)\n", "response_1": "from Compiler.types import sfix, cfix\n\ndef cone_volume(r, h):\n    # Define pi as a clear fixed-point number.\n    pi = cfix(3.141592653589793)\n    # Compute the volume as pi * r^2 * h / 3\n    return (pi * r * r * h) / cfix(3)\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_rabbits", "response_0": "from Compiler.types import sint\n\ndef how_many_rabbits(heads: sint, legs: sint) -> sint:\n    # Compute the number of rabbits in the rabbit-chicken problem.\n    return (legs - heads * 2) // 2\n", "response_1": "from Compiler.types import cint\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "model_name": "azure-openai-o1"}
