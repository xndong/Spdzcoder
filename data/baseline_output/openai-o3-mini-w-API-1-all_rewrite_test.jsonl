{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    # Assume arr is an Array (or similar container) with a clear length (public int)\n    n = len(arr)  # the array length is known at compile-time\n    new_arr = arr.same_shape()  # create a new array with the same shape and value type as arr\n    # Copy elements up until the given index.\n    for i in range(index):\n        new_arr[i] = arr[i]\n    # Shift elements after 'index' one position left.\n    for i in range(index, n - 1):\n        new_arr[i] = arr[i + 1]\n    # Place the removed element at the end.\n    new_arr[n - 1] = arr[index]\n    return new_arr\n", "response_1": "from Compiler.types import sint, Array\n\ndef move_to_end(arr, index):\n    n = len(arr)\n    left = Array.create_from(arr[:index])\n    right = Array.create_from(arr[index+1:n])\n    last = Array.create_from([arr[index]])\n    return left.concat(right).concat(last)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "second_largest", "response_0": "from Compiler.types import cint\n\ndef second_largest(arr):\n    # Assume that arr is a cint.Array or a Python list of cint elements.\n    n = len(arr)\n    for i in range(2, n):\n        # Use clear comparisons since we assume arr\u2019s elements are clear integers.\n        if (arr[i] > arr[0]) or (arr[i] > arr[1]):\n            # Determine the index of the smaller element\n            if arr[0] < arr[1]:\n                idx = 0\n            else:\n                idx = 1\n            arr[idx] = arr[i]\n    # Return the smaller one of the two candidates\n    if arr[0] < arr[1]:\n        return arr[0]\n    else:\n        return arr[1]\n", "response_1": "from Compiler.types import cint\n\ndef second_largest(arr):\n    # Assuming arr is a clear integer array (cint.Array or a list of cint objects)\n    n = len(arr)\n    for i in range(2, n):\n        # Compare element arr[i] with both candidates at arr[0] and arr[1]\n        if arr[i] > arr[0] or arr[i] > arr[1]:\n            # Choose index idx corresponding to the smaller current candidate.\n            if arr[0] < arr[1]:\n                idx = 0\n            else:\n                idx = 1\n            arr[idx] = arr[i]\n    if arr[0] < arr[1]:\n        return arr[0]\n    else:\n        return arr[1]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_true", "response_0": "from Compiler.types import sint\nfrom Compiler.library.tree_reduce import tree_reduce\n\ndef exists_true(arr):\n    # If the array is empty, return false (represented as sint(0))\n    if len(arr) == 0:\n        return sint(0)\n    # Reduce the array with the bit_or operation to check for any True value.\n    result = tree_reduce(lambda x, y: x.bit_or(y), arr)\n    return result\n", "response_1": "from Compiler.library import tree_reduce\n\ndef exists_true(arr):\n    # arr is assumed to be a sequence of secret boolean values (e.g. sbitint)\n    ret = tree_reduce(lambda x, y: x.bit_or(y), arr)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size as the input \"arr\".\n    For each element in \"arr\", the corresponding element in the returned\n    array is set to the value obtained by applying \"predicator\".\n    \"\"\"\n    ret = []\n    # Iterate over the vector \"arr\". In MP-SPDZ, container types support iteration.\n    for e in arr:\n        ret.append(predicator(e))\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_indicator(arr, predicator):\n    # Create a new array with the same shape and type as arr.\n    ret = arr.same_shape()\n    # Iterate over each index to apply the predicator on arr's element.\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    # Compute the inner product of two vectors (each element-wise multiplication is secret if the elements are secret)\n    summation = vec1[0] * vec2[0]\n    for i in range(1, len(vec1)):\n        summation = summation + vec1[i] * vec2[i]\n    return summation\n", "response_1": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    # Compute the inner product of the two secret integer arrays.\n    result = sint(0)\n    n = len(vec1)\n    for i in range(n):\n        result = result + vec1[i] * vec2[i]\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_shift_2", "response_0": "from Compiler.types import sint\n\ndef array_shift(a):\n    # Get the length of array a (compile-time constant)\n    n = len(a)\n    # Create a new array of the same shape as a\n    shifted = a.same_shape()\n    # For each index, assign the element from a with rotated index\n    for i in range(n):\n        shifted[i] = a[(i - 1) % n]\n    return shifted\n", "response_1": "from Compiler.types import sint\n\ndef array_shift(a):\n    # Assume that 'a' is an Array of secret integers with a known public length n.\n    n = len(a)  # the length of the array (a compile\u2010time public integer)\n    # Create a new Array with the same shape as a.\n    shifted = a.same_shape()\n    for i in range(n):\n        # Use modular arithmetic with a public modulus n to perform the shift.\n        shifted[i] = a[(i - 1) % n]\n    return shifted\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.types import sint\n\ndef array_greater_than_scalar(arr, bound):\n    # Create a list to hold the secret boolean bits (produced by comparisons)\n    ret = [None] * len(arr)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = [None] * n\n    for i in range(n):\n        # The comparison returns a secret bit (sbitint) indicating if arr[i] > bound.\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_rises_2", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr):\n    # Initialize count as a secret integer zero.\n    count = sint(0)\n    n = len(arr)\n    # Loop through the array indices.\n    for i in range(n - 1):\n        # Compute the secret bit: 1 if arr[i] < arr[i+1] else 0.\n        # Note: The comparison yields a secret bit on which we use if_else.\n        count += (arr[i] < arr[i+1]).if_else(1, 0)\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_rises(arr):\n    # Initialize count as a secret integer zero\n    count = sint(0)\n    # Loop over indices from 0 to len(arr)-2\n    for i in range(len(arr) - 1):\n        # Compute a secret bit: 1 if arr[i] < arr[i+1], else 0,\n        # using the if_else method on the secret comparison bit.\n        indicator = (arr[i] < arr[i+1]).if_else(sint(1), sint(0))\n        count += indicator\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    # Assuming 'arr' is an Array of secret integers (sint)\n    for i in range(len(arr)):\n        # i is public so we can decide the branch directly\n        if i % 2:\n            # For odd index: increment the element by 1\n            arr[i] = arr[i] + 1\n        else:\n            # For even index: decrement the element by 1\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    # Determine the length of the input array\n    n = len(arr)\n    # Create a new list to hold the modified results\n    res = [None] * n\n    for i in range(n):\n        # For odd index (i is public), increment by 1\n        if i % 2 == 1:\n            res[i] = arr[i] + 1\n        # For even index, decrement by 1\n        else:\n            res[i] = arr[i] - 1\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sint\n\ndef how_many_roots(a, b, c):\n    # Compute the discriminant: b^2 - 4*a*c\n    disc = b * b - 4 * a * c\n    # Evaluate: if a is zero then determine by b, else use discriminant\n    # For secret comparisons, the equality and inequality yield a secret bit,\n    # and we use the if_else method on it.\n    return ( (a == 0).if_else((b == 0).if_else(0, 1),\n                               (disc > 0).if_else(2, (disc == 0).if_else(1, 0))) )\n", "response_1": "from Compiler.types import sfix\n\ndef how_many_roots(a, b, c):\n    # a, b, c are of type sfix\n    disc = b * b - 4 * a * c\n    cond_a_zero = (a == 0)\n    cond_b_zero = (b == 0)\n    cond_disc_gt0 = (disc > 0)\n    cond_disc_eq0 = (disc == 0)\n    # When a is zero, check b: if b==0 then 0 roots, else 1 root.\n    roots_when_a_zero = cond_b_zero.if_else(0, 1)\n    # When a is non-zero, use the discriminant: if positive then 2,\n    # if zero then 1, else 0 roots.\n    roots_when_a_nonzero = cond_disc_gt0.if_else(2, cond_disc_eq0.if_else(1, 0))\n    return cond_a_zero.if_else(roots_when_a_zero, roots_when_a_nonzero)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    summation = sint(0)\n    for e in arr:\n        flag = predicator(e)\n        summation += flag\n    return summation\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    summation = sint(0)\n    for i in range(len(arr)):\n        # predicator should return 1 (satisfied) or 0 (not satisfied)\n        flag = predicator(arr[i])\n        summation += flag\n    return summation\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.library import tree_reduce\n\ndef traverse_and_sum(arr1, arr2):\n    # Compute the element-wise product of arr1 and arr2.\n    products = arr1 * arr2\n    # Sum all the products using a tree reduction.\n    return tree_reduce(lambda x, y: x + y, products)\n", "response_1": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    total = sint(0)\n    # Iterate over the pairs and accumulate the product\n    for x, y in zip(arr1, arr2):\n        total += x * y\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_round", "response_0": "from Compiler.types import cfix, cint\n\ndef array_round(arr):\n    # For each clear fixed\u2010point value e in arr,\n    # we add 0.5 and then convert to a clear integer,\n    # which is equivalent to rounding to the nearest integer.\n    ret = [cint(e + cfix(0.5)) for e in arr]\n    return ret\n", "response_1": "from Compiler.types import cfix\n\ndef array_round(arr):\n    # Assuming arr is a Python sequence of clear fixed\u2010point numbers (cfix),\n    # we round each element to its nearest integer.\n    ret = [cfix(round(x)) for x in arr]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater_eq", "response_0": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    # Assume arr and brr are of type sint.Array of equal length.\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # The comparison (arr[i] >= brr[i]) returns a secret bit.\n        # Use the if_else method to select 1 if true and 0 otherwise.\n        ret[i] = (arr[i] >= brr[i]).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = (arr[i] >= brr[i]).if_else(1, 0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # The comparison \"arr[i] < 0\" produces a secret bit.\n        # Use the if_else method to select 1 if negative, 0 otherwise.\n        ret[i] = (arr[i] < 0).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = [None] * n\n    for i in range(n):\n        # (arr[i] < 0) returns a secret bit; use if_else to select 1 if true, 0 otherwise\n        ret[i] = (arr[i] < 0).if_else(1, 0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b):\n    # Subtract the first array by the second one elementwise.\n    # If one of the arrays is shorter, pad the result with appropriate values.\n    n_a = len(a)\n    n_b = len(b)\n    pad_length = abs(n_a - n_b)\n    if n_a == n_b:\n        pad = []\n    elif n_a < n_b:\n        # When a is shorter, take the last pad_length elements of b,\n        # but subtract them (i.e. pad with their negation).\n        pad = [ -b[i] for i in range(n_b - pad_length, n_b) ]\n    else:\n        # When a is longer, take the extra elements from a unchanged.\n        pad = [ a[i] for i in range(n_a - pad_length, n_a) ]\n    # Subtract the common prefix elementwise.\n    common_diff = [ a[i] - b[i] for i in range(min(n_a, n_b)) ]\n    ret = common_diff + pad\n    return ret\n", "response_1": "def array_subtract(a, b):\n    # Subtract two arrays elementwise; pad with zeros if lengths differ.\n    # Here a and b are assumed to be lists of secret numbers (e.g., sint).\n    \n    n_a = len(a)\n    n_b = len(b)\n    pad_length = abs(n_a - n_b)\n    \n    if n_a == n_b:\n        pad = []\n    elif n_a < n_b:\n        pad = b[-pad_length:]\n    else:\n        pad = a[-pad_length:]\n    \n    if n_a <= n_b:\n        # For the case when a is shorter, pad with the negation of b's extra elements.\n        pad = [-e for e in pad]\n    else:\n        pad = [e for e in pad]\n    \n    # Compute elementwise subtraction on the overlapping part, then append padding.\n    result = [x - y for x, y in zip(a, b)] + pad\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    # Assuming 'arr' is a container (e.g. an Array) whose length is known at compile-time\n    n = len(arr)\n    # Iterate over each index and apply the provided function 'func'\n    for i in range(n):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "def array_process(arr, func):\n    # Process all elements in the input array with the given function.\n    n = len(arr)\n    # Create a new list to store processed elements\n    processed = [0] * n\n    for i in range(n):\n        processed[i] = func(arr[i])\n    return processed\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_shift", "response_0": "from Compiler.types import sint\n\ndef array_shift(a):\n    # 'a' is assumed to be an Array (e.g. sint.Array(n)) of known length.\n    n = len(a)\n    # Get the last element as a one\u2010element array\n    last_element = a.get_part(n - 1, 1)\n    # Get all the other elements except the last one\n    first_part = a.get_part(0, n - 1)\n    # Concatenate last element with the rest so that the array is cyclically shifted\n    shifted = last_element.concat(first_part)\n    return shifted\n", "response_1": "from Compiler.types import sint\n\ndef array_shift(a):\n    # Assume a is a sint.Array with compile-time known length n.\n    n = len(a)  # n is known at compile time\n    # Get the last element (a tail) and the remaining head\n    tail = a.get_part(n - 1, 1)\n    head = a.get_part(0, n - 1)\n    # Concatenate tail in front of head to achieve a cyclic shift\n    shifted = tail.concat(head)\n    return shifted\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "compare_and_select", "response_0": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    # The output array will store the element-wise maximum of a and b.\n    ret = []\n    for i in range(len(a)):\n        # The comparison returns a secret bit (of type sint's comparison result).\n        cmp_bit = a[i] > b[i]\n        # Use the if_else operator on the secret bit to choose the larger value.\n        ret.append(cmp_bit.if_else(a[i], b[i]))\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    # Compare two arrays elementwise and select the larger value.\n    ret_array = []\n    for x, y in zip(a, b):\n        # The comparison (x > y) returns a secret bit.\n        cmp_bit = (x > y)\n        # Use the secret bit's if_else to select x if cmp_bit is 1, else y.\n        ret_array.append(cmp_bit.if_else(x, y))\n    return ret_array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_subtract", "response_0": "from Compiler.types import cfix\n\ndef array_subtract(a, b):\n    # a and b are expected to be Python lists (or Arrays converted to Python lists)\n    if len(a) < len(b):\n        pad = [cfix(0.0)] * (len(b) - len(a))\n        a = a + pad\n    else:\n        pad = [cfix(0.0)] * (len(a) - len(b))\n        b = b + pad\n    ret = [x - y for x, y in zip(a, b)]\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    if len(a) < len(b):\n        pad_len = len(b) - len(a)\n        pad = [sfix(0)] * pad_len\n        a = a + pad\n    elif len(b) < len(a):\n        pad_len = len(a) - len(b)\n        pad = [sfix(0)] * pad_len\n        b = b + pad\n\n    ret = [ x - y for x, y in zip(a, b) ]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    # Repeat the input array by concatenating it with itself in MP-SPDZ\n    return c.concat(c)\n", "response_1": "def repeat_array(c):\n    # Repeat the input array by concatenating it to itself.\n    return c.concat(c)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "zeros", "response_0": "from Compiler.types import cint\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    a = cint.Array(num)\n    a.assign_all(0)\n    return a\n", "response_1": "from Compiler.types import cint\n\ndef zeros(num):\n    # Create a clear integer Array of length num and assign 0 to all entries.\n    a = cint.Array(num)\n    a.assign_all(0)\n    return a\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    # Convert public bounds to sfix type for secure arithmetic\n    ub = sfix(upper_bound)\n    lb = sfix(lower_bound)\n    res = []\n    for x in arr:\n        # Compute secret bits for the comparisons\n        cond_upper = x >= ub   # returns a secret bit (sbitint)\n        cond_lower = x > lb    # returns a secret bit (sbitint)\n        # Use nested if_else: if x >= ub then ub, else if x > lb then x, else lb.\n        y = cond_upper.if_else(ub, cond_lower.if_else(x, lb))\n        res.append(y)\n    return res\n", "response_1": "from Compiler.types import sfix\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    Clip all elements in arr to the range [lower_bound, upper_bound].\n    For each element x in arr, if x >= upper_bound then use upper_bound,\n    else if x > lower_bound then use x, otherwise use lower_bound.\n    \"\"\"\n    res = []\n    for x in arr:\n        # First branch: if x >= upper_bound, then choose upper_bound.\n        # Otherwise, choose between x and lower_bound using x > lower_bound.\n        # The if_else method selects the first argument if the secret bit is 1,\n        # and the second argument if it is 0.\n        clipped = (x >= upper_bound).if_else(upper_bound, (x > lower_bound).if_else(x, lower_bound))\n        res.append(clipped)\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_satisfied_2", "response_0": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    count = sint(0)\n    for i in range(len(arr)):\n        count = count + predicator(arr[i])\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    total = sint(0)\n    for i in range(len(arr)):\n        flag = predicator(arr[i])\n        total = total + flag\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    # Assume arr is a Python list (or MP-SPDZ Array) of 'sint' and its length is public.\n    count = sint(0)\n    n = len(arr)\n    # Iterate over indices using public values.\n    for i in range(n):\n        for j in range(i+1, n):\n            # The '>' operator returns a secret bit (of type sbitint)\n            cond = arr[i] > arr[j]\n            # Use secret if_else to add 1 if condition holds, otherwise 0.\n            count += cond.if_else(sint(1), sint(0))\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    n = len(arr)\n    count = sint(0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            count = count + (arr[i] > arr[j])\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    # In MP-SPDZ, if \"arr\" is an array/vector of a basic type (for example, a sint register vector),\n    # then element\u2010wise addition is directly supported.\n    # Thus, we can simply return \"arr + 1\" to increment every element.\n    return arr + 1\n", "response_1": "from Compiler.types import sint\n\ndef array_inc(arr):\n    # Increment every element of the input array by 1 and return a new array.\n    # Assume 'arr' is a list or an MP-SPDZ Array of type sint.\n    result = [arr[i] + 1 for i in range(len(arr))]\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr):\n    count = sint(0)\n    n = len(arr)\n    for i in range(n - 1):\n        # The comparison \u201c<\u201d on secret integers returns a secret bit.\n        count += arr[i] < arr[i+1]\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_rises(arr):\n    # count is maintained as a secret integer\n    n = len(arr)\n    count = sint(0)\n    for i in range(n - 1):\n        # The comparison (arr[i] < arr[i+1]) returns a secret bit (0 or 1),\n        # which can be used in arithmetic.\n        count += arr[i] < arr[i+1]\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process_2", "response_0": "def array_process(arr, func):\n    # Process each element of the array with the provided function\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "def array_process(arr, func):\n    # Process all elements in the MP-SPDZ array (or list of registers)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "two_norm", "response_0": "from Compiler import mpc_math\n\ndef two_norm(vec):\n    # Compute the element-wise squares of the vector.\n    squared = [x * x for x in vec]\n    # Sum the squares, then compute and return the square root of the sum.\n    return mpc_math.sqrt(sum(squared))\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Compute the square of each element.\n    squares = [x * x for x in vec]\n    total = sfix(0)\n    for value in squares:\n        total += value\n    return mpc_math.sqrt(total)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "totally_dominate", "response_0": "from Compiler.library.tree_reduce import tree_reduce\n\ndef totally_dominate(a, b):\n    # Compute the minimum element of array a using tree reduction.\n    a_min = tree_reduce(lambda x, y: x.min(y), a)\n    # Compute the maximum element of array b using tree reduction.\n    b_max = tree_reduce(lambda x, y: x.max(y), b)\n    # Return whether a_min is greater than or equal to b_max. This comparison\n    # yields a secret bit (0/1) according to MP-SPDZ semantics.\n    return a_min >= b_max\n", "response_1": "from Compiler.library import tree_reduce\n\ndef totally_dominate(a, b):\n    # Compute the minimum element in a by performing a tree reduction with the 'min' method.\n    a_min = tree_reduce(lambda x, y: x.min(y), a)\n    # Compute the maximum element in b by performing a tree reduction with the 'max' method.\n    b_max = tree_reduce(lambda x, y: x.max(y), b)\n    # Return whether every element in a is at least every element in b.\n    return a_min >= b_max\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inner_product_2", "response_0": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    # Compute the inner product of two secret vectors.\n    summation = vec1[0].__class__(0)  # Initialize summation with 0 of the appropriate secret type.\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "response_1": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    summation = 0\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    # 'a' is assumed to be an Array of a basic type.\n    ret = []\n    for i in indices:\n        ret.append(a[i])\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    # 'a' is assumed to be an Array of some basic type and 'indices' is a Python list of public integer indices.\n    ret = []    # Initialize an ordinary Python list for the resulting subarray.\n    for i in indices:\n        ret.append(a[i])   # Indexing into the Array 'a' is allowed with a public integer.\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    # Initialize a secret boolean flag (0 for False, 1 for True)\n    result = sint(0)\n    # Iterate over the array and update the result using secret bitwise OR\n    for item in arr:\n        # Compute (item == 5) OR (item == 7) using bit-level OR\n        cond = (item == 5).bit_or(item == 7)\n        result = result.bit_or(cond)\n    return result\n", "response_1": "from Compiler.types import cint\n\ndef exists_5_or_7(arr):\n    # Initialize a flag as a clear integer 0 (false)\n    flag = cint(0)\n    # Loop over every element in the array\n    for item in arr:\n        # Compute condition: item equals 5 OR item equals 7.\n        # In MP-SPDZ, boolean OR of secret/clear bits is done using the bit_or operator.\n        cond = (item == 5).bit_or(item == 7)\n        # Aggregate the condition with bitwise OR.\n        flag = flag.bit_or(cond)\n    # The returned flag is 1 if any item equals 5 or 7, and 0 otherwise.\n    return flag\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    # Obtain the left part of the array: from 0 up to (but not including) index\n    left = arr[:index]\n    # Obtain the right part of the array: from index+1 to the end\n    right = arr[index+1:]\n    # Concatenate the two parts. Since slicing on an array yields a Python list\n    # of registers and list concatenation is the normal Python list concatenation,\n    # we obtain the resulting list without the element at the given index.\n    ret_list = left + right\n    # Convert the Python list back into an MP-SPDZ Array using create_from.\n    ret = arr.__class__.create_from(ret_list)\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    # Obtain the first part from index 0 up to (but not including) the index to remove.\n    first_part = arr.get_part(0, index)\n    # Obtain the second part from index+1 to the end.\n    second_part = arr.get_part(index + 1, len(arr) - index - 1)\n    # Concatenate the two parts.\n    ret = first_part.concat(second_part)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "average", "response_0": "from Compiler.types import sfix\n\ndef average(arr):\n    # Compute the summation of all elements in the array 'arr'\n    summation = sfix(0)\n    for i in range(len(arr)):\n        summation = summation + arr[i]\n    # Divide the summation by the public length\n    ret = summation / len(arr)\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef average(arr):\n    # Compute the average value of the array of sfix numbers.\n    summation = sfix(0)\n    for i in range(len(arr)):\n        summation += arr[i]\n    length = len(arr)\n    ret = summation / length\n    return ret\n", "model_name": "azure-openai-o3-mini"}
