{"test_name": "indicate_positive", "response_0": "from Compiler.types import sint\n\ndef indicate_positive(arr):\n    # Create an output array of the same length as arr.\n    ret = sint.Array(len(arr))\n    for i in range(len(arr)):\n        # The comparison returns a secret bit.\n        indicator = arr[i] > 0\n        # Use the bit's if_else to select 1 if true, 0 otherwise.\n        ret[i] = indicator.if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_positive(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # Compute a secret indicator: if arr[i] > 0 then 1, otherwise 0.\n        ret[i] = (arr[i] > 0).if_else(1, 0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_xor", "response_0": "from Compiler.types import sint\n\ndef array_xor(a, b):\n    # Compute the elementwise XOR of the two input vectors\n    n = len(a)\n    ret = []\n    for i in range(n):\n        # Using the overloaded XOR operator on secret integers (assumed to be bits)\n        ret.append(a[i] ^ b[i])\n    return ret\n", "response_1": "def array_xor(a, b):\n    # Compute the elementwise XOR between two secret vectors.\n    ret = [0 for _ in range(len(a))]\n    for i in range(len(a)):\n        ret[i] = a[i] ^ b[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "interlaced_placement", "response_0": "from Compiler.types import sint\n\ndef interlaced_placement(a, b):\n    # Assume a and b are sint.Array with equal known length\n    n = len(a)\n    ret = sint.Array(2 * n)\n    for i in range(2 * n):\n        if i % 2:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef interlaced_placement(a, b):\n    \"\"\"\n    Interleave the elements in two sequences.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(a)\n    # Initialize ret as a list of secret integers (sint) with 0's\n    ret = [sint(0)] * (n * 2)\n    for i in range(n * 2):\n        # For odd i, take element from b, for even i, take from a.\n        if i % 2:\n            ret[i] = b[(i - 1) // 2]\n        else:\n            ret[i] = a[i // 2]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_and", "response_0": "def array_and(a, b):\n    # Compute the elementwise bitwise AND of two secret-bit vectors.\n    ret = [None] * len(a)\n    for i in range(len(a)):\n        ret[i] = a[i].bit_and(b[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_and(a, b):\n    # Compute the elementwise AND of the two input vectors.\n    ret = [sint(0) for _ in range(len(a))]\n    for i in range(len(a)):\n        ret[i] = a[i].bit_and(b[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_indicator", "response_0": "from Compiler.types import sint\n\ndef array_indicator(arr, predicator):\n    n = len(arr)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "from Compiler.types import Array\n\ndef array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size as the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    n = len(arr)\n    ret = [False for _ in range(n)]\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.types import sfix\n\ndef array_greater_than_scalar(arr, bound):\n    # Assume 'arr' is an iterable (e.g. an Array of sfix) and 'bound' is a sfix value.\n    n = len(arr)\n    ret = [None] * n\n    for i in range(n):\n        # Comparing two sfix values returns a secret bit (of type sbitint)\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound, \n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_no_greater_than_scalar", "response_0": "from Compiler.types import sint\n\ndef array_no_greater_than_scalar(arr, bound):\n    length = len(arr)\n    ret = [sint(0) for _ in range(length)]\n    for i in range(length):\n        # The comparison \u201c<=\u201d returns a secret bit (sbitint), which can be used as a boolean value.\n        ret[i] = arr[i] <= bound\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_no_greater_than_scalar(arr, bound):\n    # Create a result list to hold secret Boolean values.\n    ret = [None] * len(arr)\n    for i in range(len(arr)):\n        ret[i] = arr[i] <= bound\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "reverse_and_concat", "response_0": "def reverse_and_concat(a):\n    # Obtain a reversed version of 'a' using the built-in get_reverse_vector() method.\n    reversed_a = a.get_reverse_vector()\n    # Concatenate the original array and its reversed copy.\n    return a.concat(reversed_a)\n", "response_1": "def reverse_and_concat(a):\n    # Reverse the input array using the built-in get_reverse_vector() method\n    a_rev = a.get_reverse_vector()\n    # Concatenate the original array with its reverse using the concat() method\n    return a.concat(a_rev)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_round", "response_0": "from Compiler.types import cfix\n\ndef array_round(arr):\n    # Rounds each element in the clear fixed\u2010point array arr to the nearest integer.\n    n = len(arr)\n    ret = cfix.Array(n)\n    for i in range(n):\n        # Obtain the integer part using truncation, assuming nonnegative numbers.\n        int_part = int(arr[i])\n        # Compute the difference between the original number and its integer part.\n        diff = arr[i] - cfix(int_part)\n        # Compare the fractional part to 0.5.\n        if diff < cfix(0.5):\n            ret[i] = cfix(int_part)\n        else:\n            ret[i] = cfix(int_part + 1)\n    return ret\n", "response_1": "from Compiler.types import cfix\n\ndef array_round(arr):\n    # Round every element in the array (of clear fixed\u2010point numbers) to the nearest integer.\n    ret = [cfix(0)] * len(arr)\n    for i in range(len(arr)):\n        # Compute the floor of arr[i] via its floor division by 1.\n        int_part = arr[i] // cfix(1)\n        # Check if the fractional part is less than 0.5.\n        # If so, the rounded value is equal to int_part,\n        # otherwise we add 1.\n        if (arr[i] - int_part) < cfix(0.5):\n            ret[i] = int_part\n        else:\n            ret[i] = int_part + cfix(1)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater_eq", "response_0": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    # arr and brr are assumed to be lists/arrays of secret integers (sint)\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # The comparison \"arr[i] >= brr[i]\" results in a secret bit.\n        # We use the if_else method to branchlessly select 1 or 0.\n        ret[i] = (arr[i] >= brr[i]).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater_eq(arr, brr):\n    # assume arr and brr have the same length\n    n = len(arr)\n    ret = [None] * n\n    # For each index i, check if arr[i] >= brr[i]\n    # The comparison returns a secret bit; we use if_else to select 1 or 0.\n    for i in range(n):\n        ret[i] = (arr[i] >= brr[i]).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "reverse", "response_0": "def reverse(arr):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    # Create a new array with the same shape and type as arr.\n    ret = arr.same_shape()\n    n = len(arr)\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "response_1": "def reverse(arr):\n    \"\"\"\n    Reverse the array.\n    \"\"\"\n    ret = arr.same_shape()  # create a new Array of the same shape and type as arr\n    n = len(arr)            # the length is a public integer (compile-time constant)\n    for i in range(n):\n        ret[i] = arr[n - 1 - i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = (arr[i] < 0).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # Compute secret condition: 1 if arr[i] is negative, 0 otherwise.\n        ret[i] = (arr[i] < 0).if_else(1, 0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_sub_sequence", "response_0": "from Compiler.types import sfix\n\ndef max_sub_sequence(arr):\n    # Assume arr is a list of sfix numbers and its length is known at compile time.\n    n = len(arr)\n    partial_max = [sfix(0) for _ in range(n)]\n    suffix_max = [sfix(0) for _ in range(n)]\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    for i in range(1, n):\n        # Compute candidate for suffix_max: either continue previous subsequence or start new subsequence\n        tmp = suffix_max[i-1] + arr[i]\n        # Compare suffix_max[i-1] with 0. The result is a secret bit.\n        cond = suffix_max[i-1] >= sfix(0)\n        suffix_max[i] = cond.if_else(tmp, arr[i])\n        # partial_max stores the max so far: compare previous partial_max and current suffix_max.\n        cond2 = partial_max[i-1] >= suffix_max[i]\n        partial_max[i] = cond2.if_else(partial_max[i-1], suffix_max[i])\n    return partial_max[n - 1]\n", "response_1": "from Compiler.types import sint\n\ndef max_sub_sequence(arr):\n    # determine the length of the array (assumed to be known at compile-time)\n    n = len(arr)\n    # create two arrays to hold the dynamic programming values\n    partial_max = sint.Array(n)\n    suffix_max = sint.Array(n)\n    # initialize the first element of both arrays\n    partial_max[0] = arr[0]\n    suffix_max[0] = arr[0]\n    # iterate over the array from index 1 to n-1\n    for i in range(1, n):\n        # Compute the new suffix maximum: if the previous suffix_max is non-negative,\n        # then add the current element; otherwise, restart from the current element.\n        cond = suffix_max[i-1] >= 0   # returns a secret bit (sintbit)\n        suffix_max[i] = cond.if_else(suffix_max[i-1] + arr[i], arr[i])\n        # Update the overall partial maximum accordingly\n        cond2 = partial_max[i-1] >= suffix_max[i]\n        partial_max[i] = cond2.if_else(partial_max[i-1], suffix_max[i])\n    # return the final computed maximum subsequence sum\n    return partial_max[n-1]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "compare_and_select", "response_0": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    # a and b are assumed to be sint.Array of the same public length\n    ret = sint.Array(len(a))\n    for i in range(len(a)):\n        # The comparison operator \">\" returns a secret bit (sbitint)\n        cond = a[i] > b[i]\n        # Obliviously select a[i] if cond is 1, otherwise b[i]\n        ret[i] = cond.if_else(a[i], b[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef compare_and_select(a, b):\n    # Assume that 'a' and 'b' are lists (or Arrays) of a secret integer type (sint)\n    # This function returns an element-wise maximum array where each element is chosen\n    # via a secret conditional using if_else.\n    n = len(a)\n    ret = [None] * n\n    for i in range(n):\n        # The comparison (a[i] > b[i]) returns a secret bit; use if_else for selection.\n        ret[i] = (a[i] > b[i]).if_else(a[i], b[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_element_frequency", "response_0": "from Compiler.types import sint\n\ndef count_element_frequency(l):\n    # assume l is a Python list of secret integers (sint)\n    n = len(l)\n    # initialize frequency array with sint(0)\n    freq = [sint(0) for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            # Instead of branching on a secret condition, we add the secret\n            # boolean result of (l[i] == l[j]) to the frequency.\n            # In MP-SPDZ, the equality (==) returns a secret bit,\n            # which can be used in arithmetic operations.\n            freq[i] += (l[i] == l[j])\n    return freq\n", "response_1": "from Compiler.types import sint\n\ndef count_element_frequency(l):\n    n = len(l)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        for j in range(n):\n            # (l[j] == l[i]) is a secret bit; convert it to 1 or 0 using if_else\n            ret[i] += (l[j] == l[i]).if_else(1, 0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_or", "response_0": "from Compiler.types import sint\n\ndef array_or(a, b):\n    # Compute the elementwise OR for bits (0/1 values). For bits, OR is given by:\n    # a OR b = a + b - a * b\n    n = len(a)\n    ret = [sint(0) for i in range(n)]\n    for i in range(n):\n        ret[i] = a[i] + b[i] - a[i] * b[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_or(a, b):\n    \"\"\"\n    Compute the elementwise OR of the two input vectors.\n    \"\"\"\n    ret = [sint(0) for _ in range(len(a))]\n    for i in range(len(a)):\n        ret[i] = a[i] | b[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "stock_predicator", "response_0": "from Compiler.types import sfix\n\ndef stock_predicator(days):\n    n = len(days)\n    lowest = sfix.Array(n)\n    partial_max = sfix.Array(n)\n    lowest[0] = days[0]\n    partial_max[0] = sfix(0)\n    for i in range(1, n):\n        # Compute the minimum stock price up to day i.\n        cond = lowest[i-1] <= days[i]\n        lowest[i] = cond.if_else(lowest[i-1], days[i])\n        # Compute the maximum profit up to day i.\n        profit = days[i] - lowest[i-1]\n        cond2 = partial_max[i-1] >= profit\n        partial_max[i] = cond2.if_else(partial_max[i-1], profit)\n    return partial_max[n-1]\n", "response_1": "from Compiler.types import cfix\n\ndef stock_predicator(days):\n    # days is assumed to be a Python list of cfix elements (stock prices)\n    n = len(days)\n    lowest = [cfix(0) for _ in range(n)]\n    partial_max = [cfix(0) for _ in range(n)]\n    \n    lowest[0] = days[0]\n    # partial_max[0] is implicitly 0 because profit on first day is zero.\n    for i in range(1, n):\n        # Update lowest price so far\n        if lowest[i-1] <= days[i]:\n            lowest[i] = lowest[i-1]\n        else:\n            lowest[i] = days[i]\n        # Compute profit if selling today while using the best (lowest) price encountered so far\n        current_profit = days[i] - lowest[i-1]\n        if partial_max[i-1] >= current_profit:\n            partial_max[i] = partial_max[i-1]\n        else:\n            partial_max[i] = current_profit\n    return partial_max[n-1]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "len5_inc_array", "response_0": "from Compiler.types import sint\n\ndef len5_inc_array(init):\n    # Create an array of length 5 where each element is init incremented by the loop index.\n    ret = [init + i for i in range(5)]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef len5_inc_array(init):\n    ret = sint.Array(5)\n    for i in range(5):\n        ret[i] = init + i\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cut_first_five", "response_0": "from Compiler.types import sint\n\ndef cut_first_five(arr):\n    # Create an array of 5 secret integers and initialize it to 0.\n    ret = sint.Array(5)\n    ret.assign_all(0)\n    # Get the number of elements to copy: the minimum of 5 and the length of arr.\n    # Note: len(arr) is treated as public.\n    loop_bound = 5 if len(arr) > 5 else len(arr)\n    for i in range(loop_bound):\n        ret[i] = arr[i]\n    return ret\n", "response_1": "from Compiler.types import cint\n\ndef cut_first_five(arr):\n    # Create an array of length 5 and initialize all entries to 0.\n    ret = cint.Array(5)\n    ret.assign_all(0)\n    # Compute number to copy: the minimum between 5 and the input array's length.\n    num = min(5, len(arr))\n    for i in range(num):\n        ret[i] = arr[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_pooling_1d", "response_0": "from Compiler.types import sint\n\ndef max_pooling_1d(vec, step):\n    # Compute length of the output after pooling\n    ret_length = len(vec) // step\n    ret = sint.Array(ret_length)\n    for i in range(ret_length):\n        pool_max = vec[i * step]\n        for j in range(step):\n            candidate = vec[i * step + j]\n            # Compute secret comparison; cond is a secret bit (sintbit)\n            cond = candidate > pool_max\n            # Oblivious selection: if cond == 1 then candidate else pool_max\n            pool_max = cond.if_else(candidate, pool_max)\n        ret[i] = pool_max\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef max_pooling_1d(vec, step):\n    # Compute the output length as integer division of the vector length by step.\n    ret_length = len(vec) // step\n    # Create an Array of secret integers for the result.\n    ret = sint.Array(ret_length)\n    for i in range(ret_length):\n        # Set the first element of the current block as the initial maximum.\n        current_max = vec[i * step]\n        for j in range(step):\n            # Use a secret comparison: the \">\" operator yields a secret bit.\n            cond = (vec[i * step + j] > current_max)\n            # Update max by selecting vec[i*step+j] if cond==1, otherwise keep current_max.\n            current_max = cond.if_else(vec[i * step + j], current_max)\n        ret[i] = current_max\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_greater", "response_0": "from Compiler.types import sint\n\ndef array_greater(arr, brr):\n    # arr and brr are assumed to be lists (or arrays) of sint\n    n = len(arr)\n    ret = [None] * n\n    for i in range(n):\n        # The comparison \">\" returns a secret bit (sbitint)\n        cmp_bit = arr[i] > brr[i]\n        # Use if_else to select 1 if true, 0 otherwise\n        ret[i] = cmp_bit.if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_greater(arr, brr):\n    # Assume arr and brr are sint arrays of the same length.\n    n = len(arr)\n    ret = sint.Array(n)\n    for i in range(n):\n        # The comparison \">\" returns a secret bit.\n        # Use the built-in if_else to mux between 1 and 0.\n        ret[i] = (arr[i] > brr[i]).if_else(1, 0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "dumb_concat", "response_0": "from Compiler.types import sint\n\ndef dumb_concat(arr, brr):\n    \"\"\"\n    Concatenate the second array to the first array in a dumb way.\n    \"\"\"\n    # Calculate the total length\n    total_length = len(arr) + len(brr)\n    # Create a new array of type sint with total_length elements.\n    ret = sint.Array(total_length)\n    \n    # Copy the elements from the first array.\n    for i in range(len(arr)):\n        ret[i] = arr[i]\n    \n    # Copy the elements from the second array.\n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n    \n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef dumb_concat(arr, brr):\n    # Determine total length by summing lengths of arr and brr\n    total_length = len(arr) + len(brr)\n    # Create a new array of secret integers with the required total length\n    ret = sint.Array(total_length)\n    # Copy elements from the first array\n    for i in range(len(arr)):\n        ret[i] = arr[i]\n    # Copy elements from the second array\n    for j in range(len(brr)):\n        ret[len(arr) + j] = brr[j]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicator_if_else", "response_0": "def indicator_if_else(a, b, ind):\n    # Assume a, b are lists (or Arrays) of secret numbers and\n    # ind is a list (or vector) of secret bits,\n    # where the secret bit type supports the if_else method.\n    n = len(ind)\n    c = [0] * n\n    for i in range(n):\n        # Use the built-in if_else method on secret bits.\n        # This returns a[i] if ind[i]==1, otherwise b[i].\n        c[i] = ind[i].if_else(a[i], b[i])\n    return c\n", "response_1": "from Compiler.types import sint\n\ndef indicator_if_else(a, b, ind):\n    \"\"\"\n    Return an array c with the same length of a and b.\n    The element of c is set to be the corresponding element of a if the indicator is 1,\n    and is set to be the corresponding element of b if the indicator is 0.\n    \"\"\"\n    c = [0] * len(ind)\n    for i in range(len(ind)):\n        c[i] = ind[i].if_else(a[i], b[i])\n    return c\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "elementwise_multiplication", "response_0": "from Compiler.types import sint\n\ndef elementwise_multiplication(a, b):\n    # Assume 'a' and 'b' are vectors/lists of sint elements\n    n = len(a)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[i] * b[i]\n    return ret\n", "response_1": "def elementwise_multiplication(a, b):\n    # Compute the elementwise multiplication of two input vectors.\n    ret = [0] * len(a)\n    for i in range(len(a)):\n        ret[i] = a[i] * b[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "get_subarr_by_indices", "response_0": "from Compiler.types import sint\n\ndef get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the public indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = [0] * len(indices)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    # Determine the number of indices (assumed to be public integers)\n    n = len(indices)\n    # Instantiate the return Array of the same basic type as 'a'\n    ret = a.__class__.Array(n)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inc_array", "response_0": "from Compiler.types import cint\n\ndef inc_array(num):\n    \"\"\"\n    Return an array with length num and elements 1 to num.\n    The input is guaranteed to be a cleartext positive integer.\n    \"\"\"\n    arr = cint.Array(num)\n    for i in range(num):\n        arr[i] = i + 1\n    return arr\n", "response_1": "from Compiler.types import cint\n\ndef inc_array(num):\n    # Create an Array of clear integers (cint) with elements 1 to num.\n    # Using the \"create_from\" method to build the container from a Python list.\n    return cint.Array.create_from([i + 1 for i in range(num)])\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cut_last_five", "response_0": "from Compiler.types import sint\n\ndef cut_last_five(arr):\n    \"\"\"\n    Return the array composed of the last 5 elements of the input array.\n    If the input array does not have 5 elements, pad with 0 (at the beginning).\n    \"\"\"\n    # Create an output list of 5 secret integers, initialized to 0\n    ret = [sint(0) for _ in range(5)]\n    n = len(arr)  # public length of the input array\n    # Determine how many elements to copy (public integer because n is known)\n    loop_bound = min(5, n)\n    for i in range(loop_bound):\n        # Copy the i-th element from the end of arr to the corresponding position in ret\n        ret[4 - i] = arr[n - 1 - i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef cut_last_five(arr):\n    # Initialize the result with 5 secret integers set to 0.\n    ret = [sint(0) for _ in range(5)]\n    # The length of arr is public, so we can use Python's len() and min().\n    n = len(arr)\n    m = min(5, n)\n    for i in range(m):\n        ret[4 - i] = arr[n - 1 - i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "average_pooling_1d", "response_0": "from Compiler.types import sfix\n\ndef average_pooling_1d(vec, step):\n    # Compute the length of the result vector: integer division.\n    ret_length = len(vec) // step\n    ret = [sfix(0)] * ret_length\n    for i in range(ret_length):\n        avg = sfix(0)\n        for j in range(step):\n            # Accumulate the element, dividing by the public step.\n            avg = avg + vec[i * step + j] / step\n        ret[i] = avg\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef average_pooling_1d(vec, step):\n    ret_length = len(vec) // step\n    ret = [sfix(0) for _ in range(ret_length)]\n    for i in range(ret_length):\n        avg = sfix(0)\n        for j in range(step):\n            avg = avg + vec[i * step + j] / sfix(step)\n        ret[i] = avg\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_relu", "response_0": "from Compiler.types import sfix\n\ndef array_relu(arr):\n    # Apply ReLU function element-wise to the input array of sfix numbers.\n    ret = [sfix(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        # Use conditional selection: if arr[i] >= 0 then yield arr[i], else yield 0.\n        ret[i] = (arr[i] >= 0).if_else(arr[i], sfix(0))\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_relu(arr):\n    # Apply ReLU function elementwise on the input secret array.\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # (arr[i] >= 0) returns a secret Boolean (of type sint bit)\n        ret[i] = (arr[i] >= 0).if_else(arr[i], sint(0))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "move_to_end", "response_0": "from Compiler.types import sint\n\ndef move_to_end(arr, index):\n    # arr is assumed to be a fixed-length Array of secret integers (sint)\n    # index is a public integer (clear value)\n    temp = arr[index]\n    # Loop over the remaining elements, shifting each one position to the left\n    for i in range(index + 1, len(arr)):\n        arr[i - 1] = arr[i]\n    # Place the stored element at the end of the array\n    arr[len(arr) - 1] = temp\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef move_to_end(arr, index):\n    # Assume arr is of type sint.Array with a compile-time known length n.\n    n = len(arr)\n    temp = arr[index]\n    for i in range(index+1, n):\n        arr[i-1] = arr[i]\n    arr[n-1] = temp\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "set_to_zero", "response_0": "from Compiler.types import sint\n\ndef set_to_zero(arr, index):\n    \"\"\"\n    Set the element in the input array with given index to zero.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    arr[index] = 0\n    return arr\n", "response_1": "def set_to_zero(arr, index):\n    # Set the element at the public index 'index' of a MP-SPDZ array 'arr' to 0.\n    arr[index] = 0\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "last_partial_sum", "response_0": "from Compiler.types import sint\n\ndef last_partial_sum(arr, n):\n    \"\"\"\n    Return the sum of the last n elements in the input array.\n    n is guaranteed to be legal.\n    \"\"\"\n    ret = sint(0)\n    L = len(arr)\n    for i in range(L - n, L):\n        ret = ret + arr[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef last_partial_sum(arr, n):\n    # Initialize ret with the additive identity of the same type as the array elements.\n    ret = arr[0] * 0\n    # Use Python's range with public integers since the array length is available as len(arr).\n    for i in range(len(arr) - n, len(arr)):\n        ret = ret + arr[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "permute_by_indices", "response_0": "def permute_by_indices(a, indices):\n    # Create an output array with the same shape and type as a\n    ret = a.same_shape()\n    for i in range(len(a)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef permute_by_indices(a, indices):\n    n = len(a)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "get_rank", "response_0": "from Compiler.types import sint\n\ndef get_rank(arr, index):\n    # Initialize rank as a secret integer with value 0\n    rank = sint(0)\n    # Loop over each element in the array\n    for item in arr:\n        # Compute a secret bit that is 1 if item is less than the element at the given index, else 0.\n        # The secret comparison (item < arr[index]) returns a secret bit.\n        b = (item < arr[index]).if_else(1, 0)\n        rank += b\n    return rank\n", "response_1": "from Compiler.types import sint\n\ndef get_rank(arr, index):\n    # \"rank\" is a secret integer initialized to 0.\n    rank = sint(0)\n    # Loop over every element in the array.\n    for item in arr:\n        # The comparison \"item < arr[index]\" returns a secret bit.\n        # Convert it to a secret integer by using if_else: if the secret bit is 1, then return 1, else 0.\n        b = (item < arr[index]).if_else(sint(1), sint(0))\n        rank += b\n    return rank\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "interchange_by_indices", "response_0": "def interchange_by_indices(arr, index1, index2):\n    # Swap the two elements at public indices index1 and index2.\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "response_1": "def interchange_by_indices(arr, index1, index2):\n    # Interchange the elements at positions index1 and index2 in the MP-SPDZ array \"arr\".\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "increase_by", "response_0": "from Compiler.types import sint\n\ndef increase_by(arr, index, k):\n    # Increase the element arr[index] by k.\n    arr[index] = arr[index] + k\n    return arr\n", "response_1": "def increase_by(arr, index, k):\n    # Increase the element arr[index] in the MP-SPDZ array arr by k.\n    arr[index] = arr[index] + k\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "retrieve_by_index", "response_0": "def retrieve_by_index(arr, index):\n    # Retrieve the element from the array by index.\n    # The input index is guaranteed to be legal.\n    return arr[index]\n", "response_1": "def retrieve_by_index(arr, index):\n    \"\"\"\n    Retrieve the element in the array by index.\n    The input index is guaranteed to be legal.\n    In MP-SPDZ, container types such as Array support public indexing directly.\n    \"\"\"\n    return arr[index]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "scale_by", "response_0": "def scale_by(arr, index, k):\n    # Multiply the element at public index 'index' by k.\n    arr[index] = arr[index] * k\n    return arr\n", "response_1": "def scale_by(arr, index, k):\n    # Multiply the element at public index 'index' in the container 'arr' by k.\n    arr[index] = arr[index] * k\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "take_opposite_to", "response_0": "from Compiler.types import sint\n\ndef take_opposite_to(arr, index):\n    # Negate the element at the given public index\n    arr[index] = -arr[index]\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef take_opposite_to(arr, index):\n    # In MP-SPDZ, arr is assumed to be an Array of secret integers (sint)\n    arr[index] = -arr[index]\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_rank", "response_0": "from Compiler.types import sint\n\ndef array_rank(l):\n    n = len(l)\n    ret = sint.Array(n)\n    ret.assign_all(0)\n    for i in range(n):\n        for j in range(n):\n            # The comparison operator on sint returns a secret bit.\n            # Instead of an if, we add the secret bit to accumulate the count.\n            ret[i] = ret[i] + (l[j] < l[i])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_rank(l):\n    # Get the public length of the array l.\n    n = len(l)\n    # Initialize an output list of secret integers.\n    ret = [sint(0) for _ in range(n)]\n    # For each element in l, count the number of elements less than it.\n    for i in range(n):\n        for j in range(n):\n            # Instead of a secret branch, add the secret comparison result.\n            # The comparison operator (<) returns a secret bit that is 1 if true, 0 otherwise.\n            ret[i] = ret[i] + (l[j] < l[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "remove_by_index", "response_0": "from Compiler.types import sint\n\ndef remove_by_index(arr, index):\n    # Determine the length of the input array (compile-time integer)\n    n = len(arr)\n    # Create a new array of secret integers with length n-1\n    ret = sint.Array(n - 1)\n    # For each index of the new array, copy from the old array appropriately\n    for i in range(n - 1):\n        if i < index:\n            ret[i] = arr[i]\n        else:\n            ret[i] = arr[i + 1]\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    # Assuming arr is a list or an MP-SPDZ Array-like container.\n    ret = [0] * (len(arr) - 1)\n    for i in range(len(arr) - 1):\n        if i < index:\n            ret[i] = arr[i]\n        else:\n            ret[i] = arr[i + 1]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "process_by_index", "response_0": "def process_by_index(arr, index, func):\n    # Process the element in the input array with the given index.\n    # 'arr' is assumed to be an MP-SPDZ container (such as an Array),\n    # 'index' is a public index (an integer), and 'func' is any function that\n    # accepts an element of arr's type and returns a processed value.\n    arr[index] = func(arr[index])\n    return arr\n", "response_1": "def process_by_index(arr, index, func):\n    # arr is assumed to be an MP-SPDZ Array (e.g. sint.Array(n) or similar)\n    # and index is a public Python integer indicating the legal index.\n    arr[index] = func(arr[index])\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_by_indices", "response_0": "from Compiler.types import sint\n\ndef sum_by_indices(arr, indices):\n    total = sint(0)\n    for index in indices:\n        total = total + arr[index]\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_by_indices(arr, indices):\n    # Initialize the sum as a secret integer zero.\n    total = sint(0)\n    # Iterate over the public indices.\n    for index in indices:\n        total = total + arr[index]\n    return total\n", "model_name": "azure-openai-o3-mini"}
