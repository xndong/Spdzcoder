{"test_name": "multiply_first_five", "response_0": "from Compiler.types import sint\n\ndef multiply_first_five(array):\n    # Multiply the first five elements in the array (if len(array) < 5 then multiply all)\n    prod = sint(1)\n    for i in range(len(array)):\n        prod = prod * array[i]\n        if i >= 4:\n            break\n    return prod\n", "response_1": "from Compiler.types import sint\n\ndef multiply_first_five(arr):\n    # If array length is less than five, multiply all values\n    prod = sint(1)\n    limit = min(5, len(arr))\n    for i in range(limit):\n        prod = prod * arr[i]\n    return prod\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sint\n\ndef second_largest(arr):\n    # Determine initial largest and second largest using secure selections.\n    cond = arr[0] >= arr[1]\n    largest = cond.if_else(arr[0], arr[1])\n    second = cond.if_else(arr[1], arr[0])\n    # Loop over the remaining elements (starting from index 2)\n    for i in range(2, len(arr)):\n        # cond1 is a secret bit indicating whether arr[i] is no less than the current largest\n        cond1 = arr[i] >= largest\n        # Save the old largest to possibly update second later\n        old_largest = largest\n        # Update largest: if cond1 then choose arr[i], else keep largest\n        largest = cond1.if_else(arr[i], largest)\n        # In the case cond1 is true, second becomes the old largest.\n        # Otherwise, update second if arr[i] is no less than current second.\n        second = cond1.if_else(old_largest, ( (arr[i] >= second).if_else(arr[i], second) ))\n    return second\n", "response_1": "from Compiler.types import sint\n\ndef second_largest(arr):\n    # Assume arr is an Array of secret integers (sint)\n    # First, initialize by comparing the first two elements securely.\n    cond = arr[0] >= arr[1]\n    largest = cond.if_else(arr[0], arr[1])\n    second  = cond.if_else(arr[1], arr[0])\n    n = len(arr)  # public integer length\n    \n    # Iterate over the remaining elements (public loop index)\n    for i in range(2, n):\n        # Save current values to avoid reusing updated values in comparisons.\n        old_largest = largest\n        old_second  = second\n        # Securely compare the current element with the current largest.\n        comp1 = arr[i] >= old_largest\n        # In the branch where arr[i] is not greater than or equal to old_largest,\n        # check if it is at least as large as the current second largest.\n        comp2 = arr[i] >= old_second\n        # Update 'largest' and 'second' using secret multiplexer operations.\n        largest = comp1.if_else(arr[i], old_largest)\n        second  = comp1.if_else(old_largest, comp2.if_else(arr[i], old_second))\n    \n    return second\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "partial_sum", "response_0": "from Compiler.types import sint\n\ndef partial_sum(arr):\n    # Initialize the partial sum with a secret integer 0.\n    partial = sint(0)\n    # Iterate over the array (its length is known at compile time)\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef partial_sum(arr):\n    # Assume arr is an Array of type sint with public length.\n    partial = sint(0)\n    n = len(arr)\n    for i in range(n):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_adjacent_product", "response_0": "from Compiler.types import sint\n\ndef max_adjacent_product(arr):\n    # arr: a list or vector of secret integers (sint) with length at least 2.\n    cur = arr[0] * arr[1]\n    for i in range(len(arr) - 1):\n        prod = arr[i] * arr[i + 1]\n        cur = cur.max(prod)\n    return cur\n", "response_1": "from Compiler.types import sint\n\ndef max_adjacent_product(arr):\n    # Assumes that arr is an Array of secret integers (sint) with length at least 2.\n    cur = arr[0] * arr[1]\n    n = len(arr)\n    for i in range(n - 1):\n        prod = arr[i] * arr[i + 1]\n        cond = prod > cur      # This returns a secret bit.\n        # Use secret conditional selection: if cond then prod, else cur.\n        cur = cond.if_else(prod, cur)\n    return cur\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "argmax", "response_0": "from Compiler.types import sfix, sint\n\ndef argmax(a):\n    # Assume a is an Array of secret fixed\u2010point numbers (sfix)\n    current = a[0]\n    index = sint(0)\n    for i in range(1, len(a)):\n        # The comparison current >= a[i] returns a secret bit (sbitint)\n        cond = current >= a[i]\n        # Using the secret if_else: if cond is 1 then keep the old index/current,\n        # otherwise update with the new index i and a[i]\n        index = cond.if_else(index, sint(i))\n        current = cond.if_else(current, a[i])\n    return index\n", "response_1": "from Compiler.types import sint\n\ndef argmax(a):\n    # a is expected to be an array-like container (e.g., sint.Array) where each element is a sint\n    current = a[0]\n    index = 0\n    for i in range(len(a)):\n        # Compute a secret bit: 1 if current >= a[i], 0 otherwise.\n        cond = current >= a[i]\n        # Conditionally update the index: if cond is 1 then keep index, else set to public i.\n        index = cond.if_else(index, i)\n        # Conditionally update the current maximum value.\n        current = cond.if_else(current, a[i])\n    return index\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_distinct", "response_0": "from Compiler.types import cint\n\ndef count_distinct(arr):\n    # Initialize a public counter of type cint\n    counter = cint(0)\n    n = len(arr)\n    for i in range(n):\n        # Use 1 to indicate that arr[i] is unique, 0 otherwise.\n        unique = 1  \n        for j in range(i):\n            # Since arr is of type cint (public integers), the comparison\n            # arr[j] == arr[i] returns a public boolean suitable in a branch.\n            if arr[j] == arr[i]:\n                unique = 0\n        counter += unique\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef count_distinct(arr):\n    n = len(arr)  # public length of array\n    counter = sint(0)\n    one = sint(1)\n    # For each element, mark it as unique (1) if no previous element is equal to it,\n    # else mark it as 0. The equality operator on secret integers returns a secret bit,\n    # so we use if_else to convert it to a sint (1 if equal, 0 otherwise).\n    for i in range(n):\n        unique = one\n        for j in range(i):\n            eq_bit = (arr[i] == arr[j]).if_else(one, sint(0))\n            unique = unique * (one - eq_bit)\n        counter += unique\n    return counter\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_true", "response_0": "from Compiler.types import sint\n\ndef exists_true(arr):\n    ret = sint(0)\n    for item in arr:\n        ret = ret | item\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef exists_true(arr):\n    # ret is a secret boolean: 0 for False, 1 for True.\n    ret = sint(0)\n    for item in arr:\n        ret = ret.bit_or(item)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "range", "response_0": "from Compiler.types import sint\n\ndef range(arr):\n    max_val = arr[0]\n    min_val = arr[0]\n    for item in arr:\n        max_val = max_val.max(item)\n        min_val = min_val.min(item)\n    return max_val - min_val\n", "response_1": "from Compiler.types import sint\n\ndef range_arr(arr):\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = max_value.max(item)\n        min_value = min_value.min(item)\n    return max_value - min_value\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_larger_than_5", "response_0": "from Compiler.types import sint\n\ndef count_larger_than_5(arr):\n    # Initialize counter as a secret integer.\n    counter = sint(0)\n    for item in arr:\n        # Instead of branching on a secret value, we use the secure if_else method.\n        # (item > 5) returns a secret bit; if it is 1, add 1, otherwise add 0.\n        counter += (item > 5).if_else(1, 0)\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef count_larger_than_5(arr):\n    # Initialize a secret counter (type sint) to 0\n    counter = sint(0)\n    # Iterate over the secret array 'arr'\n    for item in arr:\n        # The comparison (item > 5) returns a secret bit.\n        # We use its if_else method to act as a multiplexer:\n        # if item > 5 then add 1, otherwise add 0.\n        counter += (item > 5).if_else(1, 0)\n    return counter\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_dominator", "response_0": "from Compiler.types import sfix\n\ndef exists_dominator(arr):\n    # Initialize max_val and sum_val as secret fixed\u2010point zeros\n    max_val = sfix(0)\n    sum_val = sfix(0)\n    for item in arr:\n        abs_item = abs(item)\n        # Create a secret Boolean (sbitint) from the comparison\n        # Then use if_else to select the new candidate for max_val\n        max_val = (abs_item > max_val).if_else(abs_item, max_val)\n        sum_val = sum_val + abs_item\n    # Return whether twice the max is strictly greater than the sum\n    return 2 * max_val > sum_val\n", "response_1": "from Compiler.types import sint\n\ndef exists_dominator(arr):\n    # Initialize secret integers for maximum absolute value and sum.\n    max_val = sint(0)\n    s = sint(0)\n    for item in arr:\n        abs_item = abs(item)\n        # secret comparison: (abs_item > max_val) returns a secret bit.\n        cmp_bit = abs_item > max_val\n        # Use secret if-else to update maximum value.\n        max_val = cmp_bit.if_else(abs_item, max_val)\n        s += abs_item\n    # Return secret bit: 2*max_val > s\n    return (2 * max_val) > s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "greedy_picker", "response_0": "from Compiler.types import sint\n\ndef greedy_picker(items, captivity):\n    # num: number of items that can be picked\n    num = sint(0)\n    # Loop over each item in the container \"items\"\n    for item in items:\n        # Compute a secret bit: 1 if the item fits into the current 'captivity', 0 otherwise.\n        cond = item <= captivity\n        # Convert the secret bit into an integer indicator (1 or 0)\n        indicator = cond.if_else(1, 0)\n        # Update captivity only if the item fits into the bag (branchless update)\n        captivity = captivity - indicator * item\n        # Increase the count if the item was picked\n        num = num + indicator\n    return num\n", "response_1": "from Compiler.types import sint\n\ndef greedy_picker(items, captivity):\n    # Initialize count as a secret integer zero.\n    num = sint(0)\n    # Process each item sequentially.\n    for item in items:\n        # Compute a secret bit that is 1 when the bag has enough space for the item,\n        # i.e. when item <= captivity, and 0 otherwise.\n        cond = item <= captivity\n        # Convert the secret bit into a secret integer 0/1.\n        cond_s = cond.if_else(sint(1), sint(0))\n        # If cond_s is 1 the item fits: subtract its \u201csize\u201d from captivity and add 1 to num.\n        captivity = captivity - cond_s * item\n        num = num + cond_s\n    return num\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s, l):\n    # 'l' is assumed to be an MP-SPDZ Array (or compatible list) of secret values.\n    for i in range(len(l)):\n        s = s + l[i]\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_equidistant_seq", "response_0": "from Compiler.types import sint\n\ndef is_equidistant_seq(arr):\n    n = len(arr)\n    if n <= 1:\n        return sint(1)\n    d = arr[1] - arr[0]\n    result = sint(1)\n    for i in range(1, n - 1):\n        diff = arr[i + 1] - arr[i]\n        eq = diff == d\n        result = result.bit_and(eq)\n        d = diff\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef is_equidistant_seq(arr):\n    n = len(arr)\n    # For arrays of length 0 or 1 the sequence is trivially equidistant.\n    if n <= 1:\n        return sint(1)\n    # Initial difference between the first two entries.\n    d = arr[1] - arr[0]\n    # Use a secret boolean (represented as a sint holding 1/0) for accumulation.\n    eq = sint(1)\n    for i in range(1, n - 1):\n        diff = arr[i + 1] - arr[i]\n        # Check if the difference equals the previous difference.\n        eq = eq.bit_and(diff == d)\n        # Update d for next iteration.\n        d = diff\n    return eq\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inner_product", "response_0": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    # Compute the inner product of the two vectors\n    result = sint(0)\n    for i in range(len(vec1)):\n        result = result + vec1[i] * vec2[i]\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    # Compute the inner product of two secret integer arrays\n    s = sint(0)\n    for i in range(len(vec1)):\n        s += vec1[i] * vec2[i]\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "more_distinct_nonnegative", "response_0": "from Compiler.types import sint\n\ndef more_distinct_nonnegative(arr):\n    # Assume arr is a Python list (or register vector) of sint.\n    n = len(arr)\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        # Check for duplicate: if any previous element equals arr[i],\n        # then mark this element as non-unique by multiplying unique by 0.\n        for j in range(i):\n            # (arr[j] == arr[i]) returns a secret bit (sbitint).\n            # Use it to update the uniqueness factor oblvously.\n            eq = (arr[j] == arr[i])\n            unique = unique * (1 - eq)\n        # Compute indicator whether arr[i] is nonnegative.\n        is_nonnegative = (arr[i] >= 0)  # returns a secret bit\n        nonnegative_counter = nonnegative_counter + unique * is_nonnegative\n        negative_counter = negative_counter + unique * (1 - is_nonnegative)\n    # Return a secret bit indicating if nonnegative distinct count is larger.\n    return nonnegative_counter > negative_counter\n", "response_1": "from Compiler.types import sint\n\ndef more_distinct_nonnegative(arr):\n    # Assume 'arr' is a list or Array of sint elements and its length is public.\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    n = len(arr)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            # Compute equality as a secret bit; if equal, (arr[j] == arr[i]) is 1.\n            unique = unique * (1 - (arr[j] == arr[i]))\n        # Create a secret indicator: 1 if arr[i] is nonnegative, 0 otherwise.\n        is_nonnegative = (arr[i] >= 0)\n        nonnegative_counter += unique * is_nonnegative\n        negative_counter += unique * (1 - is_nonnegative)\n    return nonnegative_counter > negative_counter\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "flip_positives", "response_0": "from Compiler.types import sint\n\ndef flip_positives(array):\n    # For each element, flip its sign if it is positive.\n    for i in range(len(array)):\n        # Compute a secret bit: 1 if array[i] > 0, 0 otherwise.\n        cond = array[i] > 0\n        # Use the secret multiplexer: if cond==1 then -array[i] else array[i].\n        array[i] = cond.if_else(-array[i], array[i])\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef flip_positives(array):\n    # Iterate over public indices of the array.\n    for i in range(len(array)):\n        # Compute a secret bit: 1 if array[i] > 0 else 0.\n        cond = (array[i] > 0)\n        # Use secret selection: if cond is 1 then set to -array[i], else keep array[i].\n        array[i] = cond.if_else(-array[i], array[i])\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "divide_and_plus", "response_0": "from Compiler.types import sfix\n\ndef divide_and_plus(x):\n    # Iterate 4 times: divide by 2 and then add 1 each time.\n    for _ in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n", "response_1": "from Compiler.types import sfix\n\ndef divide_and_plus(x: sfix) -> sfix:\n    for _ in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_log2", "response_0": "from Compiler import mpc_math\n\ndef array_log2(arr):\n    # Assuming 'arr' is an array of a fixed-point type (e.g., sfix.Array) with initialized values\n    for i in range(len(arr)):\n        arr[i] = mpc_math.log_fx(arr[i], 2)\n    return arr\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef array_log2(arr):\n    # Apply logarithm base-2 to each element in the array.\n    for i in range(len(arr)):\n        arr[i] = mpc_math.log_fx(arr[i], 2)\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_to_ten", "response_0": "from Compiler.types import cint\n\ndef sum_to_ten(array):\n    \"\"\"\n    Compute the partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    total = cint(0)\n    n = len(array)\n    for i in range(n):\n        total = total + array[i]\n        if total >= 10:\n            break\n    return total\n", "response_1": "from Compiler.types import cint\n\ndef sum_to_ten(array):\n    # Initialize the sum as a clear integer\n    s = cint(0)\n    # Iterate over the public length of the array\n    for i in range(len(array)):\n        s += array[i]\n        # Since 's' is clear, it can be used in a public branch\n        if s >= 10:\n            break\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "choppy_plus_minus", "response_0": "from Compiler.types import sint\n\ndef choppy_plus_minus(arr):\n    # Iterate over public indices\n    for i in range(len(arr)):\n        # For an odd index, add 1; for an even index, subtract 1.\n        if i % 2:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "def choppy_plus_minus(arr):\n    # \"arr\" is expected to be an Array of a basic type (e.g., sint, cint, or sfix),\n    # so its length is public and the indices can be iterated normally.\n    for i in range(len(arr)):\n        # For an odd index (i % 2 == 1), add 1.\n        # For an even index (i % 2 == 0), subtract 1.\n        if i % 2:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "min_element", "response_0": "def min_element(a):\n    current = a[0]\n    for item in a:\n        current = (current <= item).if_else(current, item)\n    return current\n", "response_1": "from Compiler.types import sint\n\ndef min_element(a):\n    \"\"\"\n    Return the minimum value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = (current <= item).if_else(current, item)\n    return current\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "soft_max", "response_0": "import math\nfrom Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef soft_max(arr):\n    # e_const is the constant e converted to sfix\n    e_const = sfix(math.e)\n    n = len(arr)\n    denominator = sfix(0)\n    for i in range(n):\n        denominator += mpc_math.pow_fx(e_const, arr[i])\n    result = [None] * n\n    for i in range(n):\n        result[i] = mpc_math.pow_fx(e_const, arr[i]) / denominator\n    return result\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef soft_max(arr):\n    # Define constant e as a secret fixed-point constant.\n    e_const = sfix(2.718281828459045)\n    denominator = sfix(0)\n    n = len(arr)\n    for i in range(n):\n        # Compute exponentiation of e to the power of arr[i].\n        exp_val = mpc_math.pow_fx(e_const, arr[i])\n        denominator = denominator + exp_val\n    # Create a new list for the softmax result.\n    brr = [None] * n\n    for i in range(n):\n        exp_val = mpc_math.pow_fx(e_const, arr[i])\n        brr[i] = exp_val / denominator\n    return brr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_reverse_pair_with_break", "response_0": "from Compiler.types import cint\n\ndef count_reverse_pair_with_break(arr):\n    # Initialize count as a clear integer\n    count = cint(0)\n    # n is available as a Python integer since we assume arr\u2019s length is public\n    n = len(arr)\n    for i in range(1, n):\n        # Compare arr[i] (of type cint) with public constant 10\n        if arr[i] > 10:\n            break\n        for j in range(i):\n            # If arr[j] > arr[i], increment count\n            if arr[j] > arr[i]:\n                count = count + 1\n    return count\n", "response_1": "from Compiler.types import cint\n\ndef count_reverse_pair_with_break(arr):\n    # 'arr' is assumed to be a Python list or an Array of clear integers (cint)\n    count = cint(0)\n    n = len(arr)\n    for i in range(1, n):\n        if arr[i] > 10:\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count += 1\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_unique", "response_0": "from Compiler.types import sint\n\ndef sum_unique(arr):\n    n = len(arr)\n    # Initialize the resulting sum as a secret integer.\n    sum_val = sint(0)\n    for i in range(n):\n        eq_count = sint(0)\n        for j in range(n):\n            # Compare two secret integers. This returns a secret bit.\n            # We then convert the bit to a secret integer 1 (if equal) or 0 (if not).\n            eq_bit = (arr[i] == arr[j]).if_else(sint(1), sint(0))\n            eq_count += eq_bit\n        # An element is unique if it appears exactly once.\n        # The comparison (eq_count == 1) returns a secret bit; we convert it into 1/0.\n        unique_bit = (eq_count == 1).if_else(sint(1), sint(0))\n        sum_val += arr[i] * unique_bit\n    return sum_val\n", "response_1": "from Compiler.types import sint\n\ndef sum_unique(arr):\n    # n is a public integer length of the array\n    n = len(arr)\n    total = sint(0)\n    for i in range(n):\n        unique_flag = sint(1)\n        for j in range(n):\n            if i != j:\n                # (arr[i] == arr[j]) returns a secret bit.\n                # Multiply by (1 - secret_bit) so that any duplicate forces unique_flag to zero.\n                unique_flag = unique_flag * (sint(1) - (arr[i] == arr[j]))\n        total = total + unique_flag * arr[i]\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "check_sum", "response_0": "from Compiler.types import sint\n\ndef check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value.\n    \"\"\"\n    total = sint(0)\n    for i in range(len(array)):\n        total = total + array[i]\n    return total == target\n", "response_1": "from Compiler.types import sint\n\ndef check_sum(array, target):\n    # Assumes that 'array' is an iterable of sint elements and 'target' is of type sint.\n    total = sint(0)\n    for num in array:\n        total = total + num\n    return total == target\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "prod", "response_0": "def prod(array):\n    # Multiply together all elements in the array.\n    result = 1\n    for num in array:\n        result = result * num\n    return result\n", "response_1": "def prod(array):\n    # Multiply together all elements in the array.\n    product = 1\n    for num in array:\n        product = product * num\n    return product\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_till_negative", "response_0": "from Compiler.types import cint\n\ndef sum_till_negative(array):\n    total = cint(0)\n    # Loop over the (public) length of the array.\n    for i in range(len(array)):\n        # If a negative number is encountered, break out of the loop.\n        if array[i] < 0:\n            break\n        total += array[i]\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_till_negative(array):\n    # s is the running sum, initially 0\n    s = sint(0)\n    # flag indicates whether we are still summing (1 means continue, 0 means a negative has been seen)\n    flag = sint(1)\n    n = len(array)\n    for i in range(n):\n        # Compute a secret bit that is 1 if array[i] is negative and 0 otherwise.\n        is_negative = array[i] < 0\n        # Once a negative is encountered, flag becomes 0 and remains 0.\n        flag = flag * (1 - is_negative)\n        # Multiply array[i] by flag so that only elements before the first negative (flag==1) are added.\n        s += array[i] * flag\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_satisfied", "response_0": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    count = sint(0)\n    for i in range(len(arr)):\n        # Evaluate the predicate on arr[i] which is expected to return a secret bit.\n        # The secret bit is then used to select 1 (if true) or 0 (if false).\n        count += predicator(arr[i]).if_else(1, 0)\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    total = sint(0)\n    n = len(arr)\n    for i in range(n):\n        # Evaluate the predicate to get a secret bit (0 or 1).\n        flag = predicator(arr[i])\n        # Accumulate the count by adding the secret bit.\n        total = total + flag\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "standard_deviation", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef standard_deviation(arr):\n    # assume arr is an Array of sfix with public length\n    n = len(arr)\n    average = sfix(0)\n    # Compute the average\n    for item in arr:\n        average = average + item / n\n    variance = sfix(0)\n    # Compute the variance\n    for item in arr:\n        variance = variance + (item - average)**2 / n\n    # Return the square root of variance\n    return mpc_math.sqrt(variance)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef standard_deviation(arr):\n    n = len(arr)\n    average = sfix(0)\n    variance = sfix(0)\n    for item in arr:\n        average = average + item / n\n    for item in arr:\n        variance = variance + (item - average) ** 2 / n\n    return mpc_math.sqrt(variance)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "dominate", "response_0": "from Compiler.library import tree_reduce\nfrom Compiler.types import sint\n\ndef dominate(a, b):\n    # Compute a list of secret bits where each entry is 1 if a[i] < b[i] and 0 otherwise.\n    diffs = [ a[i] < b[i] for i in range(len(a)) ]\n    # Reduce the list with secret OR (bit_or) to determine if any entry of a is less than its counterpart in b.\n    any_diff = tree_reduce(lambda x, y: x.bit_or(y), diffs)\n    # The domination condition holds if none of the comparisons was true.\n    return any_diff.bit_not()\n", "response_1": "from Compiler.types import sint\n\ndef dominate(a, b):\n    # Return a secret bit (sint) equal to 1 if every element in a is no smaller than\n    # the corresponding element in b; otherwise, return 0.\n    result = sint(1)\n    for i in range(len(a)):\n        # Compute secret bit: 1 if a[i] is NOT less than b[i], 0 otherwise.\n        # Note: (a[i] < b[i]) returns a secret bit, so we use bit_not() to invert it.\n        result = result.bit_and((a[i] < b[i]).bit_not())\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "rescale", "response_0": "from Compiler.types import sfix\n\ndef rescale(brr):\n    # Compute the maximum absolute value in a branchless manner.\n    max_abs = abs(brr[0])\n    for i in range(1, len(brr)):\n        cur = abs(brr[i])\n        cond = cur > max_abs  # This returns a secret bit (sbitint)\n        max_abs = cond.if_else(cur, max_abs)\n    # Rescale each element by dividing by max_abs.\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "response_1": "from Compiler.types import sfix\n\ndef rescale(brr):\n    # Compute the maximum absolute value in brr\n    max_abs = sfix(0)\n    for i in range(len(brr)):\n        current = abs(brr[i])\n        # Use a standard if-branch because brr is assumed public or its values are within allowed range\n        if current > max_abs:\n            max_abs = current\n    # Rescale brr so that every entry is divided by max_abs\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_minus7", "response_0": "from Compiler.types import sint\n\ndef array_minus7(arr):\n    # Assuming 'arr' is an instance of sint.Array (or similar container type)\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] - 7\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_minus7(arr):\n    # Subtract 7 from each element of the secret integer array\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "traverse_and_sum", "response_0": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    # assume arr1 and arr2 are Arrays of sint with public known lengths\n    s = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            s += arr1[i] * arr2[j]\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    # Initialize the accumulator as a secret integer zero\n    total = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            total = total + arr1[i] * arr2[j]\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler.types import cint\n\ndef longest_nondec_subseq(a):\n    # a is assumed to be a public (clear) array/list of integers (cint)\n    max_length = 0\n    cur_length = 0\n    for i in range(len(a)):\n        if i == 0:\n            cur_length = 1\n            continue\n        # Using clear integer comparisons since a[i] is of type cint\n        if a[i] >= a[i-1]:\n            cur_length = cur_length + 1\n        else:\n            # Update max_length using a clear value comparison\n            if max_length < cur_length:\n                max_length = cur_length\n            cur_length = 1\n    if max_length < cur_length:\n        max_length = cur_length\n    return max_length\n", "response_1": "from Compiler.types import cint\n\ndef longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence (by consecutive elements)\n    in the input array a.\n    Assumes that the entries in a are clear integers (cint) so that comparisons may be used in branches.\n    \"\"\"\n    n = len(a)\n    max_length = cint(0)\n    cur_length = cint(0)\n    for i in range(n):\n        if i == 0:\n            cur_length = cint(1)\n            continue\n        # The integer comparisons here are public so that standard if-else is valid.\n        if a[i] >= a[i-1]:\n            cur_length = cur_length + 1\n        else:\n            # Update max_length if cur_length is larger.\n            if max_length < cur_length:\n                max_length = cur_length\n            cur_length = cint(1)\n    if max_length < cur_length:\n        max_length = cur_length\n    return max_length\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_but_skip_biggest", "response_0": "from Compiler.types import sint\n\ndef sum_but_skip_biggest(array):\n    s = sint(0)\n    # Initialize biggest as the first element\n    biggest = array[0]\n    # Loop over the array\n    for i in range(len(array)):\n        # Compute a secret bit indicating if array[i] is at least as big as 'biggest'\n        cond = array[i] >= biggest\n        # Convert the secret bit to a sint (1 if true, 0 if false)\n        bit = cond.if_else(1, 0)\n        # Update biggest: if cond is true, choose array[i], else keep the existing biggest\n        biggest = cond.if_else(array[i], biggest)\n        # Add to the sum only when array[i] is not the biggest so far; i.e. (1-bit)*array[i]\n        s = s + array[i] * (1 - bit)\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_but_skip_biggest(array):\n    # \"s\" is a secret integer accumulator, initialized to 0.\n    s = sint(0)\n    # Initialize \"biggest\" as the first element of the array.\n    biggest = array[0]\n    # Iterate over all indices of the array.\n    for i in range(len(array)):\n        # Compute the secret bit: 1 if array[i] >= biggest, 0 otherwise.\n        cond = array[i] >= biggest\n        # Update \"biggest\" conditionally: if cond==1 then update as array[i], else keep current biggest.\n        biggest = cond.if_else(array[i], biggest)\n        # Conditionally accumulate array[i]: add array[i] only when cond==0.\n        # This is done by multiplying array[i] with the negation of cond.\n        s += cond.bit_not() * array[i]\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "second_test", "response_0": "from Compiler.types import sint\n\ndef second_test(arr):\n    # count is a secret integer\n    count = sint(0)\n    # iterate from index 1 to the end of the array (public loop)\n    for i in range(1, len(arr)):\n        # Note: the comparison \"<\" on secret integers returns a secret bit (sint bit)\n        # which takes the value 1 or 0. We add that directly to count.\n        count = count + (arr[0] < arr[i])\n    # Return the secret boolean (secret bit) indicating if count equals 1\n    return count == 1\n", "response_1": "from Compiler.types import sint\n\ndef second_test(arr):\n    # \"count\" is a secret integer that will sum up the secret bits from the comparisons.\n    count = sint(0)\n    n = len(arr)\n    for i in range(1, n):\n        # Instead of secret branch, we add the result of the secret comparison directly.\n        # The comparison (arr[0] < arr[i]) returns a secret bit.\n        count += (arr[0] < arr[i])\n    # Compute and return the secret bit indicating whether count == 1.\n    return (count == 1)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "Manhattan_distance", "response_0": "from Compiler.types import sint\n\ndef Manhattan_distance(a, b):\n    ret = sint(0)\n    for i in range(len(a)):\n        ret = ret + abs(a[i] - b[i])\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef Manhattan_distance(a, b):\n    ret = sfix(0)\n    for i in range(len(a)):\n        ret = ret + abs(a[i] - b[i])\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "deal_with_only_positive", "response_0": "from Compiler.types import cint\n\ndef deal_with_only_positive(array):\n    # Using clear integers (cint) for computation.\n    sign = cint(1)\n    total = cint(0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        total = total + sign * array[i]\n        sign = (-1) * sign\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef deal_with_only_positive(array):\n    # Initialize total sum to 0 and sign to 1 (both as secret integers)\n    total = sint(0)\n    sign = sint(1)\n    # Iterate over the array elements by public index\n    for i in range(len(array)):\n        # Compute a secret bit: 1 if array[i] > 0, else 0.\n        pos_bit = (array[i] > 0)\n        # Convert the secret bit to a secret integer: 1 if positive, 0 otherwise.\n        indicator = pos_bit.if_else(sint(1), sint(0))\n        # If the element is positive (indicator==1), add sign * array[i] to total; else add 0.\n        total = total + sign * array[i] * indicator\n        # If the element was positive, flip sign: multiply sign by (1 - 2 * indicator)\n        # (since when indicator==1, 1-2= -1; and when indicator==0, no change)\n        sign = sign * (1 - 2 * indicator)\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import cint\n\ndef compare_and_return(arr, brr):\n    # We assume that arr and brr are arrays of clear integers, for example cint.Array(n)\n    ret = -1  # initialize ret as a clear integer\n    for i in range(len(arr)):\n        # The equality check is performed on clear integers, so we can branch on it directly.\n        if arr[i] == brr[i]:\n            ret = i\n            break\n    return ret\n", "response_1": "from Compiler.types import cint\n\ndef compare_and_return(arr, brr):\n    # ret is initialized as public integer; -1 indicates not-found.\n    ret = -1\n    # Loop over the public length of the arrays.\n    for i in range(len(arr)):\n        # Since 'arr[i]' and 'brr[i]' are clear integers (cint),\n        # the equality check is performed on public values.\n        if arr[i] == brr[i]:\n            ret = i\n            break\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_odd_positive", "response_0": "from Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    total = sint(0)\n    for item in arr:\n        cond_odd = (item % 2) != 0\n        cond_positive = item > 0\n        cond = cond_odd.bit_and(cond_positive)\n        total = total + item * cond\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_odd_positive(arr):\n    # Initialize the sum as a secret integer 0\n    total = sint(0)\n    for item in arr:\n        # Determine if item is odd: (item % 2 != 0)\n        odd = (item % 2) != 0\n        # Determine if item is strictly positive\n        positive = item > 0\n        # Combine both conditions using bitwise AND (secret boolean, i.e., sbitint)\n        cond = odd.bit_and(positive)\n        # Add item multiplied by the indicator (0 if condition false, item otherwise)\n        total = total + item * cond\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "two_sum", "response_0": "from Compiler.types import sint\nfrom Compiler.GC.types import sbitint\n\ndef two_sum(arr, target):\n    n = len(arr)\n    # Initialize the flag as a secret bit integer (0 means false, 1 means true)\n    flag = sbitint(0)\n    for i in range(n):\n        for j in range(n):\n            # Compute the sum of arr[i] and arr[j]\n            s = arr[i] + arr[j]\n            # The equality returns a secret bit (sbitint) that is 1 if equal, 0 otherwise.\n            cond = (s == target)\n            # Bitwise OR to update the flag: flag becomes 1 if cond is 1.\n            flag = flag.bit_or(cond)\n    return flag\n", "response_1": "from Compiler.types import sint\n\ndef two_sum(arr, target):\n    # Initialize a secret bit as 0 (false)\n    found = sint(0)\n    n = len(arr)\n    # Loop over all pairs (even the same element twice)\n    for i in range(n):\n        for j in range(n):\n            # Compute secret equality: returns a secret bit 0 or 1\n            eq = (arr[i] + arr[j] == target)\n            # Arithmetic OR on bits: OR(a,b) = a + b - a*b\n            found = found + eq - found * eq\n    return found\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "seq_search", "response_0": "from Compiler.types import cint\n\ndef seq_search(arr, target):\n    # Sequential search in a clear array of cint.\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n", "response_1": "from Compiler.types import cint\n\ndef seq_search(arr, target):\n    # The function assumes that \"arr\" is an Array (or list) of clear integers (cint)\n    # and that \"target\" is also a clear integer.\n    n = len(arr)\n    for i in range(n):\n        # Note: equality on cint values yields a clear boolean because both operands are public.\n        if arr[i] == target:\n            return i\n    return -1\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "choppy_array", "response_0": "from Compiler.types import cint\n\ndef choppy_array(arr):\n    # Assume arr is a clear array of type cint or a Python list of integers,\n    # and its length is public.\n    n = len(arr)\n    for i in range(n):\n        # When i is even, arr[i] should be the minimum of arr[i:].\n        # When i is odd, arr[i] should be the maximum of arr[i:].\n        for j in range(n - i):\n            if i % 2:  # odd index: check that arr[i] is maximum among arr[i:]\n                if arr[i+j] > arr[i]:\n                    return False\n            else:       # even index: check that arr[i] is minimum among arr[i:]\n                if arr[i+j] < arr[i]:\n                    return False\n    return True\n", "response_1": "from Compiler.types import sint\n\ndef choppy_array(arr):\n    # Get the public length of the array\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i):\n            # When i is odd, arr[i] should be the largest among arr[i:]\n            if i % 2 == 1:\n                if arr[i+j] > arr[i]:\n                    return 0  # False represented as 0\n            # When i is even, arr[i] should be the smallest among arr[i:]\n            else:\n                if arr[i+j] < arr[i]:\n                    return 0  # False represented as 0\n    return 1  # True represented as 1\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    # Process every element in the array using the provided function.\n    n = len(arr)\n    for i in range(n):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "def array_process(arr, func):\n    # Process all elements in the input array with the given function\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "normalize", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef normalize(vec):\n    # Normalize the vector represented as an Array of sfix elements.\n    sum_sq = sfix(0)\n    for item in vec:\n        sum_sq = sum_sq + item**2\n    base = mpc_math.sqrt(sum_sq)\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef normalize(vec):\n    total = sfix(0)\n    for item in vec:\n        total = total + item * item\n    base = mpc_math.sqrt(total)\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "impatient_merchant", "response_0": "from Compiler.types import cfix\n\ndef impatient_merchant(days):\n    # days is assumed to be a Python list of clear fixed-point numbers (cfix)\n    can_buy = True\n    net = cfix(0)\n    orig_price = cfix(0)\n    n = len(days)\n    for i in range(n):\n        if can_buy:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = False\n        else:\n            if days[i] > orig_price:\n                net = net + days[i]\n                can_buy = True\n    return net\n", "response_1": "from Compiler.types import cfix\n\ndef impatient_merchant(days):\n    \"\"\"\n    You are given the prices of some goods in consecutive days.\n    Here's an impatient merchant who will buy the good on a day,\n    and then sell it as soon as its price becomes higher than its purchase cost.\n    The good left in the hand of the merchant on the last day is worthless.\n    This function returns the net profit.\n    \"\"\"\n    can_buy = True\n    net = cfix(0)\n    orig_price = cfix(0)\n    n = len(days)\n    for i in range(n):\n        if can_buy:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = False\n        else:\n            if days[i] > orig_price:\n                net = net + days[i]\n                can_buy = True\n    return net\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_shift", "response_0": "from Compiler.types import sint\n\ndef array_shift(a):\n    # Shift the given array by 1 position (rotate right)\n    temp = a[len(a)-1]\n    n = len(a)\n    for i in range(n-1):\n        a[n-i-1] = a[n-i-2]\n    a[0] = temp\n    return a\n", "response_1": "from Compiler.types import sint\n\ndef array_shift(a):\n    # Assume a is an Array of secret integers (sint)\n    n = len(a)\n    temp = a[n - 1]\n    for i in range(n - 1):\n        a[n - i - 1] = a[n - i - 2]\n    a[0] = temp\n    return a\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_double", "response_0": "from Compiler.types import sint\n\ndef array_double(arr):\n    # Double all elements in the input array.\n    n = len(arr)  # assuming arr is an Array with a compile-time known length\n    for i in range(n):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "def array_double(arr):\n    # Double each element in the input array.\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.types import cint\n\ndef stop_at_zero(array):\n    # array is assumed to be a clear integer Array (cint.Array)\n    n = len(array)\n    for i in range(n):\n        # if a zero is encountered, break out of the loop\n        if array[i] == 0:\n            break\n        # otherwise, add 1 to the element at index i\n        array[i] = array[i] + 1\n    return array\n", "response_1": "from Compiler.types import cint\n\ndef stop_at_zero(array):\n    # \"array\" is assumed to be a cint.Array or a public array of integers.\n    stop_flag = 0\n    for i in range(len(array)):\n        if stop_flag == 0:\n            if array[i] == 0:\n                stop_flag = 1\n            else:\n                array[i] += 1\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_not", "response_0": "from Compiler.types import sint\n\ndef array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i].bit_not()\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_not(arr):\n    # Assuming arr is an Array of secret bits stored as sint\n    for i in range(len(arr)):\n        arr[i] = arr[i].bit_not()\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process_then_clip", "response_0": "from Compiler.types import sfix\n\ndef array_process_then_clip(arr, func):\n    # Assume 'arr' is an Array of sfix and 'func' maps sfix -> sfix.\n    n = len(arr)\n    for i in range(n):\n        # Process the element using the given function.\n        temp = func(arr[i])\n        # Clip the value if it exceeds the upper bound.\n        temp = (temp > sfix(10)).if_else(sfix(10), temp)\n        # Clip the value if it is below the lower bound.\n        temp = (temp < sfix(-10)).if_else(sfix(-10), temp)\n        arr[i] = temp\n    return arr\n", "response_1": "from Compiler.types import sfix\n\ndef array_process_then_clip(arr, func):\n    # Assume 'arr' is an sfix.Array and 'func' is a function that takes an sfix and returns an sfix.\n    n = len(arr)\n    for i in range(n):\n        # Apply the processing function.\n        x = func(arr[i])\n        # Clip x from above: if x > 10 then set x to 10.\n        x = (x > 10).if_else(sfix(10), x)\n        # Clip x from below: if x < -10 then set x to -10.\n        x = (x < -10).if_else(sfix(-10), x)\n        arr[i] = x\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "add_and_count_positive", "response_0": "from Compiler.types import sint\n\ndef add_and_count_positive(array, k):\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        # The '>' comparison returns a secret bit (sbitint). Use its if_else method to convert to 1 if true, 0 otherwise.\n        count += (array[i] > 0).if_else(1, 0)\n    return array, count\n", "response_1": "from Compiler.types import sint\n\ndef add_and_count_positive(array, k):\n    count = sint(0)\n    n = len(array)\n    for i in range(n):\n        array[i] = array[i] + k\n        # Compute indicator: if array[i] > 0 then 1 else 0.\n        positive_indicator = (array[i] > 0).if_else(1, 0)\n        count = count + positive_indicator\n    return array, count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_subtract", "response_0": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it is padded with 0.\n    \"\"\"\n    if len(a) > len(b):\n        new_length = len(a)\n        ret = sint.Array(new_length)\n        for i in range(len(b)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(a) - len(b)):\n            ret[len(b) + i] = a[len(b) + i]  # padded by a's remaining elements\n        return ret\n    else:\n        new_length = len(b)\n        ret = sint.Array(new_length)\n        for i in range(len(a)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(b) - len(a)):\n            ret[len(a) + i] = -b[len(a) + i]  # padded by negative of b's remaining elements\n        return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    # Subtract the first array by the second one elementwise.\n    # If one array is shorter than the other, it is padded with 0.\n    if len(a) > len(b):\n        n = len(a)\n        ret = [sint(0) for _ in range(n)]\n        for i in range(len(b)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(a) - len(b)):\n            ret[len(b) + i] = a[len(b) + i]\n        return ret\n    else:\n        n = len(b)\n        ret = [sint(0) for _ in range(n)]\n        for i in range(len(a)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(b) - len(a)):\n            ret[len(a) + i] = -b[len(a) + i]\n        return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "lower_bound", "response_0": "from Compiler.types import cint\n\ndef lower_bound(arr, x):\n    # ret holds the index of the candidate element (or -1 if none is found)\n    ret = -1\n    # distance will hold the gap (x - arr[i]) for the current candidate\n    distance = 0\n    # found serves as a flag to indicate if we have found any element \u2264 x yet\n    found = False\n\n    # Iterate over the entire array (arr is assumed to be a Python list of cint elements)\n    for i in range(len(arr)):\n        # Compare clear integers; this \u201cif\u201d is executed in the clear.\n        if arr[i] <= x:\n            # Check if no candidate has been found or if the new candidate is closer to x.\n            # Note: For secret booleans one would use bit-level operations (e.g. bit_or),\n            # but here we assume clear (cint) values, so Python booleans suffice.\n            if (not found) or ((x - arr[i]) < distance):\n                ret = i\n                distance = x - arr[i]\n                found = True\n\n    return ret\n", "response_1": "from Compiler.types import cint\n\ndef lower_bound(arr, x):\n    # ret: index of the best candidate (initialized to -1)\n    ret = cint(-1)\n    # distance: difference between x and candidate element; valid only if found is True\n    distance = 0\n    found = False\n    for i in range(len(arr)):\n        # Use public branch as arr and x are assumed clear integers.\n        if arr[i] <= x:\n            # For the first candidate or a closer candidate, update\n            if (not found) or ((x - arr[i]) < distance):\n                ret = i\n                distance = x - arr[i]\n                found = True\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "argmin", "response_0": "from Compiler.types import sfix, sint\n\ndef argmin(a):\n    # 'a' is expected to be an Array of sfix elements.\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        # The comparison (current <= a[i]) returns a secret bit (sbitint).\n        cond = (current <= a[i])\n        # Conditionally update the index and current value:\n        # If current <= a[i] then keep the previous values,\n        # otherwise update with new index and element.\n        index = cond.if_else(index, sint(i))\n        current = cond.if_else(current, a[i])\n    return index\n", "response_1": "from Compiler.types import sfix, sint\n\ndef argmin(a):\n    # Assume a is an Array of sfix elements.\n    current = a[0]\n    # Use a secret integer for the index.\n    index = sint(0)\n    n = len(a)\n    # Loop over indices starting from 1 since 0 is our initial choice.\n    for i in range(1, n):\n        # The comparison \"current <= a[i]\" returns a secret bit (sbitint).\n        cond = current <= a[i]\n        # Update index: if cond is true, keep the old index, else update to i.\n        index = cond.if_else(index, sint(i))\n        # Similarly update the current minimum.\n        current = cond.if_else(current, a[i])\n    return index\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "independent_robbery", "response_0": "from Compiler.types import sint\n\ndef independent_robbery(houses):\n    # Assume houses is an Array of secret integers (sint) and its length is at least 3.\n    n = len(houses)\n    dp = sint.Array(n)\n    dp.assign_all(0)\n    \n    # Initialize the dynamic programming table.\n    dp[0] = houses[0]\n    # dp[1] should be the maximum of houses[0] and houses[1].\n    cond = houses[1] >= houses[0]\n    dp[1] = cond.if_else(houses[1], houses[0])\n    \n    # Dynamic Programming recurrence:\n    # For each house i (starting from index 2), calculate:\n    #   candidate = dp[i-2] + houses[i]\n    # and choose the greater value between candidate and dp[i-1].\n    for i in range(2, n):\n        candidate = dp[i-2] + houses[i]\n        cond = candidate >= dp[i-1]\n        dp[i] = cond.if_else(candidate, dp[i-1])\n        \n    return dp[n-1]\n", "response_1": "from Compiler.types import sint\n\ndef independent_robbery(houses):\n    # Assume houses is a list of secret integers (sint).\n    n = len(houses)\n    dp = [sint(0) for _ in range(n)]\n    \n    dp[0] = houses[0]\n    # dp[1] is the maximum of houses[0] and houses[1]\n    dp[1] = (houses[1] >= houses[0]).if_else(houses[1], houses[0])\n    \n    for i in range(2, n):\n        option1 = dp[i-2] + houses[i]\n        option2 = dp[i-1]\n        # Choose option1 if it is at least option2, otherwise choose option2.\n        dp[i] = (option1 >= option2).if_else(option1, option2)\n        \n    return dp[n-1]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_odd_and_odd", "response_0": "from Compiler.types import sint\n\ndef sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function in MP-SPDZ. 'arr' is assumed to be an Array\n    of secret integers (sint).\n    \"\"\"\n    total = sint(0)\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            total += arr[j]\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_odd_and_odd(arr):\n    # A strange sum function\n    total = sint(0)\n    n = len(arr)  # n is public, since loop indices are clear integers\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            total += arr[j]\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_monotonous", "response_0": "from Compiler.types import cfix\n\ndef is_monotonous(arr):\n    # \"arr\" is assumed to be a Python list (or Array converted to vector)\n    # of clear fixed-point numbers.\n    d = 0  # d is a clear fixed-point number (cfix)\n    n = len(arr)\n    for i in range(n - 1):\n        # For i>0, check if the current difference and the previous one have non-positive product.\n        if i > 0 and (arr[i+1] - arr[i]) * d <= 0:\n            return False\n        d = arr[i+1] - arr[i]\n    return True\n", "response_1": "from Compiler.types import cfix\n\ndef is_monotonous(arr):\n    # arr is assumed to be a clear fixed\u2010point array (cfix.Array)\n    d = cfix(0)\n    n = len(arr)\n    for i in range(n - 1):\n        if i > 0 and (arr[i + 1] - arr[i]) * d <= 0:\n            return False\n        d = arr[i + 1] - arr[i]\n    return True\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    # Initialize count and negative_sum as secret integers.\n    count = sint(0)\n    negative_sum = sint(0)\n    for item in arr:\n        # Compute secret flags: they are secret bits (0 or 1)\n        pos_flag = (item > 0)\n        neg_flag = (item < 0)\n        # Use arithmetic to update count and negative_sum\n        count = count + pos_flag\n        negative_sum = negative_sum + (item * neg_flag)\n    return count, negative_sum\n", "response_1": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    # Initialize secret integers for the count and negative sum.\n    count = sint(0)\n    neg_sum = sint(0)\n    # Loop over each element in the array.\n    for i in range(len(arr)):\n        item = arr[i]\n        # Compute a secret bit: 1 if item > 0, else 0.\n        pos_bit = (item > 0).if_else(sint(1), sint(0))\n        count += pos_bit\n        # If item < 0 then add item, else add 0.\n        neg_item = (item < 0).if_else(item, sint(0))\n        neg_sum += neg_item\n    return count, neg_sum\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_even", "response_0": "from Compiler.types import sint\n\ndef sum_even(arr):\n    total = sint(0)\n    for item in arr:\n        # Compute an indicator that is 1 if item is even, 0 otherwise.\n        # Since item % 2 yields 0 for even numbers and 1 for odd numbers,\n        # 1 - (item % 2) will be 1 for even numbers.\n        is_even = 1 - (item % 2)\n        total = total + item * is_even\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_even(arr):\n    total = sint(0)\n    for item in arr:\n        # Compute a secret bit that is 1 if item is even and 0 if odd.\n        # Since \"item % 2\" yields 0 for even numbers and 1 for odd numbers,\n        # we can use (1 - (item % 2)) as the selection bit.\n        total += item * (1 - (item % 2))\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    # Return the one-norm of the vector by summing the absolute values of its elements.\n    total = 0\n    for item in vec:\n        total = total + abs(item)\n    return total\n", "response_1": "from Compiler.types import sfix\n\ndef one_norm(vec):\n    total = sfix(0)\n    for item in vec:\n        total = total + abs(item)\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_floor", "response_0": "from Compiler.types import cfix, cint\nimport math\n\ndef array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array.\n    Assumes that arr is an Array (or Python list) of clear fixed\u2010point numbers (cfix),\n    and returns a Python list of clear integers (cint) corresponding to the floor\n    of each element.\n    \"\"\"\n    n = len(arr)\n    ret = [None] * n\n    for i in range(n):\n        # Compute floor on clear data using Python math.floor.\n        ret[i] = cint(math.floor(arr[i]))\n    return ret\n", "response_1": "from Compiler.types import cfix, cint, Array\nimport math\n\ndef array_floor(arr):\n    # 'arr' is assumed to be an Array of clear fixed\u2010point numbers (cfix)\n    # The result will be an Array of clear integers (cint)\n    ret = cint.Array(len(arr))\n    for i in range(len(arr)):\n        # Using Python's math.floor here since the cfix values are public\n        ret[i] = cint(math.floor(arr[i]))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "three_five", "response_0": "from Compiler.types import sint\n\ndef three_five(arr):\n    # arr is assumed to be an iterable (e.g. a sint Array) of secret integers.\n    # We use secret boolean values (results of comparisons) which are of type sbitint,\n    # and perform logical operations with bit_or, bit_and and bit_not.\n    has3 = 0  # equivalent to secret boolean False\n    has5 = 0  # equivalent to secret boolean False\n    for item in arr:\n        # item == 3 returns a secret bit indicating equality.\n        has3 = has3.bit_or(item == 3)\n        has5 = has5.bit_or(item == 5)\n    # Compute: (has3 and has5) or ((not has3) and (not has5))\n    return (has3.bit_and(has5)).bit_or((has3.bit_not()).bit_and(has5.bit_not()))\n", "response_1": "from Compiler.GC.types import sbitint\n\ndef three_five(arr):\n    # Initialize secret bits for whether arr contains a 3 or a 5.\n    has3 = sbitint(0)\n    has5 = sbitint(0)\n    for item in arr:\n        # Comparison returns a secret bit; update via bitwise OR.\n        has3 = has3.bit_or(item == 3)\n        has5 = has5.bit_or(item == 5)\n    # Return (has3 AND has5) OR ((NOT has3) AND (NOT has5))\n    return has3.bit_and(has5).bit_or(has3.bit_not().bit_and(has5.bit_not()))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "num_above_average", "response_0": "from Compiler.types import cfix\n\ndef num_above_average(arr):\n    # Here arr is assumed to be an Array of cfix numbers (public fixed\u2010point values).\n    total = cfix(0)\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        total = total + arr[i]\n    avg = total / n\n    for i in range(n):\n        # Since arr elements are clear (cfix), the comparison is public.\n        if arr[i] >= avg:\n            count = count + 1\n    return count\n", "response_1": "from Compiler.types import sfix, sint\n\ndef num_above_average(arr):\n    # Compute the sum as an sfix number.\n    s = sfix(0)\n    n = len(arr)  # public integer length\n    for i in range(n):\n        s = s + arr[i]\n    avg = s / n  # sfix division by public integer\n\n    # Count the number of elements that are greater than or equal to the average.\n    count = sint(0)\n    for i in range(n):\n        # The comparison returns a secret bit; use if_else to select 1 if true, else 0.\n        cond = (arr[i] >= avg)\n        count = count + cond.if_else(1, 0)\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    n = len(arr)\n    for i in range(n):\n        # First, clip to lower_bound\n        # (arr[i] < lower_bound) returns a secret bit.\n        lower_cond = arr[i] < lower_bound\n        tmp = lower_cond.if_else(lower_bound, arr[i])\n        # Then, clip to upper_bound\n        upper_cond = tmp > upper_bound\n        arr[i] = upper_cond.if_else(upper_bound, tmp)\n    return arr\n", "response_1": "from Compiler.types import sfix\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    # Iterate over the array indices (the length is public)\n    for i in range(len(arr)):\n        # Replace element with lower_bound if it is less than lower_bound,\n        # otherwise leave it unchanged.\n        arr[i] = (arr[i] < lower_bound).if_else(lower_bound, arr[i])\n        # Replace element with upper_bound if it is greater than upper_bound,\n        # otherwise leave it unchanged.\n        arr[i] = (arr[i] > upper_bound).if_else(upper_bound, arr[i])\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "from Compiler.types import sint\n\ndef sum_with_certain_element_skipped(array):\n    # initialize the secret sum as a sint with value 0\n    s = sint(0)\n    for i in range(len(array)):\n        # compute the candidate partial sum\n        candidate = s + array[i]\n        # check if candidate is at least 5 and at most 10\n        cond_ge = 5 <= candidate\n        cond_le = candidate <= 10\n        # combine the two secret booleans using bitwise AND\n        cond = cond_ge.bit_and(cond_le)\n        # if condition holds, skip addition (s remains unchanged),\n        # otherwise update s as candidate (s + array[i])\n        s = cond.if_else(s, candidate)\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef sum_with_certain_element_skipped(array):\n    # Initialize total as a secret integer with value 0.\n    total = sint(0)\n    n = len(array)\n    for i in range(n):\n        # Compute the tentative new sum.\n        temp = total + array[i]\n        # Check if temp is at least 5.\n        cond_ge = (temp >= 5)\n        # Check if temp is at most 10.\n        cond_le = (temp <= 10)\n        # Combine the comparisons using secret bitwise AND.\n        # Note: both cond_ge and cond_le are secret bits.\n        cond = cond_ge.bit_and(cond_le)\n        # If the condition is true, then skip addition (keep total);\n        # otherwise, update total with temp.\n        # The if_else method on secret bits returns the first argument if the bit is 1,\n        # and the second if it is 0.\n        total = cond.if_else(total, temp)\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr):\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        # Compute indicator: 1 if item is odd, 0 if even.\n        indicator = item % 2\n        odd_sum = odd_sum + item * indicator\n        even_sum = even_sum + item * (1 - indicator)\n    return odd_sum, even_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr):\n    # Initialize secret accumulators for odd and even sums.\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        # Compute modulus with 2 (allowed since 2 is a compile-time constant power-of-two).\n        r = item % 2  # r will be 0 or 1 in secret arithmetic.\n        # Add to odd_sum if r==1, and to even_sum if r==0, using arithmetic without secret branching.\n        odd_sum += item * r\n        even_sum += item * (1 - r)\n    return odd_sum, even_sum\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "distance", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef distance(vec1, vec2):\n    sum_val = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        sum_val = sum_val + diff * diff\n    return mpc_math.sqrt(sum_val)\n", "response_1": "from Compiler import mpc_math\nfrom Compiler.types import sfix\n\ndef distance(vec1, vec2):\n    s = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        s = s + diff * diff\n    return mpc_math.sqrt(s)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "num_occurrence", "response_0": "from Compiler.types import sint\n\ndef num_occurrence(arr, target):\n    count = sint(0)\n    for item in arr:\n        # Instead of branching on a secret condition, use a secret\u2010arithmetic indicator:\n        count += (item == target).if_else(sint(1), sint(0))\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef num_occurrence(arr, target):\n    count = sint(0)\n    for item in arr:\n        # The comparison (==) returns a secret bit (sbitint). Use if_else to convert it into a secret integer (sint)\n        count = count + (item == target).if_else(sint(1), sint(0))\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "palindrome", "response_0": "from Compiler.types import sint\n\ndef palindrome(arr):\n    # 'flag' is initialized as secret true (1) of type sint.\n    flag = sint(1)\n    n = len(arr)\n    for i in range(n):\n        # Compare the i-th and the (n-1-i)-th elements.\n        # The equality returns a secret bit; combine it with flag using bit_and.\n        flag = flag.bit_and(arr[i] == arr[n-1-i])\n    return flag\n", "response_1": "from Compiler.types import sint\n\ndef palindrome(arr):\n    # arr is assumed to be an Array (or Python list) of secret integers (sint),\n    # and its length is known at compile time.\n    n = len(arr)\n    flag = sint(1)\n    for i in range(n):\n        # Compute equality of the i-th element and its symmetric counterpart.\n        eq = (arr[i] == arr[n - 1 - i])\n        # Logical AND using bit_and (note: eq and flag are secret bit values)\n        flag = flag.bit_and(eq)\n    return flag\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    # arr is assumed to be an Array or list of sint elements with a public known length.\n    num = sint(0)\n    n = len(arr)  # public length\n    for i in range(n):\n        for j in range(i+1, n):\n            # (arr[i] > arr[j]) returns a secret bit.\n            # Use the if_else method to choose 1 when true, 0 otherwise.\n            num = num + (arr[i] > arr[j]).if_else(1, 0)\n    return num\n", "response_1": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    # arr is expected to be an Array of secret integers (sint)\n    num = sint(0)\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            # The comparison \"arr[i] > arr[j]\" returns a secret bit.\n            # Add this secret bit (0 or 1) to num.\n            num += (arr[i] > arr[j])\n    return num\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_of_cubes", "response_0": "from Compiler.types import sint\n\ndef sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array.\n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        ret = ret + (item ** 3)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_cubes(arr):\n    # Initialize the accumulator as a secret integer with value 0\n    ret = sint(0)\n    # Loop over each secret integer in the array and add its cube\n    for item in arr:\n        ret = ret + (item ** 3)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_element", "response_0": "from Compiler.types import sint\n\ndef max_element(a):\n    current = a[0]\n    for item in a:\n        current = current.max(item)\n    return current\n", "response_1": "from Compiler.types import sint\n\ndef max_element(a):\n    current = a[0]\n    for item in a:\n        current = current.max(item)\n    return current\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_if_else", "response_0": "from Compiler.types import sint  # or sfix if using fixed-point values\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    # For each index in the array, select the new value based on the secret predicate.\n    # It is assumed that predicator(x) returns a secret bit (of type sint or similar)\n    # that supports the if_else() method, and that if_func(x) and else_func(x)\n    # produce values compatible with the type stored in arr.\n    for i in range(len(arr)):\n        temp = arr[i]\n        cond = predicator(temp)\n        # Using the secret conditional selection provided by if_else().\n        arr[i] = cond.if_else(if_func(temp), else_func(temp))\n    return arr\n", "response_1": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator applied on the element returns a secure bit (0 or 1),\n    then apply the if_func to the element using secure multiplexer,\n    otherwise apply the else_func.\n    \"\"\"\n    for i in range(len(arr)):\n        # Obtain a secret predicate bit from the element\n        b = predicator(arr[i])\n        # Select between if_func(arr[i]) and else_func(arr[i]) using secure if_else operator.\n        arr[i] = b.if_else(if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "inf_norm", "response_0": "from Compiler.types import sfix\n\ndef inf_norm(vec):\n    norm = sfix(0)\n    for item in vec:\n        temp = abs(item)\n        cond = norm >= temp\n        norm = cond.if_else(norm, temp)\n    return norm\n", "response_1": "from Compiler.types import sint\n\ndef inf_norm(vec):\n    # Compute the infinite norm (max of absolute values)\n    norm = sint(0)\n    for item in vec:\n        norm = norm.max(abs(item))\n    return norm\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    # Increment each element of the input array by 1\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1.\n    Assumes that arr is an MP-SPDZ Array of secret integers (sint).\n    \"\"\"\n    for i in range(len(arr)):\n        # Increment each element by 1\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr):\n    # initialize count as a secret integer zero\n    count = sint(0)\n    # iterate over public indices from 0 to len(arr)-2\n    for i in range(len(arr) - 1):\n        # Instead of a secret branch, add the secret boolean (0/1) directly\n        count += (arr[i] < arr[i+1])\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_rises(arr):\n    # \"arr\" is assumed to be an Array (or list) of secret integers (sint)\n    count = sint(0)\n    # Use the public length, loops over indices using a public range\n    for i in range(len(arr) - 1):\n        # The comparison \"arr[i] < arr[i+1]\" returns a secret bit (sbitint)\n        # We use if_else to covert it into 1 or 0 without branching on secret data.\n        count += (arr[i] < arr[i+1]).if_else(1, 0)\n    return count\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "skip_at_zero", "response_0": "from Compiler.types import cint\n\ndef skip_at_zero(array):\n    # add 1 to each element unless it is equal to 0\n    for i in range(len(array)):\n        # since array elements are clear (cint), the condition is public\n        if array[i] == 0:\n            continue\n        array[i] = array[i] + 1\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef skip_at_zero(array):\n    # For each element in the array, add 1 if it is nonzero.\n    # Note: array is assumed to be an Array of sint with publicly known length.\n    for i in range(len(array)):\n        # Compute a secret bit: if array[i] equals 0 then returns 0, else returns 1.\n        add_value = (array[i] == 0).if_else(0, 1)\n        array[i] = array[i] + add_value\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_intersect", "response_0": "from Compiler.types import cint\n\ndef array_intersect(p, q):\n    # p and q are assumed to be arrays of clear integers (cint) or any type\n    # that supports public equality testing.\n    for i in range(len(p)):\n        for j in range(len(q)):\n            if p[i] == q[j]:\n                return 1\n    return 0\n", "response_1": "from Compiler.types import sint\n\ndef array_intersect(p, q):\n    # p and q are assumed to be arrays (or lists) of secret integers of type sint.\n    # Since branching on secret data is not allowed, we compute the OR of all equality tests.\n    flag = sint(0)  # secret bit representing False\n    for i in range(len(p)):\n        for j in range(len(q)):\n            # The equality check returns a secret bit (0 or 1)\n            eq = p[i] == q[j]\n            # Use bitwise OR to update the flag\n            flag = flag.bit_or(eq)\n    return flag\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef two_norm(vec):\n    # Compute the sum of squares of the vector elements\n    s = sfix(0)\n    for item in vec:\n        s = s + item * item\n    # Return the square root of the sum\n    return mpc_math.sqrt(s)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef two_norm(vec):\n    s = sfix(0)\n    for item in vec:\n        s = s + item * item\n    return mpc_math.sqrt(s)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_between", "response_0": "from Compiler.types import sint\n\ndef sum_between(arr, l, u):\n    total = sint(0)\n    for item in arr:\n        cond1 = (l <= item)\n        cond2 = (item <= u)\n        cond = cond1.bit_and(cond2)\n        total = total + cond * item\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_between(arr, l, u):\n    total = sint(0)\n    for item in arr:\n        # Compute condition as a secret bit for (l <= item) and (item <= u)\n        cond_lower = l <= item\n        cond_upper = item <= u\n        cond = cond_lower.bit_and(cond_upper)\n        # Convert secret boolean to 1 or 0 as a sint\n        cond_int = cond.if_else(1, 0)\n        total += item * cond_int\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "largest_gap", "response_0": "from Compiler.types import sfix\n\ndef largest_gap(arr):\n    # Assume arr is a list or an Array of sfix values and its length is at least 2.\n    cur = sfix(0)\n    n = len(arr)\n    for i in range(n - 1):\n        diff = abs(arr[i + 1] - arr[i])\n        # The comparison (diff > cur) returns a secret bit (sbitint).\n        # Use the if_else method to update cur without leaking secret information.\n        cur = (diff > cur).if_else(diff, cur)\n    return cur\n", "response_1": "from Compiler.types import sfix\n\ndef largest_gap(arr):\n    # Assumes 'arr' is an Array (or list) of sfix numbers with length at least 2.\n    cur = abs(arr[1] - arr[0])\n    for i in range(len(arr) - 1):\n        diff = abs(arr[i + 1] - arr[i])\n        # Perform a secure multiplexer update:\n        cur = (diff > cur).if_else(diff, cur)\n    return cur\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "totally_dominate", "response_0": "from Compiler.types import sint\n\ndef totally_dominate(a, b):\n    # a and b are assumed to be arrays (or vectors) of secret integers (sint)\n    amin = a[0]\n    bmax = b[0]\n    n = len(a)\n    m = len(b)\n    for i in range(1, n):\n        # Compute secret condition: a[i] < amin\n        cond = a[i] < amin\n        # Use the secret bit to select the new minimum\n        amin = cond.if_else(a[i], amin)\n    for j in range(1, m):\n        # Compute secret condition: b[j] > bmax\n        cond = b[j] > bmax\n        # Use the secret bit to select the new maximum\n        bmax = cond.if_else(b[j], bmax)\n    # Return the secret boolean (sint bit) for amin >= bmax\n    return amin >= bmax\n", "response_1": "from Compiler.types import cint\n\ndef totally_dominate(a, b):\n    # a and b are assumed to be Arrays of cint with a known compile\u2010time length.\n    amin = a[0]\n    bmax = b[0]\n    for i in range(len(a)):\n        if a[i] < amin:\n            amin = a[i]\n    for i in range(len(b)):\n        if b[i] > bmax:\n            bmax = b[i]\n    return (amin >= bmax)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "element_count", "response_0": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    ret = sint(0)\n    for item in arr:\n        # The equality check (item == target) returns a secret bit.\n        # Convert it to a numerical value using if_else.\n        ret = ret + (item == target).if_else(1, 0)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    # ret is declared as a secret integer for accumulating the count\n    ret = sint(0)\n    for item in arr:\n        # The equality test (item == target) returns a secret bit; we covert it to 1 or 0\n        ret = ret + (item == target).if_else(1, 0)\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_subarray", "response_0": "from Compiler.types import sint\n\ndef is_subarray(c, d):\n    # c and d are assumed to be Arrays (or vectors) of secret integers (sint)\n    # The function returns a secret boolean (0/1 as sint) indicating whether c is a contiguous subarray of d.\n    found = 0\n    n = len(d)  # public length\n    m = len(c)  # public length\n    for i in range(n):\n        # Only check positions where c can fit into d\n        if m <= n - i:\n            flag = 1\n            for j in range(m):\n                # Equality of secret integers yields a secret bit.\n                # Combine using MP-SPDZ bit_and (logical AND) for secret bits.\n                flag = flag.bit_and(d[i + j] == c[j])\n            # Combine results with MP-SPDZ bit_or (logical OR) for secret bits.\n            found = found.bit_or(flag)\n    return found\n", "response_1": "from Compiler.types import sint\n\ndef is_subarray(c, d):\n    # Let len(c) and len(d) be public integers\n    len_c = len(c)\n    len_d = len(d)\n    found = sint(0)  # secret bit: 1 means True, 0 means False\n    for i in range(len_d):\n        # Check only if a subarray starting at i could match\n        if len_c <= len_d - i:\n            candidate = sint(1)  # start with True (as secret bit)\n            for j in range(len_c):\n                # Use secret equality and bit-wise AND\n                candidate = candidate.bit_and(d[i+j] == c[j])\n            # Accumulate the result using bit_or; if any candidate holds true, found becomes true.\n            found = found.bit_or(candidate)\n    return found\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint, sbitint\n\ndef exists_5_or_7(arr):\n    # 'res' is a secret bit integer initialized to 0 (False)\n    res = sbitint(0)\n    for x in arr:\n        # x == 5 and x == 7 both yield a secret bit (sbitint). Use bit_or for secret logic OR.\n        cond = (x == 5).bit_or(x == 7)\n        res = res.bit_or(cond)\n    return res\n", "response_1": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    # The goal is to compute a secret bit indicating whether any element equals 5 or 7.\n    # Since direct secret branching on a secret condition is not allowed in MP-SPDZ,\n    # we combine the comparisons arithmetically.\n    # For secret bits b and c, one can compute OR as: b OR c = b + c - b*c.\n    found = sint(0)\n    for item in arr:\n        # Compute secret bits for the comparisons.\n        cond5 = (item == 5)\n        cond7 = (item == 7)\n        # Compute OR using: 1 - (1-b)*(1-c)\n        cond = 1 - (1 - cond5) * (1 - cond7)\n        # Accumulate the OR over all items: found = found OR cond = found + cond - found*cond\n        found = found + cond - found * cond\n    return found\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "variance", "response_0": "from Compiler.types import sfix\n\ndef variance(arr):\n    n = len(arr)\n    avg = sfix(0)\n    var = sfix(0)\n    for i in range(n):\n        avg = avg + arr[i] / n\n    for i in range(n):\n        diff = arr[i] - avg\n        var = var + (diff * diff) / n\n    return var\n", "response_1": "from Compiler.types import sfix\n\ndef variance(arr):\n    # arr is assumed to be an Array of sfix elements.\n    n = len(arr)  # public integer length\n    total = sfix(0)\n    for item in arr:\n        total += item\n    avg = total / n\n\n    var = sfix(0)\n    for item in arr:\n        diff = item - avg\n        var += diff * diff\n    var = var / n\n    return var\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_ascending", "response_0": "from Compiler.types import sint\n\ndef is_ascending(arr):\n    \"\"\"\n    Return whether the secret array is in strictly ascending order.\n    For an array of length 1, returns a secret 1 (True).\n    \"\"\"\n    n = len(arr)\n    if n == 1:\n        return sint(1)\n    # Compute the AND of all comparisons: arr[i] < arr[i+1]\n    result = arr[0] < arr[1]\n    for i in range(1, n - 1):\n        result = result.bit_and(arr[i] < arr[i+1])\n    return result\n", "response_1": "from Compiler.types import sint\n\ndef is_ascending(arr):\n    # If the array length is 1, return True (represented as 1)\n    n = len(arr)\n    if n == 1:\n        return 1\n    # Initialize the result to True (secret bit 1)\n    ascending = 1\n    # Iterate over all consecutive pairs\n    for i in range(n - 1):\n        # For secret types, the comparison yields a secret bit.\n        # We require a strictly ascending order, i.e. arr[i] < arr[i+1].\n        cond = arr[i] < arr[i+1]\n        # Combine the conditions using bitwise AND for secret booleans.\n        ascending = ascending.bit_and(cond)\n    return ascending\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "xor_all", "response_0": "from Compiler.types import sint\n\ndef xor_all(arr):\n    # Assume arr is a Python list or MP-SPDZ Array of secret bits (0's and 1's) of type sint.\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef xor_all(arr):\n    # arr is assumed to be a list or an Array of secret integers (sint) containing only 0's and 1's.\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "upper_bound", "response_0": "from Compiler.types import sint\n\ndef upper_bound(arr, x):\n    # Return the index of the smallest element in arr that is greater than x.\n    # If no such element exists, return -1.\n    #\n    # Note: This implementation assumes that arr is an Array (or list)\n    # of secret integers (sint) and that x is of type sint.\n    # The flag \u201cfound\u201d is maintained as a secret bit (0 meaning false, 1 meaning true).\n    #\n    # Initialize variables\n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)  # secret bit: 0 if not found, 1 if found\n    n = len(arr)    # public length\n\n    # Loop through every index i in arr\n    for i in range(n):\n        # cond is a secret bit: 1 if arr[i] > x, 0 otherwise.\n        cond = arr[i] > x\n        # Compute the candidate difference.\n        cand_diff = arr[i] - x\n        # When an element has already been found, we compare the candidate difference\n        cmp_bit = cand_diff < distance\n        # notFound is true if no element has been selected yet.\n        notFound = sint(1) - found\n        # We update if the current element is greater than x and either no element has been found\n        # or the current difference is smaller than the previously recorded one. \n        update_cond = cond.bit_and(notFound.bit_or(cmp_bit))\n        # Conditionally update the result.\n        ret = update_cond.if_else(sint(i), ret)\n        distance = update_cond.if_else(cand_diff, distance)\n        found = update_cond.if_else(sint(1), found)\n    return ret\n", "response_1": "from Compiler.types import cint\n\ndef upper_bound(arr, x):\n    # ret: index of the current best candidate, initialized to -1\n    # distance: difference between arr[ret] and x\n    # found: indicator (0 for false, 1 for true) whether a candidate has been found\n    ret = -1\n    distance = 0\n    found = 0\n    for i in range(len(arr)):\n        # if the current element is greater than x\n        if arr[i] > x:\n            # if no candidate found yet or current difference is smaller than the best difference\n            if (found == 0) or ((arr[i] - x) < distance):\n                ret = i\n                distance = arr[i] - x\n                found = 1\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler.types import sint\n\ndef array_process_then_sum(arr, func):\n    # Initialize total using the same secret type (sint) as the array elements\n    total = sint(0)\n    for i in range(len(arr)):  # i is a public integer index\n        arr[i] = func(arr[i])\n        total = total + arr[i]\n    return total\n", "response_1": "def array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function,\n    then sum up the processed elements.\n    \"\"\"\n    # Initialize total to zero (using the same type as the array elements)\n    total = arr[0] - arr[0]\n    for i in range(len(arr)):\n        # Process the current element with func\n        processed_val = func(arr[i])\n        # Update the array element with the processed value\n        arr[i] = processed_val\n        # Add the processed value to total\n        total = total + processed_val\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "average", "response_0": "from Compiler.types import sfix\n\ndef average(arr):\n    # Initialize total as an sfix value\n    total = sfix(0)\n    length = len(arr)\n    for i in range(length):\n        total = total + arr[i]\n    return total / length\n", "response_1": "from Compiler.types import sfix\n\ndef average(arr):\n    # Initialize sum as a secret fixed-point number\n    sum_val = sfix(0)\n    length = len(arr)  # length is a public integer\n    for i in range(length):\n        sum_val = sum_val + arr[i]\n    # Divide by a public constant (length) to compute the average\n    ret = sum_val / length\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_filter", "response_0": "from Compiler.types import sint\n\ndef array_filter(arr, predicator):\n    # For each index in the array, select the element or 0 based on the predicate.\n    for i in range(len(arr)):\n        # The predicate is assumed to return a secret bit (i.e. a value 0/1 of type sint)\n        # Use the secret conditional selection (if_else) to choose between arr[i] and 0.\n        arr[i] = predicator(arr[i]).if_else(arr[i], sint(0))\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_filter(arr, predicator):\n    # For each index i in the array, update arr[i] to:\n    # if predicator(arr[i]) returns a secret bit 1 then keep arr[i], otherwise set to 0.\n    for i in range(len(arr)):\n        cond = predicator(arr[i])\n        # Use the secret conditional selection (if_else) provided by sint.\n        # Note: arr[i].__class__(0) creates a zero of the same secret type (here, sint).\n        arr[i] = cond.if_else(arr[i], arr[i].__class__(0))\n    return arr\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_up", "response_0": "from Compiler.types import sint\n\ndef sum_up(array):\n    \"\"\"\n    The sum_up function in MP-SPDZ.\n    \"\"\"\n    total = sint(0)\n    for num in array:\n        total = total + num\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef sum_up(array):\n    \"\"\"\n    The sum_up function to compute the sum of elements in an MP-SPDZ array.\n    \"\"\"\n    total = sint(0)\n    for num in array:\n        total = total + num\n    return total\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "negative_to_zero", "response_0": "from Compiler.types import sint\n\ndef negative_to_zero(array):\n    # Loop through each element in the array.\n    for i in range(len(array)):\n        # Evaluate the condition: element is non-negative.\n        cond = array[i] >= 0\n        # If cond is true then result is array[i], otherwise 0.\n        array[i] = cond.if_else(array[i], 0)\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef negative_to_zero(array):\n    # For each element in the secret integer array, set it to 0 if it is negative.\n    for i in range(len(array)):\n        # Compare secret element with 0; the comparison returns a secret bit.\n        cond = array[i] >= 0\n        # Use the secret multiplexer: if cond==1 keep array[i], else set to 0.\n        array[i] = cond.if_else(array[i], 0)\n    return array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_only_positive_to_ten", "response_0": "from Compiler.types import cint\n\ndef sum_only_positive_to_ten(array):\n    # Compute partial sum of the array with only the positive elements\n    # until the sum becomes no smaller than 10.\n    s = cint(0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        if s >= 10:\n            break\n        s = s + array[i]\n    return s\n", "response_1": "from Compiler.types import cint\n\ndef sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    s = cint(0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        if s >= 10:\n            break\n        s = s + array[i]\n    return s\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "bubble_sort", "response_0": "from Compiler.types import sint\n\ndef bubble_sort(arr):\n    # n is public, as the length of the array is known\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            # Compute a secret bit: 1 if arr[j] >= arr[j+1], 0 otherwise.\n            b = arr[j] >= arr[j+1]\n            # Instead of a branch, compute the new pair using arithmetic\n            new_j   = b * arr[j+1] + (1 - b) * arr[j]\n            new_jp  = b * arr[j]   + (1 - b) * arr[j+1]\n            arr[j]     = new_j\n            arr[j+1]   = new_jp\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef bubble_sort(arr):\n    # assume arr is an Array of sint with a known public length\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            # Compute secret bit: 1 if arr[j] >= arr[j+1] else 0\n            b = arr[j] >= arr[j+1]\n            # Compute the difference between the two entries\n            diff = arr[j] - arr[j+1]\n            # Swap elements if condition is true (using arithmetic for oblivious conditional swap)\n            arr[j] = arr[j] - b * diff\n            arr[j+1] = arr[j+1] + b * diff\n    return arr\n", "model_name": "azure-openai-o3-mini"}
