{"test_name": "sin_or_cos", "response_0": "from Compiler.library import mpc_math\nfrom Compiler.types import sfix\n\ndef sin_or_cos(x):\n    # x is assumed to be of type sfix.\n    # The comparison (x >= 0) returns a secret bit (sbitint).\n    cond = (x >= 0)\n    # Secure mux selecting between sin(x) and cos(x)\n    return cond.if_else(mpc_math.sin(x), mpc_math.cos(x))\n", "response_1": "from Compiler import mpc_math\n\ndef sin_or_cos(x):\n    # x is assumed to be of type sfix (secret fixed-point).\n    cond = (x >= 0)  # This comparison yields a secret bit (sbitint)\n    return cond.if_else(mpc_math.sin(x), mpc_math.cos(x))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "negative_relu", "response_0": "from Compiler.types import sfix\n\ndef negative_relu(x):\n    # Check if x is less than 0; if so, return x, otherwise return 0.\n    return (x < sfix(0)).if_else(x, sfix(0))\n", "response_1": "from Compiler.types import sint\n\ndef negative_relu(x):\n    # Compute the condition: if x < 0 then cond is 1 (true) else 0 (false)\n    cond = x < 0\n    # Use secret conditional selection: if cond equals 1, return x, otherwise return 0.\n    return cond.if_else(x, 0)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_close", "response_0": "from Compiler.types import sfix\n\ndef is_close(a, b):\n    \"\"\"\n    Return whether or not the two secret values are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    return abs(a - b) <= sfix(1)\n", "response_1": "def is_close(a, b):\n    # Compute the absolute difference between a and b and check if it is at most 1.\n    return (a - b).abs() <= 1\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "hardswish", "response_0": "from Compiler.types import sfix\n\ndef hardswish(x):\n    return (x < sfix(-3)).if_else(sfix(0),\n           (x > sfix(3)).if_else(x, x * (x + sfix(3)) / sfix(6)))\n", "response_1": "from Compiler.types import sfix\n\ndef hardswish(x):\n    # x is assumed to be of type sfix.\n    cond1 = x < sfix(-3)\n    cond2 = x > sfix(3)\n    middle = (x * (x + sfix(3))) / sfix(6)\n    # If cond1 is true then return 0; otherwise, if cond2 is true then return x; else return middle.\n    return cond1.if_else(sfix(0), cond2.if_else(x, middle))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "clip_at_6", "response_0": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    # First, if x > 6 then clip to 6, otherwise keep x.\n    y = (x > sfix(6)).if_else(sfix(6), x)\n    # Then, if y < -6 then clip to -6, otherwise keep y.\n    y = (y < sfix(-6)).if_else(sfix(-6), y)\n    return y\n", "response_1": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    # First, if x > 6 then replace x by 6\n    y = (x > sfix(6)).if_else(sfix(6), x)\n    # Next, if x < -6 then replace x by -6\n    y = (y < sfix(-6)).if_else(sfix(-6), y)\n    return y\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "piecewise_function", "response_0": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    one = sfix(1)\n    neg_one = sfix(-1)\n    zero = sfix(0)\n    cond1 = x > one\n    cond2 = x < neg_one\n    cond3 = x > zero\n    cond4 = x < zero\n    ret = cond1.if_else(x, cond2.if_else(x, cond3.if_else(one, cond4.if_else(neg_one, zero))))\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    # Returns:\n    #   x, if x > 1 or x < -1\n    #   1, if 0 < x <= 1\n    #  -1, if -1 <= x < 0\n    #   0, otherwise\n    ret = (x > sfix(1)).if_else(x,\n            (x < sfix(-1)).if_else(x,\n            (x > sfix(0)).if_else(sfix(1),\n            (x < sfix(0)).if_else(sfix(-1), sfix(0)))))\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "middle", "response_0": "from Compiler.types import sint\n\ndef middle(a, b, c):\n    # First swap: if a >= b then swap a and b.\n    cond = a >= b\n    a_temp = cond.if_else(b, a)\n    b_temp = cond.if_else(a, b)\n    a = a_temp\n    b = b_temp\n\n    # Second swap: if b >= c then swap b and c.\n    cond = b >= c\n    b_temp = cond.if_else(c, b)\n    c_temp = cond.if_else(b, c)\n    b = b_temp\n    c = c_temp\n\n    # Third swap: if a >= b then swap a and b.\n    cond = a >= b\n    a_temp = cond.if_else(b, a)\n    b_temp = cond.if_else(a, b)\n    a = a_temp\n    b = b_temp\n\n    return b\n", "response_1": "from Compiler.types import sint\n\ndef middle(a, b, c):\n    # Perform conditional swaps in a branchless manner using cond_swap.\n    a, b = (a >= b).cond_swap(a, b)\n    b, c = (b >= c).cond_swap(b, c)\n    a, b = (a >= b).cond_swap(a, b)\n    return b\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler.library import mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    sin_x = mpc_math.sin(x)\n    cos_x = mpc_math.cos(x)\n    # When 'ind' is a secret bit (of type sint or sbitint),\n    # the if_else function chooses sin_x if 'ind' equals 1, and cos_x otherwise.\n    return ind.if_else(sin_x, cos_x)\n", "response_1": "from Compiler.types import sfix, sint\nimport mpc_math\n\ndef indicated_sin_or_cos(x, ind):\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n    return ind.if_else(sin_val, cos_val)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "minus2_if_else", "response_0": "from Compiler.types import sint\n\ndef minus2_if_else(x):\n    # Compute condition: x - 2 is non-negative\n    cond = (x - 2) >= 0\n    # Use the secret bit's if_else: returns x-2 if cond is true, x otherwise.\n    return cond.if_else(x - 2, x)\n", "response_1": "from Compiler.types import sint\n\ndef minus2_if_else(x):\n    diff = x - 2\n    cond = diff >= 0\n    return cond.if_else(diff, x)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "relu6", "response_0": "from Compiler.types import sfix\n\ndef relu6(x):\n    # x is assumed to be of type sfix\n    # Compute secret bits for x < 0 and x > 6\n    is_negative = x < 0\n    is_over6 = x > 6\n    # Use substitution via if_else to avoid branching on secret data\n    return is_negative.if_else(sfix(0), is_over6.if_else(sfix(6), x))\n", "response_1": "from Compiler.types import sfix\n\ndef relu6(x):\n    # Using element-wise max and min, compute ReLU6 as min(max(x, 0), 6)\n    return x.max(0).min(6)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "exp_slide", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef exp_slide(x):\n    # x is expected to be of type sfix.\n    # Compute the predicate: 1 if x >= 0, 0 otherwise.\n    cond = x >= sfix(0)\n    # Define the constant e as an sfix constant.\n    E = sfix(2.718281828459045)\n    # Compute e^x using the MP-SPDZ math function for exponentiation.\n    exp_val = mpc_math.pow_fx(E, x)\n    # Compute the alternative value: x + 1.\n    alt_val = x + sfix(1)\n    # Use oblivious selection based on the condition.\n    # cond.if_else(a, b) returns a if cond is 1, and b otherwise.\n    return cond.if_else(exp_val, alt_val)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef exp_slide(x):\n    # Set constants as sfix numbers.\n    one = sfix(1)\n    zero = sfix(0)\n    e_const = sfix(2.718281828459045)\n    # Compute the condition bit: 1 if x >= 0, 0 otherwise.\n    cond = (x >= zero)\n    # Instead of branching on a secret value, compute both branches and select the result:\n    # When cond is 1, use e_const^x computed as mpc_math.pow_fx(e_const, x)\n    # When cond is 0, use x + 1.\n    result = cond * mpc_math.pow_fx(e_const, x) + (one - cond) * (x + one)\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "pass_or_not", "response_0": "from Compiler.types import sint\n\ndef pass_or_not(score):\n    # Check if the score is at least 60\n    passed = score >= 60\n    # Select the original score if passed, otherwise choose 59\n    adj_score = passed.if_else(score, sint(59))\n    return adj_score, passed\n", "response_1": "from Compiler.types import sint\n\ndef pass_or_not(score):\n    # score is of type sint\n    cond = score >= 60\n    new_score = cond.if_else(score, sint(59))\n    return new_score, cond\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import cfix\n\ndef how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    # When a is zero, the function is not quadratic.\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n\n    # Compute the discriminant: b^2 - 4*a*c\n    disc = b * b - 4 * a * c\n\n    if disc > 0:\n        return 2\n    elif disc == 0:\n        return 1\n    else:\n        return 0\n", "response_1": "from Compiler.types import cfix\n\ndef how_many_roots(a: cfix, b: cfix, c: cfix):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    # Check if the quadratic coefficient is zero.\n    if a == 0:\n        # With a == 0, the function is linear: b*x + c = 0.\n        if b == 0:\n            return 0\n        else:\n            return 1\n    # Compute the discriminant: b**2 - 4*a*c.\n    disc = b * b - 4 * a * c\n    if disc > 0:\n        return 2\n    elif disc == 0:\n        return 1\n    else:\n        return 0\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "elu", "response_0": "from Compiler.types import sfix\nimport mpc_math\nimport math\n\ndef elu(x):\n    # x is expected to be of type sfix\n    cond = (x > sfix(0))\n    true_val = x\n    false_val = mpc_math.pow_fx(sfix(math.e), x) - sfix(1)\n    return cond.if_else(true_val, false_val)\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import mpc_math\n\ndef elu(x):\n    # x is assumed to be of type sfix\n    # Define constant e as sfix\n    e_val = sfix(2.718281828459045)\n    # Compute exponentiation e^x using the MP-SPDZ non-linear function\n    exp_x = mpc_math.pow_fx(e_val, x)\n    \n    # Compute branch for x <= 0: e^x - 1\n    neg_branch = exp_x - sfix(1)\n    \n    # Compute branch for x > 0: just x\n    pos_branch = x\n\n    # The comparison x > 0 returns a secret bit (sbitint),\n    # so we use its if_else method for conditional selection.\n    return (x > 0).if_else(pos_branch, neg_branch)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "relu", "response_0": "from Compiler.types import sfix\n\ndef relu(x):\n    # x is assumed to be an sfix secret fixed\u2010point number.\n    # The comparison (x > sfix(0)) returns a secret bit,\n    # then if_else selects x if the bit is 1, otherwise sfix(0).\n    return (x > sfix(0)).if_else(x, sfix(0))\n", "response_1": "from Compiler.types import sfix\n\ndef relu(x):\n    # Compute a secret bit: 1 if x > 0, 0 otherwise.\n    b = x > sfix(0)\n    # Use the secret bit to select between x and 0 without branching.\n    return b.if_else(x, sfix(0))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "leaky_relu", "response_0": "from Compiler.types import sfix\n\ndef leaky_relu(x, alpha):\n    # Evaluate the condition x > 0. This comparison returns a secret bit.\n    cond = (x > 0)\n    # Select x if cond is 1, or x*alpha if cond is 0.\n    return cond.if_else(x, x * alpha)\n", "response_1": "from Compiler.types import sfix\n\ndef leaky_relu(x, alpha):\n    # Compute a secret bit: 1 if x > 0, else 0\n    b = (x > sfix(0))\n    # Use the secure multiplexer: if b==1 return x, else return x * alpha\n    return b.if_else(x, x * alpha)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max", "response_0": "def max_value(a, b):\n    return a.max(b)\n", "response_1": "def max_val(a, b):\n    # In MP-SPDZ, comparisons between secret numbers (such as sint or sfix) yield a secret bit.\n    # Then, the secret bit\u2019s if_else method is used for oblivious selection.\n    cond = a >= b\n    return cond.if_else(a, b)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "bowl_shape", "response_0": "from Compiler.types import sint\n\ndef bowl_shape(x):\n    # x is assumed to be of type sint\n    cond1 = x > 1   # returns a secret bit\n    cond2 = x < -1  # returns a secret bit\n    # Select x-1 if cond1 is true, else select (-x-1) if cond2 is true, otherwise 0.\n    return cond1.if_else(x - 1, cond2.if_else(-x - 1, 0))\n", "response_1": "from Compiler.types import sfix\n\ndef bowl_shape(x):\n    # Using nested if_else expressions to avoid branching on secret values:\n    return (x > sfix(1)).if_else(x - sfix(1),\n           (x < -sfix(1)).if_else(-x - sfix(1), sfix(0)))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "rounded_kinetic_energy", "response_0": "from Compiler.types import sfix, sint\n\ndef rounded_kinetic_energy(m, v):\n    # Compute the kinetic energy: k = m * v\u00b2 / 2\n    k = m * (v ** 2) / sfix(2)\n    # Obtain the floored integer part by converting k to a secret integer (truncation)\n    k_int = sint(k)\n    # Compute the fractional part of k\n    diff = k - sfix(k_int)\n    # If the fractional part is less than 0.5, keep k_int; otherwise, round up by adding 1.\n    return diff.lt(sfix(0.5)).if_else(k_int, k_int + 1)\n", "response_1": "from Compiler.types import sfix, sint\n\ndef rounded_kinetic_energy(m, v):\n    # Compute kinetic energy: k = m*v^2/2   (all operations are element\u2010wise on sfix numbers)\n    k = m * (v * v) / 2\n    # Obtain the integer part of k. Here we assume that k.int() returns the floor of the sfix number.\n    k_int = k.int()\n    # Compute the remainder: k - floor(k); note that sfix(k_int) converts the integer part back to fixed-point.\n    remainder = k - sfix(k_int)\n    # Create a secret bit that is 1 if remainder < 0.5 and 0 otherwise.\n    # The comparison between sfix numbers returns a secret bit (of type sint) so that branching is done obliviously.\n    decision = remainder < 0.5\n    # Use the secret bit to select between k_int and k_int+1.\n    # If (k-k_int) < 0.5 then the bit is 1 and if_else returns k_int; otherwise returns k_int+1.\n    return decision.if_else(k_int, k_int + 1)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "danger_test", "response_0": "from Compiler.types import sint\n\ndef danger_test(origin, damage):\n    # Compute the remaining health after taking damage\n    remaining = origin - damage\n    # Return whether the remaining health is no more than 10\n    return remaining <= 10\n", "response_1": "from Compiler.types import sint\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy!\n    Given the Dragon Warrior's initial health and the damage he receives,\n    decide whether the situation is dangerous.\n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return (origin - damage) <= 10\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    # If 'ind' is a secret bit (e.g. a sint that is 0 or 1),\n    # then multiplying by 'ind' selects the sum (if ind=1)\n    # while multiplying by (1-ind) selects the product (if ind=0).\n    return ind * (x + y) + (1 - ind) * (x * y)\n", "response_1": "from Compiler.types import sint\n\ndef indicated_sum_or_multiply(x, y, ind):\n    # If \"ind\" is 1 (True), return the sum; otherwise return the product.\n    # Here we compute: ind*(x+y) + (1-ind)*(x*y)\n    return ind * (x + y) + (1 - ind) * (x * y)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "median", "response_0": "from Compiler.types import sfix\n\ndef median(arr):\n    # Check if the array is empty\n    if len(arr) == 0:\n        raise Exception(\"The length of the array is 0!\")\n    \n    # Sort the array in-place (the sort is implemented as a radix sort for sfix arrays)\n    arr.sort()\n    \n    n = len(arr)\n    # Determine the median based on odd or even number of elements\n    if n % 2 == 1:\n        return arr[n // 2]\n    else:\n        # Here division \"/\" on sfix types performs a fixed-point division.\n        return (arr[n // 2] + arr[(n // 2) - 1]) / 2\n", "response_1": "from Compiler.types import sfix\n\ndef median(arr):\n    # Check whether the array is empty\n    if len(arr) == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    # Sort the Array in place (supported by MP-SPDZ Array.sort())\n    arr.sort()\n    n = len(arr)\n    # Compute median: if n is odd, return middle element; if even, average the two middle elements.\n    if n % 2 == 1:\n        ret = arr[n // 2]\n    else:\n        ret = (arr[n // 2] + arr[n // 2 - 1]) / 2\n    return ret\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "add_upto_10", "response_0": "from Compiler.types import sfix\n\ndef add_upto_10(a, b):\n    s = a + b\n    # Compute a secret bit: 1 if s > 10, 0 otherwise.\n    c = s > sfix(10)\n    # Use arithmetic selection: if c==1 return 10, else return s.\n    return sfix(10) * c + s * (sfix(1) - c)\n", "response_1": "from Compiler.types import sint\n\ndef add_upto_10(a, b):\n    s = a + b\n    # Compute secret bit: 1 if s > 10, 0 otherwise\n    cond = s > 10\n    # Use oblivious selection: if cond then return 10 else return s\n    return cond.if_else(10, s)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "taxi_fare", "response_0": "from Compiler.types import sfix\n\ndef taxi_fare(m):\n    five = sfix(5)\n    ten = sfix(10)\n    fare1 = five\n    fare2 = five + sfix(1.2) * (m - five)\n    fare3 = sfix(11) + sfix(1.5) * (m - ten)\n    cond1 = m <= five\n    cond2 = m <= ten\n    return cond1.if_else(fare1, cond2.if_else(fare2, fare3))\n", "response_1": "from Compiler.types import sfix\n\ndef taxi_fare(m):\n    # Define constant values as sfix numbers\n    five = sfix(5)\n    ten = sfix(10)\n    # Compute the three possible fare cases\n    fare1 = sfix(5)\n    fare2 = sfix(5) + sfix(1.2) * (m - five)\n    fare3 = sfix(11) + sfix(1.5) * (m - ten)\n    # Compute conditions as secret bits; comparisons on sfix yield sbitint objects.\n    cond1 = m <= five\n    cond2 = (m > five) & (m <= ten)\n    # Cond3 is true when m > 10 (i.e. neither cond1 nor cond2)\n    cond3 = sfix(1) - cond1 - cond2\n    # Combine the cases using branchless selection.\n    return cond1 * fare1 + cond2 * fare2 + cond3 * fare3\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "round", "response_0": "from Compiler.types import cfix\nimport math\n\ndef round(x: cfix) -> cfix:\n    # Compute the integer part of x using floor\n    x_int = cfix(math.floor(x))\n    # Determine the fractional part by subtracting the integer part\n    frac = x - x_int\n    # Return x_int if fractional part is less than 0.5, otherwise x_int + 1\n    return x_int if frac < 0.5 else x_int + 1\n", "response_1": "from Compiler.types import cfix\nfrom math import floor\n\ndef round_fx(x: cfix) -> cfix:\n    # Round x to the nearest integer (round half up)\n    x_int = cfix(floor(x))\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "gpa_calculator", "response_0": "from Compiler.types import sfix\n\ndef gpa_calculator(score):\n    # score is assumed to be of type sfix and in the range [0, 100]\n    # Comparisons on sfix yield secret bit integers (sbitint) on which we can use if_else\n    cond1 = score >= sfix(90)\n    cond2 = score >= sfix(85)\n    cond3 = score >= sfix(80)\n    cond4 = score >= sfix(75)\n    cond5 = score >= sfix(70)\n    res = cond1.if_else(sfix(4.0),\n           cond2.if_else(sfix(3.6),\n           cond3.if_else(sfix(3.3),\n           cond4.if_else(sfix(3.0),\n           cond5.if_else(sfix(2.6), sfix(2.3)))))\n    return res\n", "response_1": "from Compiler.types import sfix\n\ndef gpa_calculator(score):\n    # Here, score is assumed to be of type sfix.\n    # All comparisons on sfix yield a secret bit (sintbit) that supports if_else.\n    # We compare with sfix constants.\n    cond90 = score >= sfix(90)\n    cond85 = score >= sfix(85)\n    cond80 = score >= sfix(80)\n    cond75 = score >= sfix(75)\n    cond70 = score >= sfix(70)\n    result = cond90.if_else(sfix(4.0),\n             cond85.if_else(sfix(3.6),\n             cond80.if_else(sfix(3.3),\n             cond75.if_else(sfix(3.0),\n             cond70.if_else(sfix(2.6), sfix(2.3)))))\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sign", "response_0": "from Compiler.types import sint\n\ndef sign(x):\n    # x is expected to be a secret integer (sint)\n    # Compute secret bits for comparisons\n    is_zero = (x == 0)\n    pos = (x > 0)\n    # If x == 0 then output 0, else if x > 0 output 1, else output -1.\n    return is_zero.if_else(0, pos.if_else(1, -1))\n", "response_1": "from Compiler.types import sint\n\ndef sign(x):\n    # When x > 0, (x > 0).if_else(1, ...) returns 1.\n    # Otherwise, evaluate (x < 0).if_else(-1, 0) to return -1 if x < 0, and 0 if x == 0.\n    return (x > 0).if_else(1, (x < 0).if_else(-1, 0))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sum_or_difference", "response_0": "from Compiler.types import sint\n\ndef sum_or_difference(a, b):\n    # Compute the secret comparison; this yields a secret bit.\n    cond = a <= b\n    # Use the secret bit's if_else: if cond is 1 then return a+b, else a-b.\n    return cond.if_else(a + b, a - b)\n", "response_1": "from Compiler.types import sint\n\ndef sum_or_difference(a, b):\n    # a and b are assumed to be of type sint.\n    # The comparison (a <= b) yields a secret bit.\n    # Using if_else on the secret bit, we select a+b if true, otherwise a-b.\n    return (a <= b).if_else(a + b, a - b)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "CNOT", "response_0": "from Compiler.types import sint\n\ndef CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit.\n    \"\"\"\n    return control_bit.if_else(flip_bit.bit_not(), flip_bit)\n", "response_1": "from Compiler.types import sint\n\ndef CNOT(control_bit: sint, flip_bit: sint):\n    # If control_bit is 1, invert flip_bit using bit_not(); otherwise, return flip_bit.\n    return control_bit.if_else(flip_bit.bit_not(), flip_bit)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "negative_plus1", "response_0": "from Compiler.types import sint\n\ndef negative_plus1(y):\n    # Return y+1 if y is negative, otherwise return y\n    return (y < 0).if_else(y + 1, y)\n", "response_1": "from Compiler.types import sint\n\ndef negative_plus1(y: sint) -> sint:\n    # Compute secret bit: 1 if y is negative, 0 otherwise.\n    cond = y < 0\n    # Use the secret bit's if_else to choose between y+1 and y.\n    return cond.if_else(y + 1, y)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler.types import sint\n\ndef is_a_parallelogram(a, b, c, d):\n    # a, b, c, d are assumed to be lists (or tuples) of two sint values each.\n    def same(x, y):\n        return (x[0] == y[0]).bit_and(x[1] == y[1])\n    # Check for duplicated vertices.\n    duplicates = same(a, b).bit_or(same(a, c)).bit_or(same(a, d)).bit_or(same(b, c)).bit_or(same(b, d)).bit_or(same(c, d))\n    \n    # Compute the three possible parallelogram conditions.\n    cond1 = ((a[0] + b[0]) == (c[0] + d[0])).bit_and((a[1] + b[1]) == (c[1] + d[1]))\n    cond2 = ((a[0] + c[0]) == (b[0] + d[0])).bit_and((a[1] + c[1]) == (b[1] + d[1]))\n    cond3 = ((a[0] + d[0]) == (b[0] + c[0])).bit_and((a[1] + d[1]) == (b[1] + c[1]))\n    \n    # Only if there are no duplicates and at least one condition holds,\n    # we declare the vertices form a parallelogram.\n    is_para = (sint(1) - duplicates).bit_and(cond1.bit_or(cond2).bit_or(cond3))\n    \n    return is_para\n", "response_1": "from Compiler.types import sint\n\ndef is_a_parallelogram(a, b, c, d):\n    # Helper function to check equality of two vertices\n    def same(x, y):\n        return (x[0] == y[0]).bit_and(x[1] == y[1])\n    \n    # Check if any two vertices are identical\n    dup = same(a, b).bit_or(same(a, c)).bit_or(same(a, d)) \\\n          .bit_or(same(b, c)).bit_or(same(b, d)).bit_or(same(c, d))\n    \n    # Three cases for parallelogram: the sums of opposite vertices must be equal\n    cond1 = (a[0] + b[0] == c[0] + d[0]).bit_and(a[1] + b[1] == c[1] + d[1])\n    cond2 = (a[0] + c[0] == b[0] + d[0]).bit_and(a[1] + c[1] == b[1] + d[1])\n    cond3 = (a[0] + d[0] == b[0] + c[0]).bit_and(a[1] + d[1] == b[1] + c[1])\n    \n    par = cond1.bit_or(cond2).bit_or(cond3)\n    \n    # If there is a duplicate vertex, return False (0), else return the parallelogram condition\n    return dup.if_else(0, par)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "min", "response_0": "def min(a, b):\n    return a.min(b)\n", "response_1": "def min_val(a, b):\n    # Compute the secret condition (a <= b) which yields a secret bit,\n    # then use the if_else() method to select a if true, else b.\n    return (a <= b).if_else(a, b)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "choice_of_the_knight", "response_0": "from Compiler.types import sint\n\ndef legal(a, b):\n    # Each comparison (e.g., a >= 0) returns a secret bit.\n    # Use bit_and to compute the logical AND of the four conditions.\n    cond = (a >= 0).bit_and(a <= 7).bit_and((b >= 0).bit_and(b <= 7))\n    # Convert the secret bit into a secret integer (1 if true, 0 if false)\n    return cond.if_else(1, 0)\n\ndef choice_of_the_knight(x, y):\n    # x and y are assumed to be of type sint representing the board coordinates.\n    counter = sint(0)\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef legal(a, b):\n    # Each comparison returns a secret bit (0 or 1)\n    cond1 = (0 <= a)\n    cond2 = (a <= 7)\n    cond3 = (0 <= b)\n    cond4 = (b <= 7)\n    # Combine conditions using multiplication to act as logical AND\n    return cond1 * cond2 * cond3 * cond4\n\ndef choice_of_the_knight(x, y):\n    # The knight's moves offsets\n    counter = legal(x+1, y+2) + legal(x-1, y+2) + legal(x+1, y-2) + legal(x-1, y-2) \\\n            + legal(x+2, y+1) + legal(x-2, y+1) + legal(x+2, y-1) + legal(x-2, y-1)\n    return counter\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_sum_difference", "response_0": "from Compiler.types import sint\n\ndef max_sum_different(a, b):\n    s1 = a + b\n    s2 = a - b\n    # Comparison of secret integers yields a secret bit.\n    cond = s1 > s2\n    # Using the secret bit\u2019s if_else to select the maximum value.\n    return cond.if_else(s1, s2)\n", "response_1": "from Compiler.types import sint\n\ndef max_sum_different(a, b):\n    # Compute a+b and a-b\n    sum_val = a + b\n    diff_val = a - b\n    # Compare the two; the result is a secret bit (sbitint)\n    condition = sum_val > diff_val\n    # Use if_else to select the maximum value without leaking information\n    return condition.if_else(sum_val, diff_val)\n", "model_name": "azure-openai-o3-mini"}
