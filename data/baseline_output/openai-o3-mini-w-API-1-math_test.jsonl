{"test_name": "next_integer", "response_0": "from Compiler.types import cfix, cint\n\ndef next_integer(t):\n    # Here t is assumed to be a clear fixed\u2010point number (cfix).\n    # Converting t to cint truncates the fraction (i.e. behaves as floor for nonnegative t).\n    return cint(t) + 1\n", "response_1": "from Compiler.types import cfix, cint\nimport math\n\ndef next_integer(t):\n    # t is assumed to be a clear fixed\u2010point value (cfix)\n    # Compute the floor in clear and convert it to a clear integer, then add 1.\n    return cint(math.floor(t)) + 1\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "father_and_son", "response_0": "from Compiler.types import sint\n\ndef father_and_son(father_age, son_age):\n    # Given the age of father and son,\n    # return the number of years before or after such that\n    # the father's age becomes twice the son's age.\n    return abs(father_age - son_age * 2)\n", "response_1": "from Compiler.types import sint\n\ndef father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son,\n    return before how many years or after how many years,\n    the age of father is twice as the age of son.\n    \"\"\"\n    return abs(father_age - son_age * 2)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "triangle_area", "response_0": "from Compiler.types import sfix\n\ndef triangle_area(side: sfix, height: sfix) -> sfix:\n    \"\"\"\n    Computes the area of a triangle given a side length and the corresponding height.\n    \"\"\"\n    return side * height / 2\n", "response_1": "from Compiler.types import sfix\n\ndef triangle_area(side, height):\n    # Compute the area as: (side * height) / 2\n    return side * height / sfix(2)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sin_plus_cos", "response_0": "import mpc_math\n\ndef sin_plus_cos(a):\n    return mpc_math.sin(a) + mpc_math.cos(a)\n", "response_1": "from Compiler.library import mpc_math\n\ndef sin_plus_cos(a):\n    # a is expected to be a secret fixed-point number (sfix)\n    return mpc_math.sin(a) + mpc_math.cos(a)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sigmoid", "response_0": "from Compiler.library import mpc_math\nfrom Compiler.types import sfix\n\ndef sigmoid(x):\n    # Compute the exponentiation: e^(-x)\n    exp_val = mpc_math.pow_fx(sfix(2.718281828459045), -x)\n    return sfix(1) / (sfix(1) + exp_val)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef sigmoid(x):\n    # Assumes that x is of type sfix\n    e = sfix(2.718281828459045)\n    neg_x = -x\n    exp_val = mpc_math.pow_fx(e, neg_x)\n    return sfix(1) / (sfix(1) + exp_val)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "self_exponent", "response_0": "from Compiler import mpc_math\n\ndef self_exponent(k):\n    # k is assumed to be of type sfix for fixed-point secret values.\n    return mpc_math.pow_fx(k, k)\n", "response_1": "from Compiler.library.mpc_math import pow_fx\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return pow_fx(k, k)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "silu", "response_0": "from Compiler.library import mpc_math\nfrom Compiler.types import sfix\n\ndef silu(x):\n    # SiLU (Sigmoid-Weighted Linear Unit) activation function: x / (1 + exp(-x))\n    e = sfix(2.718281828459045)\n    return x / (1 + mpc_math.pow_fx(e, -x))\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef silu(x):\n    # SiLU function: x/(1 + e^(-x))\n    return x / (1 + mpc_math.pow_fx(2.718281828459045, -x))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "Gaussian_bracket", "response_0": "from Compiler.types import sfix\n\ndef Gaussian_bracket(x: sfix) -> sfix:\n    # Compute the integral part of x.\n    # Here we assume x is nonnegative and use the built\u2010in truncation method for sfix.\n    x_int = x.truncate()\n    return x - x_int\n", "response_1": "from Compiler.types import cfix\n\ndef Gaussian_bracket(x: cfix):\n    # Assuming x is a clear fixed\u2010point number (cfix),\n    # int(x) computes the floor for non\u2010negative values.\n    x_int = int(x)\n    return x - x_int\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "asin_and_square", "response_0": "from Compiler.library import mpc_math\n\ndef asin_and_square(x):\n    # Compute arcsin of x and then return its square using mpc_math.pow_fx.\n    return mpc_math.pow_fx(mpc_math.asin(x), 2)\n", "response_1": "from Compiler.library import mpc_math\n\ndef asin_and_square(x):\n    # Compute arcsin using MP-SPDZ's mpc_math.asin, then square the result using mpc_math.pow_fx.\n    y = mpc_math.asin(x)\n    return mpc_math.pow_fx(y, 2)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cylinder_surface", "response_0": "from Compiler.types import sfix, cfix\nimport math\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    # Convert math.pi into a secret fixed-point constant\n    pi = sfix(cfix(math.pi))\n    return 2 * pi * (r ** 2) + 2 * pi * r * h\n", "response_1": "from Compiler.types import sfix\nfrom Compiler import mpc_math\n\ndef cylinder_surface(r, h):\n    pi = sfix(3.141592653589793)\n    r_squared = mpc_math.pow_fx(r, 2)\n    return sfix(2) * pi * r_squared + sfix(2) * pi * r * h\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "radian_to_degree", "response_0": "from Compiler.types import sfix\nimport math\n\ndef radian_to_degree(r):\n    # Converting radian to degree\n    return r / sfix(math.pi) * sfix(180)\n", "response_1": "from Compiler.types import sfix\n\ndef radian_to_degree(r):\n    # Converting radian to degree\n    pi_val = sfix(3.141592653589793)\n    return r / pi_val * 180\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "square_root", "response_0": "from Compiler.library import mpc_math\n\ndef square_root(a):\n    return mpc_math.sqrt(a)\n", "response_1": "from Compiler import mpc_math\n\ndef square_root(a):\n    \"\"\"\n    Return the square root of the input.\n    \"\"\"\n    return mpc_math.sqrt(a)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cosine_theorem", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them,\n    use the cosine theorem to compute the length of the third edge.\n    All parameters are assumed to be of type sfix.\n    \"\"\"\n    # Compute a^2, b^2 and the cosine term.\n    a_squared = a * a\n    b_squared = b * b\n    cosine_term = mpc_math.cos(rad)\n    double_product = 2 * a * b * cosine_term\n    # Compute the third edge using the sine theorem\n    result = mpc_math.sqrt(a_squared + b_squared - double_product)\n    return result\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use the cosine theorem to compute the length of the third edge.\n    \"\"\"\n    return mpc_math.sqrt(a * a + b * b - 2 * a * b * mpc_math.cos(rad))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "lights_states", "response_0": "from Compiler.math import mpc_math\nfrom Compiler.types import sfix\n\ndef lights_states(num: sfix) -> sfix:\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    two = sfix(2)\n    return mpc_math.pow_fx(two, num)\n", "response_1": "from Compiler.mpc_math import pow_fx\n\ndef lights_states(num):\n    # Compute 2 raised to the power num, where num corresponds to the number of lights.\n    # Each light can be either on or off, so the total number of states is 2^num.\n    return pow_fx(2, num)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "degree_to_radian", "response_0": "from Compiler.types import sfix\n\ndef degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian.\n    d is expected to be a secret fixed-point number (sfix).\n    \"\"\"\n    pi_val = sfix(3.141592653589793)\n    return d * (pi_val / 180)\n", "response_1": "from Compiler.types import cfix\nimport math\n\ndef degree_to_radian(d: cfix) -> cfix:\n    # Conversion factor: \u03c0/180\n    return d * (cfix(math.pi) / cfix(180))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "Fah_to_Cel", "response_0": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - sfix(32)) / sfix(1.8)\n", "response_1": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    # F is assumed to be a sfix (secret fixed-point number) representing a Fahrenheit temperature.\n    return (F - sfix(32)) / sfix(1.8)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "elliptic_area", "response_0": "from Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    # Define the constant \u03c0 as a secret fixed-point number\n    pi_val = sfix(3.141592653589793)\n    return pi_val * a * b\n", "response_1": "from Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    # Calculate the area of an ellipse: \u03c0 * a * b\n    PI = sfix(3.141592653589793)\n    return PI * a * b\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "floor", "response_0": "def floor(z):\n    # Return the maximum integer no bigger than the input.\n    # Note: when working with clear fixed\u2010point numbers (cfix), \n    # int(z) yields the truncation toward zero. For negative numbers,\n    # we need to subtract one if z is not already an integer.\n    t = int(z)\n    if z < 0 and t != z:\n        return t - 1\n    return t\n", "response_1": "from Compiler.types import cfix, cint\n\ndef floor(z: cfix) -> cint:\n    # Return the maximum integer no bigger than the input z.\n    # Since z is a clear fixed\u2010point number (cfix),\n    # using floor division by 1 yields the floor value.\n    return cint(z // 1)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "log_and_cube", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef log_and_cube(x):\n    # Compute logarithm with base 2 and then cube the result.\n    log_val = mpc_math.log_fx(x, 2)\n    return mpc_math.pow_fx(log_val, 3)\n", "response_1": "from Compiler.library import mpc_math\n\ndef log_and_cube(x):\n    \"\"\"\n    Compute the logarithm (base 2) of x and then cube the result.\n    Assumes x is of type sfix.\n    \"\"\"\n    log_val = mpc_math.log_fx(x, 2)\n    result = mpc_math.pow_fx(log_val, 3)\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "floor_and_square", "response_0": "from Compiler.types import cfix, cint\nimport math\n\ndef floor_and_square(z: cfix) -> cint:\n    # Compute the largest integer not exceeding z (since z is clear fixed\u2010point)\n    floor_val = cint(math.floor(z))\n    return floor_val * floor_val\n", "response_1": "from Compiler.types import sfix, sint\n\ndef floor_and_square(z: sfix) -> sint:\n    # Obtain the floor of the secret fixed\u2010point number z.\n    # Here, we assume that z.truncate() returns the largest secret integer no bigger than z.\n    i = z.truncate()\n    return i * i\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "meters_to_feet", "response_0": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * sfix(3.2808)\n", "response_1": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    # Convert the length in meters (sfix) to the length in feet (sfix)\n    return m * 3.2808\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "sphere_area", "response_0": "from Compiler.types import sfix\n\npi = sfix(3.141592653589793)\n\ndef sphere_area(r):\n    # Return the area of a sphere surface with given radius r.\n    return sfix(4) * pi * (r * r)\n", "response_1": "import mpc_math\n\ndef sphere_area(r):\n    # r is expected to be of type sfix (secret fixed-point)\n    # Use mpc_math.pow_fx for exponentiation and a numerical constant for pi.\n    return 4 * 3.141592653589793 * mpc_math.pow_fx(r, 2)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "coarse_abs", "response_0": "from Compiler.types import sfix, sint\n\ndef coarse_abs(x):\n    # x is assumed to be of type sfix.\n    # Compute absolute value (a sfix) and then convert to a secret integer,\n    # which acts as a truncation (i.e. rounds towards zero)\n    return sint(abs(x))\n", "response_1": "from Compiler.types import sfix, sint\n\ndef coarse_abs(x):\n    # Compute the absolute value (sfix supports abs())\n    abs_x = abs(x)\n    # Converting the fixed\u2010point value to a secret integer\n    # truncates (rounds toward zero) the fractional part.\n    return sint(abs_x)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "how_many_chickens", "response_0": "from Compiler.types import sint\n\ndef how_many_chickens(heads: sint, legs: sint) -> sint:\n    # Compute the number of chickens as: heads - ((legs - heads*2) / 2)\n    # Note: since legs - heads*2 is always even for valid inputs, the field division by 2 \n    # correctly computes integer division modulo the prime.\n    return heads - (legs - heads * 2) / 2\n", "response_1": "from Compiler.types import sint\n\ndef how_many_chickens(heads, legs):\n    # Compute the number of chickens in the rabbit-chicken problem.\n    # Since heads and legs are nonnegative, we use right-shift to perform division by 2.\n    return heads - ((legs - heads * 2) >> 1)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "interest_calculator", "response_0": "import mpc_math\nfrom Compiler.types import sfix\n\ndef interest_calculator(capital, ratio, months):\n    # Compute (1 + ratio)^months using mpc_math.pow_fx, then subtract 1, and finally multiply by capital.\n    temp = mpc_math.pow_fx(ratio + sfix(1), months) - sfix(1)\n    return temp * capital\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get.\n    \"\"\"\n    return (mpc_math.pow_fx(1 + ratio, months) - 1) * capital\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "circle_area", "response_0": "from Compiler.types import sfix\n\nPI = sfix(3.141592653589793)\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    return PI * (r * r)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef circle_area(r):\n    # r is expected to be of type sfix (secret fixed-point)\n    pi = 3.141592653589793  # public constant; it will be converted to sfix as needed\n    return pi * (r ** 2)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef cube_and_square_root(x):\n    # Compute x cubed using mpc_math.pow_fx\n    cube = mpc_math.pow_fx(x, 3)\n    # Then compute the square root of the cubed value\n    return mpc_math.sqrt(cube)\n", "response_1": "from Compiler import mpc_math\n\ndef cube_and_square_root(x):\n    # Compute cube of x and then the square root of the result.\n    return mpc_math.sqrt(mpc_math.pow_fx(x, 3))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "round", "response_0": "from Compiler.types import sfix\n\ndef round_sfix(x):\n    # Compute the floor of x.\n    # Here we use the sfix.truncate() method which for non\u2010negative x returns floor(x).\n    x_int = x.truncate()\n    # Compute the fractional part and then use a secret if_else selection.\n    # The comparison (x - x_int) < sfix(0.5) returns a secret bit.\n    # If the fractional part is less than 0.5, then x rounds to x_int; otherwise to x_int + 1.\n    return ( (x - x_int) < sfix(0.5) ).if_else(x_int, x_int + 1)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef round_sfix(x):\n    # Compute the integer part (floor) of x using MP-SPDZ's floor function\n    x_int = mpc_math.floor_fx(x)\n    # Compute the fractional part\n    frac = x - x_int\n    # Compare the fractional part with 0.5; the '<' operator returns a secret bit\n    cond = (frac < 0.5)\n    # Select x_int if frac < 0.5, else x_int + 1\n    return cond.if_else(x_int, x_int + 1)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cryptic_adjustment", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef cryptic_adjustment(origin):\n    # The adjustment formula is 10*sqrt(10*sqrt(origin))\n    return sfix(10) * mpc_math.sqrt(sfix(10) * mpc_math.sqrt(origin))\n", "response_1": "import mpc_math\n\ndef cryptic_adjustment(origin):\n    # The adjustment formula is: 10 * sqrt(10 * sqrt(origin))\n    return 10 * mpc_math.sqrt(10 * mpc_math.sqrt(origin))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "specific_pow", "response_0": "from Compiler.library import mpc_math\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5).\n    \"\"\"\n    return mpc_math.pow_fx(x, 2.5)\n", "response_1": "from Compiler import mpc_math\n\ndef specific_pow(x):\n    # Return x raised to the power 2.5\n    return mpc_math.pow_fx(x, 2.5)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "soft_plus", "response_0": "from Compiler import mpc_math\nfrom Compiler.types import sfix\n\ndef soft_plus(x):\n    # Define the Euler constant as a clear fixed-point number\n    e = sfix(2.718281828459045)\n    # Compute 1 + e^x\n    one = sfix(1)\n    exp_val = mpc_math.pow_fx(e, x)\n    # Compute logarithm base e: log_e(1 + e^x)\n    result = mpc_math.log_fx(one + exp_val, e)\n    return result\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef soft_plus(x):\n    e = sfix(2.718281828459045)\n    return mpc_math.log_fx(sfix(1) + mpc_math.pow_fx(e, x), e)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "ball_volume", "response_0": "from Compiler.types import cfix\nimport mpc_math\n\ndef ball_volume(r):\n    # Compute r^3 using mpc_math's power function for fixed-point numbers.\n    r_cubed = mpc_math.pow_fx(r, 3)\n    # Define the constants as clear fixed-point numbers.\n    pi = cfix(3.141592653589793)\n    factor = cfix(4) / cfix(3)\n    # Return the volume: (4/3)*pi*r^3\n    return pi * factor * r_cubed\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef ball_volume(r):\n    # r is assumed to be of type sfix\n    pi = sfix(3.141592653589793)  # constant \u03c0 as sfix\n    # Compute volume as (4/3)*\u03c0*r^3\n    return (4 * pi * (r ** 3)) / 3\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "Heron", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\ndef Heron(a: sfix, b: sfix, c: sfix) -> sfix:\n    p = (a + b + c) / sfix(2)\n    area = mpc_math.sqrt(p * (p - a) * (p - b) * (p - c))\n    return area\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef Heron(a, b, c):\n    # Compute the semi-perimeter p = (a + b + c) / 2\n    p = (a + b + c) / sfix(2)\n    # Return the area computed using Heron's formula\n    return mpc_math.sqrt(p * (p - a) * (p - b) * (p - c))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "next_perfect_square", "response_0": "from Compiler.library import mpc_math\nfrom Compiler.types import cint, cfix\n\ndef next_perfect_square(x):\n    # Assume x is a public/clear integer of type cint.\n    # Convert x into a clear fixed\u2010point number.\n    x_fix = cfix(x)\n    # Compute the square root using MP-SPDZ\u2019s built-in function. This returns a cfix.\n    sqrt_x = mpc_math.sqrt(x_fix)\n    # Convert the fixed-point square root to an integer, effectively taking its floor.\n    floor_sqrt = cint(sqrt_x)\n    # Increment the floor and square to get the next perfect square.\n    next_int = floor_sqrt + 1\n    return next_int * next_int\n", "response_1": "from Compiler.types import cfix\nimport mpc_math\n\ndef next_perfect_square(x):\n    # Convert the clear integer x into a clear fixed\u2010point number.\n    sqrt_x = mpc_math.sqrt(cfix(x))\n    # Since x is positive, converting the clear fixed\u2010point value to an int\n    # yields its floor.\n    n = int(sqrt_x)\n    return (n + 1) ** 2\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "pi_to_the_x", "response_0": "from Compiler.types import sfix\nimport Compiler.mpc_math as mpc_math\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return mpc_math.pow_fx(pi, x)\n", "response_1": "from Compiler.types import sfix\nimport mpc_math\n\ndef pi_to_the_x(x):\n    # Compute pi^x using the fixed-point power function.\n    return mpc_math.pow_fx(sfix(3.141592653589793), x)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "spring_rocket", "response_0": "def spring_rocket(height, m, k):\n    from Compiler.types import sfix\n    import mpc_math\n    g = sfix(9.8)\n    two = sfix(2)\n    numerator = two * m * g * height\n    return mpc_math.sqrt(numerator / k)\n", "response_1": "from Compiler.library import mpc_math\nfrom Compiler.types import sfix\n\ndef spring_rocket(height, m, k):\n    g = sfix(9.8)\n    return mpc_math.sqrt(2 * m * g * height / k)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cone_volume", "response_0": "from Compiler.types import sfix\n\ndef cone_volume(r, h):\n    # Define pi as an sfix constant\n    pi = sfix(3.141592653589793)\n    return (pi * r * r * h) / 3\n", "response_1": "from Compiler.types import sfix\nimport math\n\ndef cone_volume(r, h):\n    # r and h are expected to be sfix values, i.e. secret fixed-point numbers.\n    return sfix(math.pi) * r * r * h / 3\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "how_many_rabbits", "response_0": "from Compiler.types import sint\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    In this implementation, heads and legs are of type sint.\n    Note that division (/) on sint performs field division modulo a prime,\n    which equals the intended result provided (legs - heads*2) is exactly divisible by 2.\n    \"\"\"\n    return (legs - heads * 2) / 2\n", "response_1": "from Compiler.types import cint\n\ndef how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit\u2010chicken problem.\n    Both heads and legs are clear integers (cint).\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "model_name": "azure-openai-o3-mini"}
