{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler.types import cfix\n\nstart = cfix(0)\nend = cfix(99)\nnum = 10\na = cfix.Array(num)\n\nif num > 1:\n    step = (end - start) / cfix(num - 1)\n    for i in range(num):\n        a[i] = start + cfix(i) * step\nelse:\n    a[0] = start\n", "response_1": "from Compiler.types import cfix\n\nnum = 10\nstart = cfix(0)\nend = cfix(99)\nstep = (end - start) / (num - 1)\n\na = cfix.Array(num)\nfor i in range(num):\n    a[i] = start + i * step\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "more_positive", "response_0": "from Compiler.types import sint\n\ndef more_positive(arr):\n    # arr is assumed to be an iterable of secret integers (sint)\n    total = sint(0)\n    for x in arr:\n        # Compute the sign of x:\n        # If x > 0 then contributes 1; if x < 0 then contributes -1; else contributes 0.\n        pos_bit = (x > 0).if_else(1, 0)\n        neg_bit = (x < 0).if_else(1, 0)\n        total += pos_bit - neg_bit\n    # Return whether the total sum is greater than zero\n    return (total > 0)\n", "response_1": "from Compiler.types import sint\n\ndef more_positive(arr):\n    # Initialize count as a secret integer\n    count = sint(0)\n    # Loop over all elements in the Array\n    for i in range(len(arr)):\n        x = arr[i]\n        # Compute the sign of x:\n        # If x > 0 then sign = 1, elif x < 0 then sign = -1, otherwise 0.\n        sign_x = (x > 0).if_else(sint(1), (x < 0).if_else(sint(-1), sint(0)))\n        count += sign_x\n    # Return whether the total sum is greater than 0.\n    return count > 0\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "select", "response_0": "from Compiler.types import sfix, sint\n\ndef select(ind, a, b):\n    # Element-wise selection: if ind[i] is 1 select from a, otherwise from b.\n    # Here, a and b are lists (or arrays) of sfix numbers and ind is a list (or array)\n    # of secret bits (sint) with values 0 or 1.\n    res = [None] * len(a)\n    for i in range(len(a)):\n        # Using arithmetic to select element:\n        # When ind[i] is 1, (a[i]-b[i])*1 + b[i] = a[i]\n        # When ind[i] is 0, (a[i]-b[i])*0 + b[i] = b[i]\n        res[i] = b[i] + (a[i] - b[i]) * ind[i]\n    return res\n", "response_1": "def select(ind, a, b):\n    # Assume that \"ind\" is an Array (or list) of secret bits (sintbit or similar),\n    # and that \"a\" and \"b\" are Arrays (or lists) of secret fixed-point numbers (sfix) or other numeric types.\n    n = len(ind)\n    res = [None] * n\n    for i in range(n):\n        # Use the if_else method provided by secret integer types for conditional selection.\n        # It returns a[i] if ind[i] equals 1, else b[i].\n        res[i] = ind[i].if_else(a[i], b[i])\n    return res\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_relu", "response_0": "from Compiler.types import sfix\n\ndef relu(y):\n    # Compute (y > 0) as a secret bit (0 or 1), then multiply with y.\n    return (y > sfix(0)) * y\n", "response_1": "from Compiler.types import sfix\n\ndef relu(y):\n    # Return y if y is non-negative, otherwise return 0.\n    return (y >= sfix(0)).if_else(y, sfix(0))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "cost_matrix", "response_0": "from Compiler.types import sfix\n\ndef cost_matrix(profit_matrix, m, n):\n    # Compute the maximum element in the profit_matrix.\n    max_val = profit_matrix[0][0]\n    for i in range(m):\n        for j in range(n):\n            max_val = max_val.max(profit_matrix[i][j])\n    \n    # Create a cost matrix of the same dimensions.\n    cost_mat = sfix.Matrix(m, n)\n    for i in range(m):\n        for j in range(n):\n            cost_mat[i][j] = max_val - profit_matrix[i][j]\n    \n    return cost_mat\n", "response_1": "from Compiler.types import sfix, Matrix\nfrom Compiler.library import tree_reduce\n\ndef cost_matrix(profit_matrix):\n    # profit_matrix is assumed to be a Matrix (of type sfix) with known rows and columns\n    # Flatten the matrix into a vector for reduction.\n    flat_profit = profit_matrix.get_vector()\n    # Compute the maximal profit via a tree reduction using the built-in max operation.\n    profit_max = tree_reduce(lambda a, b: a.max(b), flat_profit)\n    # Create a new matrix with the same dimensions and assign every entry to profit_max.\n    offset_matrix = Matrix(profit_matrix.rows, profit_matrix.columns, sfix)\n    offset_matrix.assign_all(profit_max)\n    # Compute the cost matrix by subtracting the profit matrix from the offset matrix.\n    cost = offset_matrix - profit_matrix\n    return cost\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_zeros", "response_0": "from Compiler.types import sint\n\nn = 10\na = sint.Array(n)\na.assign_all(0)\n", "response_1": "from Compiler.types import cint\n\nn = 10\na = cint.Array(n)\na.assign_all(0)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "from Compiler.types import Matrix, Array\n\ndef array_dimensional_indexing(ndarray, row_index):\n    # MP-SPDZ function to index the row_index-th row from a 2-D matrix.\n    # The entire row is returned as an Array.\n    row = ndarray[row_index][:]  # Retrieve all elements in the selected row.\n    return row\n", "response_1": "from Compiler.types import Matrix, Array\n\ndef array_dimensional_indexing(ndarray: Matrix, row_index: int) -> Array:\n    # Index the row-th entry from the 2-D matrix,\n    # which returns an Array corresponding to that row.\n    row = ndarray[row_index]\n    return row\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_zeros_2", "response_0": "from Compiler.types import cint\n\ndef zeros(n):\n    arr = cint.Array(n)\n    arr.assign_all(0)\n    return arr\n", "response_1": "from Compiler.types import cint\n\ndef zeros(n):\n    a = cint.Array(n)\n    a.assign_all(0)\n    return a\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_slicing_stride", "response_0": "from Compiler.types import sint\n\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays:\n    Collect all the even-index elements from the first array and\n    collect all the odd-index elements from the second array.\n    \"\"\"\n    # Obtain even-index elements from the first array.\n    viewA = ndarrayA[::2]\n    # Obtain odd-index elements from the second array:\n    # First slice from index 1 to get odd-indexed elements,\n    # then take every 2nd element from that slice.\n    viewB = ndarrayB[1:][::2]\n    # Concatenate the two register vectors.\n    concatenated = viewA + viewB\n    # Convert the concatenated register vector back into an Array.\n    return sint.Array.create_from(concatenated)\n", "response_1": "from Compiler.types import sint\n\ndef array_concate(ndarrayA, ndarrayB):\n    # Get the length of the two arrays (assumed to be public compile\u2010time constants)\n    n = len(ndarrayA)\n    m = len(ndarrayB)\n    # For ndarrayA, select all elements at even indices.\n    # If n is odd then (n+1)//2 gives the correct count.\n    len_viewA = (n + 1) // 2\n    # For ndarrayB, select all elements at odd indices.\n    len_viewB = m // 2\n\n    viewA = sint.Array(len_viewA)\n    viewB = sint.Array(len_viewB)\n\n    # Copy even-indexed elements from ndarrayA to viewA.\n    for i in range(len_viewA):\n        viewA[i] = ndarrayA[2 * i]\n\n    # Copy odd-indexed elements from ndarrayB to viewB.\n    for i in range(len_viewB):\n        viewB[i] = ndarrayB[1 + 2 * i]\n\n    # Concatenate viewA and viewB.\n    result = viewA.concat(viewB)\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "QR_decomposition", "response_0": "from Compiler.types import sfix\nimport mpc_math\n\n# QR_decomposition performs a Gram-Schmidt orthogonalization on a Matrix A.\n# It returns the Q matrix of the QR-decomposition of A.\n# In this code, A and Q are assumed to be instances of sfix.Matrix of dimensions m x n.\n# The caller must supply the number of rows (m) and columns (n) of A.\ndef QR_decomposition(A, m, n):\n    Q = sfix.Matrix(m, n)\n    # Process each column of A\n    for j in range(n):\n        # Extract the j-th column of A.\n        a_j = A.get_column(j)\n        # Make a working copy of the current column.\n        v = a_j[:]  # v is an sfix Array with m entries\n        # For each previous column of Q, remove the projection from a_j.\n        for i in range(j):\n            q_i = Q.get_column(i)\n            # Compute the dot product between q_i and a_j.\n            dot = sfix(0)\n            for k in range(m):\n                dot += q_i[k] * a_j[k]\n            # Subtract the projection coefficient times the earlier basis vector.\n            for k in range(m):\n                v[k] = v[k] - dot * q_i[k]\n        # Compute the squared norm of v.\n        norm_sq = sfix(0)\n        for k in range(m):\n            norm_sq += v[k] * v[k]\n        # Compute the norm using the MP-SPDZ square-root function.\n        norm = mpc_math.sqrt(norm_sq)\n        # Normalize v to form the new orthogonal basis column.\n        q_j = [None] * m\n        for k in range(m):\n            q_j[k] = v[k] / norm\n        # Set the j-th column of Q to the normalized vector.\n        Q.set_column(j, q_j)\n    return Q\n", "response_1": "from Compiler.types import sfix, Matrix, Array\nimport mpc_math\n\ndef QR_decomposition(mat, n, m):\n    # mat is assumed to be a Matrix of dimensions n x m with entries of type sfix.\n    # Q will store the orthonormal basis as columns.\n    Q = Matrix(n, m, sfix)\n    # For each column i of the input matrix\n    for i in range(m):\n        # Copy the i-th column of mat into a temporary vector v.\n        v = Array(n, sfix)\n        for k in range(n):\n            # Assume matrix indexing as mat[row][column]\n            v[k] = mat[k][i]\n        # Subtract from v its projections on all previous Q columns.\n        for j in range(i):\n            s = sfix(0)\n            for k in range(n):\n                s += Q[k][j] * v[k]\n            for k in range(n):\n                v[k] = v[k] - s * Q[k][j]\n        # Compute the norm of v as the square root of the sum of squares.\n        norm_sq = sfix(0)\n        for k in range(n):\n            norm_sq += v[k] * v[k]\n        norm = mpc_math.sqrt(norm_sq)\n        # Normalize v and store it as the i-th column in Q.\n        for k in range(n):\n            Q[k][i] = v[k] / norm\n    return Q\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "find_nearest_index", "response_0": "from Compiler.types import cfix\n\ndef find_nearest_index(array, value):\n    # Assume array is a clear fixed-point Array (cfix.Array) and value is of type cfix.\n    best_idx = 0\n    best_diff = abs(array[0] - value)\n    for i in range(1, len(array)):\n        diff = abs(array[i] - value)\n        if diff < best_diff:\n            best_diff = diff\n            best_idx = i\n    return best_idx\n", "response_1": "from Compiler.types import cfix\n\ndef find_nearest_index(array, value):\n    # Determine the length of the array\n    n = len(array)\n    \n    # Initialize the best index and best difference (absolute difference)\n    best_idx = 0\n    best_diff = abs(array[0] - value)\n\n    # Iterate over the array to find the minimal absolute difference\n    for i in range(1, n):\n        diff = abs(array[i] - value)\n        # Since array elements are clear fixed-point numbers, the comparison is public\n        if diff < best_diff:\n            best_diff = diff\n            best_idx = i\n\n    return best_idx\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_concat_simple_row", "response_0": "from Compiler.types import Matrix\n\ndef matrix_simple_concate_rows(matrixA, matrixB):\n    # Concatenate two 2-D matrices along axis 0 (row-wise).\n    # It is assumed that matrixA and matrixB have the same number of columns.\n    concatenated_matrix = matrixA.concat(matrixB)\n    return concatenated_matrix\n", "response_1": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    # Concatenate two 2D matrices along the first dimension (rows)\n    concatenated = ndarrayA.concat(ndarrayB)\n    return concatenated\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    # Create a new container of the same type by copying via slice indexing\n    new_array = type(ndarray).create_from(ndarray[:])\n    return new_array\n", "response_1": "def array_copy(ndarray):\n    # obtain a vector copy of the array via slice indexing\n    vector_copy = ndarray[:]\n    # re-create an Array from the vector copy using the Array.create_from method\n    copied_array = type(ndarray).create_from(vector_copy)\n    return copied_array\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "max_pooling", "response_0": "from Compiler.types import sfix, MultiArray\nfrom Compiler.library import tree_reduce\n\ndef max_pooling(x, stride):\n    # x is assumed to be a three-dimensional MultiArray with dimensions:\n    # [batch, height, width]. 'stride' is a public integer value.\n    n_batches = len(x)\n    n_rows = len(x[0])\n    n_cols = len(x[0][0])\n    out_rows = n_rows // stride\n    out_cols = n_cols // stride\n\n    # Create an output MultiArray with dimensions [n_batches, out_rows, out_cols] of type sfix.\n    out = MultiArray([n_batches, out_rows, out_cols], sfix)\n\n    for b in range(n_batches):\n        for i in range(0, n_rows, stride):\n            for j in range(0, n_cols, stride):\n                # Extract the current block into a list.\n                block = []\n                for ii in range(i, i + stride):\n                    for jj in range(j, j + stride):\n                        block.append(x[b][ii][jj])\n                # Compute the maximum of the block using tree_reduce and the sfix.max() method.\n                max_val = tree_reduce(lambda a, b: a.max(b), block)\n                out[b][i // stride][j // stride] = max_val\n\n    return out\n", "response_1": "from Compiler.types import sint, MultiArray\n\ndef max_pooling(x, stride):\n    # Assume x is a MultiArray of shape [batch, height, width] with secret integers (sint).\n    batch = len(x)\n    height = len(x[0])\n    width = len(x[0][0])\n    out_height = height // stride\n    out_width = width // stride\n    # Create output multi-dimensional array for storing pooling results.\n    out = MultiArray([batch, out_height, out_width], sint)\n    \n    for b in range(batch):\n        for i in range(0, height, stride):\n            for j in range(0, width, stride):\n                # Initialize the maximum with the first element in the current block.\n                block_max = x[b][i][j]\n                for ii in range(i, i + stride):\n                    for jj in range(j, j + stride):\n                        block_max = block_max.max(x[b][ii][jj])\n                # Pooling result is stored at index (i//stride, j//stride)\n                out[b][i // stride][j // stride] = block_max\n    return out\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_reshape", "response_0": "from Compiler.types import cint, Matrix\n\na = Matrix(3, 5, cint)\na.assign([[0, 1, 2, 3, 4],\n          [5, 6, 7, 8, 9],\n          [10, 11, 12, 13, 14]])\n", "response_1": "from Compiler.types import cint\n\n# Create a 3x5 clear integer matrix with values 0 to 14.\na = cint.Matrix(3, 5)\n# Assign the values in row-major order.\na.assign([[i * 5 + j for j in range(5)] for i in range(3)])\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_concat_simple_column", "response_0": "from Compiler.types import Matrix\n\ndef array_simple_concate_column(matrixA, matrixB):\n    # Concatenate two matrices along columns, equivalent to numpy.concatenate(..., axis=1)\n    return matrixA.concat_columns(matrixB)\n", "response_1": "from Compiler.types import Matrix\n\ndef array_simple_concate_column(matrixA, matrixB):\n    # Concatenate two matrices along the column axis\n    concatenated_matrix = matrixA.concat_columns(matrixB)\n    return concatenated_matrix\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "from Compiler.types import Matrix\n\ndef array_dimensional_indexing(ndarray, column_index):\n    # Return the column vector obtained from the given 2-D Matrix \"ndarray\"\n    # using the built-in \"get_column\" method.\n    return ndarray.get_column(column_index)\n", "response_1": "from Compiler.types import Matrix\n\ndef array_dimensional_indexing(ndarray, column_index):\n    # Retrieve the i-th column from a 2-D matrix using the built-in get_column method.\n    result = ndarray.get_column(column_index)\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_diagonal", "response_0": "def diag(matrix):\n    diag = matrix.diag()\n    return diag\n", "response_1": "def diag(array):\n    # Using the built-in diag() method from the Matrix API in MP-SPDZ.\n    return array.diag()\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_concat_special", "response_0": "from Compiler.types import cint, Matrix\n\ndef array_special_concate(matrixA, matrixB, m, n):\n    # matrixA and matrixB are m x n matrices of clear integers (cint)\n    # The goal is to create a new m x (even_count+odd_count) matrix where we take\n    # the even-indexed columns (0-indexed) from matrixA and the odd-indexed columns from matrixB.\n    \n    even_count = (n + 1) // 2  # number of even-indexed columns\n    odd_count = n // 2         # number of odd-indexed columns\n    total_cols = even_count + odd_count\n\n    # Create result matrix of dimensions m x total_cols\n    res = Matrix(m, total_cols, cint)\n    col_index = 0\n\n    # First, copy even-indexed columns from matrixA.\n    for j in range(n):\n        if j % 2 == 0:\n            for i in range(m):\n                res[i][col_index] = matrixA[i][j]\n            col_index += 1\n\n    # Next, copy odd-indexed columns from matrixB.\n    for j in range(n):\n        if j % 2 == 1:\n            for i in range(m):\n                res[i][col_index] = matrixB[i][j]\n            col_index += 1\n\n    return res\n", "response_1": "from Compiler.types import Matrix, cint\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    # Assume that the dimensions of the input matrices are compile\u2010time constants.\n    # Let R be the number of rows and C be the number of columns.\n    R = len(ndarrayA)\n    C = len(ndarrayA[0])\n    # For even-indexed columns from ndarrayA and odd-indexed columns from ndarrayB,\n    # the total number of columns in the result is:\n    new_cols = ((C + 1) // 2) + (C // 2)\n    result = Matrix(R, new_cols, cint)\n    for i in range(R):\n        pos = 0\n        # Collect even-indexed columns from ndarrayA (i.e. indices 0,2,4,...)\n        for j in range(0, C, 2):\n            result[i][pos] = ndarrayA[i][j]\n            pos += 1\n        # Collect odd-indexed columns from ndarrayB (i.e. indices 1,3,5,...)\n        for j in range(1, C, 2):\n            result[i][pos] = ndarrayB[i][j]\n            pos += 1\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_arange", "response_0": "from Compiler.types import cint\n\ndef arange(start, stop=None, step=1):\n    if stop is None:\n        stop = start\n        start = 0\n    # Determine the number of elements as in Python's range\n    length = len(range(start, stop, step))\n    a = cint.Array(length)\n    for i in range(length):\n        a[i] = start + i * step\n    return a\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-d array of plain (public) integers analogous to numpy.arange.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    result = []\n    for i in range(start, stop, step):\n        result.append(i)\n    return result\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_eye_2", "response_0": "from Compiler.types import cint\n\nm = 3\nn = 5\na = cint.Matrix(m, n)\na.assign_all(0)\n\nmin_dim = m if m < n else n\nfor i in range(min_dim):\n    a[i][i] = 1\n", "response_1": "from Compiler.types import cfix\n\nm = 3\nn = 5\na = cfix.Matrix(m, n)\na.assign_all(0)\n\nfor i in range(min(m, n)):\n    a[i][i] = 1\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "third_smallest", "response_0": "from Compiler.types import sint\n\ndef third_smallest(arr):\n    # Sort the array in place using the built-in sort method\n    arr.sort()\n    return arr[2]\n", "response_1": "from Compiler.types import sint\n\ndef third_smallest(arr):\n    # Sort the array in-place using radix sort.\n    arr.sort()\n    # Return the third smallest element (at index 2).\n    return arr[2]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "from Compiler.types import Matrix\n\ndef array_dimensional_indexing(ndarray, row_index):\n    # In MP-SPDZ, indexing a Matrix with row_index returns the row as an Array.\n    row = ndarray[row_index]\n    return row\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    # In MP-SPDZ, a 2-D array can be represented as a Matrix.\n    # Accessing a row by a public integer index is done via indexing.\n    row = ndarray[row_index]\n    return row\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_from_intrinsic_arange", "response_0": "from Compiler.types import cint\n\nn = 10\na = cint.Array.create_from([i for i in range(n)])\n", "response_1": "from Compiler.types import cint\n\nn = 10\na = cint.Array.create_from(range(n))\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "from Compiler.types import Matrix\n\ndef array_dimensional_indexing(ndarray, row_index):\n    # 'ndarray' is assumed to be a 2-D Matrix.\n    # Index the row 'row_index' and return it as an Array.\n    row = ndarray[row_index]\n    return row\n", "response_1": "from Compiler.types import Matrix\n\ndef array_dimensional_indexing(ndarray, row_index):\n    # In MP-SPDZ, a 2-D Matrix supports row indexing by writing \"ndarray[row_index]\".\n    row = ndarray[row_index]\n    return row\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler.types import cint\n\na = cint.Array.create_from([0, 10, 20, 30, 40])\n", "response_1": "from Compiler.types import cint\n\na = cint.Array.create_from([0, 10, 20, 30, 40])\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_reshape", "response_0": "from Compiler.types import sint, Matrix\n\ndef array_reshape(ndarray, m, n):\n    # Assume that 'ndarray' is a linear Array of secret integers (sint)\n    # with length equal to m * n.\n    # Create a new Matrix with m rows and n columns.\n    reshaped = sint.Matrix(m, n)\n    # Copy the elements from the flat array into the matrix.\n    # The assign_vector method assigns the vector content in row\u2010major order.\n    reshaped.assign_vector(ndarray[:])\n    return reshaped\n", "response_1": "from Compiler.types import sint, Matrix\n\ndef array_reshape(ndarray, m, n):\n    # Create an m x n matrix of secret integers\n    reshaped = sint.Matrix(m, n)\n    # Flatten the input array into a vector and assign it to the matrix\n    reshaped.assign_vector(ndarray, 0)\n    return reshaped\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_ones", "response_0": "from Compiler.types import cfix\n\nn = 10\na = cfix.Array(n)\na.assign_all(1)\n", "response_1": "from Compiler.types import sint\n\nn = 10\na = sint.Array(n)\na.assign_all(1)\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "set_one_to_zero", "response_0": "from Compiler.types import sint\n\ndef set_one_to_zero(y):\n    # Iterate over every index of the array y.\n    for i in range(len(y)):\n        # For each element, if it equals 1 then multiply by (1 - (y[i]==1)).\n        # When y[i] equals 1, (y[i]==1) yields secret 1 and 1 - 1 is 0.\n        # Otherwise, (y[i]==1) yields secret 0 and 1 - 0 is 1.\n        y[i] = y[i] * (1 - (y[i] == 1))\n    return y\n", "response_1": "from Compiler.types import sint\n\ndef set_one_to_zero(y):\n    # 'y' is assumed to be an Array of secret integers (sint)\n    for i in range(len(y)):\n        flag = (y[i] == 1)  # This comparison returns a secret bit (sbitint)\n        # Use the secret bit's if_else: if flag is true, choose 0, otherwise y[i]\n        y[i] = flag.if_else(0, y[i])\n    return y\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_eye", "response_0": "from Compiler.types import cint\n\nn = 10\na = cint.Matrix(n, n)\na.assign_all(0)\nfor i in range(n):\n    a[i][i] = 1\n", "response_1": "from Compiler.types import cint, Matrix\n\nn = 10\na = cint.Matrix(n, n)\na.assign_all(0)\nfor i in range(n):\n    a[i][i] = 1\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_diag", "response_0": "from Compiler.types import cint\n\nn = 6\na_l = [1, 3, 5, 2, 4, 6]\na = cint.Matrix(n, n)\na.assign_all(0)\nfor i in range(n):\n    a[i][i] = a_l[i]\n", "response_1": "from Compiler.types import cint\n\n# Define the list of clear integers\na_l = [1, 3, 5, 2, 4, 6]\n\n# Create a 6x6 clear integer matrix and initialize all elements to 0\na = cint.Matrix(6, 6)\na.assign_all(0)\n\n# Set the diagonal elements to the values in a_l\nfor i in range(6):\n    a[i][i] = a_l[i]\n", "model_name": "azure-openai-o3-mini"}
{"test_name": "np_advanced_integer_indexing", "response_0": "def integer_array_indexing(array, indices):\n    # \"indices\" is assumed to be a public Python list of integers.\n    # MP-SPDZ Array supports public indexing via the usual Python indexing operator.\n    ret = []\n    for idx in indices:\n        ret.append(array[idx])\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef integer_array_indexing(array, indices):\n    # Convert indices into a Python list of integers if needed.\n    indices = list(indices)\n    # Create an output array of the same secret type as the input \u201carray\u201d\n    n = len(indices)\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = array[indices[i]]\n    return ret\n", "model_name": "azure-openai-o3-mini"}
