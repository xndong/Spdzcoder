{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    new_arr = Array(n, sint)\n    \n    # Copy elements before the index\n    for i in range(index):\n        new_arr[i] = arr[i]\n    \n    # Copy elements after the index\n    for i in range(index + 1, n):\n        new_arr[i - 1] = arr[i]\n    \n    # Move the element at the given index to the end\n    new_arr[n - 1] = arr[index]\n    \n    return new_arr\n", "response_1": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    new_arr = Array(n, sint)\n    for i in range(n):\n        if i < index:\n            new_arr[i] = arr[i]\n        elif i > index:\n            new_arr[i] = arr[i]\n    new_arr[n-1] = arr[index]\n    return new_arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    for i in range(2, n):\n        cond1 = arr[i] > arr[0]\n        cond2 = arr[i] > arr[1]\n        cond = cond1 + cond2\n        idx = cond1.if_else(0, 1)\n        arr[idx] = cond.if_else(arr[i], arr[idx])\n    return (arr[0] < arr[1]).if_else(arr[0], arr[1])\n", "response_1": "from Compiler import mpc_math\n\ndef second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    for i in range(2, n):\n        if arr[i] > arr[0] or arr[i] > arr[1]:\n            idx = mpc_math.cond_swap(arr[0] < arr[1], 0, 1)\n            arr[idx] = arr[i]\n    return mpc_math.cond_swap(arr[0] < arr[1], arr[0], arr[1])\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_true", "response_0": "def exists_true(arr: sint):\n    \"\"\"\n    Check whether the secret-shared boolean array contains a True.\n    \"\"\"\n    n = len(arr)\n    result = sbit(0)\n    for i in range(n):\n        result = result | arr[i]\n    return result\n", "response_1": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    arr_bits = [sbit(x) for x in arr]  # Convert each element to sbit\n    ret = arr_bits.any()\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_indicator", "response_0": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret-shared vectors.\n    \"\"\"\n    # Ensure the vectors have the same length\n    n = len(vec1)\n    assert n == len(vec2), \"Vectors must have the same length\"\n    \n    # Compute the element-wise product\n    lst = [vec1[i] * vec2[i] for i in range(n)]\n    \n    # Sum the products\n    summation = ssum(lst)\n    \n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret-shared vectors.\n    \"\"\"\n    # Ensure the vectors are of the same length\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n\n    # Compute the element-wise product\n    products = [vec1[i] * vec2[i] for i in range(len(vec1))]\n\n    # Sum the products\n    summation = sum(products)\n\n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    array = Array(n, sint)\n    for i in range(n):\n        array[i] = a[(i - 1) % n]\n    return array\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, sint)\n    for i in range(n):\n        shifted_array[i] = a[(i - 1) % n]\n    return shifted_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises_2", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    flag = sfix.Array(n - 1)\n    for i in range(n - 1):\n        flag[i] = sfix(1) if arr[i] < arr[i + 1] else sfix(0)\n    \n    count = sfix(0)\n    for i in range(n - 1):\n        count += flag[i]\n    \n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    flag = [sint(1) if arr[i].less_than(arr[i+1]) else sint(0) for i in range(len(arr)-1)]\n    count = sum(flag)\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(arr)\n    new_arr = Array(n, sint)\n    for i in range(n):\n        if i % 2 == 1:\n            new_arr[i] = arr[i] + 1\n        else:\n            new_arr[i] = arr[i] - 1\n    return new_arr\n", "response_1": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            arr[i] = arr[i] - 1\n        else:\n            arr[i] = arr[i] + 1\n    return arr\n\n# Example usage in MP-SPDZ\nfrom Compiler import types\n\ndef main():\n    # Define the input array\n    arr = types.Array(5, types.sint)\n    arr = arr.alloc_slots(5)\n    \n    # Initialize the array with some values (for demonstration purposes)\n    for i in range(5):\n        arr[i] = types.sint(i)\n    \n    # Apply the choppy_plus_minus function\n    result = choppy_plus_minus(arr)\n    \n    # Output the result\n    for i in range(5):\n        print_ln(\"Result[%s] = %s\", i, result[i].reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    # Check if a is zero\n    a_is_zero = a == 0\n    \n    # If a is zero, check if b is zero\n    b_is_zero = b == 0\n    roots_when_a_is_zero = sfix.if_else(b_is_zero, 0, 1)\n    \n    # If a is not zero, compute the discriminant\n    discriminant = b**2 - 4 * a * c\n    discriminant_positive = discriminant > 0\n    discriminant_zero = discriminant == 0\n    \n    # Determine the number of roots based on the discriminant\n    roots_when_a_is_not_zero = sfix.if_else(discriminant_positive, 2, sfix.if_else(discriminant_zero, 1, 0))\n    \n    # Return the appropriate number of roots\n    return sfix.if_else(a_is_zero, roots_when_a_is_zero, roots_when_a_is_not_zero)\n", "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    # Check if 'a' is zero\n    a_is_zero = a == 0\n\n    # If 'a' is zero, check if 'b' is zero\n    b_is_zero = b == 0\n\n    # Return 0 if both 'a' and 'b' are zero, otherwise return 1\n    result_if_a_is_zero = a_is_zero * b_is_zero * 0 + a_is_zero * (1 - b_is_zero) * 1\n\n    # Calculate the discriminant\n    discriminant = b**2 - 4 * a * c\n\n    # Check if the discriminant is greater than zero\n    discriminant_gt_zero = discriminant > 0\n\n    # Check if the discriminant is equal to zero\n    discriminant_eq_zero = discriminant == 0\n\n    # Return 2 if discriminant > 0, 1 if discriminant == 0, otherwise 0\n    result_if_a_is_not_zero = discriminant_gt_zero * 2 + discriminant_eq_zero * 1 + (1 - discriminant_gt_zero - discriminant_eq_zero) * 0\n\n    # Combine the results based on whether 'a' is zero or not\n    return a_is_zero * result_if_a_is_zero + (1 - a_is_zero) * result_if_a_is_not_zero\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    n = len(arr)\n    flag = Array(n, sfix)\n    for i in range(n):\n        flag[i] = predicator(arr[i])\n    \n    summation = sfix(0)\n    for i in range(n):\n        summation = summation + flag[i]\n    \n    return summation\n", "response_1": "fromCompiler import *\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Apply the predicator to each element in the array\n    flag = [predicator(e) for e in arr]\n    \n    # Sum the results\n    summation = sum(flag)\n    \n    return summation\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Assuming arr is a list of secret-shared integers\n    arr = sfix.Array(10)  # Example array with 10 elements\n    \n    # Define a predicator function\n    def predicator(e):\n        return e > 0.5  # Example condition\n    \n    # Call the function\n    result = count_satisfied(arr, predicator)\n    \n    # Output the result\n    print_ln(\"Number of satisfied elements: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    n = len(arr1)\n    ret = sfix(0)\n    for i in range(n):\n        ret += arr1[i] * arr2[i]\n    return ret\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming arr1 and arr2 are read from input files or provided as program arguments\n    arr1 = Array(n, sfix)  # Replace n with the actual size of the array\n    arr2 = Array(n, sfix)  # Replace n with the actual size of the array\n    \n    # Read arrays from input\n    arr1.input_from(0)\n    arr2.input_from(1)\n    \n    result = traverse_and_sum(arr1, arr2)\n    \n    # Output the result\n    print_ln(\"The result is: %s\", result.reveal())\n\n", "response_1": "from Compiler import types\n\ndef traverse_and_sum(arr1: types.Array, arr2: types.Array) -> types.sint:\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    n = len(arr1)\n    if len(arr2) != n:\n        raise ValueError(\"Arrays must be of the same length\")\n    \n    # Initialize the sum as a secret integer\n    total_sum = types.sint(0)\n    \n    # Iterate over the arrays and compute the product of each pair\n    for i in range(n):\n        product = arr1[i] * arr2[i]\n        total_sum = total_sum + product\n    \n    return total_sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_round", "response_0": "from Compiler import mpc_math\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = [mpc_math.round_to_nearest(e) for e in arr]\n    return ret\n", "response_1": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)  # Create an array of secret integers\n    for i in range(len(arr)):\n        ret[i] = arr[i].round()  # Round each element to the nearest integer\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(arr)\n    ret = sfix.Array(n)  # Initialize an array of secret fixed-point numbers\n\n    for i in range(n):\n        # Compare arr[i] and brr[i] and set ret[i] accordingly\n        ret[i] = (arr[i] >= brr[i]).if_else(1, 0)\n\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = sint(1) if arr[i] >= brr[i] else sint(0)\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = sint(arr[i] < 0)\n    return ret\n", "response_1": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        ret[i] = arr[i] < 0\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    from Compiler import types\n\n    # Determine the length of the arrays\n    len_a = len(a)\n    len_b = len(b)\n\n    # Determine the padding length\n    pad_length = abs(len_a - len_b)\n\n    # Initialize the result array\n    ret = []\n\n    # Perform element-wise subtraction\n    for x, y in zip(a, b):\n        ret.append(x - y)\n\n    # Pad the shorter array with zeros\n    if len_a < len_b:\n        for _ in range(pad_length):\n            ret.append(-b[len_a + _])\n    elif len_a > len_b:\n        for _ in range(pad_length):\n            ret.append(a[len_b + _])\n\n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    from Compiler import types\n\n    # Determine the length of the longer array\n    max_length = max(len(a), len(b))\n\n    # Pad the shorter array with 0s\n    a_padded = a + [types.sint.load_int(0)] * (max_length - len(a))\n    b_padded = b + [types.sint.load_int(0)] * (max_length - len(b))\n\n    # Element-wise subtraction\n    ret = [x - y for x, y in zip(a_padded, b_padded)]\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    result = Array(len(arr), sint)\n    for i in range(len(arr)):\n        result[i] = func(arr[i])\n    return result\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    # Assuming arr is a list of MP-SPDZ integers or floats\n    processed_arr = Array(len(arr), sint)  # Create an array to store the processed elements\n    for i in range(len(arr)):\n        processed_arr[i] = func(arr[i])\n    return processed_arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_a = [a[-1]] + a[:-1]\n    return shifted_a\n\n# Example usage in MP-SPDZ\nfrom Compiler import types\n\n# Define the array as a list of integers\na = types.Array(3, types. sint)\n\n# Initialize the array with some values\na[0] = types.sint(0)\na[1] = types.sint(1)\na[2] = types.sint(2)\n\n# Call the array_shift function\nshifted_a = array_shift(a)\n\n# Print the result (for debugging purposes)\nprint_ln(\"Shifted array: %s\", shifted_a)\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_a = [a[-1]] + a[:-1]\n    return shifted_a\n\n# Example usage in MP-SPDZ\nn = 3\na = sfix.Array(n)  # Assuming a is a secret-shared array of fixed-point numbers\nshifted_a = array_shift(a)\n", "model_name": "deepseek-v2.5"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    n = len(a)\n    ret_array = Array(n, sint)\n    for i in range(n):\n        ret_array[i] = a[i] if a[i] > b[i] else b[i]\n    return ret_array\n", "response_1": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = Array(len(a), sint)\n    for i in range(len(a)):\n        ret_array[i] = a[i] + (b[i] - a[i]) * (a[i] < b[i])\n    return ret_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the length of the longer array\n    max_len = max(len(a), len(b))\n    \n    # Pad the shorter array with zeros\n    if len(a) < max_len:\n        a += [sint(0)] * (max_len - len(a))\n    else:\n        b += [sint(0)] * (max_len - len(b))\n    \n    # Perform element-wise subtraction\n    ret = [a[i] - b[i] for i in range(max_len)]\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the lengths of the arrays\n    len_a = len(a)\n    len_b = len(b)\n    \n    # Pad the shorter array with zeros\n    if len_a < len_b:\n        pad = [sint(0)] * (len_b - len_a)\n        a = a + pad\n    else:\n        pad = [sint(0)] * (len_a - len_b)\n        b = b + pad\n    \n    # Perform elementwise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c + c\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    n = len(c)\n    repeated = sfix.Array(2 * n)\n    for i in range(n):\n        repeated[i] = c[i]\n        repeated[i + n] = c[i]\n    return repeated\n", "model_name": "deepseek-v2.5"}
{"test_name": "zeros", "response_0": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = Array(num, sint)\n    array.assign_all(0)\n    return array\n", "response_1": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = [sint() for _ in range(num)]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip", "response_0": "from Compiler import mpc_math\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x):\n        return mpc_math.max(lower_bound, mpc_math.min(upper_bound, x))\n\n    arr = [helper_func(x) for x in arr]\n    return arr\n", "response_1": "from Compiler import mpc_math\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x):\n        # Use mpc_math.cond to handle conditional statements\n        return mpc_math.cond(x >= upper_bound, upper_bound, mpc_math.cond(x > lower_bound, x, lower_bound))\n\n    # Apply the helper function to each element in the array\n    clipped_arr = [helper_func(x) for x in arr]\n    return clipped_arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    summmation = sum(flag)\n    return summmation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    flag = Array(len(arr), sint)\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    summation = sint()\n    for i in range(len(arr)):\n        summation += flag[i]\n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    count = sfix(0)  # Initialize count as a fixed-point number\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\n\n# Example usage in MP-SPDZ\nif __name__ == \"__main__\":\n    # Assuming arr is a list of sfix values\n    arr = [sfix(x) for x in [3, 1, 2, 4, 5]]\n    result = reverse_order_pair(arr)\n    print_ln(\"Number of reverse order pairs: %s\", result.reveal())\n", "response_1": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n\n    for i in range(n):\n        current = arr[i]\n        for j in range(i + 1, n):\n            count = count + (current > arr[j])\n\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    arr = [arr[i] + 1 for i in range(len(arr))]\n    return arr\n\n# MP-SPDZ equivalent\ndef array_inc_mpspdz(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    result = [sint(0)] * n\n    for i in range(n):\n        result[i] = arr[i] + 1\n    return result\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    arr = [arr[i] + 1 for i in range(len(arr))]\n    return arr\n\n# MP-SPDZ version\n\ndef array_inc_mpspdz(arr):\n    \"\"\"\n    Increment all elements in the input array by 1 in MP-SPDZ\n    \"\"\"\n    # Assuming arr is a list of sint or cint\n    arr = [arr[i] + 1 for i in range(len(arr))]\n    return arr\n\n# Example usage in MP-SPDZ\n# arr = [sint(x) for x in [1, 2, 3]]  # Example input array\n# result = array_inc_mpspdz(arr)\n# print_ln(\"Result: %s\", result)\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises", "response_0": "from Compiler import types\n\ndef count_rises(arr: types.Array):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = types.sint(0)\n    n = len(arr)\n    for i in range(n - 1):\n        count += 1 if arr[i] < arr[i + 1] else 0\n    return count\n", "response_1": "fromCompiler import *\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n    for i in range(n - 1):\n        count += arr[i] < arr[i + 1]\n    return count\n\n# Example usage (not part of the MP-SPDZ program, just for demonstration)\n# arr = Array(5, sint)\n# arr.input_from(0)\n# result = count_rises(arr)\n# print_ln(\"Number of rises: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_2", "response_0": "# Define a function to apply to each element\ndef square(x):\n    return x * x\n\n# Example array\narr = [sint(1), sint(2), sint(3), sint(4)]\n\n# Process the array\nprocessed_arr = array_process(arr, square)\n\n# Output the result\nfor element in processed_arr:\n    print_ln(\"%s\", element.reveal())\n", "response_1": "from Compiler import mpc_math\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    processed_arr = [func(x) for x in arr]\n    return processed_arr\n\n# Example usage in MP-SPDZ\n# Assuming `arr` is a list of secret shared values and `func` is a function that operates on secret shared values\n# For example, if `func` is a function to compute the square of a number\n\ndef square(x):\n    return x * x\n\n# Assuming `arr` is already defined as a list of secret shared values\nresult = array_process(arr, square)\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    vec = [item**2 for item in vec]\n    return (sum(vec) ** .5)\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    vec = [item**2 for item in vec]\n    return (sum(vec)).sqrt()\n", "model_name": "deepseek-v2.5"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Compute the minimum of array a\n    amin = sfix.Array(a).min()\n    \n    # Compute the maximum of array b\n    bmax = sfix.Array(b).max()\n    \n    # Compare amin and bmax\n    return amin >= bmax\n", "response_1": "from Compiler import types\n\ndef totally_dominate(a: types.Array, b: types.Array) -> types.sint:\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Compute the minimum element of array a\n    amin = a[0]\n    for element in a[1:]:\n        amin = amin.max(element)\n    \n    # Compute the maximum element of array b\n    bmax = b[0]\n    for element in b[1:]:\n        bmax = bmax.min(element)\n    \n    # Compare amin and bmax\n    return amin >= bmax\n\n# Example usage\nif __name__ == \"__main__\":\n    n = 5\n    a = types.Array(n, types.sint)\n    b = types.Array(n, types.sint)\n    \n    # Input values for a and b\n    a.input_from(0)\n    b.input_from(1)\n    \n    result = totally_dominate(a, b)\n    print_ln(\"Array a totally dominates array b: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    # Assuming vec1 and vec2 are lists of secret integers (sint)\n    summation = sint(0)\n    for x, y in zip(vec1, vec2):\n        summation = summation + x * y\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays in MP-SPDZ.\n    \"\"\"\n    summation = sfix(0)  # Initialize summation with a secret fixed-point number\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "model_name": "deepseek-v2.5"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    n = len(indices)\n    ret = Array(n, sint)\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)  # Initialize an array of size len(indices) with sint elements\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = Array(len(arr), sbit)\n    for i in range(len(arr)):\n        flag[i] = (arr[i] == cint(5)) | (arr[i] == cint(7))\n    return flag.any()\n", "response_1": "fromCompiler import *\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7 in an MP-SPDZ program.\n    \"\"\"\n    # Initialize a list to store the comparison results\n    flag = Array(len(arr), sint)\n\n    # Iterate over the array and check for 5 or 7\n    for i in range(len(arr)):\n        flag[i] = (arr[i] == 5) | (arr[i] == 7)\n\n    # Use the `or_op` function to check if any element is True\n    result = or_op(flag)\n\n    return result\n\n# Example usage in an MP-SPDZ program\n# arr = Array(10, sint)  # Assuming arr is an array of secret-shared integers\n# result = exists_5_or_7(arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n - 1, sint)\n    for i in range(index):\n        ret[i] = arr[i]\n    for i in range(index, n - 1):\n        ret[i] = arr[i + 1]\n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n-1, sint)\n    \n    for i in range(index):\n        ret[i] = arr[i]\n    \n    for i in range(index, n-1):\n        ret[i] = arr[i+1]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the array in MP-SPDZ.\n    \"\"\"\n    summmation = sum(arr)\n    length = len(arr)\n    ret = summmation / length\n    return ret\n\n# Example usage in MP-SPDZ\n# Assuming arr is a list of secret-shared integers or floats\narr = [sint(1), sint(2), sint(3), sint(4)]  # Example array\navg = average(arr)\nprint_ln(\"The average is: %s\", avg.reveal())\n", "response_1": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = sum(arr)\n    length = len(arr)\n    ret = summmation.reveal() / length\n    return ret\n", "model_name": "deepseek-v2.5"}
