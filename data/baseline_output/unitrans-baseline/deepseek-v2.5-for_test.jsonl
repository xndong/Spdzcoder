{"test_name": "multiply_first_five", "response_0": "def multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sfix(1)  # Initialize the product with 1, using sfix for fixed-point arithmetic\n    for i in range(min(len(array), 5)):  # Loop through the first five elements or all if less than 5\n        prod *= array[i]  # Multiply the current product by the array element\n    return prod\n", "response_1": "def multiply_first_five(array):\n    prod = 1\n    for i in range(min(len(array), 5)):\n        prod *= array[i]\n    return prod\n\n# Example usage in an MP-SPDZ program\narray = sfix.Array(5)  # Assuming an array of 5 fixed-point numbers\n# Initialize array with some values\nfor i in range(5):\n    array[i] = sfix(i + 1)  # Example values: 1, 2, 3, 4, 5\n\nresult = multiply_first_five(array)\nprint_ln(\"The result is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array. \n    \"\"\"\n    n = len(arr)\n    largest = arr[0] if arr[0] >= arr[1] else arr[1]\n    second = arr[1] if arr[0] >= arr[1] else arr[0]\n\n    for i in range(2, n):\n        if arr[i] >= largest:\n            second = largest\n            largest = arr[i]\n        else:\n            if arr[i] >= second:\n                second = arr[i]\n\n    return second\n\n# Example usage in MP-SPDZ\nfrom Compiler import types\n\n# Define the array as a private input\narr = types.Array(10, types. sint)\n\n# Call the function\nresult = second_largest(arr)\n\n# Output the result\nprint_ln(\"The second largest element is: %s\", result.reveal())\n", "response_1": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    n = len(arr)\n    largest = smax(arr)\n    second = sint(0)\n\n    for i in range(n):\n        if i > 1:\n            if arr[i] >= largest:\n                second = largest\n                largest = arr[i]\n            else:\n                if arr[i] >= second:\n                    second = arr[i]\n\n    return second\n", "model_name": "deepseek-v2.5"}
{"test_name": "partial_sum", "response_0": "def partial_sum(arr: sint):\n    \"\"\"\n    Compute the partial sum of the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    partial = sint(0)\n    for i in range(n):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    for i in range(1, n):\n        arr[i] = arr[i] + arr[i - 1]\n    return arr\n\n# Example usage in MP-SPDZ\n# Assuming `arr` is a list of integers or fixed-point numbers in MP-SPDZ\n# arr = Array(n, sint) or Array(n, sfix)\n# partial_sum(arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_adjacent_product", "response_0": "def max_adjacent_product(arr):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2.\n    \"\"\"\n    n = len(arr)\n    cur = arr[0] * arr[1]\n    for i in range(n - 1):\n        product = arr[i] * arr[i + 1]\n        cur = max(cur, product)\n    return cur\n", "response_1": "def max_adjacent_product(arr):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2.\n    \"\"\"\n    cur = arr[0] * arr[1]\n    for i in range(1, len(arr) - 1):\n        product = arr[i] * arr[i + 1]\n        cur = max(cur, product)\n    return cur\n", "model_name": "deepseek-v2.5"}
{"test_name": "argmax", "response_0": "def argmax(a):\n    \"\"\"\n    Return the index of the max value of an array in MP-SPDZ.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = sfix(0)\n\n    for i in range(1, n):\n        # Secure comparison\n        cond = current >= a[i]\n        # Update index and current value based on the comparison\n        index = cond.if_else(index, sfix(i))\n        current = cond.if_else(current, a[i])\n\n    return index\n", "response_1": "def argmax(a):\n    \"\"\"\n    Return the index of the maximum value of an array in MP-SPDZ.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = cint(0)\n\n    for i in range(1, n):\n        # Secure comparison to determine the new maximum\n        is_greater = a[i] > current\n        current = is_greater.if_else(a[i], current)\n        index = is_greater.if_else(cint(i), index)\n\n    return index\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_distinct", "response_0": "from Compiler import mpc_math\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = sfix(0)  # Initialize counter as a secret fixed-point number\n    n = len(arr)\n    \n    for i in range(n):\n        unique = sfix(1)  # Assume the element is unique\n        for j in range(i):\n            # Compare the current element with all previous elements\n            unique = unique * (arr[j] != arr[i])\n        \n        # Increment the counter if the element is unique\n        counter = counter + unique\n    \n    return counter\n", "response_1": "from Compiler import mpc_math\n\ndef count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = sint(0)\n    n = len(arr)\n    for i in range(n):\n        unique = sbool(True)\n        for j in range(i):\n            unique = unique & (arr[j] != arr[i])\n        counter = counter + unique.if_else(1, 0)\n    return counter\n\n# Example usage in MP-SPDZ context\n# arr = [sint(x) for x in [1, 2, 2, 3, 3, 3, 4, 5, 5]]\n# result = count_distinct(arr)\n# print_ln(\"Number of distinct values: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_true", "response_0": "fromCompiler import *\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sbit(0)  # Initialize ret as a secret bit with value 0\n    for item in arr:\n        ret = ret | item  # Use bitwise OR to combine the results\n    return ret\n\n# Example usage in an MP-SPDZ program\ndef main():\n    n = 5\n    arr = Array(n, sbit)\n    # Assume arr is populated with secret-shared boolean values\n    result = exists_true(arr)\n    # Output the result\n    print_ln(\"The array contains a True: %s\", result.reveal())\n", "response_1": "from Compiler import mpc_math\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sint(0)  # Initialize ret as a secret integer with value 0\n    for item in arr:\n        ret = ret | item  # Use bitwise OR to combine the results\n    return ret.reveal()  # Reveal the result to check if it's True\n", "model_name": "deepseek-v2.5"}
{"test_name": "range", "response_0": "from Compiler import mpc_math\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr[1:]:\n        max_value = mpc_math.max(max_value, item)\n        min_value = mpc_math.min(min_value, item)\n    return max_value - min_value\n", "response_1": "def range(arr):\n    \"\"\"\n    Return the range of the array in MP-SPDZ.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n\n    for item in arr[1:]:\n        max_value = max(max_value, item)\n        min_value = min(min_value, item)\n\n    return max_value - min_value\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_larger_than_5", "response_0": "def count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5. \n    \"\"\"\n    counter = sfix(0)\n    for i in range(len(arr)):\n        if arr[i] > sfix(5):\n            counter = counter + sfix(1)\n    return counter\n", "response_1": "arr = [sint(x) for x in [3, 7, 8, 4, 6, 9, 2, 5]]  # Example array of secret integers\nresult = count_larger_than_5(arr)\nprint_ln(\"Number of elements larger than 5: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr: Array):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = sint(0)\n    sum = sint(0)\n\n    for i in range(len(arr)):\n        item = arr[i]\n        abs_item = abs(item)\n        max = max(max, abs_item)\n        sum = sum + abs_item\n\n    return 2 * max > sum\n", "response_1": "def exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = sfix(0)\n    sum = sfix(0)\n    for item in arr:\n        max = max(abs(item), max)\n        sum = sum + abs(item)\n    return 2 * max > sum\n\n# Example usage in MP-SPDZ\n# arr = Array(n, sfix)  # Assuming n is the size of the array\n# exists_dominator(arr)\n", "model_name": "deepseek-v2.5"}
{"test_name": "greedy_picker", "response_0": "# MP-SPDZ program for greedy_picker\n\n# Inputs: items (list of integers) and captivity (integer)\n# Output: number of items the greedy picker can pick\n\n# Define the function in MP-SPDZ syntax\ndef greedy_picker(items, captivity):\n    # Initialize the number of items picked\n    num = sfix(0)\n\n    # Loop through each item\n    for i in range(len(items)):\n        # Check if the current item can fit in the bag\n        if items[i] <= captivity:\n            # Decrease the remaining capacity of the bag\n            captivity = captivity - items[i]\n            # Increment the number of items picked\n            num = num + 1\n\n    # Return the number of items picked\n    return num\n\n# Example usage in MP-SPDZ\n# items = [sfix(5), sfix(3), sfix(2), sfix(4)]\n# captivity = sfix(10)\n# result = greedy_picker(items, captivity)\n# print_ln(\"Number of items picked: %s\", result.reveal())\n", "response_1": "def greedy_picker(items, captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    for i in range(len(items)):\n        if_statement(items[i] <= captivity, \n                     lambda: (captivity.assign(captivity - items[i]), num.assign(num + 1)))\n    return num\n", "model_name": "deepseek-v2.5"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    for i in range(len(l)):\n        s = s + l[i]\n    return s\n\n# Example usage in MP-SPDZ\n# s = sint(5)  # Example scalar\n# l = [sint(1), sint(2), sint(3)]  # Example array\n# result = scalar_add_array(s, l)\n# print_ln(\"Result: %s\", result.reveal())\n", "response_1": "def scalar_add_array(s, l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result.\n    \"\"\"\n    for i in range(len(l)):\n        s = s + l[i]\n    return s\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_equidistant_seq", "response_0": "bool is_equidistant_seq(const vector<int>& arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    int d = arr[1] - arr[0];\n    for (int i = 1; i < n - 1; i++) {\n        if (arr[i + 1] - arr[i] != d) {\n            return false;\n        }\n    }\n    return true;\n}\n", "response_1": "def is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence. \n    If the array has length 1 or 0, return True.\n    \"\"\"\n    n = len(arr)\n    if n <= 1:\n        return True\n\n    d = arr[1] - arr[0]\n    for i in range(1, n-1):\n        if arr[i+1] - arr[i] != d:\n            return False\n    return True\n", "model_name": "deepseek-v2.5"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret shared arrays.\n    \"\"\"\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    \n    sum = sfix(0)  # Initialize sum as a secret fixed-point number\n    for i in range(len(vec1)):\n        sum += vec1[i] * vec2[i]\n    return sum\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        sum += vec1[i] * vec2[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "more_distinct_nonnegative", "response_0": "def more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    nonnegative_counter = sfix(0)\n    negative_counter = sfix(0)\n    n = len(arr)\n\n    for i in range(n):\n        unique = sbool(True)\n        for j in range(i):\n            is_equal = arr[j] == arr[i]\n            unique = unique & ~is_equal\n\n        is_nonnegative = arr[i] >= sfix(0)\n        nonnegative_counter = nonnegative_counter + sfix(unique) * sfix(is_nonnegative)\n        negative_counter = negative_counter + sfix(unique) * sfix(~is_nonnegative)\n\n    return nonnegative_counter > negative_counter\n", "response_1": "def more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    n = len(arr)\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    \n    for i in range(n):\n        unique = sbool(True)\n        for j in range(i):\n            unique = unique & (arr[j] != arr[i])\n        if_then(unique)\n        if_then(arr[i] >= 0)\n        nonnegative_counter = nonnegative_counter + 1\n        else_then()\n        negative_counter = negative_counter + 1\n        end_if()\n        end_if()\n    \n    return nonnegative_counter > negative_counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "flip_positives", "response_0": "def flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        # Check if the element is positive\n        is_positive = array[i] > 0\n        # Flip the element if it is positive\n        array[i] = array[i].if_else(-array[i], array[i], is_positive)\n    return array\n", "response_1": "def flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        if_statement = array[i] > 0\n        array[i] = if_statement.if_else(-array[i], array[i])\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "divide_and_plus", "response_0": "def divide_and_plus(x):\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n", "response_1": "def divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n    return x\n\n# Example usage in MP-SPDZ\nprogram.set_input(x)\nresult = divide_and_plus(x)\nprogram.output(result)\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_log2", "response_0": "def array_log2(arr: Array[sfix]):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = log2(arr[i])\n    return arr\n", "response_1": "def array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array using fixed-point arithmetic.\n    \"\"\"\n    from fixed_point import FPArray, log2\n\n    # Assuming arr is a list of FPArray (fixed-point arrays)\n    for i in range(len(arr)):\n        arr[i] = log2(arr[i])\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_to_ten", "response_0": "def sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for i in range(len(array)):\n        sum += array[i]\n        if sum >= 10:\n            break\n    return sum\n\n# Example usage in MP-SPDZ\n# array = [sint(1), sint(2), sint(3), sint(4), sint(5)]  # Example array with secret integers\n# result = sum_to_ten(array)\n# print_ln(\"The result is: %s\", result.reveal())\n", "response_1": "def sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(array)):\n        sum += array[i]\n        if_then(sum >= sfix(10))\n        break_loop()\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "def choppy_plus_minus(arr):\n    n = len(arr)\n    for i in range(n):\n        cond = i % 2 == 1\n        arr[i] = cond.if_else(arr[i] + 1, arr[i] - 1)\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "min_element", "response_0": "from Compiler import types\n\ndef min_element(a: types.Array):\n    \"\"\"\n    Return the minimum value of a secure array.\n    \"\"\"\n    current = a[0]\n    for i in range(len(a)):\n        current = types.minimum(current, a[i])\n    \n    return current\n", "response_1": "def min_element(a):\n    \"\"\"\n    Return the minimum value of an array in MP-SPDZ.\n    \"\"\"\n    current = a[0]\n    for i in range(len(a)):\n        current = current if current <= a[i] else a[i]\n    \n    return current\n\n# Example usage in MP-SPDZ\nfrom Compiler import types\n\n# Define the array type\na = types.Array(10, types. sint)\n\n# Call the function\nresult = min_element(a)\n", "model_name": "deepseek-v2.5"}
{"test_name": "soft_max", "response_0": "def soft_max(arr: regint):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    # Initialize the denominator\n    denominator = sfix(0)\n    \n    # Calculate the sum of e^item for all items in the array\n    for item in arr:\n        denominator += sfix.exp(sfix(item))\n    \n    # Initialize the output array\n    brr = Array(len(arr), sfix)\n    \n    # Calculate the soft-max values\n    for i in range(len(arr)):\n        brr[i] = sfix.exp(sfix(arr[i])) / denominator\n    \n    return brr\n", "response_1": "def soft_max(arr: sint):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    denominator = sint(0)\n    for item in arr:\n        denominator = denominator + exp(item)\n    \n    brr = arr.same_shape()\n    for i in range(len(arr)):\n        brr[i] = exp(arr[i]) / denominator\n    \n    return brr\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_reverse_pair_with_break", "response_0": "def count_reverse_pair_with_break(arr: Array):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    \"\"\"\n    n = len(arr)\n    count = sfix(0)\n    for i in range(1, n):\n        if arr[i] > sfix(10):\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count += sfix(1)\n    return count\n\n# Example usage in MP-SPDZ\n# arr = Array(n, sfix)  # Assuming `n` is the size of the array and `sfix` is the fixed-point type\n# count = count_reverse_pair_with_break(arr)\n# print_ln(\"Number of reverse pairs: %s\", count.reveal())\n", "response_1": "def count_reverse_pair_with_break(arr):\n    n = len(arr)\n    count = sfix(0)\n    for i in range(1, n):\n        if arr[i] > sfix(10):\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count += sfix(1)\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_unique", "response_0": "def sum_unique(arr: Array):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    sum = sint(0)\n    n = len(arr)\n    for i in range(n):\n        unique = sbool(True)\n        for j in range(n):\n            if arr[j] == arr[i] and j != i:\n                unique = sbool(False)\n                break\n        if unique.reveal():\n            sum = sum + arr[i]\n    return sum\n", "response_1": "def sum_unique(arr):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    n = len(arr)\n    sum = sint(0)\n    for i in range(n):\n        unique = sbool(1)\n        for j in range(n):\n            if_statement = arr[j] == arr[i]\n            unique = unique & (if_statement.if_else(sbool(0), sbool(1)) if j != i else sbool(1))\n        sum = sum + unique.if_else(arr[i], sint(0))\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "check_sum", "response_0": "def check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        sum = sum + array[i]\n    return sum == target\n", "response_1": "def check_sum(array, target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for num in array:\n        sum = sum + num  # Accumulate the sum\n    return sum == target  # Compare the sum with the target\n\n# Example usage in MP-SPDZ program\n# array = [sint(1), sint(2), sint(3)]  # Example array of secret integers\n# target = sint(6)  # Example target value as a secret integer\n# result = check_sum(array, target)\n# print_ln(\"Sum equals target: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "prod", "response_0": "#include \"math.h\"\n#include \"array.h\"\n\ntemplate <class T>\nT prod(const vector<T>& array) {\n    T prod = 1;\n    for (int i = 0; i < array.size(); i++) {\n        prod = prod * array[i];\n    }\n    return prod;\n}\n", "response_1": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    prod = sfix(1)\n    for num in array:\n        prod = prod * num\n    return prod\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_till_negative", "response_0": "def sum_till_negative(array: Array[sint]):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = sint(0)\n    n = len(array)\n    for i in range(n):\n        if_statement = array[i] < 0\n        if if_statement.reveal():\n            break\n        sum = sum + array[i]\n    return sum\n", "response_1": "def sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = 0\n    for i in range(len(array)):\n        if array[i] < 0:\n            break\n        sum += array[i]\n    return sum\n\n# MP-SPDZ equivalent\ndef sum_till_negative_mpspdz(array):\n    sum = sint(0)\n    for i in range(len(array)):\n        if array[i] < 0:\n            break\n        sum += array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for i in range(len(arr)):\n        if predicator(arr[i]):\n            sum = sum + 1\n    return sum\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicate.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr)):\n        if predicator(arr[i]):\n            sum = sum + sfix(1)\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "standard_deviation", "response_0": "from Compiler import types\n\ndef standard_deviation(arr: types.Array):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    n = len(arr)\n    average = types.sint()\n    variance = types.sint()\n\n    # Calculate the average\n    for item in arr:\n        average += item / n\n\n    # Calculate the variance\n    for item in arr:\n        variance += (item - average) ** 2 / n\n\n    # Return the square root of the variance\n    return variance.sqrt()\n", "response_1": "def standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    n = len(arr)\n    average = sfix.Array(n).load_mem(arr).sum() / sfix(n)\n    \n    variance = sfix(0)\n    for i in range(n):\n        variance += (arr[i] - average) ** sfix(2)\n    variance /= sfix(n)\n    \n    return variance.sqrt()\n", "model_name": "deepseek-v2.5"}
{"test_name": "dominate", "response_0": "def dominate(a, b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    n = len(a)\n    ret = sbit()\n    ret = 1  # Initialize ret to True\n\n    for i in range(n):\n        ret = ret & (a[i] >= b[i])\n\n    return ret\n", "response_1": "def dominate(a: sint, b: sint, n: int):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    ret = sint(1)\n    for i in range(n):\n        ret = ret & (a[i] >= b[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = sfix(0)\n    for item in brr:\n        if abs(item) > max_abs:\n            max_abs = abs(item)\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n\n# Example usage in MP-SPDZ\nn = 5\nbrr = sfix.Array(n)\n# Initialize brr with some values\nfor i in range(n):\n    brr[i] = sfix(i + 1)\n\n# Call the rescale function\nrescaled_brr = rescale(brr)\n\n# Output the result\nfor i in range(n):\n    print_ln(\"rescaled_brr[%s] = %s\", i, rescaled_brr[i])\n", "response_1": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = sfix(0)\n    for item in brr:\n        max_abs = max(max_abs, abs(item))\n    \n    for i in range(len(brr)):\n        brr[i] = brr[i].div(max_abs)\n    \n    return brr\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_minus7", "response_0": "def array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] - 7\n    return arr\n\n# MP-SPDZ program\ndef array_minus7_mpspdz(arr):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] - cint(7)\n    return arr\n", "response_1": "from Compiler import mpc_math\n\ndef array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] - cint(7)\n    return arr\n\n# Example usage\nif __name__ == \"__main__\":\n    arr = Array(10, cint)  # Create an array of 10 clear integers\n    arr = array_minus7(arr)\n    print_ln(\"Result: %s\", arr.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    n = len(arr1)\n    m = len(arr2)\n    sum = sfix(0)\n    for i in range(n):\n        for j in range(m):\n            sum = sum + arr1[i] * arr2[j]\n    return sum\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum = sum + arr1[i] * arr2[j]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "longest_nondec_subseq", "response_0": "from Compiler import types\n\ndef longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    max_length = types.sint(0)\n    cur_length = types.sint(0)\n    n = len(a)\n    \n    for i in range(n):\n        if i == 0:\n            cur_length = types.sint(1)\n            continue\n        if a[i] >= a[i - 1]:\n            cur_length = cur_length + 1\n        else:\n            max_length = max_length if max_length >= cur_length else cur_length\n            cur_length = types.sint(1)\n    max_length = max_length if max_length >= cur_length else cur_length\n    return max_length\n\n# Example usage\n# a = [types.sint(1), types.sint(2), types.sint(3), types.sint(1), types.sint(2)]\n# result = longest_nondec_subseq(a)\n# print_ln(\"The length of the longest non-decreasing subsequence is: %s\", result.reveal())\n", "response_1": "def longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-decreasing subsequence in the input array.\n    \"\"\"\n    max_length = sint(0)\n    cur_length = sint(0)\n    n = len(a)\n    \n    for i in range(n):\n        if i == 0:\n            cur_length = sint(1)\n            continue\n        if a[i] >= a[i - 1]:\n            cur_length += 1\n        else:\n            max_length = max_length if max_length >= cur_length else cur_length\n            cur_length = sint(1)\n    \n    max_length = max_length if max_length >= cur_length else cur_length\n    return max_length\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_but_skip_biggest", "response_0": "def sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    n = len(array)\n    sum = sfix(0)\n    biggest = array[0]\n\n    for i in range(n):\n        if_statement = array[i] >= biggest\n        biggest = if_statement.if_else(array[i], biggest)\n        sum += if_statement.if_else(sfix(0), array[i])\n\n    return sum\n", "response_1": "from Compiler import types\n\ndef sum_but_skip_biggest(array: types.Array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = types.sint(0)\n    biggest = array[0]\n    for i in range(len(array)):\n        if array[i] >= biggest:\n            biggest = array[i]\n            continue\n        sum += array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "second_test", "response_0": "def second_test(arr: Array<int>):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    for i in range(1, len(arr)):\n        if arr[0] < arr[i]:\n            count = count + 1\n    return count == 1\n", "response_1": "def second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    for i in range(1, len(arr)):\n        if arr[0] < arr[i]:\n            count = count + 1\n    return count == 1\n", "model_name": "deepseek-v2.5"}
{"test_name": "Manhattan_distance", "response_0": "def Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    n = len(a)\n    ret = sfix(0)\n    for i in range(n):\n        ret = ret + abs(a[i] - b[i])\n    return ret\n", "response_1": "def Manhattan_distance(a, b):\n    \"\"\"\n    Compute the Manhattan distance of the two secret-shared vectors.\n    \"\"\"\n    n = len(a)\n    ret = sint(0)  # Initialize the result as a secret integer\n    for i in range(n):\n        ret = ret + abs(a[i] - b[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "deal_with_only_positive", "response_0": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sfix(1)\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        sum = sum + sign * array[i]\n        sign = (-1) * sign\n    return sum\n", "response_1": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and subtract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sfix(1)\n    sum = sfix(0)\n    for i in range(len(array)):\n        if array[i] <= sfix(0):\n            continue\n        sum = sum + sign * array[i]\n        sign = (-1) * sign\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "compare_and_return", "response_0": "from Compiler import types\n\ndef compare_and_return(arr: types.Array, brr: types.Array) -> types.sint:\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    ret = types.sint(-1)\n    n = len(arr)\n    for i in range(n):\n        cond = arr[i] == brr[i]\n        ret = types.cond_swap(cond, i, ret)\n        if cond.reveal():\n            break\n    return ret\n", "response_1": "def compare_and_return(arr, brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    for i in range(n):\n        cond = arr[i] == brr[i]\n        ret = cond.if_else(i, ret)\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_odd_positive", "response_0": "def sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        item = arr[i]\n        if item.reveal() % 2 == 1 and item.reveal() > 0:\n            sum = sum + item\n    return sum\n", "response_1": "def sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for item in arr:\n        if item % 2 == 1 and item > 0:\n            sum = sum + item\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_sum", "response_0": "def two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            if arr[i] + arr[j] == target:\n                return True\n    return False\n\n# MP-SPDZ specific code\nfrom Compiler import mpc_math\n\ndef main():\n    # Assuming arr and target are already defined as MP-SPDZ secure types\n    arr = [sint(x) for x in arr]  # Convert to MP-SPDZ secure integers\n    target = sint(target)\n\n    result = two_sum(arr, target)\n    print_ln(\"The result is %s\", result.reveal())\n\nmain()\n", "response_1": "from Compiler import mpc_math\n\ndef two_sum(arr, target):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            sum = arr[i] + arr[j]\n            if sum == target:\n                return 1  # Return True in MP-SPDZ (1 represents True)\n    return 0  # Return False in MP-SPDZ (0 represents False)\n\n# Example usage in MP-SPDZ program\n# arr = Array(5, sint)  # Example array with 5 secret integers\n# target = sint(10)  # Example target value\n# result = two_sum(arr, target)\n# print_ln(\"Result: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "seq_search", "response_0": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        found = (arr[i] == target)\n        if_else(found, return_op(i), continue_op())\n    return -1\n", "response_1": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    n = len(arr)\n    found = sint(0)\n    index = sint(-1)\n\n    for i in range(n):\n        # Check if arr[i] == target\n        is_equal = arr[i] == target\n        # Update found and index if the target is found\n        found = found | is_equal\n        index = is_equal.if_else(i, index)\n\n    # Return the index if found, otherwise return -1\n    return index\n", "model_name": "deepseek-v2.5"}
{"test_name": "choppy_array", "response_0": "from Compiler import types\n\ndef choppy_array(arr: types.Array):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i):\n            if i % 2 == 1:\n                # Check if arr[i+j] > arr[i]\n                if arr[i + j] > arr[i]:\n                    return types.sint(0)  # False\n            else:\n                # Check if arr[i+j] < arr[i]\n                if arr[i + j] < arr[i]:\n                    return types.sint(0)  # False\n    return types.sint(1)  # True\n\n# Example usage in an MP-SPDZ program\narr = types.Array(5, types.sint)  # Example array of size 5\n# Initialize arr with some values (this is just an example, actual initialization would depend on the input)\narr[0] = types.sint(1)\narr[1] = types.sint(5)\narr[2] = types.sint(2)\narr[3] = types.sint(4)\narr[4] = types.sint(3)\n\nresult = choppy_array(arr)\nprint_ln(\"Is choppy array: %s\", result.reveal())\n", "response_1": "def choppy_array(arr: Array):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i):\n            if i % 2 == 1:\n                if arr[i + j] > arr[i]:\n                    return cint(0)\n            else:\n                if arr[i + j] < arr[i]:\n                    return cint(0)\n    return cint(1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process", "response_0": "def square(x: sint):\n    return x * x\n\n# Example usage\narr = sint(10)  # Assuming arr is a secret-shared array of size 10\nprocessed_arr = array_process(arr, square)\n", "response_1": "# MP-SPDZ program: array_process.mpc\n\ndef array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n\n# Example usage of array_process with a simple function\n# Define the function to be applied to each element\ndef square(x):\n    return x * x\n\n# Initialize a secret array\nn = 5\narr = sint.Array(n)\narr.assign([1, 2, 3, 4, 5])  # Example values\n\n# Process the array\nresult = array_process(arr, square)\n\n# Output the result\nprint_ln(\"Processed array: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "normalize", "response_0": "def normalize(vec):\n    \"\"\"\n    Normalize the vector in MP-SPDZ.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum += item**2\n    base = sqrt(sum)\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    return vec\n", "response_1": "def normalize(vec):\n    \"\"\"\n    Normalize the vector in MP-SPDZ.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item**2\n    \n    # Secure square root computation\n    base = sqrt(sum)\n    \n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n    \n    return vec\n", "model_name": "deepseek-v2.5"}
{"test_name": "impatient_merchant", "response_0": "def impatient_merchant(days):\n    \"\"\"\n    MP-SPDZ version of the impatient merchant problem.\n    \"\"\"\n    can_buy = sint(1)  # Initialize can_buy as a secret integer with value 1 (True)\n    net = sint(0)      # Initialize net as a secret integer with value 0\n    orig_price = sint(0)  # Initialize orig_price as a secret integer with value 0\n\n    for i in range(len(days)):\n        can_buy = can_buy & (net == net)  # Ensure can_buy is a secret integer\n        net = net - (can_buy * days[i])\n        orig_price = can_buy * days[i] + (1 - can_buy) * orig_price\n        can_buy = (1 - can_buy) * (days[i] > orig_price) + can_buy * (1 - (days[i] > orig_price))\n\n    return net\n\n# Example usage in MP-SPDZ\n# days = sint.Array(len(days_input))\n# days.assign(days_input)  # Assign private inputs to the array\n# result = impatient_merchant(days)\n# print_ln(\"Net value: %s\", result.reveal())\n", "response_1": "def impatient_merchant(days):\n    \"\"\"\n    You are given the prices of some goods in consecutive days. \n    Here's an impatient merchant who will buy the good at the first days, \n    and sell it until its price becomes higher than its original cost. \n    Then he will buy the good in the next day and repeat the above process. \n    The good left in the hand of the merchant in the last day will worth nothing.\n    You should calculate the net value the impatient merchant can earn.\n    \"\"\"\n    can_buy = sfix(1)  # Initialize can_buy as a fixed-point number with value 1\n    net = sfix(0)  # Initialize net as a fixed-point number with value 0\n    orig_price = sfix(0)  # Initialize orig_price as a fixed-point number with value 0\n\n    for i in range(len(days)):\n        if can_buy == 1:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = sfix(0)\n        else:\n            if days[i] > orig_price:\n                net = net + days[i]\n                can_buy = sfix(1)\n\n    return net\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1, 0, -1):\n        a[i] = a[i-1]\n    a[0] = temp\n    return a\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    temp = a[n-1]\n    for i in range(n-1, 0, -1):\n        a[i] = a[i-1]\n    a[0] = temp\n    return a\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_double", "response_0": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n\n# Example usage in MP-SPDZ\n# Assuming 'arr' is an array of integers in MP-SPDZ\narr = Array(10, sint)  # Example array of 10 secret integers\narray_double(arr)\n", "response_1": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "stop_at_zero", "response_0": "def stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        if array[i] == cint(0):\n            break\n        array[i] = array[i] + cint(1)\n    return array\n", "response_1": "from Compiler import types\n\ndef stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        if array[i] == 0:\n            break\n        array[i] = array[i] + 1\n    return array\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define an array of integers\n    array = types.Array(5, types. sint)\n    array.assign([1, 2, 0, 4, 5])\n\n    # Call the function\n    result = stop_at_zero(array)\n\n    # Print the result\n    print_ln(\"Resulting array: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = 1 - arr[i]\n    return arr\n", "response_1": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = 1 - arr[i]\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_then_clip", "response_0": "def array_process_then_clip(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome into the range [-10, 10]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = func(arr[i])\n        arr[i] = arr[i].max(-10).min(10)\n    return arr\n", "response_1": "def array_process_then_clip(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome into the range [-10, 10]\n    \"\"\"\n    # Process each element in the array\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    \n    # Clip the elements to the range [-10, 10]\n    for i in range(len(arr)):\n        arr[i] = max(-10, min(arr[i], 10))\n    \n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "add_and_count_positive", "response_0": "def add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    n = len(array)\n    count = sfix(0)\n    for i in range(n):\n        array[i] = array[i] + k\n        if array[i] > 0:\n            count = count + 1\n    return array, count\n", "response_1": "def add_and_count_positive(array, k):\n    \"\"\"\n    Add k to all elements in the given secret-shared array, and count the number of positive numbers in the output array.\n    Return both the output array and the count.\n    \"\"\"\n    n = len(array)\n    output_array = Array(n, sfix)\n    count = sfix(0)\n\n    for i in range(n):\n        output_array[i] = array[i] + k\n        count = count + (output_array[i] > 0)\n\n    return output_array, count\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other, it will be padded with 0.\n    \"\"\"\n    n = len(a)\n    m = len(b)\n    \n    if n > m:\n        ret = sfix.Array(n)\n        for i in range(m):\n            ret[i] = a[i] - b[i]\n        for i in range(n - m):\n            ret[m + i] = a[m + i]\n    else:\n        ret = sfix.Array(m)\n        for i in range(n):\n            ret[i] = a[i] - b[i]\n        for i in range(m - n):\n            ret[n + i] = -b[n + i]\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    n = max(len(a), len(b))\n    ret = Array(n, sint)\n    \n    for i in range(len(a)):\n        ret[i] = a[i]\n    \n    for i in range(len(b)):\n        ret[i] -= b[i]\n    \n    for i in range(len(a), n):\n        ret[i] = 0\n    \n    for i in range(len(b), n):\n        ret[i] = -b[i]\n    \n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "lower_bound", "response_0": "def lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = x + 1  # Initialize distance to a value larger than x\n    found = False\n\n    for i in range(n):\n        cond1 = arr[i] <= x\n        cond2 = not found | (x - arr[i] < distance)\n        ret = cond1 & cond2 * i + (1 - cond1 | cond2) * ret\n        distance = cond1 & cond2 * (x - arr[i]) + (1 - cond1 | cond2) * distance\n        found = found | cond1\n\n    return ret\n", "response_1": "def lower_bound(arr, x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = x + 1  # Initialize distance to a value larger than any possible difference\n    found = sbool(0)  # Initialize found flag to False\n\n    for i in range(n):\n        cond = arr[i] <= x\n        new_distance = x - arr[i]\n        ret = cond.if_else(i, ret)\n        distance = cond.if_else(new_distance, distance)\n        found = cond | found\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "argmin", "response_0": "from Compiler import mpc_math\n\ndef argmin(a):\n    \"\"\"\n    Return the index of the minimum value of an array.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = sfix(0)\n\n    for i in range(1, n):\n        # Compare current with a[i]\n        cond = current <= a[i]\n        # Update index\n        index = cond.if_else(index, sfix(i))\n        # Update current\n        current = cond.if_else(current, a[i])\n\n    return index\n", "response_1": "def argmin(a):\n    \"\"\"\n    Return the index of the minimum value of an array.\n    \"\"\"\n    n = len(a)\n    current = a[0]\n    index = sfix(0)\n\n    for i in range(1, n):\n        # Compare current and a[i]\n        is_less = current < a[i]\n        # Update current and index based on the comparison\n        current = is_less.if_else(current, a[i])\n        index = is_less.if_else(index, sfix(i))\n\n    return index\n", "model_name": "deepseek-v2.5"}
{"test_name": "independent_robbery", "response_0": "from Compiler import mpc_math\n\ndef independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem in MP-SPDZ.\n    \"\"\"\n    n = len(houses)\n    dp = sfix.Array(n)\n    dp[0] = houses[0]\n    dp[1] = max(houses[1], dp[0])\n    for i in range(2, n):\n        dp[i] = max(dp[i-2] + houses[i], dp[i-1])\n    return dp[n-1]\n\n# Example usage in MP-SPDZ program\nif __name__ == \"__main__\":\n    # Example houses with secret-shared values\n    houses = sfix.Array(5)\n    houses[0] = sfix(10)\n    houses[1] = sfix(20)\n    houses[2] = sfix(30)\n    houses[3] = sfix(40)\n    houses[4] = sfix(50)\n\n    result = independent_robbery(houses)\n    print_ln(\"The maximum amount of money the robber can get is: %s\", result.reveal())\n", "response_1": "def independent_robbery(houses):\n    n = len(houses)\n    dp = sfix.Array(n)\n    dp[0] = houses[0]\n    dp[1] = max(houses[1], dp[0])\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-2] + houses[i], dp[i-1])\n    \n    return dp[n-1]\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_odd_and_odd", "response_0": "#include <array>\n#include <iostream>\n\ntemplate <size_t N>\nint sum_odd_and_odd(const std::array<int, N>& arr) {\n    int sum = 0;\n    for (size_t i = 0; i < N; ++i) {\n        if (i % 2 == 0) {\n            continue;\n        }\n        for (size_t j = 0; j < i; ++j) {\n            if (j % 2 == 0) {\n                continue;\n            }\n            sum += arr[j];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::array<int, 5> arr = {1, 2, 3, 4, 5};\n    std::cout << \"Sum: \" << sum_odd_and_odd(arr) << std::endl;\n    return 0;\n}\n", "response_1": "def sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    sum = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            sum += arr[j]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_monotonous", "response_0": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    d = sint(0)\n    n = len(arr)\n    for i in range(n-1):\n        if i > 0 and (arr[i+1] - arr[i]) * d <= 0:\n            return sbool(False)\n        d = arr[i+1] - arr[i]\n    return sbool(True)\n", "response_1": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    n = len(arr)\n    d = sint(0)\n    for i in range(n-1):\n        if i > 0 and (arr[i+1] - arr[i]) * d <= 0:\n            return cint(0)\n        d = arr[i+1] - arr[i]\n    return cint(1)\n\n# Example usage in MP-SPDZ\n# arr = [sint(x) for x in [1, 2, 3, 4]]\n# result = is_monotonous(arr)\n# print_ln(\"Is monotonous: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "positive_count_negative_sum", "response_0": "def positive_count_negative_sum(arr: sint):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint(0)\n    sum = sint(0)\n    for item in arr:\n        if_statement(item > 0, count.assign(count + 1))\n        if_statement(item < 0, sum.assign(sum + item))\n    return count, sum\n", "response_1": "def positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint(0)\n    sum = sfix(0)\n    for item in arr:\n        if_statement = item > 0\n        count = count + if_statement\n        sum = sum + item * (item < 0)\n    return count, sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_even", "response_0": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            sum = sum + arr[i]\n    return sum\n", "response_1": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for item in arr:\n        if item.reveal() % 2 == 0:  # Check if the item is even\n            sum = sum + item\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for item in vec:\n        sum = sum + abs(item)  # Sum the absolute values of the vector elements\n    return sum\n", "response_1": "def one_norm(vector<sint> vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sint sum = 0;\n    for (int i = 0; i < vec.size(); i++) {\n        sum = sum + abs(vec[i]);\n    }\n    return sum;\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_floor", "response_0": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    from Compiler import mpc_math\n    \n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = mpc_math.floor(arr[i])\n    return ret\n", "response_1": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    from Compiler import math\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = math.floor(arr[i])\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "three_five", "response_0": "def three_five(arr):\n    \"\"\"\n    If the input array contains both/neither 3 and/or 5, return True, \n    otherwise return False. \n    \"\"\"\n    has3 = sbit()\n    has5 = sbit()\n    for item in arr:\n        has3 = has3 | (item == 3)\n        has5 = has5 | (item == 5)\n    return (has3 & has5) | ((~has3) & (~has5))\n", "response_1": "from Compiler import mpc_math\n\ndef three_five(arr):\n    \"\"\"\n    If the input array contains both/neither 3 and/or 5, return True, \n    otherwise return False. \n    \"\"\"\n    has3 = sfix(0)\n    has5 = sfix(0)\n    \n    for item in arr:\n        has3 = has3 + (item == sfix(3))\n        has5 = has5 + (item == sfix(5))\n    \n    # Check if has3 and has5 are both 1 or both 0\n    result = (has3 * has5) + ((sfix(1) - has3) * (sfix(1) - has5))\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "num_above_average", "response_0": "def num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    n = len(arr)\n    sum = sfix.Array(n).sum()  # Sum of all elements in the array\n    avg = sum / sfix(n)  # Calculate the average\n    count = sfix(0)  # Initialize count\n\n    for i in range(n):\n        if arr[i] >= avg:\n            count = count + 1\n\n    return count\n", "response_1": "#include \"MP-SPDZ/Compiler/types.h\"\n\ntemplate<class T>\nint num_above_average(const vector<T>& arr) {\n    T sum = T(0);\n    int count = 0;\n    int n = arr.size();\n    \n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n    }\n    \n    T avg = sum / T(n);\n    \n    for (const auto& item : arr) {\n        if (item >= avg) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip", "response_0": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = max(lower_bound, min(arr[i], upper_bound))\n    return arr\n", "response_1": "from Compiler import types\n\ndef clip(arr: types.Array, upper_bound: types.sint, lower_bound: types.sint) -> types.Array:\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = types.max(lower_bound, types.min(arr[i], upper_bound))\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "def sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(array)):\n        if_condition = (sum + array[i]) >= sfix(5) & (sum + array[i]) <= sfix(10)\n        sum = sum + array[i] * (1 - if_condition)\n    return sum\n", "response_1": "def sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(array)):\n        temp_sum = sum + array[i]\n        skip = (5 <= temp_sum) * (temp_sum <= 10)\n        sum = sum + array[i] * (1 - skip)\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_of_odd_and_even", "response_0": "def sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers. \n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        if item.reveal() % 2:\n            odd_sum = odd_sum + item\n        else:\n            even_sum = even_sum + item\n    return odd_sum, even_sum\n", "response_1": "def sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers. \n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        if item.reveal() % 2:\n            odd_sum = odd_sum + item\n        else:\n            even_sum = even_sum + item\n    return odd_sum, even_sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "distance", "response_0": "from Compiler import mpc_math\n\ndef distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        sum = sum + (vec1[i] - vec2[i])**2\n    return mpc_math.sqrt(sum)\n", "response_1": "def distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(vec1)):\n        sum = sum + (vec1[i] - vec2[i])**2\n    return sqrt(sum)\n", "model_name": "deepseek-v2.5"}
{"test_name": "num_occurrence", "response_0": "from Compiler import mpc_math\n\ndef num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sint(0)  # Initialize count as a secret integer\n    for item in arr:\n        # Use mpc_math.eq to compare secret-shared values\n        count = count + mpc_math.eq(item, target)\n    return count\n", "response_1": "def num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sint(0)  # Initialize count as a secret integer\n    for item in arr:\n        if item == target:\n            count = count + 1\n    return count\n\n# Example usage in MP-SPDZ program\n# Assuming arr and target are already defined and loaded into MP-SPDZ\n# result = num_occurrence(arr, target)\n# reveal(result)  # To reveal the result if needed\n", "model_name": "deepseek-v2.5"}
{"test_name": "palindrome", "response_0": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    flag = sbool(True)\n    for i in range(n):\n        flag = flag & (arr[i] == arr[n-1-i])\n    return flag\n", "response_1": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    n = len(arr)\n    flag = sbit()  # Initialize a secret bit\n    flag = 1  # Set flag to True initially\n\n    for i in range(n):\n        flag = flag & (arr[i] == arr[n - 1 - i])\n\n    return flag\n", "model_name": "deepseek-v2.5"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array using MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    num = sint(0)  # Initialize the count as a secret integer\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compare arr[i] and arr[j] securely\n            greater = arr[i] > arr[j]\n            # Increment the count securely if arr[i] > arr[j]\n            num = num + greater\n\n    return num\n", "response_1": "from Compiler import mpc_math\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    n = len(arr)\n    num = sint(0)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                num = num + 1\n    return num\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_of_cubes", "response_0": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        ret = ret + item**3\n    return ret\n", "response_1": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sfix(0)  # Initialize the return value as a fixed-point number\n    for item in arr:\n        ret = ret + item**3  # Compute the cube and add it to the result\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_element", "response_0": "def max_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    current = a[0]\n    for i in range(1, len(a)):\n        current = current.max(a[i])\n    \n    return current\n", "response_1": "from Compiler import types\n\ndef max_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a[1:]:\n        current = types.max(current, item)\n    \n    return current\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_if_else", "response_0": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    n = len(arr)\n    result = sfix.Array(n)  # Create an array to store the results\n\n    for i in range(n):\n        # Evaluate the predicator on the current element\n        pred_result = predicator(arr[i])\n        \n        # Use the secure if-else operation\n        result[i] = pred_result.if_else(if_func(arr[i]), else_func(arr[i]))\n    \n    return result\n", "response_1": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        cond = predicator(arr[i])\n        if_then(cond)\n        arr[i] = if_func(arr[i])\n        else_then()\n        arr[i] = else_func(arr[i])\n        end_if()\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "inf_norm", "response_0": "def inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    max_val = sfloat(0)\n    for item in vec:\n        abs_item = abs(item)\n        max_val = max_val.max(abs_item)\n    return max_val\n", "response_1": "def inf_norm(const vector<int>& vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    int sum = 0;\n    for (int i = 0; i < vec.size(); i++) {\n        sum = max(sum, abs(vec[i]));\n    }\n    return sum;\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_inc", "response_0": "from Compiler import mpc_math\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n\n# Example usage in MP-SPDZ\ndef main():\n    # Assuming `arr` is a list of secret shared integers\n    arr = [sint(x) for x in [1, 2, 3, 4, 5]]  # Example input array\n    result = array_inc(arr)\n    # Output the result\n    for i in range(len(result)):\n        print_ln(\"%s\", result[i].reveal())\n", "response_1": "from Compiler import types\n\ndef array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = arr[i] + 1\n    return arr\n\ndef main():\n    n = 5  # Example size of the array\n    arr = types.sint.Array(n)\n    arr.input_from(0)  # Input array elements from party 0\n    arr = array_inc(arr)\n    arr.print_output_to(0)  # Output the result to party 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sfix(0)\n    for i in range(len(arr) - 1):\n        if arr[i] < arr[i + 1]:\n            count = count + 1\n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sint(0)\n    n = len(arr)\n    for i in range(n-1):\n        if arr[i] < arr[i+1]:\n            count = count + 1\n    return count\n", "model_name": "deepseek-v2.5"}
{"test_name": "skip_at_zero", "response_0": "def skip_at_zero(array: cint):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        # Check if the element is equal to 0\n        if array[i] == 0:\n            continue\n        # Add 1 to the element\n        array[i] = array[i] + 1\n    return array\n", "response_1": "def skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    for i in range(len(array)):\n        # Check if the element is zero\n        is_zero = array[i] == 0\n        # If the element is not zero, add 1\n        array[i] = array[i] + is_zero.if_else(0, 1)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_intersect", "response_0": "from Compiler import types\n\ndef array_intersect(p: types.sint.Array, q: types.sint.Array) -> types.sint:\n    \"\"\"\n    Return whether the two arrays share any common element.\n    \"\"\"\n    n = len(p)\n    m = len(q)\n    for i in range(n):\n        for j in range(m):\n            if_condition = p[i] == q[j]\n            if types.reveal(if_condition):\n                return types.sint(1)\n    return types.sint(0)\n", "response_1": "def array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element.\n    \"\"\"\n    n = len(p)\n    m = len(q)\n    \n    # Load arrays into MP-SPDZ secure types\n    p_array = Array(n, sint)\n    q_array = Array(m, sint)\n    \n    for i in range(n):\n        p_array[i] = sint(p[i])\n    \n    for j in range(m):\n        q_array[j] = sint(q[j])\n    \n    # Check for intersection\n    for i in range(n):\n        for j in range(m):\n            if_cond = p_array[i] == q_array[j]\n            if if_cond.if_else(1, 0) == 1:\n                return True\n    \n    return False\n", "model_name": "deepseek-v2.5"}
{"test_name": "two_norm", "response_0": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item * item\n    return sqrt(sum)\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    for item in vec:\n        sum = sum + item**2\n    return sqrt(sum)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_between", "response_0": "def sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sint(0)\n    for i in range(len(arr)):\n        item = arr[i]\n        if_statement = (l <= item) * (item <= u)\n        sum = sum + if_statement * item\n    return sum\n", "response_1": "def sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sfix(0)\n    for i in range(len(arr)):\n        if l <= arr[i] <= u:\n            sum = sum + arr[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "largest_gap", "response_0": "def largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = sfix(0)\n    for i in range(len(arr)-1):\n        gap = abs(arr[i+1] - arr[i])\n        cur = max(cur, gap)\n    return cur\n", "response_1": "def largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = sfix(0)\n    for i in range(len(arr)-1):\n        diff = abs(arr[i+1] - arr[i])\n        cur = max(cur, diff)\n    return cur\n", "model_name": "deepseek-v2.5"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    \n    for i in range(len(a)):\n        amin = max(amin, a[i])\n    \n    for i in range(len(b)):\n        bmax = max(bmax, b[i])\n    \n    return amin >= bmax\n", "response_1": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    n = len(a)\n    m = len(b)\n    \n    # Initialize amin and bmax with the first elements of a and b\n    amin = a[0]\n    bmax = b[0]\n    \n    # Find the minimum element in a\n    for i in range(1, n):\n        amin = amin.max(a[i])\n    \n    # Find the maximum element in b\n    for i in range(1, m):\n        bmax = bmax.min(b[i])\n    \n    # Check if the minimum element in a is greater than or equal to the maximum element in b\n    return amin.geq(bmax)\n", "model_name": "deepseek-v2.5"}
{"test_name": "element_count", "response_0": "def element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    ret = sint(0)  # Initialize the return value as a secret integer\n    for item in arr:\n        if item == target:\n            ret = ret + 1\n    return ret\n", "response_1": "def element_count(arr, target):\n    \"\"\"\n    Count the number of times the target element occurs in the array.\n    \"\"\"\n    ret = sfix(0)  # Initialize the return value as a fixed-point number\n    for item in arr:\n        # Secure comparison to check if item equals target\n        if item == target:\n            ret = ret + sfix(1)  # Increment the count securely\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_subarray", "response_0": "def is_subarray(sint c[M], sint d[N]):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    n = N\n    m = M\n    for i in range(n):\n        if m <= n - i:\n            flag = True\n            for j in range(m):\n                flag = flag and (d[i + j] == c[j])\n            if flag:\n                return True\n    return False\n", "response_1": "def is_subarray(c, d):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    for i in range(len(d)):\n        if len(c) <= len(d) - i:\n            flag = True\n            for j in range(len(c)):\n                flag = flag and d[i + j] == c[j]\n            if flag:\n                return True\n    return False\n\n# MP-SPDZ version\ndef is_subarray_mpspdz(c, d):\n    \"\"\"\n    Return whether the first array is a continuous subarray of the second array.\n    \"\"\"\n    n = len(d)\n    m = len(c)\n    for i in range(n):\n        flag = sint(1)  # Initialize flag as a secret integer\n        for j in range(m):\n            flag = flag & (d[i + j] == c[j])\n        if flag.reveal():  # Reveal the flag to check if it's true\n            return True\n    return False\n", "model_name": "deepseek-v2.5"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    for item in arr:\n        # Check if the item is equal to 5 or 7\n        is_5 = item == 5\n        is_7 = item == 7\n        if is_5.reveal() or is_7.reveal():\n            return sTrue\n    return sFalse\n", "response_1": "def exists_5_or_7(arr: cint):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == 5 or arr[i] == 7:\n            return 1\n    return 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "variance", "response_0": "from Compiler import types\n\ndef variance(arr: types.Array):\n    \"\"\"\n    Return the variance of the array. \n    \"\"\"\n    n = len(arr)\n    average = types.sfix(0)\n    variance = types.sfix(0)\n\n    # Calculate the average\n    for item in arr:\n        average += item / n\n\n    # Calculate the variance\n    for item in arr:\n        variance += (item - average) ** 2 / n\n\n    return variance\n", "response_1": "def variance(arr):\n    \"\"\"\n    Return the variance of the array.\n    \"\"\"\n    n = len(arr)\n    average = sfix(0)\n    variance = sfix(0)\n\n    # Calculate the average\n    for item in arr:\n        average += item / sfix(n)\n\n    # Calculate the variance\n    for item in arr:\n        variance += (item - average) ** 2 / sfix(n)\n\n    return variance\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_ascending", "response_0": "def is_ascending(arr):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    n = len(arr)\n    if n == 1:\n        return True\n\n    for i in range(n - 1):\n        if arr[i] >= arr[i + 1]:\n            return False\n\n    return True\n\n# MP-SPDZ specific code to handle secure computation\ndef secure_is_ascending(arr):\n    n = len(arr)\n    if n == 1:\n        return cint(1)  # Return True if the array length is 1\n\n    for i in range(n - 1):\n        # Compare elements securely\n        if arr[i] >= arr[i + 1]:\n            return cint(0)  # Return False if not strictly ascending\n\n    return cint(1)  # Return True if all elements are strictly ascending\n", "response_1": "from Compiler import types\n\ndef is_ascending(arr: types.Array):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    n = len(arr)\n    result = types.sint(1)  # Start with True\n\n    for i in range(n - 1):\n        condition = arr[i] >= arr[i + 1]\n        result = result & (~condition)\n\n    return result\n\n# Example usage:\n# arr = types.Array(5, types.sint)\n# arr[0], arr[1], arr[2], arr[3], arr[4] = 1, 2, 3, 4, 5\n# result = is_ascending(arr)\n# print_ln('Is ascending: %s', result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "xor_all", "response_0": "from Compiler import types\n\ndef xor_all(arr: types.Array):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n\n# Example usage in an MP-SPDZ program\ndef main():\n    # Assuming `arr` is an array of secret bits\n    arr = types.Array(10, types.sbit)\n    # Initialize `arr` with some values (0's and 1's)\n    # ...\n    result = xor_all(arr)\n    # Output the result\n    types.print_ln(\"XOR result: %s\", result)\n", "response_1": "def xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n\n# MP-SPDZ program\nfrom Compiler import mpc_math\n\ndef xor_all_mpspdz(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret = ret ^ arr[i]\n    return ret\n\n# Example usage in MP-SPDZ\n# arr = [sint(0), sint(1), sint(0), sint(1)]\n# result = xor_all_mpspdz(arr)\n# print_ln(\"Result: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "upper_bound", "response_0": "def upper_bound(arr, x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = sfloat.load_int(0)\n    found = sbool.load_int(0)\n\n    for i in range(n):\n        cond1 = arr[i] > x\n        cond2 = sbool.if_else(found, arr[i] - x < distance, 1)\n        cond = cond1 & cond2\n        ret = sint.if_else(cond, i, ret)\n        distance = sfloat.if_else(cond, arr[i] - x, distance)\n        found = sbool.if_else(cond, 1, found)\n\n    return ret\n", "response_1": "def upper_bound(arr, x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    n = len(arr)\n    ret = -1\n    distance = 0\n    found = False\n\n    for i in range(n):\n        cond = arr[i] > x\n        new_distance = cond.if_else(arr[i] - x, distance)\n        new_ret = cond.if_else(i, ret)\n        found = cond | found\n        distance = new_distance\n        ret = new_ret\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler import types\n\ndef square(x):\n    return x * x\n\ndef array_process_then_sum(arr, func):\n    n = len(arr)\n    processed_arr = [func(arr[i]) for i in range(n)]\n    sum = sum(processed_arr)\n    return sum\n\n# Example usage\narr = [types.sint(1), types.sint(2), types.sint(3)]\nresult = array_process_then_sum(arr, square)\nprint_ln(\"The sum is: %s\", result.reveal())\n", "response_1": "def func(x):\n    return x * 2\n\ndef array_process_then_sum(arr):\n    n = len(arr)\n    sum = sint(0)\n    for i in range(n):\n        arr[i] = func(arr[i])\n        sum = sum + arr[i]\n    return sum\n\n# Example usage\narr = [sint(1), sint(2), sint(3)]\nresult = array_process_then_sum(arr)\nprint_ln(\"Sum of processed array: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "average", "response_0": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sfix(0)  # Initialize sum as a secret-shared fixed-point number\n    length = len(arr)\n    for i in range(length):\n        sum = sum + arr[i]\n    ret = sum / sfix(length)  # Divide by the length, using sfix for fixed-point division\n    return ret\n", "response_1": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    length = len(arr)\n    for i in range(length):\n        sum = sum + arr[i]\n    ret = sum.reveal() / length  # Reveal the sum and compute the average\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_filter", "response_0": "def array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * predicator(arr[i])\n    return arr\n", "response_1": "def array_filter(arr, predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns True, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Use the MP-SPDZ conditional assignment\n        arr[i] = arr[i] * predicator(arr[i])\n    return arr\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_up", "response_0": "def sum_up(array):\n    \"\"\"\n    The sum_up function in MP-SPDZ\n    \"\"\"\n    sum = sint(0)  # Initialize sum as a secret integer\n    for num in array:\n        sum = sum + num  # Securely add each element to the sum\n    return sum\n", "response_1": "def sum_up(array):\n    \"\"\"\n    The sum_up function in MP-SPDZ\n    \"\"\"\n    sum = array[0]\n    for i in range(1, len(array)):\n        sum = sum + array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_to_zero", "response_0": "def negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(len(array)):\n        if array[i] >= 0:\n            continue\n        array[i] = 0\n    return array\n\n# Assuming array is a list of sint (secret integers)\ndef negative_to_zero_sint(array):\n    for i in range(len(array)):\n        # Check if the element is negative\n        is_negative = array[i] < 0\n        # Set the element to zero if it is negative\n        array[i] = is_negative.if_else(0, array[i])\n    return array\n", "response_1": "def negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    n = len(array)\n    for i in range(n):\n        # Check if the element is negative\n        is_negative = array[i] < 0\n        # Set the element to zero if it is negative\n        array[i] = is_negative.if_else(0, array[i])\n    return array\n\n# Example usage in MP-SPDZ program\n# Assuming `array` is a list of secret-shared integers\n# array = ...\n# result = negative_to_zero(array)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_only_positive_to_ten", "response_0": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    n = len(array)\n    for i in range(n):\n        if_statement = array[i] > 0\n        sum = if_statement * (sum + array[i]) + (1 - if_statement) * sum\n        if sum >= 10:\n            break\n    return sum\n", "response_1": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)  // Initialize sum as a secret integer\n    for i in range(len(array)):\n        if array[i] <= 0:\n            continue\n        if sum >= 10:\n            break\n        sum = sum + array[i]\n    return sum\n", "model_name": "deepseek-v2.5"}
{"test_name": "bubble_sort", "response_0": "def bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array in MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            # Compare arr[j] and arr[j+1]\n            if_statement = arr[j] >= arr[j+1]\n            # Swap arr[j] and arr[j+1] if arr[j] >= arr[j+1]\n            temp = arr[j]\n            arr[j] = if_statement * arr[j+1] + (1 - if_statement) * arr[j]\n            arr[j+1] = if_statement * temp + (1 - if_statement) * arr[j+1]\n    return arr\n", "response_1": "def bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array. \n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            # Compare arr[j] and arr[j+1]\n            if_statement = arr[j] >= arr[j+1]\n            # Swap arr[j] and arr[j+1] if the condition is true\n            temp = arr[j].if_else(arr[j+1], arr[j])\n            arr[j+1] = arr[j+1].if_else(arr[j], arr[j+1])\n            arr[j] = temp\n    return arr\n", "model_name": "deepseek-v2.5"}
