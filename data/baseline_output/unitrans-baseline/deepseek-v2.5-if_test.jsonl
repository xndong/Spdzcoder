{"test_name": "sin_or_cos", "response_0": "def sin_or_cos(x : sfix):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Check if x is nonnegative\n    condition = x >= 0.0\n    # Return sin(x) if condition is true, otherwise return cos(x)\n    return if_then_else(condition, sin(x), cos(x))\n", "response_1": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    if x >= 0:\n        return sin(x)\n    return cos(x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return input * (input < 0)\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return input * (input < 0)\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close: \n    their absolute difference is no larger than 1. \n    \"\"\"\n    # Compute the difference between a and b\n    diff = a - b\n    \n    # Compute the absolute value of the difference\n    abs_diff = sfix.abs(diff)\n    \n    # Check if the absolute difference is less than or equal to 1\n    result = sfix.leq(abs_diff, 1)\n    \n    return result\n", "response_1": "fromCompiler import *\n\ndef is_close(a, b):\n    difference = a - b\n    abs_difference = abs(difference)\n    return abs_difference <= 1\n\n# Example usage in an MP-SPDZ program\ndef main():\n    # Assuming a and b are secret shared inputs\n    a = sfix.get_input_from(0)\n    b = sfix.get_input_from(1)\n    \n    result = is_close(a, b)\n    \n    # Output the result\n    print_ln(\"The inputs are close: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "hardswish", "response_0": "fromCompiler import *\n\ndef hardswish(x):\n    \"\"\"\n    Hardswish function in MP-SPDZ.\n    \"\"\"\n    # Define the constants\n    minus_three = sfix(-3.0)\n    plus_three = sfix(3.0)\n    one_sixth = sfix(1.0 / 6.0)\n\n    # Compute the conditions\n    less_than_minus_three = x < minus_three\n    greater_than_three = x > plus_three\n    between_minus_three_and_three = ~(less_than_minus_three | greater_than_three)\n\n    # Compute the result based on the conditions\n    result = (less_than_minus_three * sfix(0.0)) + \\\n             (greater_than_three * x) + \\\n             (between_minus_three_and_three * (x * (x + plus_three) * one_sixth))\n\n    return result\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function implemented in MP-SPDZ.\n    \"\"\"\n    # Define the threshold values\n    threshold_neg = -3\n    threshold_pos = 3\n\n    # Compute the conditions for the hardswish function\n    cond_neg = x < threshold_neg\n    cond_pos = x > threshold_pos\n    cond_middle = 1 - cond_neg - cond_pos\n\n    # Compute the results for each condition\n    result_neg = 0\n    result_pos = x\n    result_middle = x * (x + 3) / 6\n\n    # Combine the results using the conditions\n    return cond_neg * result_neg + cond_pos * result_pos + cond_middle * result_middle\n", "model_name": "deepseek-v2.5"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    if_then(x > 6, lambda: x.assign(6))\n    if_then(x < -6, lambda: x.assign(-6))\n    return x\n", "response_1": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    # Define the clipping thresholds\n    upper_bound = 6\n    lower_bound = -6\n\n    # Perform the clipping operation\n    clipped_x = x.max(lower_bound).min(upper_bound)\n\n    return clipped_x\n", "model_name": "deepseek-v2.5"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    ret = 0\n    if x > 1:\n        ret = x\n    else:\n        if x < -1:\n            ret = x\n        else:\n            if x > 0:\n                ret = 1\n            else:\n                if x < 0:\n                    ret = -1\n                else:\n                    ret = 0\n    return ret\n", "response_1": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    ret = sfix(0)  # Initialize ret as a fixed-point number\n    if_statement = x > sfix(1)\n    elif1_statement = x < sfix(-1)\n    elif2_statement = x > sfix(0)\n    elif3_statement = x < sfix(0)\n\n    # Using conditional assignment\n    ret = if_statement.if_else(x, ret)\n    ret = elif1_statement.if_else(x, ret)\n    ret = elif2_statement.if_else(sfix(1), ret)\n    ret = elif3_statement.if_else(sfix(-1), ret)\n\n    return ret\n", "model_name": "deepseek-v2.5"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # Ensure a <= b\n    if_a_ge_b = a >= b\n    temp = if_a_ge_b * a + (1 - if_a_ge_b) * b\n    a = if_a_ge_b * b + (1 - if_a_ge_b) * a\n    b = temp\n\n    # Ensure b <= c\n    if_b_ge_c = b >= c\n    temp = if_b_ge_c * b + (1 - if_b_ge_c) * c\n    b = if_b_ge_c * c + (1 - if_b_ge_c) * b\n    c = temp\n\n    # Ensure a <= b\n    if_a_ge_b = a >= b\n    temp = if_a_ge_b * a + (1 - if_a_ge_b) * b\n    a = if_a_ge_b * b + (1 - if_a_ge_b) * a\n    b = temp\n\n    return b\n", "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    # Swap a and b if a >= b\n    cond1 = a >= b\n    temp1 = cond1 * (a - b)\n    a = a - temp1\n    b = b + temp1\n\n    # Swap b and c if b >= c\n    cond2 = b >= c\n    temp2 = cond2 * (b - c)\n    b = b - temp2\n    c = c + temp2\n\n    # Swap a and b if a >= b\n    cond3 = a >= b\n    temp3 = cond3 * (a - b)\n    a = a - temp3\n    b = b + temp3\n\n    return b\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicated_sin_or_cos", "response_0": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Assuming x and ind are in secure format (e.g., sfix for fixed-point numbers)\n    import mpc_math  # MP-SPDZ library for mathematical functions\n\n    # Compute sine and cosine using MP-SPDZ's trigonometric functions\n    sin_val = mpc_math.sin(x)\n    cos_val = mpc_math.cos(x)\n\n    # Use a conditional to return the appropriate value\n    result = ind.if_else(sin_val, cos_val)\n\n    return result\n", "response_1": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Assuming x and ind are already defined as MP-SPDZ types\n    if ind.reveal():\n        return sin(x)\n    return cos(x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    return if_else(x - 2 >= 0, x - 2, x)\n", "response_1": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    # Compute x-2\n    x_minus_2 = x - 2\n    \n    # Create a boolean condition for x_minus_2 >= 0\n    condition = x_minus_2 >= 0\n    \n    # Use the condition to select the appropriate result\n    result = condition * x_minus_2 + (1 - condition) * x\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    return max(0, min(x, 6))\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    zero = sfloat(0)\n    six = sfloat(6)\n    \n    less_than_zero = x < zero\n    greater_than_six = x > six\n    between_zero_and_six = ~(less_than_zero | greater_than_six)\n    \n    return (less_than_zero * zero) + (greater_than_six * six) + (between_zero_and_six * x)\n", "model_name": "deepseek-v2.5"}
{"test_name": "exp_slide", "response_0": "from Compiler import mpc_math\n\ndef exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    if_condition = x >= 0\n    exp_result = mpc_math.pow(mpc_math.e, x)\n    add_result = x + 1\n    return if_condition * exp_result + (1 - if_condition) * add_result\n", "response_1": "def exp_slide(x: sfix):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    if_then(x >= 0)\n    y = exp(x)\n    else_then()\n    y = x + 1\n    end_if()\n    return y\n", "model_name": "deepseek-v2.5"}
{"test_name": "pass_or_not", "response_0": "from Compiler import mpc_math\n\ndef pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Define the threshold for passing\n    threshold = 60\n\n    # Check if the score is greater than or equal to the threshold\n    passed = mpc_math.geq(score, threshold)\n\n    # Compute the adjusted score based on whether the student passed or not\n    adjusted_score = score * passed + 59 * (1 - passed)\n\n    return adjusted_score, passed\n", "response_1": "fromCompiler import *\n\ndef pass_or_not(score):\n    \"\"\"\n    Securely determine if a student has passed the exam.\n    If the score is >= 60, return the actual score and True.\n    Otherwise, return 59 and False.\n    \"\"\"\n    # Define the passing score as a secure integer\n    passing_score = sint(60)\n    \n    # Securely compare the score with the passing score\n    passed = score >= passing_score\n    \n    # Securely compute the adjusted score\n    adjusted_score = score * passed + (1 - passed) * 59\n    \n    # Return the adjusted score and the passing status\n    return adjusted_score, passed\n\n# Example usage in an MP-SPDZ program\nif __name__ == \"__main__\":\n    # Input the student's score securely\n    score = sint.get_input_from(0)\n    \n    # Call the function to determine pass or not\n    adjusted_score, passed = pass_or_not(score)\n    \n    # Output the results\n    adjusted_score.reveal().print_reg()\n    passed.reveal().print_reg()\n", "model_name": "deepseek-v2.5"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    else:\n        discriminant = b**2 - 4 * a * c\n        if discriminant > 0:\n            return 2\n        elif discriminant == 0:\n            return 1\n        else:\n            return 0\n", "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return cint(0)\n        else:\n            return cint(1)\n    discriminant = b**2 - 4 * a * c\n    if discriminant > 0:\n        return cint(2)\n    elif discriminant == 0:\n        return cint(1)\n    else:\n        return cint(0)\n\n# Example usage in MP-SPDZ\na = sint(5)  # Example values, replace with actual inputs\nb = sint(3)\nc = sint(1)\nresult = how_many_roots(a, b, c)\nprint_ln(\"Number of roots: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "elu", "response_0": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    if_else(x > 0, lambda: x, lambda: exp(x) - 1)\n", "response_1": "from Compiler import mpc_math\n\ndef elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    if_condition = x > 0\n    positive_branch = x\n    negative_branch = mpc_math.pow(mpc_math.exp(x), 1) - 1\n    return if_condition.if_else(positive_branch, negative_branch)\n", "model_name": "deepseek-v2.5"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function in MP-SPDZ\n    \"\"\"\n    return x * (x > 0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return x * x.greater_than_zero()\n", "model_name": "deepseek-v2.5"}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    return x.if_else(x, x * alpha)\n", "response_1": "from Compiler import mpc_math\n\ndef leaky_relu(x, alpha):\n    \"\"\"\n    Leaky ReLU function with a leaking factor alpha.\n    \"\"\"\n    # Secure comparison to check if x > 0\n    is_positive = x > 0\n    \n    # Secure conditional selection\n    return mpc_math.select(is_positive, x, x * alpha)\n", "model_name": "deepseek-v2.5"}
{"test_name": "max", "response_0": "fromCompiler import *\n\ndef max(a, b):\n    \"\"\"\n    Return the maximum value of the two secret-shared inputs.\n    \"\"\"\n    return (a + b + sint.abs(a - b)) / 2\n\n# Example usage in an MP-SPDZ program\na = sint(10)  # Example secret-shared value\nb = sint(15)  # Example secret-shared value\nresult = max(a, b)\nprint_ln(\"The maximum value is: %s\", result.reveal())\n", "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.max(b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Check if x > 1\n    cond1 = x > 1\n    # Check if x < -1\n    cond2 = x < -1\n    \n    # Compute the result based on the conditions\n    result = cond1.if_else(x - 1, cond2.if_else(-x - 1, 0))\n    \n    return result\n", "response_1": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Assuming x is a secure fixed-point number\n    result = sfix(0)\n\n    # Check if x > 1\n    cond1 = x > 1\n    result = cond1.if_else(x - 1, result)\n\n    # Check if x < -1\n    cond2 = x < -1\n    result = cond2.if_else(-x - 1, result)\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "rounded_kinetic_energy", "response_0": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    # Compute the kinetic energy\n    k = m * v**2 / 2\n    \n    # Convert the result to an integer by truncating the decimal part\n    k_int = k.floor()\n    \n    # Compute the fractional part\n    fractional_part = k - k_int\n    \n    # Determine if the fractional part is >= 0.5\n    should_round_up = (fractional_part >= 0.5)\n    \n    # Return the rounded value\n    return k_int + should_round_up\n", "response_1": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    k = m * v**2 / 2\n    k_int = k.floor()\n    return k_int + (k - k_int >= sf.Fraction(1, 2))\n", "model_name": "deepseek-v2.5"}
{"test_name": "danger_test", "response_0": "# Define origin and damage as secret integers\norigin = sint(input())\ndamage = sint(input())\n\n# Call the danger_test function\nresult = danger_test(origin, damage)\n\n# Output the result\nprint_ln(\"The situation is dangerous: %s\", result.reveal())\n", "response_1": "fromCompiler import *\n\ndef danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    return health_left <= 10\n\n# Example usage in an MP-SPDZ program\nif __name__ == \"__main__\":\n    # Assume origin and damage are secret-shared inputs\n    origin = sfix.get_input_from(0)  # Input from party 0\n    damage = sfix.get_input_from(1)  # Input from party 1\n    \n    # Call the danger_test function\n    is_dangerous = danger_test(origin, damage)\n    \n    # Output the result\n    is_dangerous.reveal_it().print_reg()\n", "model_name": "deepseek-v2.5"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    # MP-SPDZ does not have a direct boolean type, so we use a comparison to 1\n    result = (x + y) * ind + (x * y) * (1 - ind)\n    return result\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    # Assuming ind is a secret shared boolean value\n    result = sfix.if_else(ind, x + y, x * y)\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "median", "response_0": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array\n    sorted_arr = sorted(arr)\n    \n    ret = sfix(0)\n    if len(sorted_arr) % 2:\n        ret = sorted_arr[len(sorted_arr) // 2]\n    else:\n        ret = (sorted_arr[len(sorted_arr) // 2] + sorted_arr[len(sorted_arr) // 2 - 1]) / sfix(2)\n    \n    return ret\n", "response_1": "from Compiler import types\n\ndef median(arr: types.Array):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array\n    sorted_arr = sorted(arr)\n    \n    # Calculate the median\n    n = len(sorted_arr)\n    if n % 2 == 1:\n        ret = sorted_arr[n // 2]\n    else:\n        ret = (sorted_arr[n // 2] + sorted_arr[n // 2 - 1]) / 2\n    \n    return ret\n\n# Example usage in an MP-SPDZ program\narr = types.Array(5, types. sint)  # Example array of size 5 with secret integers\n# Initialize arr with some values\n# arr = ...\n\nmedian_value = median(arr)\nprint_ln(\"The median is: %s\", median_value.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "add_upto_10", "response_0": "fromCompiler import *\n\ndef add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    return smax(sum_ab, 10)\n\n# Example usage in an MP-SPDZ program\nif __name__ == \"__main__\":\n    # Assuming a and b are secret shared values\n    a = sfix(5)  # Example value for a\n    b = sfix(7)  # Example value for b\n    \n    result = add_upto_10(a, b)\n    print_ln(\"The result is: %s\", result.reveal())\n", "response_1": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum_ab = a + b\n    return (sum_ab > 10).if_else(10, sum_ab)\n", "model_name": "deepseek-v2.5"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    # Define constants\n    base_fare = 5\n    rate1 = 1.2\n    rate2 = 1.5\n    threshold1 = 5\n    threshold2 = 10\n\n    # Initialize the fare\n    fare = sfix(0)\n\n    # Compute the fare based on the miles\n    if_statement = m <= threshold1\n    fare = if_statement.if_else(base_fare, fare)\n\n    if_statement = (m > threshold1) * (m <= threshold2)\n    fare = if_statement.if_else(base_fare + rate1 * (m - threshold1), fare)\n\n    if_statement = m > threshold2\n    fare = if_statement.if_else(base_fare + rate1 * (threshold2 - threshold1) + rate2 * (m - threshold2), fare)\n\n    return fare\n", "response_1": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    # Base fare for the first 5 miles\n    base_fare = 5\n    \n    # Initialize the total fare\n    total_fare = sfix(0)\n    \n    # Check if the distance is less than or equal to 5 miles\n    @if_(m <= 5)\n    def _():\n        total_fare = base_fare\n    \n    # Check if the distance is between 5 and 10 miles\n    @elif_(5 < m <= 10)\n    def _():\n        total_fare = base_fare + 1.2 * (m - 5)\n    \n    # Check if the distance is more than 10 miles\n    @else_\n    def _():\n        total_fare = 11 + 1.5 * (m - 10)\n    \n    return total_fare\n", "model_name": "deepseek-v2.5"}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = x.floor()\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    x_int = sfix.floor(x)\n    difference = x - x_int\n    return if_else(difference < 0.5, x_int, x_int + 1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    if score >= 90:\n        return cint(4.0)\n    elif score >= 85:\n        return cint(3.6)\n    elif score >= 80:\n        return cint(3.3)\n    elif score >= 75:\n        return cint(3.0)\n    elif score >= 70:\n        return cint(2.6)\n    else:\n        return cint(2.3)\n", "response_1": "#include \"math.h\"\n\ndef gpa_calculator(score):\n    if score >= 90:\n        return 4.0\n    elif score >= 85:\n        return 3.6\n    elif score >= 80:\n        return 3.3\n    elif score >= 75:\n        return 3.0\n    elif score >= 70:\n        return 2.6\n    else:\n        return 2.3\n\ndef main():\n    score = sint(100)  // Example input, replace with actual input\n    gpa = gpa_calculator(score)\n    print_ln(\"The GPA is: %s\", gpa)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sign", "response_0": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sfix(0)\n    one = sfix(1)\n    neg_one = sfix(-1)\n\n    if_x_eq_zero = x == zero\n    if_x_gt_zero = x > zero\n    if_x_lt_zero = x < zero\n\n    result = sfix.if_else(if_x_eq_zero, zero, \n                          sfix.if_else(if_x_gt_zero, one, \n                                       sfix.if_else(if_x_lt_zero, neg_one, zero)))\n    return result\n", "response_1": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = sint(0)\n    one = sint(1)\n    neg_one = sint(-1)\n\n    is_zero = x == zero\n    is_positive = x > zero\n    is_negative = x < zero\n\n    return (is_zero * zero) + (is_positive * one) + (is_negative * neg_one)\n", "model_name": "deepseek-v2.5"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    # Compare a and b\n    condition = a <= b\n    \n    # Compute the sum and difference\n    sum_result = a + b\n    diff_result = a - b\n    \n    # Use the condition to select the result\n    result = condition * sum_result + (1 - condition) * diff_result\n    \n    return result\n", "response_1": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    # Compare a and b\n    condition = a <= b\n    \n    # Compute the sum and the difference\n    sum_result = a + b\n    diff_result = a - b\n    \n    # Return the appropriate result based on the condition\n    return condition.if_else(sum_result, diff_result)\n", "model_name": "deepseek-v2.5"}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ.\n    \"\"\"\n    return flip_bit ^ (control_bit & (flip_bit ^ 1))\n", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ.\n    \"\"\"\n    # XOR operation to flip the flip_bit if control_bit is 1\n    return (control_bit * (1 - flip_bit)) + ((1 - control_bit) * flip_bit)\n", "model_name": "deepseek-v2.5"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # In MP-SPDZ, we use the sfix or sint data types for fixed-point or integer operations\n    # Here, we assume y is of type sfix or sint\n    # We use the lt (less than) operation to compare y with 0\n    # The select operation is used to choose between y+1 and y based on the comparison result\n    return select(y < 0, y + 1, y)\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Check if y is negative\n    is_negative = y < 0\n    \n    # Compute y+1\n    y_plus1 = y + 1\n    \n    # Select y+1 if y is negative, otherwise select y\n    result = sfix.if_else(is_negative, y_plus1, y)\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler import types\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] & x[1] == y[1]\n    \n    # Check if any two vertices are the same\n    same_vertices = same(a, b) | same(a, c) | same(a, d) | same(b, c) | same(b, d) | same(c, d)\n    \n    # If any two vertices are the same, return False\n    if_same = types.sint.if_else(same_vertices, 0, 1)\n    \n    # Check the parallelogram conditions\n    condition1 = (a[0] + b[0] == c[0] + d[0]) & (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) & (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) & (a[1] + d[1] == b[1] + c[1])\n    \n    # Combine the conditions\n    is_parallelogram = condition1 | condition2 | condition3\n    \n    # Return the result, considering the case where vertices are the same\n    return types.sint.if_else(if_same, 0, is_parallelogram)\n", "response_1": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n    \n    return (a[0] + b[0] == c[0] + d[0] and a[1] + b[1] == c[1] + d[1]) or \\\n           (a[0] + c[0] == b[0] + d[0] and a[1] + c[1] == b[1] + d[1]) or \\\n           (a[0] + d[0] == b[0] + c[0] and a[1] + d[1] == b[1] + c[1])\n\n# Assuming a, b, c, d are private inputs in MP-SPDZ\na = [sint(x) for x in get_private_input()]\nb = [sint(x) for x in get_private_input()]\nc = [sint(x) for x in get_private_input()]\nd = [sint(x) for x in get_private_input()]\n\nresult = is_a_parallelogram(a, b, c, d)\nprint_ln(\"The four vertices %s, %s, %s, %s %s form a parallelogram.\", a, b, c, d, result)\n", "model_name": "deepseek-v2.5"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.min(b)\n", "model_name": "deepseek-v2.5"}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sint(0)\n\n    def legal(a, b):\n        return (sint(0) <= a) * (a <= sint(7)) * (sint(0) <= b) * (b <= sint(7))\n\n    counter = counter + (sint(1) if legal(x + sint(1), y + sint(2)) else sint(0))\n    counter = counter + (sint(1) if legal(x - sint(1), y + sint(2)) else sint(0))\n    counter = counter + (sint(1) if legal(x + sint(1), y - sint(2)) else sint(0))\n    counter = counter + (sint(1) if legal(x - sint(1), y - sint(2)) else sint(0))\n    counter = counter + (sint(1) if legal(x + sint(2), y + sint(1)) else sint(0))\n    counter = counter + (sint(1) if legal(x - sint(2), y + sint(1)) else sint(0))\n    counter = counter + (sint(1) if legal(x + sint(2), y - sint(1)) else sint(0))\n    counter = counter + (sint(1) if legal(x - sint(2), y - sint(1)) else sint(0))\n\n    return counter\n", "response_1": "def choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sfix(0)\n\n    def legal(a, b):\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n\n    return counter\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    comparison = sum_ab > diff_ab\n    result = comparison.if_else(sum_ab, diff_ab)\n    return result\n", "response_1": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    max_val = smax(sum_ab, diff_ab)\n    return max_val\n", "model_name": "deepseek-v2.5"}
