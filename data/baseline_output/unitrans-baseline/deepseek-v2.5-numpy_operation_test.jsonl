{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler import types\n\nstart = types.int(0)\nend = types.int(99)\nnum = types.int(10)\n\n# Calculate the step size\nstep = (end - start) / (num - 1)\n\n# Initialize an array to store the linspace values\na = [types.int(start + i * step) for i in range(num)]\n", "response_1": "from Compiler import types\n\n# Initialize the program\nprogram = types.Program()\n\n# Define the range parameters\nstart = types.sint(0)\nend = types.sint(99)\nnum = 10\n\n# Calculate the step size\nstep = (end - start) / types.sint(num - 1)\n\n# Create the array\na = [start + i * step for i in range(num)]\n\n# Print the array (for debugging purposes)\nfor i in range(num):\n    print_ln('%s', a[i].reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "more_positive", "response_0": "from Compiler import mpc_math\nfrom Compiler import types\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    signs = [mpc_math.sign(x) for x in arr]\n    count = sum(signs)\n    return count > 0\n", "response_1": "from Compiler import mpc_math\n\ndef more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    # Convert the array to MP-SPDZ secure types\n    arr = [sint(x) for x in arr]\n    \n    # Compute the sign of each element\n    signs = [mpc_math.sign(x) for x in arr]\n    \n    # Sum the signs\n    count = sum(signs)\n    \n    # Check if the sum is greater than 0\n    return count > 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "select", "response_0": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    assert len(ind) == len(a) == len(b), \"All input arrays must have the same length\"\n    result = [None] * len(ind)\n    for i in range(len(ind)):\n        result[i] = a[i] + (b[i] - a[i]) * ind[i]\n    return result\n\n# Example usage in MP-SPDZ\nfrom Compiler import types\n\n# Define the input arrays as secret fixed-point numbers\nind = types.sfix.Array(10)  # Example: 10 elements\na = types.sfix.Array(10)   # Example: 10 elements\nb = types.sfix.Array(10)   # Example: 10 elements\n\n# Populate the arrays with secret data (not shown here)\n\n# Call the select function\nresult = select(ind, a, b)\n\n# The result will be an array of selected elements\n", "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are secret-shared float data.\n    \"\"\"\n    # Ensure the inputs are of the same length\n    assert len(ind) == len(a) == len(b), \"Input arrays must have the same length\"\n    \n    result = Array(len(a), sfloat)\n    \n    for i in range(len(a)):\n        # Use a conditional to select between a[i] and b[i]\n        result[i] = sfloat.if_else(ind[i], a[i], b[i])\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return y * (y > 0)\n", "response_1": "def relu_array(y_array):\n    \"\"\"\n    Compute the ReLU function for an array.\n    \"\"\"\n    return [relu(y) for y in y_array]\n", "model_name": "deepseek-v2.5"}
{"test_name": "cost_matrix", "response_0": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix in MP-SPDZ.\n    \"\"\"\n    # Assume profit_matrix is a 2D array of secret integers (sint)\n    n_rows = len(profit_matrix)\n    n_cols = len(profit_matrix[0])\n\n    # Find the maximum value in the profit matrix\n    max_value = profit_matrix[0][0]\n    for i in range(n_rows):\n        for j in range(n_cols):\n            max_value = max(max_value, profit_matrix[i][j])\n\n    # Create an offset matrix with the same shape as profit_matrix\n    offset_matrix = [[max_value for _ in range(n_cols)] for _ in range(n_rows)]\n\n    # Compute the cost matrix\n    cost_matrix = [[offset_matrix[i][j] - profit_matrix[i][j] for j in range(n_cols)] for i in range(n_rows)]\n\n    return cost_matrix\n", "response_1": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    # Assuming profit_matrix is a matrix of type sfix or sint\n    matrix_shape = profit_matrix.sizes()\n    max_value = profit_matrix.max()\n    offset_matrix = sfix.Matrix(matrix_shape[0], matrix_shape[1])\n    offset_matrix.assign_all(max_value)\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_zeros", "response_0": "n = 10\na = sint.Array(n)\na.assign(0)\n", "response_1": "n = 10\na = [sint(0) for _ in range(n)]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array of fixed-point numbers\n    # and row_index is a secure integer.\n    array = ndarray[row_index]\n    return array\n", "response_1": "from Compiler import mpc_math\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array in MP-SPDZ format\n    # and row_index is a secure integer or clear integer\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    return [sint() for _ in range(n)]\n", "response_1": "def zeros(n):\n    return [sint() for _ in range(n)]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_slicing_stride", "response_0": "from Compiler import mpc_math\n\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays.\n    Collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    # Determine the lengths of the arrays\n    lenA = len(ndarrayA)\n    lenB = len(ndarrayB)\n    \n    # Collect even index elements from the first array\n    viewA = [ndarrayA[i] for i in range(0, lenA, 2)]\n    \n    # Collect odd index elements from the second array\n    viewB = [ndarrayB[i] for i in range(1, lenB, 2)]\n    \n    # Concatenate the two lists\n    array = viewA + viewB\n    \n    return array\n", "response_1": "def array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    # Determine the lengths of the arrays\n    lenA = len(ndarrayA)\n    lenB = len(ndarrayB)\n    \n    # Collect even index elements from the first array\n    viewA = []\n    for i in range(0, lenA, 2):\n        viewA.append(ndarrayA[i])\n    \n    # Collect odd index elements from the second array\n    viewB = []\n    for i in range(1, lenB, 2):\n        viewB.append(ndarrayB[i])\n    \n    # Concatenate the two lists\n    array = viewA + viewB\n    \n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "QR_decomposition", "response_0": "def QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    from Compiler import mpc_math\n    q, _ = mpc_math.qr(mat)\n    return q\n", "response_1": "def QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    n, m = shape(mat)\n    Q = matrix(n, m)\n    R = matrix(m, m)\n\n    for j in range(m):\n        v = mat[0:, j]\n        for i in range(j):\n            R[i][j] = dot_product(Q[0:, i], mat[0:, j])\n            v = v - R[i][j] * Q[0:, i]\n        R[j][j] = sqrt(dot_product(v, v))\n        Q[0:, j] = v / R[j][j]\n\n    return Q\n", "model_name": "deepseek-v2.5"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    min_diff = array[0] - value\n    min_index = 0\n\n    for i in range(1, len(array)):\n        diff = array[i] - value\n        min_diff, min_index = (diff, i) if diff < min_diff else (min_diff, min_index)\n\n    return min_index\n", "response_1": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    min_diff = None\n    min_index = 0\n\n    for i in range(len(array)):\n        diff = abs(array[i] - value)\n        if min_diff is None or diff < min_diff:\n            min_diff = diff\n            min_index = i\n\n    return min_index\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_simple_row", "response_0": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are already defined as MP-SPDZ matrices\n    # Concatenate the two matrices along axis 0 (rows)\n    array = ndarrayA.concat(ndarrayB)\n    return array\n", "response_1": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Get the dimensions of the input arrays\n    rowsA, colsA = len(ndarrayA), len(ndarrayA[0])\n    rowsB, colsB = len(ndarrayB), len(ndarrayB[0])\n\n    # Initialize the result array with zeros\n    result = [[0 for _ in range(colsA)] for _ in range(rowsA + rowsB)]\n\n    # Copy elements from ndarrayA to the result array\n    for i in range(rowsA):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n\n    # Copy elements from ndarrayB to the result array\n    for i in range(rowsB):\n        for j in range(colsB):\n            result[rowsA + i][j] = ndarrayB[i][j]\n\n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    array = sfix.Array(len(ndarray))\n    for i in range(len(ndarray)):\n        array[i] = ndarray[i]\n    return array\n", "response_1": "def array_copy(ndarray):\n    array = ndarray.same_shape()\n    array.assign(ndarray)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "max_pooling", "response_0": "from Compiler import mpc_math\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling.\n    \"\"\"\n    # Determine the output shape\n    out_shape = (x.shape[0], x.shape[1] / stride, x.shape[2] / stride)\n    out = sfix.Array(out_shape[0], out_shape[1], out_shape[2])\n    \n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                # Extract the current window\n                window = x[b, i:i+stride, j:j+stride]\n                # Compute the max of the window\n                max_val = mpc_math.max(window)\n                # Store the result in the output array\n                out[b, i / stride, j / stride] = max_val\n    \n    return out\n", "response_1": "from Compiler import mpc_math\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling in MP-SPDZ.\n    \"\"\"\n    batch_size, height, width = x.shape\n    out_height = height // stride\n    out_width = width // stride\n    out = sfix.Matrix(batch_size, out_height, out_width)\n\n    for b in range(batch_size):\n        for i in range(0, height, stride):\n            for j in range(0, width, stride):\n                window = x[b, i:i+stride, j:j+stride]\n                max_val = mpc_math.max(window.ravel())\n                out[b, i // stride, j // stride] = max_val\n    return out\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_reshape", "response_0": "from Compiler import types\n\n# Define the array dimensions\nrows = 3\ncols = 5\n\n# Create a 2D array with values from 0 to 14\na = types.Matrix(rows, cols, types.sint)\nfor i in range(rows):\n    for j in range(cols):\n        a[i][j] = types.sint(i * cols + j)\n\n# Print the array (for debugging purposes)\na.print_reveal_nested()\n", "response_1": "from Compiler import types\n\n# Define the array\na = types.Matrix(3, 5, types.sint)\n\n# Initialize the array with values from 0 to 14\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = types.sint(i * 5 + j)\n\n# At this point, 'a' is a 3x5 matrix initialized with values from 0 to 14\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_simple_column", "response_0": "from Compiler import mpc_math\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are already secret-shared in MP-SPDZ\n    # Get the number of rows and columns of the input arrays\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n    \n    # Initialize the result array with the appropriate size\n    result = [[0 for _ in range(colsA + colsB)] for _ in range(rows)]\n    \n    # Copy elements from ndarrayA to the result array\n    for i in range(rows):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from ndarrayB to the result array\n    for i in range(rows):\n        for j in range(colsB):\n            result[i][j + colsA] = ndarrayB[i][j]\n    \n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are already defined as MP-SPDZ arrays\n    # and have the same number of rows\n    num_rows = len(ndarrayA)\n    num_cols_A = len(ndarrayA[0])\n    num_cols_B = len(ndarrayB[0])\n    \n    # Initialize the result array with the correct dimensions\n    result = [[None for _ in range(num_cols_A + num_cols_B)] for _ in range(num_rows)]\n    \n    # Copy elements from ndarrayA\n    for i in range(num_rows):\n        for j in range(num_cols_A):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from ndarrayB\n    for i in range(num_rows):\n        for j in range(num_cols_B):\n            result[i][j + num_cols_A] = ndarrayB[i][j]\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "from Compiler import types\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array of sfix or sint type\n    array = ndarray.get_column(column_index)\n    return array\n", "response_1": "from Compiler import mpc_math\nfrom Compiler import matrix\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D matrix in MP-SPDZ\n    # and column_index is a secret-shared integer\n    array = matrix.get_column(ndarray, column_index)\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    n = len(array)\n    diag = Array(n, sfix)\n    for i in range(n):\n        diag[i] = array[i][i]\n    return diag\n", "response_1": "from Compiler import types\n\ndef diag(array):\n    # Assuming array is a 2D array of sint\n    n = len(array)\n    diag = [array[i][i] for i in range(n)]\n    return diag\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_concat_special", "response_0": "def array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1. \n    Collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type sint\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n\n    # Collect even columns from ndarrayA\n    even_cols_A = []\n    for col in range(0, colsA, 2):\n        even_cols_A.append([ndarrayA[row][col] for row in range(rows)])\n\n    # Collect odd columns from ndarrayB\n    odd_cols_B = []\n    for col in range(1, colsB, 2):\n        odd_cols_B.append([ndarrayB[row][col] for row in range(rows)])\n\n    # Concatenate the collected columns\n    result = []\n    for row in range(rows):\n        new_row = []\n        for col in even_cols_A:\n            new_row.append(col[row])\n        for col in odd_cols_B:\n            new_row.append(col[row])\n        result.append(new_row)\n\n    return result\n", "response_1": "from Compiler import mpc_math\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are already in the MP-SPDZ format\n    # and have the same number of rows\n\n    # Get the number of rows and columns\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n\n    # Collect all the even columns from the first array\n    viewA = [[ndarrayA[i][j] for j in range(0, colsA, 2)] for i in range(rows)]\n\n    # Collect all the odd columns from the second array\n    viewB = [[ndarrayB[i][j] for j in range(1, colsB, 2)] for i in range(rows)]\n\n    # Concatenate viewA and viewB along axis 1\n    array = [viewA[i] + viewB[i] for i in range(rows)]\n\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_arange", "response_0": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-D array with evenly spaced values.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Determine the number of elements in the array\n    num_elements = (stop - start + step - 1) // step\n\n    # Create an array of the specified size\n    array = sint.Array(num_elements)\n\n    # Fill the array with values\n    for i in range(num_elements):\n        array[i] = start + i * step\n\n    return array\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-d array similar to numpy.arange in MP-SPDZ.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Determine the number of elements in the array\n    size = (stop - start + step - 1) // step\n\n    # Initialize an empty array\n    array = Array(size, sint)\n\n    # Fill the array with values\n    for i in range(size):\n        array[i] = start + i * step\n\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_eye_2", "response_0": "from Compiler import mpc_math\n\nm = 3\nn = 5\n\n# Initialize a zero matrix of size (m, n)\na = [ [sfix(0) for _ in range(n)] for _ in range(m) ]\n\n# Set the diagonal elements to 1\nfor i in range(min(m, n)):\n    a[i][i] = sfix(1)\n", "response_1": "from Compiler import types\n\ndef create_non_square_diagonal_matrix(m, n):\n    # Initialize a 2-dimensional array with zeros\n    a = types.Matrix(m, n, types.sint)\n    \n    # Set the diagonal elements to 1\n    for i in range(min(m, n)):\n        a[i][i] = 1\n    \n    return a\n\n# Example usage\nm = 3\nn = 5\nmatrix = create_non_square_diagonal_matrix(m, n)\n", "model_name": "deepseek-v2.5"}
{"test_name": "third_smallest", "response_0": "fromCompiler import *\n\ndef third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Sort the array in ascending order\n    sorted_arr = Array(len(arr), sint)\n    sorted_arr.assign(arr)\n    sorted_arr.sort()\n    \n    # Return the third smallest element\n    return sorted_arr[2]\n\n# Example usage\nif __name__ == \"__main__\":\n    arr = Array(5, sint)\n    arr.input_from(0)  # Assuming the array is input by party 0\n    result = third_smallest(arr)\n    print_ln(\"The third smallest element is: %s\", result.reveal())\n", "response_1": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Sort the array\n    sorted_arr = sfix.Array(len(arr))\n    for i in range(len(arr)):\n        sorted_arr[i] = arr[i]\n    sorted_arr.sort()\n    \n    # Return the third smallest element\n    return sorted_arr[2]\n\n# Example usage\n# arr = sfix.Array(5)\n# arr.input_from(0)  # Assuming the array is input from party 0\n# result = third_smallest(arr)\n# print_ln(\"The third smallest element is: %s\", result.reveal())\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "fromCompiler import Array, sint\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array of sint (secret integers)\n    # and row_index is a secret integer.\n    rows = len(ndarray)\n    cols = len(ndarray[0]) if rows > 0 else 0\n    \n    # Create a new array to hold the result\n    result = Array(cols, sint)\n    \n    # Index the i-th row\n    for j in range(cols):\n        result[j] = ndarray[row_index][j]\n    \n    return result\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array in MP-SPDZ\n    # row_index should be an integer or a secret shared integer\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = Array(n, sfix)\nfor i in range(n):\n    a[i] = i\n", "response_1": "from Compiler import types\n\nn = 10\na = types.sint.Array(n)\na.assign(types.sint.range(n))\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "fromCompiler(\"some_compiler\")\n\ndef main():\n    # Assuming ndarray is a 2-D array of secret-shared values\n    ndarray = [[sfix(1), sfix(2), sfix(3)], [sfix(4), sfix(5), sfix(6)]]\n    row_index = sint(0)\n    \n    result = array_dimensional_indexing(ndarray, row_index)\n    \n    # Output the result\n    print_ln(\"Selected row: %s\", result)\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2-D array in MP-SPDZ\n    rows = len(ndarray)\n    cols = len(ndarray[0])\n    \n    # Initialize an array to store the result\n    result = Array(cols, sint)\n    \n    # Extract the i-th row\n    for j in range(cols):\n        result[j] = ndarray[row_index][j]\n    \n    return result\n", "model_name": "deepseek-v2.5"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler import types\n\n# Define the array length\narray_length = 5\n\n# Create a list of clear integers\na_l = [0, 10, 20, 30, 40]\n\n# Convert the list to an array of secret integers in MP-SPDZ\na = types.Array(array_length, types.sint)\nfor i in range(array_length):\n    a[i] = types.sint(a_l[i])\n", "response_1": "a_l = [0, 10, 20, 30, 40]\na = sfix.Array(5)\nfor i in range(5):\n    a[i] = sfix(a_l[i])\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_reshape", "response_0": "from Compiler import mpc_math\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a matrix.\n    \"\"\"\n    # Assuming ndarray is already a Matrix in MP-SPDZ\n    reshaped_array = ndarray.reshape(m, n)\n    return reshaped_array\n", "response_1": "def array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a secret-shared array.\n    \"\"\"\n    # Assuming ndarray is already a secret-shared array in MP-SPDZ\n    # Reshape the array to the specified dimensions (m, n)\n    reshaped_array = ndarray.reshape(m, n)\n    return reshaped_array\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_ones", "response_0": "n = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = sint(1)\n", "response_1": "n = 10\na = Array(n, sint)\na = a.fill(1)\n", "model_name": "deepseek-v2.5"}
{"test_name": "set_one_to_zero", "response_0": "from Compiler import types\n\ndef set_one_to_zero(y: types.sint):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    # Create a mask where elements equal to 1 are True\n    mask = y == 1\n    # Use the mask to set the elements to 0\n    y = y * (1 - mask)\n    return y\n", "response_1": "from Compiler import mpc_math\n\ndef set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    # Create a secure array of booleans where each element is True if y[i] == 1\n    is_one = [y_i == 1 for y_i in y]\n    \n    # Use the secure array to set elements to zero\n    for i in range(len(y)):\n        y[i] = y[i] * (1 - is_one[i])\n    \n    return y\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_eye", "response_0": "n = 10\na = [[sfix(0) for _ in range(n)] for _ in range(n)]\n\nfor i in range(n):\n    a[i][i] = sfix(1)\n", "response_1": "n = 10\na = Array(n, Array(n, sfix))\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = 1\n        else:\n            a[i][j] = 0\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_diag", "response_0": "from Compiler import mpc_math\n\n# Define the list a_l\na_l = [1, 3, 5, 2, 4, 6]\n\n# Convert the list to a diagonal matrix\na = mpc_math.diag(a_l)\n", "response_1": "fromCompiler import *\n\n# Define the list a_l\na_l = [1, 3, 5, 2, 4, 6]\n\n# Convert the list to an array of integers\na_l = Array(len(a_l), sint, a_l)\n\n# Create a square matrix with zeros\nn = len(a_l)\na = Matrix(n, n, sint)\n\n# Fill the diagonal with the elements from a_l\nfor i in range(n):\n    a[i][i] = a_l[i]\n", "model_name": "deepseek-v2.5"}
{"test_name": "np_advanced_integer_indexing", "response_0": "def integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an MP-SPDZ array from an integer array.\n    \"\"\"\n    n = len(indices)\n    ret_array = Array(n, sint)\n    for i in range(n):\n        ret_array[i] = array[indices[i]]\n    return ret_array\n", "response_1": "def integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an MP-SPDZ array from an integer array.\n    \"\"\"\n    # Convert indices to an MP-SPDZ array\n    indices = sfix.Array(len(indices))(*indices)\n    \n    # Initialize the return array\n    ret_array = sfix.Array(len(indices))\n    \n    # Perform the indexing\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    \n    return ret_array\n", "model_name": "deepseek-v2.5"}
