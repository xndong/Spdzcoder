{"test_name": "move_to_end", "response_0": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Extract the element at the given index\n    element = arr[index]\n    \n    # Create a new array without the element at the given index\n    new_array = Array(len(arr) - 1, arr.value_type)\n    for i in range(len(arr)):\n        if i < index:\n            new_array[i] = arr[i]\n        elif i > index:\n            new_array[i - 1] = arr[i]\n    \n    # Append the element to the end of the new array\n    new_array.append(element)\n    \n    return new_array\n", "response_1": "from Compiler import types\n\ndef move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array excluding the element at the given index\n    new_array = types.Array(len(arr) - 1, arr.value_type)\n    for i in range(len(arr)):\n        if i < index:\n            new_array[i] = arr[i]\n        elif i > index:\n            new_array[i - 1] = arr[i]\n    \n    # Append the element at the given index to the end of the new array\n    new_array.append(arr[index])\n    \n    return new_array\n", "model_name": "deepseek-v3"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    # Initialize the two largest elements\n    largest = arr[0]\n    second_largest = arr[1]\n    \n    # Swap if necessary to ensure largest is greater than second_largest\n    comparison = largest < second_largest\n    largest = comparison * second_largest + (1 - comparison) * largest\n    second_largest = comparison * largest + (1 - comparison) * second_largest\n    \n    # Iterate through the array to find the two largest elements\n    for i in range(2, len(arr)):\n        # Check if the current element is larger than the second largest\n        comparison = arr[i] > second_largest\n        # Update the second largest if necessary\n        second_largest = comparison * arr[i] + (1 - comparison) * second_largest\n        # Check if the current element is larger than the largest\n        comparison = arr[i] > largest\n        # Update the largest and second largest if necessary\n        temp = largest\n        largest = comparison * arr[i] + (1 - comparison) * largest\n        second_largest = comparison * temp + (1 - comparison) * second_largest\n    \n    return second_largest\n", "response_1": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    # Initialize the first two elements as candidates for the largest and second largest\n    largest = arr[0]\n    second_largest = arr[1]\n    \n    # Iterate through the array starting from the third element\n    for i in range(2, len(arr)):\n        # If the current element is greater than the largest or second largest\n        if arr[i] > largest or arr[i] > second_largest:\n            # Determine which one to replace\n            if largest < second_largest:\n                largest = arr[i]\n            else:\n                second_largest = arr[i]\n    \n    # Return the smaller of the two candidates\n    return second_largest if largest > second_largest else largest\n", "model_name": "deepseek-v3"}
{"test_name": "exists_true", "response_0": "from Compiler import types\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    # Initialize the result as False\n    ret = types.sint(0)\n    \n    # Iterate over the array and perform a logical OR operation\n    for val in arr:\n        ret = ret | val\n    \n    # Return the result (1 if any element is True, 0 otherwise)\n    return ret\n", "response_1": "from Compiler import types\n\ndef exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    # Initialize the result as False (0)\n    ret = types.sint(0)\n    \n    # Iterate over the array and OR the result with each element\n    for element in arr:\n        ret = ret | element\n    \n    # Return the result\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_indicator", "response_0": "from Compiler.library import *\n\ndef array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), predicator.value_type())\n    @for_range(len(arr))\n    def _(i):\n        ret[i] = predicator(arr[i])\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = Array(len(arr), predicator.value_type)\n    @for_range(len(arr))\n    def _(i):\n        ret[i] = predicator(arr[i])\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    # Ensure the vectors are of the same length\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    \n    # Initialize the result to 0\n    result = sfix(0)\n    \n    # Compute the inner product\n    for i in range(len(vec1)):\n        result += vec1[i] * vec2[i]\n    \n    return result\n", "response_1": "from Compiler import types\n\ndef inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret-shared arrays.\n    \"\"\"\n    # Ensure both vectors are of the same length\n    assert len(vec1) == len(vec2), \"Vectors must be of the same length\"\n    \n    # Multiply corresponding elements in the vectors\n    product = [x * y for x, y in zip(vec1, vec2)]\n    \n    # Sum the products to get the inner product\n    summation = types.sint(0)\n    for p in product:\n        summation += p\n    \n    return summation\n", "model_name": "deepseek-v3"}
{"test_name": "array_shift_2", "response_0": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, sint)  # Create an array of the same size as 'a'\n    \n    for i in range(n):\n        shifted_array[i] = a[(i - 1) % n]\n    \n    return shifted_array\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    array = Array(n, sint)\n    for i in range(n):\n        array[i] = a[(i-1) % n]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater_than_scalar", "response_0": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = Array(len(arr), sbool)\n    for i in range(len(arr)):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "count_rises_2", "response_0": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    flag = sint.Array(n - 1)\n    \n    @for_range(n - 1)\n    def _(i):\n        flag[i] = (arr[i] < arr[i + 1]).if_else(1, 0)\n    \n    count = sint(0)\n    @for_range(n - 1)\n    def _(i):\n        count.iadd(flag[i])\n    \n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)  # Initialize the count as a secure integer\n\n    for i in range(n - 1):\n        # Compare arr[i] and arr[i+1] securely\n        flag = arr[i] < arr[i + 1]\n        # Add the result to the count\n        count += flag\n\n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    result = Array(len(arr), sint)\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            result[i] = arr[i] - 1\n        else:\n            result[i] = arr[i] + 1\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    # Check if a is zero\n    is_a_zero = a == 0\n    \n    # If a is zero, check if b is zero\n    is_b_zero = b == 0\n    \n    # If a is zero and b is zero, return 0\n    # Else if a is zero, return 1\n    result_if_a_zero = 0 if is_b_zero else 1\n    \n    # If a is not zero, compute the discriminant\n    discriminant = b * b - 4 * a * c\n    \n    # Check if discriminant is greater than zero\n    is_discriminant_positive = discriminant > 0\n    \n    # Check if discriminant is zero\n    is_discriminant_zero = discriminant == 0\n    \n    # If discriminant is positive, return 2\n    # Else if discriminant is zero, return 1\n    # Else return 0\n    result_if_a_not_zero = 2 if is_discriminant_positive else (1 if is_discriminant_zero else 0)\n    \n    # Return the appropriate result based on whether a is zero\n    result = result_if_a_zero if is_a_zero else result_if_a_not_zero\n    \n    return result\n", "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    if a == 0:\n        return if_else(b == 0, 0, 1)\n    else:\n        discriminant = b * b - 4 * a * c\n        return if_else(discriminant > 0, 2, if_else(discriminant == 0, 1, 0))\n", "model_name": "deepseek-v3"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize a list to store the flags\n    flag = Array(len(arr), sint)\n    \n    # Apply the predicator to each element and store the result in the flag array\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    \n    # Sum up the flags to get the count of elements that satisfy the predicator\n    summmation = sum(flag)\n    \n    return summmation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize a list to store the flags\n    flag = Array(len(arr), sint)\n    \n    # Iterate over the array and set the flag based on the predicator\n    for i in range(len(arr)):\n        flag[i] = predicator(arr[i])\n    \n    # Sum the flags to get the count of elements that satisfy the predicator\n    summation = sum(flag)\n    \n    return summation\n", "model_name": "deepseek-v3"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    # Initialize the result as a secret-shared zero\n    result = sfix(0)\n    \n    # Iterate over the pairs of elements\n    for x, y in zip(arr1, arr2):\n        # Multiply the elements and add to the result\n        result += x * y\n    \n    # Return the final sum\n    return result\n", "response_1": "from Compiler import types\n\ndef traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    # Ensure the inputs are of the same length\n    assert len(arr1) == len(arr2), \"Input arrays must be of the same length\"\n\n    # Initialize the sum to zero\n    total_sum = types.sint(0)\n\n    # Iterate over the pairs of elements\n    for i in range(len(arr1)):\n        # Multiply the corresponding elements\n        product = arr1[i] * arr2[i]\n        # Add the product to the total sum\n        total_sum += product\n\n    return total_sum\n", "model_name": "deepseek-v3"}
{"test_name": "array_round", "response_0": "from Compiler.types import Array, cint\nfrom Compiler.library import for_range\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    n = len(arr)\n    ret = Array(n, cint)\n    \n    @for_range(n)\n    def _(i):\n        ret[i] = arr[i].round()\n    \n    return ret\n", "response_1": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = arr[i] + 0.5\n        ret[i] = sint(ret[i].reveal())\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = Array(len(arr), sfix)  # Initialize an array of the same length as arr and brr\n    for i in range(len(arr)):\n        ret[i] = arr[i] >= brr[i]  # MP-SPDZ automatically converts boolean to sfix (0 or 1)\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = Array(len(arr), sint)  # Initialize an array of secret integers with the same length as arr\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] >= brr[i])  # Set ret[i] to 1 if arr[i] >= brr[i], otherwise 0\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "indicate_negative", "response_0": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = sint(arr[i] < 0)\n    return ret\n", "response_1": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = Array(len(arr), sint)\n    for i in range(len(arr)):\n        ret[i] = if_else(arr[i] < 0, sint(1), sint(0))\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_subtract_2", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = abs(len_a - len_b)\n    \n    # Determine which array is shorter and pad it with zeros\n    if len_a < len_b:\n        pad = b[-pad_length:]\n        pad = [-e for e in pad]\n        ret = [x - y for x, y in zip(a, b)] + pad\n    elif len_a > len_b:\n        pad = a[-pad_length:]\n        ret = [x - y for x, y in zip(a, b)] + pad\n    else:\n        ret = [x - y for x, y in zip(a, b)]\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    # Determine the length difference between the two arrays\n    len_a = len(a)\n    len_b = len(b)\n    pad_length = abs(len_a - len_b)\n\n    # Pad the shorter array with zeros\n    if len_a < len_b:\n        pad = b[-pad_length:]\n        pad = [-e for e in pad]\n    elif len_a > len_b:\n        pad = a[-pad_length:]\n    else:\n        pad = []\n\n    # Perform element-wise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n\n    # Add the padding to the result\n    ret += pad\n\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    result = Array(len(arr), sgf2n)\n    for i in range(len(arr)):\n        result[i] = func(arr[i])\n    return result\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    # Initialize an empty array to store the processed elements\n    processed_arr = Array(len(arr), sfix)\n    \n    # Iterate over the input array and apply the function to each element\n    for i in range(len(arr)):\n        processed_arr[i] = func(arr[i])\n    \n    return processed_arr\n", "model_name": "deepseek-v3"}
{"test_name": "array_shift", "response_0": "from Compiler.types import Array, sint\n\ndef array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, sint)\n    \n    # Shift the array elements\n    shifted_array[0] = a[n-1]\n    for i in range(1, n):\n        shifted_array[i] = a[i-1]\n    \n    return shifted_array\n", "response_1": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    n = len(a)\n    shifted_array = Array(n, a[0].type)\n    \n    # Shift the elements\n    shifted_array[0] = a[-1]\n    for i in range(1, n):\n        shifted_array[i] = a[i - 1]\n    \n    return shifted_array\n", "model_name": "deepseek-v3"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = []\n    for i in range(len(a)):\n        # Compare the elements and select the larger one\n        larger = a[i] > b[i]\n        ret_array.append(larger.if_else(a[i], b[i]))\n    return ret_array\n", "response_1": "from Compiler import types\n\ndef compare_and_select(a, b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    # Assuming a and b are arrays of secret integers\n    ret_array = types.Array(len(a), types.sint)\n    \n    for i in range(len(a)):\n        # Compare each element and select the larger one\n        ret_array[i] = (a[i] > b[i]).if_else(a[i], b[i])\n    \n    return ret_array\n", "model_name": "deepseek-v3"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    max_len = max(len_a, len_b)\n    \n    # Pad the shorter array with zeros\n    if len_a < max_len:\n        a = a + [sfix(0.0)] * (max_len - len_a)\n    elif len_b < max_len:\n        b = b + [sfix(0.0)] * (max_len - len_b)\n    \n    # Perform elementwise subtraction\n    ret = [x - y for x, y in zip(a, b)]\n    \n    return ret\n", "response_1": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n    max_len = max(len_a, len_b)\n    \n    # Pad the shorter array with 0s\n    if len_a < max_len:\n        a = a + [sfix(0.0)] * (max_len - len_a)\n    elif len_b < max_len:\n        b = b + [sfix(0.0)] * (max_len - len_b)\n    \n    # Perform element-wise subtraction\n    ret = [a[i] - b[i] for i in range(max_len)]\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "repeat_array", "response_0": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    # Get the length of the input array\n    n = len(c)\n    \n    # Create a new array with double the length\n    result = Array(n * 2, sfix)\n    \n    # Copy the original array into the first half of the result\n    for i in range(n):\n        result[i] = c[i]\n    \n    # Copy the original array into the second half of the result\n    for i in range(n):\n        result[n + i] = c[i]\n    \n    return result\n", "response_1": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c + c\n", "model_name": "deepseek-v3"}
{"test_name": "zeros", "response_0": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    # Initialize an array of clear integers (cint) with zeros\n    array = Array(num, cint)\n    for i in range(num):\n        array[i] = cint(0)\n    return array\n", "response_1": "from Compiler.library import Array\n\ndef zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    array = Array(num, sint)\n    for i in range(num):\n        array[i] = sint(0)\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "clip", "response_0": "from util import if_else\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x):\n        # Check if x is greater than or equal to upper_bound\n        is_upper = x >= upper_bound\n        # Check if x is greater than lower_bound\n        is_lower = x > lower_bound\n        # Return upper_bound if x is greater than or equal to upper_bound\n        # Otherwise, return x if x is greater than lower_bound\n        # Else, return lower_bound\n        return if_else(is_upper, upper_bound, if_else(is_lower, x, lower_bound))\n\n    # Apply the helper function to each element in the array\n    clipped_arr = [helper_func(x) for x in arr]\n    return clipped_arr\n", "response_1": "from util import if_else\n\ndef clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    result = []\n    for x in arr:\n        # Check if x is greater than or equal to upper_bound\n        is_upper = x >= upper_bound\n        # Check if x is greater than lower_bound\n        is_lower = x > lower_bound\n        # Clip the value\n        clipped_value = if_else(is_upper, upper_bound, if_else(is_lower, x, lower_bound))\n        result.append(clipped_value)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize the sum to 0\n    summmation = 0\n\n    # Iterate over each element in the array\n    for x in arr:\n        # Apply the predicator to the element and add the result to the sum\n        summmation += predicator(x)\n\n    return summmation\n", "response_1": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfy the predicator.\n    \"\"\"\n    # Initialize the sum to 0\n    summmation = 0\n    \n    # Iterate over the array and apply the predicator\n    for x in arr:\n        # Apply the predicator to the element\n        flag = predicator(x)\n        \n        # Add the result to the sum\n        summmation += flag\n    \n    return summmation\n", "model_name": "deepseek-v3"}
{"test_name": "reverse_order_pair", "response_0": "from Compiler import types\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    count = types.sint(0)\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            count += (arr[i] > arr[j])\n    \n    return count\n", "response_1": "from Compiler import types\n\ndef reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    count = types.sint(0)\n    n = len(arr)\n    for i in range(n):\n        ndarray = types.Array(n - i, types.sint)\n        for j in range(n - i):\n            ndarray[j] = arr[i]\n        for j in range(n - i):\n            count += (ndarray[j] > arr[i + j])\n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    result = Array(n, sfix)\n    for i in range(n):\n        result[i] = arr[i] + 1\n    return result\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    n = len(arr)\n    result = Array(n, sint)\n    for i in range(n):\n        result[i] = arr[i] + 1\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "count_rises", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] < arr[i + 1]:\n            count += 1\n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] < arr[i + 1]:\n            count += 1\n    return count\n", "model_name": "deepseek-v3"}
{"test_name": "array_process_2", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    result = Array(len(arr), sfix)  # Initialize an array to store the results\n    for i in range(len(arr)):\n        result[i] = func(arr[i])  # Apply the function to each element\n    return result\n", "response_1": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array with the given function.\n    \"\"\"\n    result = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        result[i] = func(arr[i])\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "two_norm", "response_0": "from Compiler.library import *\n\ndef two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Square each element in the vector\n    squared_vec = [v * v for v in vec]\n    \n    # Sum the squared elements\n    sum_squared = sum(squared_vec)\n    \n    # Compute the square root of the sum\n    norm = sqrt(sum_squared)\n    \n    return norm\n", "response_1": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    # Square each element in the vector\n    squared_vec = [item * item for item in vec]\n    \n    # Sum the squared elements\n    sum_squared = sum(squared_vec)\n    \n    # Compute the square root of the sum\n    norm = sqrt(sum_squared)\n    \n    return norm\n", "model_name": "deepseek-v3"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Compute the minimum value in array a\n    amin = min(a)\n    \n    # Compute the maximum value in array b\n    bmax = max(b)\n    \n    # Compare the minimum of a with the maximum of b\n    result = amin >= bmax\n    \n    return result\n", "response_1": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    # Find the minimum value in array a\n    amin = a.min()\n    \n    # Find the maximum value in array b\n    bmax = b.max()\n    \n    # Check if the minimum of a is greater than or equal to the maximum of b\n    return amin >= bmax\n", "model_name": "deepseek-v3"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret-shared arrays.\n    \"\"\"\n    summation = sfix(0)\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    summation = sfix(0)\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "model_name": "deepseek-v3"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sint)  # Initialize an array to store the result\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(indices), sgf2n)\n    for i in range(len(indices)):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = Array(len(arr), sbool)\n    for i in range(len(arr)):\n        flag[i] = (arr[i] == 5) or (arr[i] == 7)\n    return any(flag)\n", "response_1": "from util import if_else\nfrom Compiler.library import for_range\n\ndef exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = [if_else((item == 5) | (item == 7), 1, 0) for item in arr]\n    return sum(flag) > 0\n", "model_name": "deepseek-v3"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    # Create a new array to store the result\n    result = Array(len(arr) - 1, arr.value_type)\n    \n    # Copy elements before the index\n    for i in range(index):\n        result[i] = arr[i]\n    \n    # Copy elements after the index\n    for i in range(index + 1, len(arr)):\n        result[i - 1] = arr[i]\n    \n    return result\n", "response_1": "def remove_by_index(arr, index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    ret = Array(len(arr) - 1, arr.value_type)\n    j = 0\n    for i in range(len(arr)):\n        if i != index:\n            ret[j] = arr[i]\n            j += 1\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "average", "response_0": "from Compiler import types\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of the array in MP-SPDZ.\n    \"\"\"\n    # Sum all elements in the array\n    summmation = types.sint(0)\n    for x in arr:\n        summmation += x\n    \n    # Get the length of the array\n    length = types.sint(len(arr))\n    \n    # Compute the average\n    ret = summmation / length\n    \n    return ret\n", "response_1": "def average(arr):\n    \"\"\"\n    Compute the average value of the array using fixed-point arithmetic.\n    \"\"\"\n    # Sum all elements in the array\n    summmation = sum(arr)\n    \n    # Get the length of the array\n    length = len(arr)\n    \n    # Convert length to a fixed-point value\n    length_fp = sfix(length)\n    \n    # Compute the average using fixed-point division\n    ret = summmation / length_fp\n    \n    return ret\n", "model_name": "deepseek-v3"}
