{"test_name": "sin_or_cos", "response_0": "from library import if_else\nfrom math import sin, cos\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    # Assuming x is a secret integer or fixed-point number\n    is_nonnegative = x >= 0\n    \n    # Compute sin(x) and cos(x)\n    sin_x = sin(x)\n    cos_x = cos(x)\n    \n    # Use conditional to return sin(x) or cos(x)\n    result = if_else(is_nonnegative, sin_x, cos_x)\n    \n    return result\n", "response_1": "from math import sin, cos\nfrom Compiler.library import if_else\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    return if_else(x >= 0, sin(x), cos(x))\n", "model_name": "deepseek-v3"}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return input * (input < 0)\n", "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    return if_else(input < 0, input, 0)\n", "model_name": "deepseek-v3"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    diff = a - b\n    abs_diff = sgn(diff) * diff\n    return abs_diff <= 1\n", "response_1": "template<typename T>\nsbit is_close(const T& a, const T& b) {\n    // Compute the absolute difference\n    T diff = a - b;\n    T abs_diff = diff < 0 ? -diff : diff;\n\n    // Check if the absolute difference is no larger than 1\n    return abs_diff <= 1;\n}\n", "model_name": "deepseek-v3"}
{"test_name": "hardswish", "response_0": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    if x < -3:\n        return 0\n    elif x > 3:\n        return x\n    else:\n        return x * (x + 3) / 6\n", "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    if x < -3:\n        return 0\n    elif x > 3:\n        return x\n    else:\n        return x * (x + 3) / 6\n", "model_name": "deepseek-v3"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    result = x\n    if x > 6:\n        result = 6\n    if x < -6:\n        result = -6\n    return result\n", "response_1": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    result = x\n    @if_ (x > 6)\n    def _():\n        result.update(6)\n    @if_ (x < -6)\n    def _():\n        result.update(-6)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function in MP-SPDZ.\n    \"\"\"\n    ret = sfix(0)\n    if x > 1:\n        ret = x\n    elif x < -1:\n        ret = x\n    elif x > 0:\n        ret = sfix(1)\n    elif x < 0:\n        ret = sfix(-1)\n    else:\n        ret = sfix(0)\n    return ret\n", "response_1": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function in MP-SPDZ.\n    \"\"\"\n    ret = sfix(0)\n    if x > 1:\n        ret = x\n    elif x < -1:\n        ret = x\n    elif x > 0:\n        ret = sfix(1)\n    elif x < 0:\n        ret = sfix(-1)\n    else:\n        ret = sfix(0)\n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # First comparison and swap\n    temp = a\n    a = b\n    b = temp\n    # Second comparison and swap\n    temp = b\n    b = c\n    c = temp\n    # Third comparison and swap\n    temp = a\n    a = b\n    b = temp\n    return b\n", "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    # Compare and swap a and b\n    cmp = a >= b\n    temp = cmp * (a - b) + b\n    a = cmp * b + (1 - cmp) * a\n    b = temp\n    \n    # Compare and swap b and c\n    cmp = b >= c\n    temp = cmp * (b - c) + c\n    b = cmp * c + (1 - cmp) * b\n    c = temp\n    \n    # Compare and swap a and b again\n    cmp = a >= b\n    temp = cmp * (a - b) + b\n    a = cmp * b + (1 - cmp) * a\n    b = temp\n    \n    return b\n", "model_name": "deepseek-v3"}
{"test_name": "indicated_sin_or_cos", "response_0": "from library import if_else\n\ndef indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input.\n    \"\"\"\n    # Assuming sin and cos are implemented or approximated elsewhere\n    sin_val = sin(x)\n    cos_val = cos(x)\n    \n    # Use if_else to choose between sin and cos based on the indicator\n    result = if_else(ind, sin_val, cos_val)\n    \n    return result\n", "response_1": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    # Assuming sine and cosine functions are implemented elsewhere\n    # For simplicity, let's assume they are available as sin(x) and cos(x)\n    # Note: In practice, you would need to implement or import these functions\n    \n    # Conditional selection based on the indicator\n    result = ind.if_else(sin(x), cos(x))\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    return if_else(x - 2 >= 0, x - 2, x)\n", "response_1": "from util import if_else\n\ndef minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    condition = x - 2 >= 0\n    result = if_else(condition, x - 2, x)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    return (x < 0).if_else(0, (x > 6).if_else(6, x))\n", "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function in MP-SPDZ.\n    \"\"\"\n    return ((x >= 0) * (x <= 6)) * x + (x > 6) * 6\n", "model_name": "deepseek-v3"}
{"test_name": "exp_slide", "response_0": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    if x >= 0:\n        # Approximate e^x using a Taylor series expansion\n        e_x = 1.0\n        term = 1.0\n        for i in range(1, 10):  # Adjust the range for better precision\n            term *= x / i\n            e_x += term\n        return e_x\n    else:\n        return x + 1\n", "response_1": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    e = 2.718281828459045  # Approximation of e\n    if x >= 0:\n        return e ** x\n    else:\n        return x + 1\n", "model_name": "deepseek-v3"}
{"test_name": "pass_or_not", "response_0": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    passed = score >= 60\n    score = if_else(passed, score, 59)\n    return score, passed\n", "response_1": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Determine if the score is greater than or equal to 60\n    passed = score >= 60\n    \n    # If the score is less than 60, set it to 59\n    score = if_else(passed, score, 59)\n    \n    return score, passed\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    discriminant = b * b - 4 * a * c\n    if discriminant > 0:\n        return 2\n    elif discriminant == 0:\n        return 1\n    else:\n        return 0\n", "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    # Check if a is zero\n    is_a_zero = (a == 0)\n    \n    # Check if b is zero\n    is_b_zero = (b == 0)\n    \n    # If a is zero, check if b is zero\n    if_else_a_zero = if_else(is_a_zero, \n                             if_else(is_b_zero, 0, 1), \n                             # If a is not zero, calculate discriminant\n                             if_else(b**2 - 4*a*c > 0, 2, \n                                     if_else(b**2 - 4*a*c == 0, 1, 0)))\n    \n    return if_else_a_zero\n", "model_name": "deepseek-v3"}
{"test_name": "elu", "response_0": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    e = 2.718281828459045  # Approximation of e\n    zero = sfix(0)\n    one = sfix(1)\n    \n    # Check if x > 0\n    condition = x > zero\n    \n    # Compute ELU\n    result = x * condition + (e ** x - one) * (1 - condition)\n    \n    return result\n", "response_1": "def elu(x):\n    \"\"\"\n    ELU function in MP-SPDZ\n    \"\"\"\n    # MP-SPDZ does not have a direct math.pow function, so we use the exponential function\n    # and subtraction directly.\n    if x > 0:\n        return x\n    else:\n        return exp(x) - 1\n", "model_name": "deepseek-v3"}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function in MP-SPDZ\n    \"\"\"\n    return if_else(x > 0, x, 0)\n", "response_1": "def relu(x):\n    \"\"\"\n    ReLU function in MP-SPDZ\n    \"\"\"\n    # Compare x with 0 to determine if x > 0\n    cmp = x > 0\n    \n    # Use the comparison result to select between x and 0\n    result = cmp * x\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "leaky_relu", "response_0": "from Compiler.library import if_else\n\ndef leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    return if_else(x > 0, x, x * alpha)\n", "response_1": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha.\n    \"\"\"\n    # Check if x is greater than 0\n    is_positive = x > 0\n    \n    # If x is positive, return x; otherwise, return x * alpha\n    result = is_positive.if_else(x, x * alpha)\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return a.if_else(a >= b, b)\n", "response_1": "template <class T>\nT max(const T& a, const T& b) {\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    if (a >= b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n", "model_name": "deepseek-v3"}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Compare x with 1 and -1\n    greater_than_1 = x > 1\n    less_than_minus_1 = x < -1\n\n    # Compute the results for each condition\n    result_gt_1 = x - 1\n    result_lt_minus_1 = -x - 1\n    result_else = 0\n\n    # Use if_else to select the correct result based on the conditions\n    result = if_else(greater_than_1, result_gt_1, \n                     if_else(less_than_minus_1, result_lt_minus_1, result_else))\n\n    return result\n", "response_1": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    gt_1 = x > 1\n    lt_minus_1 = x < -1\n    result = if_else(gt_1, x - 1, if_else(lt_minus_1, -x - 1, 0))\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "rounded_kinetic_energy", "response_0": "# Define the function rounded_kinetic_energy\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    # Calculate the kinetic energy\n    k = m * v * v / 2\n    \n    # Compute the floor of k\n    k_int = k.floor()\n    \n    # Determine if the fractional part is less than 0.5\n    fractional_part = k - k_int\n    rounding_condition = fractional_part < 0.5\n    \n    # Return the rounded value\n    return k_int + (1 - rounding_condition)\n", "response_1": "from math import floor\n\ndef rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    k = m * v**2 / 2\n    k_int = floor(k)\n    return k_int if (k - k_int) < 0.5 else k_int + 1\n", "model_name": "deepseek-v3"}
{"test_name": "danger_test", "response_0": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy!\n    Given the Dragon Warrior's initial health and the damage he receives,\n    decide whether the situation is dangerous.\n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    is_dangerous = health_left <= 10\n    return is_dangerous\n", "response_1": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    health_left = origin - damage\n    is_dangerous = health_left <= 10\n    return is_dangerous\n", "model_name": "deepseek-v3"}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    result = (ind) * (x + y) + (1 - ind) * (x * y)\n    return result\n", "response_1": "def indicated_sum_or_multiply(x: sint, y: sint, ind: sint) -> sint:\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    sum_result = x + y\n    product_result = x * y\n    return ind.if_else(sum_result, product_result)\n", "model_name": "deepseek-v3"}
{"test_name": "median", "response_0": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array\n    arr = sorted(arr)\n    \n    # Calculate the median\n    if n % 2 == 1:\n        ret = arr[n // 2]\n    else:\n        ret = (arr[n // 2] + arr[n // 2 - 1]) / 2\n    \n    return ret\n", "response_1": "def median(arr):\n    \"\"\"\n    Return the median of the array securely.\n    Check first whether the array is empty.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    \n    # Sort the array securely\n    arr = sort(arr)\n    \n    # Calculate the median securely\n    if n % 2 == 1:\n        ret = arr[n // 2]\n    else:\n        ret = (arr[n // 2] + arr[n // 2 - 1]) / 2\n    \n    return ret\n", "model_name": "deepseek-v3"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum = a + b\n    result = if_else(sum > 10, 10, sum)\n    return result\n", "response_1": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    sum = a + b\n    is_greater_than_10 = sum > 10\n    result = is_greater_than_10.if_else(10, sum)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers.\n    The rule is the following:\n    Base fare: 5, which can cover the first 5 miles.\n    The part in [5,10] is charged with 1.2 dollars per mile.\n    The part in [10,+INF] is charged with 1.5 dollars per mile.\n    \"\"\"\n    base_fare = 5\n    rate_5_10 = 1.2\n    rate_10_inf = 1.5\n    \n    # Determine the fare based on the miles\n    if m <= 5:\n        return base_fare\n    elif m <= 10:\n        return base_fare + rate_5_10 * (m - 5)\n    else:\n        return base_fare + rate_5_10 * (10 - 5) + rate_10_inf * (m - 10)\n", "response_1": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers.\n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile.\n    \"\"\"\n    if m <= 5:\n        return 5\n    elif m <= 10:\n        return 5 + 1.2 * (m - 5)\n    else:\n        return 11 + 1.5 * (m - 10)\n", "model_name": "deepseek-v3"}
{"test_name": "round", "response_0": "from util import sint, cint, sfix, cfix\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer using fixed-point arithmetic.\n    \"\"\"\n    # Convert x to a fixed-point number if it's not already\n    x_fixed = sfix(x)\n    \n    # Extract the integer part\n    x_int = x_fixed.floor()\n    \n    # Calculate the fractional part\n    fractional = x_fixed - x_int\n    \n    # Compare the fractional part to 0.5\n    is_round_up = fractional >= sfix(0.5)\n    \n    # Return the rounded result\n    return x_int + is_round_up\n", "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x // 1  # Equivalent to math.floor(x)\n    fractional_part = x - x_int\n    return x_int + (fractional_part >= 0.5)\n", "model_name": "deepseek-v3"}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score.\n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    gpa = sfix(0.0)  # Initialize GPA as a fixed-point number\n\n    if score >= 90:\n        gpa = sfix(4.0)\n    elif score >= 85:\n        gpa = sfix(3.6)\n    elif score >= 80:\n        gpa = sfix(3.3)\n    elif score >= 75:\n        gpa = sfix(3.0)\n    elif score >= 70:\n        gpa = sfix(2.6)\n    else:\n        gpa = sfix(2.3)\n\n    return gpa\n", "response_1": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    gpa = sfix(0.0)\n    if score >= 90:\n        gpa = sfix(4.0)\n    elif score >= 85:\n        gpa = sfix(3.6)\n    elif score >= 80:\n        gpa = sfix(3.3)\n    elif score >= 75:\n        gpa = sfix(3.0)\n    elif score >= 70:\n        gpa = sfix(2.6)\n    else:\n        gpa = sfix(2.3)\n    return gpa\n", "model_name": "deepseek-v3"}
{"test_name": "sign", "response_0": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = x == 0\n    positive = x > 0\n    negative = x < 0\n    \n    # If x is zero, return 0, otherwise return 1 if positive, -1 if negative\n    return zero.if_else(0, positive.if_else(1, -1))\n", "response_1": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = x == 0\n    positive = x > 0\n    negative = x < 0\n    \n    result = zero.if_else(0, positive.if_else(1, -1))\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    condition = a <= b\n    result = condition.if_else(a + b, a - b)\n    return result\n", "response_1": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    condition = a <= b\n    result = condition.if_else(a + b, a - b)\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "CNOT", "response_0": "from Compiler import types\n\ndef CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using secure computation.\n    \n    Args:\n        control_bit (sbit): The control bit.\n        flip_bit (sbit): The bit to be flipped if the control bit is set.\n    \n    Returns:\n        sbit: The result of the CNOT operation.\n    \"\"\"\n    return (1 - flip_bit) * control_bit + flip_bit * (1 - control_bit)\n", "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit using MP-SPDZ.\n    \"\"\"\n    # If control_bit is 1, flip the flip_bit; otherwise, leave it unchanged\n    return (1 - flip_bit) * control_bit + flip_bit * (1 - control_bit)\n", "model_name": "deepseek-v3"}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Check if y is negative\n    is_negative = y < 0\n    \n    # If y is negative, return y+1, else return y\n    result = is_negative * (y + 1) + (1 - is_negative) * y\n    \n    return result\n", "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Check if y is negative\n    is_negative = y < 0\n    \n    # If y is negative, return y+1, otherwise return y\n    result = is_negative * (y + 1) + (1 - is_negative) * y\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "is_a_parallelogram", "response_0": "from Compiler.library import *\n\ndef is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram.\n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n\n    # Check if any two points are the same\n    same_ab = same(a, b)\n    same_ac = same(a, c)\n    same_ad = same(a, d)\n    same_bc = same(b, c)\n    same_bd = same(b, d)\n    same_cd = same(c, d)\n\n    any_same = same_ab or same_ac or same_ad or same_bc or same_bd or same_cd\n\n    # Check the conditions for a parallelogram\n    condition1 = (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1])\n    condition2 = (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1])\n    condition3 = (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1])\n\n    # Return True if none of the points are the same and one of the conditions is met\n    return (1 - any_same) * (condition1 + condition2 + condition3)\n", "response_1": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    # Check if any two points are the same\n    if same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d):\n        return False\n    \n    # Check the parallelogram condition\n    cond1 = (a[0] + b[0] == c[0] + d[0]) and (a[1] + b[1] == c[1] + d[1])\n    cond2 = (a[0] + c[0] == b[0] + d[0]) and (a[1] + c[1] == b[1] + d[1])\n    cond3 = (a[0] + d[0] == b[0] + c[0]) and (a[1] + d[1] == b[1] + c[1])\n    \n    return cond1 or cond2 or cond3\n", "model_name": "deepseek-v3"}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    c = a <= b\n    return c.if_else(a, b)\n", "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return a.if_else(a <= b, b)\n", "model_name": "deepseek-v3"}
{"test_name": "choice_of_the_knight", "response_0": "program choice_of_the_knight:\n    # Define the function to check if a position is legal\n    def legal(a, b):\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n\n    # Main function to calculate the number of positions the knight can reach\n    def main(x, y):\n        counter = 0\n        counter += legal(x + 1, y + 2)\n        counter += legal(x - 1, y + 2)\n        counter += legal(x + 1, y - 2)\n        counter += legal(x - 1, y - 2)\n        counter += legal(x + 2, y + 1)\n        counter += legal(x - 2, y + 1)\n        counter += legal(x + 2, y - 1)\n        counter += legal(x - 2, y - 1)\n        return counter\n", "response_1": "def legal(a, b):\n    return (0 <= a) * (a <= 7) * (0 <= b) * (b <= 7)\n\ndef choice_of_the_knight(x, y):\n    counter = 0\n    counter = counter + legal(x + 1, y + 2)\n    counter = counter + legal(x - 1, y + 2)\n    counter = counter + legal(x + 1, y - 2)\n    counter = counter + legal(x - 1, y - 2)\n    counter = counter + legal(x + 2, y + 1)\n    counter = counter + legal(x - 2, y + 1)\n    counter = counter + legal(x + 2, y - 1)\n    counter = counter + legal(x - 2, y - 1)\n    return counter\n", "model_name": "deepseek-v3"}
{"test_name": "max_sum_difference", "response_0": "from Compiler.types import sbitint\nfrom Compiler.library import if_else\n\ndef max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_result = a + b\n    diff_result = a - b\n    \n    # Compare sum_result and diff_result\n    is_sum_greater = sum_result > diff_result\n    \n    # Use if_else to return the maximum value\n    result = if_else(is_sum_greater, sum_result, diff_result)\n    \n    return result\n", "response_1": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    sum_ab = a + b\n    diff_ab = a - b\n    result = sum_ab.greater_than(diff_ab).if_else(sum_ab, diff_ab)\n    return result\n", "model_name": "deepseek-v3"}
