{"test_name": "next_integer", "response_0": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    # In MP-SPDZ, we assume t is a secret-shared integer or fixed-point number.\n    # To get the floor of t, we can simply cast it to an integer if it's not already.\n    # Then, add 1 to get the next integer.\n    return t + 1\n", "response_1": "def next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return t.to_int() + 1\n", "model_name": "deepseek-v3"}
{"test_name": "father_and_son", "response_0": "def father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    difference = father_age - son_age * 2\n    if difference < 0:\n        return -difference\n    else:\n        return difference\n", "response_1": "def father_and_son(father_age, son_age):\n    \"\"\"\n    Given the age of father and son, \n    return before how many years or after how many years, the age of father is twice as the age of son.\n    \"\"\"\n    return abs(father_age - son_age * 2)\n", "model_name": "deepseek-v3"}
{"test_name": "triangle_area", "response_0": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the size of the triangle.\n    \"\"\"\n    return (side * height) / 2\n", "response_1": "def triangle_area(side, height):\n    \"\"\"\n    Given the length of one side and the corresponding height, compute the area of the triangle.\n    \"\"\"\n    return (side * height) / 2\n", "model_name": "deepseek-v3"}
{"test_name": "sin_plus_cos", "response_0": "# Assuming 'a' is a secret-shared value\ndef sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a) using a polynomial approximation.\n    \"\"\"\n    # Polynomial approximation for sin(x) and cos(x)\n    # These are example coefficients; you may need to adjust them\n    sin_coeffs = [0, 1, 0, -1/6, 0, 1/120]  # sin(x) \u2248 x - x^3/6 + x^5/120\n    cos_coeffs = [1, 0, -1/2, 0, 1/24, 0]   # cos(x) \u2248 1 - x^2/2 + x^4/24\n    \n    # Compute sin(a) using polynomial approximation\n    sin_a = sum(coeff * (a ** i) for i, coeff in enumerate(sin_coeffs))\n    \n    # Compute cos(a) using polynomial approximation\n    cos_a = sum(coeff * (a ** i) for i, coeff in enumerate(cos_coeffs))\n    \n    # Return sin(a) + cos(a)\n    return sin_a + cos_a\n", "response_1": "def sin_plus_cos(a):\n    \"\"\"\n    Return sin(a) + cos(a) using polynomial approximation.\n    \"\"\"\n    # Polynomial approximation for sin(x)\n    def sin_approx(x):\n        return x - (x**3)/6 + (x**5)/120 - (x**7)/5040\n\n    # Polynomial approximation for cos(x)\n    def cos_approx(x):\n        return 1 - (x**2)/2 + (x**4)/24 - (x**6)/720\n\n    # Calculate sin(a) and cos(a) using the approximations\n    sin_a = sin_approx(a)\n    cos_a = cos_approx(a)\n\n    # Return the sum of sin(a) and cos(a)\n    return sin_a + cos_a\n", "model_name": "deepseek-v3"}
{"test_name": "sigmoid", "response_0": "def sigmoid(x):\n    \"\"\"\n    sigmoid function using fixed-point arithmetic\n    \"\"\"\n    # Define the fixed-point precision factor (e.g., 2^16)\n    precision = sfix(1 << 16)\n    \n    # Compute e^(-x) using fixed-point arithmetic\n    exp_minus_x = exp(-x * precision) / precision\n    \n    # Compute 1 + e^(-x)\n    denominator = sfix(1) + exp_minus_x\n    \n    # Compute 1 / (1 + e^(-x))\n    result = sfix(1) / denominator\n    \n    return result\n", "response_1": "from Compiler import floatingpoint\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function using fixed-point arithmetic\n    \"\"\"\n    # Constants for fixed-point arithmetic\n    one = sfix(1.0)\n    e = sfix(2.718281828459045)  # Approximation of e\n    \n    # Calculate e^(-x)\n    neg_x = -x\n    e_neg_x = floatingpoint.pow(e, neg_x)\n    \n    # Calculate 1 + e^(-x)\n    denominator = one + e_neg_x\n    \n    # Calculate 1 / (1 + e^(-x))\n    result = one / denominator\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "self_exponent", "response_0": "def self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    result = 1\n    for _ in range(k):\n        result *= k\n    return result\n", "response_1": "from math import pow\n\ndef self_exponent(k):\n    \"\"\"\n    Return the self-exponent k^k.\n    \"\"\"\n    return pow(k, k)\n", "model_name": "deepseek-v3"}
{"test_name": "silu", "response_0": "def silu(x):\n    \"\"\"\n    SiLU function\n    \"\"\"\n    # Compute e^(-x)\n    exp_neg_x = cfloat(1) / (cfloat(1) + exp(x))\n    \n    # Compute x / (1 + e^(-x))\n    result = x / (cfloat(1) + exp_neg_x)\n    \n    return result\n", "response_1": "from Compiler.library import print_ln, for_range\nfrom Compiler.types import sfix, cint\n\ndef silu(x):\n    \"\"\"\n    SiLU function in MP-SPDZ\n    \"\"\"\n    # Compute e^(-x)\n    exp_neg_x = sfix.exp(-x)\n    \n    # Compute 1 + e^(-x)\n    denominator = sfix(1) + exp_neg_x\n    \n    # Compute x / (1 + e^(-x))\n    result = x / denominator\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "Gaussian_bracket", "response_0": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    # Convert x to an integer (floor function)\n    x_int = x.to_int()\n    \n    # Subtract the integer part from the original value\n    return x - x_int\n", "response_1": "def Gaussian_bracket(x):\n    \"\"\"\n    Return the value of Gaussian large bracket.\n    \"\"\"\n    x_int = x // 1  # Equivalent to math.floor(x) for positive x\n    return x - x_int\n", "model_name": "deepseek-v3"}
{"test_name": "asin_and_square", "response_0": "from Compiler import types\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    # Approximate arcsin using a polynomial (e.g., Taylor series)\n    # For simplicity, we use a linear approximation here\n    # Note: This is a placeholder and should be replaced with a more accurate approximation\n    asin_x = x  # Placeholder for arcsin approximation\n    \n    # Square the result\n    result = asin_x * asin_x\n    \n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef asin_and_square(x):\n    \"\"\"\n    Take arcsin to the input, then compute the square of the outcome.\n    \"\"\"\n    # Approximate arcsin using fixed-point arithmetic\n    # Note: This is a simple approximation and may not be accurate for all inputs\n    arcsin_x = sfix(0)\n    arcsin_x = x + (x ** 3) / sfix(6) + (3 * x ** 5) / sfix(40)  # Taylor series approximation\n    \n    # Compute the square of the result\n    result = arcsin_x * arcsin_x\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "cylinder_surface", "response_0": "# Define a fixed-point approximation of pi\npi = sfix(3.141592653589793)\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    r_squared = r * r\n    surface_area = 2 * pi * r_squared + 2 * pi * r * h\n    return surface_area\n", "response_1": "from Compiler.types import sfix\n\ndef cylinder_surface(r, h):\n    \"\"\"\n    Given the radius and the height of a cylinder, return its surface area.\n    \"\"\"\n    pi = sfix(3.14159265358979323846)\n    return 2 * pi * r * r + 2 * pi * r * h\n", "model_name": "deepseek-v3"}
{"test_name": "radian_to_degree", "response_0": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    # Define the value of \u03c0\n    pi = 3.14159265358979323846\n    # Convert radian to degree\n    return r / pi * 180\n", "response_1": "def radian_to_degree(r):\n    \"\"\"\n    Converting radian to degree\n    \"\"\"\n    # MP-SPDZ uses fixed-point arithmetic, so we need to define pi as a fixed-point number\n    # Assuming we are using 16 bits of precision for the fractional part\n    pi = sfix(3.141592653589793)\n    \n    # Perform the conversion: r / pi * 180\n    return (r / pi) * sfix(180)\n", "model_name": "deepseek-v3"}
{"test_name": "square_root", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef square_root(a):\n    \"\"\"\n    Return the square root of the input using fixed-point arithmetic.\n    \"\"\"\n    # Initialize variables\n    x = a\n    y = cint(1)\n    precision = 20  # Adjust precision as needed\n\n    # Newton-Raphson method for square root\n    @for_range(precision)\n    def _(i):\n        x_prev = x\n        x = (x + y) / 2\n        y = a / x\n\n    return x\n", "response_1": "def square_root(a):\n    \"\"\"\n    Return the integer approximation of the square root of the input using the Babylonian method.\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Cannot compute square root of a negative number\")\n    \n    x = a\n    y = (x + 1) // 2\n    while y < x:\n        x = y\n        y = (x + a // x) // 2\n    \n    return x\n", "model_name": "deepseek-v3"}
{"test_name": "cosine_theorem", "response_0": "def cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    # Compute a^2 and b^2\n    a_squared = a * a\n    b_squared = b * b\n\n    # Compute 2 * a * b * cos(rad)\n    # Assuming fixed-point arithmetic for cos(rad)\n    cos_rad = cos(rad)\n    two_a_b_cos_rad = 2 * a * b * cos_rad\n\n    # Compute the length of the third edge\n    c_squared = a_squared + b_squared - two_a_b_cos_rad\n    c = sqrt(c_squared)\n\n    return c\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef cosine_theorem(a, b, rad):\n    \"\"\"\n    Given the two edges a, b and the angle rad between them, \n    use cosine theorem to compute the length of the third edge.\n    \"\"\"\n    # Compute a^2 + b^2\n    a_squared = a * a\n    b_squared = b * b\n    sum_of_squares = a_squared + b_squared\n\n    # Compute 2 * a * b * cos(rad)\n    # Assuming rad is in radians and cosine is implemented or approximated\n    two_a_b = 2 * a * b\n    cos_rad = sfix.cos(rad)  # Assuming sfix.cos is available or implemented\n    product = two_a_b * cos_rad\n\n    # Compute the final result using the cosine theorem\n    result = sum_of_squares - product\n    return sfix.sqrt(result)  # Assuming sfix.sqrt is available or implemented\n", "model_name": "deepseek-v3"}
{"test_name": "lights_states", "response_0": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return 1 << num\n", "response_1": "def lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states. \n    (Each light has two states: on/off)\n    \"\"\"\n    return 2 ** num\n", "model_name": "deepseek-v3"}
{"test_name": "degree_to_radian", "response_0": "def degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    # Define pi as a fixed-point constant\n    pi = sfix(3.14159265358979323846)\n    \n    # Convert degree to radian using fixed-point arithmetic\n    return (d * pi) / sfix(180)\n", "response_1": "def degree_to_radian(d):\n    \"\"\"\n    Converting degree to radian\n    \"\"\"\n    pi = 3.14159265358979323846  # Define pi manually\n    return d / 180 * pi\n", "model_name": "deepseek-v3"}
{"test_name": "Fah_to_Cel", "response_0": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - 32) / 1.8\n", "response_1": "def Fah_to_Cel(F):\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature.\n    \"\"\"\n    return (F - 32) / 1.8\n", "model_name": "deepseek-v3"}
{"test_name": "elliptic_area", "response_0": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    # MP-SPDZ does not have a built-in pi constant, so we define it as a fixed-point number\n    pi = sfix(3.14159265358979323846)\n    \n    # Calculate the area using the formula: pi * a * b\n    area = pi * a * b\n    \n    return area\n", "response_1": "def elliptic_area(a, b):\n    \"\"\"\n    Given the lengths of major axis and minor axis of the elliptic, return its area.\n    \"\"\"\n    # Define pi as a fixed-point constant\n    pi = 3.14159265358979323846 * 2**64  # Scaled for fixed-point arithmetic\n    \n    # Calculate the area using fixed-point arithmetic\n    area = (pi * a * b) / 2**64\n    \n    return area\n", "model_name": "deepseek-v3"}
{"test_name": "floor", "response_0": "def floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    return z - (z % 1)\n", "response_1": "from Compiler import floatingpoint\n\ndef floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Convert the input to a fixed-point number\n    fixed_z = floatingpoint.Trunc(z, floatingpoint.f, floatingpoint.kappa)\n    # Truncate to get the floor value\n    return fixed_z\n", "model_name": "deepseek-v3"}
{"test_name": "log_and_cube", "response_0": "from util import log2, pow\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    log_x = log2(x)\n    return pow(log_x, 3)\n", "response_1": "from Compiler.library import log2_fx, pow_fx\n\ndef log_and_cube(x):\n    \"\"\"\n    take log (with base-2) to the input, then compute the cube of the outcome\n    \"\"\"\n    log_x = log2_fx(x)\n    return pow_fx(log_x, 3)\n", "model_name": "deepseek-v3"}
{"test_name": "floor_and_square", "response_0": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input.\n    Then return the square of the previous outcome.\n    \"\"\"\n    # Floor operation in MP-SPDZ\n    floored_z = sfloordiv(z, 1)\n    \n    # Square the floored value\n    squared_result = floored_z * floored_z\n    \n    return squared_result\n", "response_1": "def floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input.\n    Then return the square of the previous outcome.\n    \"\"\"\n    # Convert the input to an integer, which effectively floors it\n    floored_z = cint(z)\n    \n    # Square the floored value\n    squared_value = floored_z * floored_z\n    \n    return squared_value\n", "model_name": "deepseek-v3"}
{"test_name": "meters_to_feet", "response_0": "# MP-SPDZ program to convert meters to feet\nprogram = \"\"\"\ndef meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    # Define the conversion factor as a constant\n    conversion_factor = 3.2808\n    \n    # Perform the conversion\n    feet = m * conversion_factor\n    \n    return feet\n\"\"\"\n", "response_1": "def meters_to_feet(m):\n    \"\"\"\n    Convert the length in meters to the length in feet.\n    \"\"\"\n    return m * 3.2808\n", "model_name": "deepseek-v3"}
{"test_name": "sphere_area", "response_0": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    # Define pi as a fixed-point constant\n    pi = sfix(3.14159265358979323846)\n    \n    # Calculate the area using fixed-point arithmetic\n    area = 4 * pi * r * r\n    \n    return area\n", "response_1": "def sphere_area(r):\n    \"\"\"\n    Return the area of a sphere surface with given radius r.\n    \"\"\"\n    # Approximate value of \u03c0 using fixed-point arithmetic\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the area using the formula 4 * \u03c0 * r^2\n    area = sfix(4) * pi * r * r\n    \n    return area\n", "model_name": "deepseek-v3"}
{"test_name": "coarse_abs", "response_0": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = abs(x)\n    return floor(abs_x)\n", "response_1": "def coarse_abs(x):\n    \"\"\"\n    Return the absolute value of x, and round it to zero.\n    \"\"\"\n    abs_x = x.if_else(x, -x)  # Compute the absolute value\n    return abs_x.floor()  # Round it to zero\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_chickens", "response_0": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - (legs - heads * 2) // 2\n", "response_1": "def how_many_chickens(heads, legs):\n    \"\"\"\n    Compute the number of chickens in the rabbit-chicken problem.\n    \"\"\"\n    return heads - (legs - heads * 2) // 2\n", "model_name": "deepseek-v3"}
{"test_name": "interest_calculator", "response_0": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get. \n    \"\"\"\n    # Calculate (1 + ratio) ^ months\n    base = 1 + ratio\n    result = 1\n    for _ in range(months):\n        result = result * base\n    \n    # Calculate (result - 1) * capital\n    interest = (result - 1) * capital\n    return interest\n", "response_1": "def interest_calculator(capital, ratio, months):\n    \"\"\"\n    Given the initial capital, interest ratio and the number of months you deposit your money to the bank, \n    calculate the interest you can get.\n    \"\"\"\n    result = 1 + ratio\n    for i in range(1, months):\n        result = result * (1 + ratio)\n    return (result - 1) * capital\n", "model_name": "deepseek-v3"}
{"test_name": "circle_area", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    # Define the value of \u03c0 as a fixed-point number\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the area using fixed-point arithmetic\n    area = pi * r * r\n    \n    return area\n", "response_1": "def circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    # Define pi as a fixed-point number (3.141592653589793)\n    pi = sfix(3.141592653589793)\n    \n    # Calculate the area of the circle\n    area = pi * r * r\n    \n    return area\n", "model_name": "deepseek-v3"}
{"test_name": "cube_and_square_root", "response_0": "def cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    x_cubed = x * x * x\n    return sqrt(x_cubed)\n", "response_1": "def cube_and_square_root(x):\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    # Compute the cube of x\n    cube = x * x * x\n    \n    # Compute the square root of the cube\n    sqrt = sqrt(cube)\n    \n    return sqrt\n", "model_name": "deepseek-v3"}
{"test_name": "round", "response_0": "from Compiler.library import *\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer using fixed-point arithmetic.\n    \"\"\"\n    # Assuming x is a fixed-point number, convert it to an integer representation\n    x_int = x.to_int()\n    \n    # Calculate the fractional part\n    fractional = x - x_int\n    \n    # If the fractional part is less than 0.5, return the integer part\n    # Otherwise, return the integer part + 1\n    return x_int + (fractional >= 0.5)\n", "response_1": "from Compiler.library import *\n\ndef round(x, k):\n    \"\"\"\n    Round x to the nearest integer.\n    x is a fixed-point number with k bits of precision.\n    \"\"\"\n    # Extract the integer part\n    x_int = x >> k\n    \n    # Extract the fractional part\n    fractional = x - (x_int << k)\n    \n    # Determine if the fractional part is >= 0.5\n    threshold = 1 << (k - 1)\n    should_round_up = fractional >= threshold\n    \n    # Return the rounded value\n    return x_int + should_round_up\n", "model_name": "deepseek-v3"}
{"test_name": "cryptic_adjustment", "response_0": "from Compiler import types\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor wants to adjust the pessimistic score of his students mid-term exam.\n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    # Calculate the inner square root\n    inner_sqrt = types.sfix(origin).sqrt()\n    \n    # Multiply by 10\n    inner_result = 10 * inner_sqrt\n    \n    # Calculate the outer square root\n    outer_sqrt = inner_result.sqrt()\n    \n    # Multiply by 10 to get the final result\n    result = 10 * outer_sqrt\n    \n    return result\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor wants to adjust the pessimistic score of his students mid-term exam.\n    The adjustment formula is 10*sqrt(10*sqrt(origin))\n    \"\"\"\n    # Convert origin to a fixed-point number\n    origin_fp = sfix(origin)\n    \n    # Compute the inner square root: sqrt(origin)\n    inner_sqrt = origin_fp.sqrt()\n    \n    # Multiply by 10: 10 * sqrt(origin)\n    inner_adjusted = sfix(10) * inner_sqrt\n    \n    # Compute the outer square root: sqrt(10 * sqrt(origin))\n    outer_sqrt = inner_adjusted.sqrt()\n    \n    # Multiply by 10: 10 * sqrt(10 * sqrt(origin))\n    final_adjusted = sfix(10) * outer_sqrt\n    \n    return final_adjusted\n", "model_name": "deepseek-v3"}
{"test_name": "specific_pow", "response_0": "from Compiler.types import sfix, cint\nfrom Compiler.library import print_ln\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    # Convert x to fixed-point type\n    x_fix = sfix(x)\n    \n    # Compute x^2\n    x_squared = x_fix * x_fix\n    \n    # Compute sqrt(x) using fixed-point arithmetic\n    x_sqrt = x_fix.sqrt()\n    \n    # Compute x^(2.5) = x^2 * sqrt(x)\n    result = x_squared * x_sqrt\n    \n    return result\n\n# Example usage\nx = 4\nresult = specific_pow(x)\nprint_ln(\"Result: %s\", result.reveal())\n", "response_1": "from util import *\nfrom fixedpt import *\n\ndef specific_pow(x):\n    \"\"\"\n    Return x^(2.5) using fixed-point arithmetic.\n    \"\"\"\n    # Convert x to fixed-point\n    x_fixed = sfix(x)\n    \n    # Calculate x^2.5 as x^2 * sqrt(x)\n    x_squared = x_fixed * x_fixed\n    sqrt_x = sfix(math.sqrt(x_fixed.v))  # Use math.sqrt for the square root\n    \n    # Multiply x^2 by sqrt(x) to get x^2.5\n    result = x_squared * sqrt_x\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "soft_plus", "response_0": "def soft_plus(x):\n    \"\"\"\n    Softplus function\n    \"\"\"\n    e_x = exp(x)\n    one_plus_e_x = 1 + e_x\n    return log(one_plus_e_x)\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef soft_plus(x):\n    \"\"\"\n    Softplus function approximation in MP-SPDZ\n    \"\"\"\n    # Constants for approximation\n    e = sfix(2.718281828459045)\n    one = sfix(1.0)\n\n    # Calculate e^x using fixed-point arithmetic\n    exp_x = e ** x\n\n    # Calculate 1 + e^x\n    sum_exp = one + exp_x\n\n    # Approximate natural logarithm using fixed-point arithmetic\n    # Note: This is a simple approximation and may not be accurate for all values\n    # For better accuracy, consider using a more sophisticated method or a lookup table\n    log_sum_exp = log2(sum_exp) * log2(e)\n\n    return log_sum_exp\n\ndef log2(x):\n    \"\"\"\n    Approximate log2(x) using fixed-point arithmetic\n    \"\"\"\n    # This is a simple approximation using the fact that log2(x) is the number of bits - 1\n    # For more accurate results, consider using a more sophisticated method\n    bits = x.size()\n    return sfix(bits - 1)\n", "model_name": "deepseek-v3"}
{"test_name": "ball_volume", "response_0": "from Compiler.types import sfloat\nfrom Compiler.library import print_ln\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    pi = sfloat(3.141592653589793)\n    return pi * r ** 3 * sfloat(4) / sfloat(3)\n", "response_1": "def ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius.\n    \"\"\"\n    # Define pi as a fixed-point constant\n    pi = sfix(3.14159265358979323846)\n    \n    # Calculate the volume using fixed-point arithmetic\n    volume = pi * r * r * r * sfix(4) / sfix(3)\n    \n    return volume\n", "model_name": "deepseek-v3"}
{"test_name": "Heron", "response_0": "from util import if_else\nfrom Compiler import floatingpoint\n\ndef Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    p = (a + b + c) / 2\n    s = floatingpoint.sqrt(p * (p - a) * (p - b) * (p - c))\n    return s\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef Heron(a, b, c):\n    \"\"\"\n    Given the lengths of three sides of the triangle, compute its size with Heron's formula.\n    \"\"\"\n    # Compute the semi-perimeter\n    p = (a + b + c) / 2\n    \n    # Compute the product inside the square root\n    product = p * (p - a) * (p - b) * (p - c)\n    \n    # Compute the square root securely\n    area = sqrt(product)\n    \n    return area\n", "model_name": "deepseek-v3"}
{"test_name": "next_perfect_square", "response_0": "def next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x. \n    The input x is guaranteed to be a positive integer. \n    \"\"\"\n    import math\n    sqrt_x = math.sqrt(x)\n    floor_sqrt_x = math.floor(sqrt_x)\n    next_square = (floor_sqrt_x + 1) ** 2\n    return next_square\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\nfrom Compiler.util import *\n\ndef next_perfect_square(x):\n    \"\"\"\n    Return the smallest perfect square number bigger than x.\n    The input x is guaranteed to be a positive integer.\n    \"\"\"\n    # Compute the square root of x\n    sqrt_x = sqrt(x)\n    \n    # Floor the square root and add 1\n    next_int = sqrt_x.floor() + 1\n    \n    # Compute the square of the next integer\n    perfect_square = next_int * next_int\n    \n    return perfect_square\n\ndef sqrt(x):\n    \"\"\"\n    Compute the integer square root of x using the Babylonian method.\n    \"\"\"\n    if x <= 1:\n        return x\n    \n    # Initial guess\n    guess = x // 2\n    \n    # Iteratively improve the guess\n    while True:\n        new_guess = (guess + x // guess) // 2\n        if new_guess >= guess:\n            break\n        guess = new_guess\n    \n    return guess\n", "model_name": "deepseek-v3"}
{"test_name": "pi_to_the_x", "response_0": "from Compiler import floatingpoint\n\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    # Define pi as a fixed-point number\n    pi = floatingpoint.fxpn(3.14159265358979323846)\n    \n    # Compute pi^x using the fixed-point power function\n    result = floatingpoint.fxpn_pow(pi, x)\n    \n    return result\n", "response_1": "# Define a function to compute pi^x\ndef pi_to_the_x(x):\n    \"\"\"\n    Return the value of pi^x.\n    \"\"\"\n    # Define pi as a fixed-point number (3.141592653589793)\n    pi = sfix(3.141592653589793)\n    \n    # Compute pi^x using the power function\n    result = pi ** x\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "spring_rocket", "response_0": "def spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = 9.8\n    numerator = 2 * m * g * height\n    denominator = k\n    result = numerator / denominator\n    return sqrt(result)\n", "response_1": "from Compiler import types\nfrom Compiler import floatingpoint\n\ndef spring_rocket(height, m, k):\n    \"\"\"\n    You want to use a spring with stiffness coefficient k to bounce an object with mass m to the given height. \n    You should return the minimum length the spring should be compressed. \n    Assume g = 9.8\n    \"\"\"\n    g = types.sfix(9.8)\n    height = types.sfix(height)\n    m = types.sfix(m)\n    k = types.sfix(k)\n    \n    # Calculate the numerator: 2 * m * g * height\n    numerator = 2 * m * g * height\n    \n    # Divide by k\n    division_result = numerator / k\n    \n    # Compute the square root using fixed-point arithmetic\n    compressed_length = floatingpoint.sqrt(division_result)\n    \n    return compressed_length\n", "model_name": "deepseek-v3"}
{"test_name": "cone_volume", "response_0": "from Compiler import types\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    r: sfix, the radius of the cone\n    h: sfix, the height of the cone\n    Returns: sfix, the volume of the cone\n    \"\"\"\n    pi = types.sfix(3.141592653589793)\n    volume = pi * r * r * h / 3\n    return volume\n", "response_1": "# Define pi as a constant\npi = 3.141592653589793\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    return pi * r * r * h / 3\n", "model_name": "deepseek-v3"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "response_1": "def how_many_rabbits(heads, legs):\n    \"\"\"\n    Compute the number of rabbits in the rabbit-chicken problem.\n    \"\"\"\n    return (legs - heads * 2) // 2\n", "model_name": "deepseek-v3"}
