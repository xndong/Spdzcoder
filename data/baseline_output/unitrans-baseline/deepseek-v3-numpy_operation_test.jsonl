{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler import types\n\nstart = 0\nend = 99\nnum = 10\n\n# Calculate the step size\nstep = (end - start) / (num - 1)\n\n# Initialize an array to store the results\na = types.Array(num, types.sint)\n\n# Generate the linearly spaced values\nfor i in range(num):\n    a[i] = start + i * step\n\n# Now 'a' contains the linearly spaced values\n", "response_1": "from util import if_else\nfrom Compiler.types import cint, sint\n\nstart = 0\nend = 99\nnum = 10\n\n# Calculate the step size\nstep = (end - start) / (num - 1)\n\n# Initialize an array to store the results\na = Array(num, cint)\n\n# Generate the evenly spaced values\nfor i in range(num):\n    a[i] = start + i * step\n", "model_name": "deepseek-v3"}
{"test_name": "more_positive", "response_0": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        count += (arr[i] > 0).if_else(1, 0)\n    return count > 0\n", "response_1": "# Define the function to check if there are more positive numbers in the array\ndef more_positive(arr):\n    # Initialize a counter for positive numbers\n    positive_count = 0\n    \n    # Iterate through the array\n    for num in arr:\n        # Check if the number is positive\n        if num > 0:\n            positive_count += 1\n    \n    # Check if the count of positive numbers is greater than half the array length\n    return positive_count > len(arr) / 2\n", "model_name": "deepseek-v3"}
{"test_name": "select", "response_0": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays based on the condition in `ind`.\n    The array elements are assumed to be floating-point numbers.\n    \"\"\"\n    result = sfloat.Array(len(ind))\n    for i in range(len(ind)):\n        result[i] = if_else(ind[i], a[i], b[i])\n    return result\n", "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are secret-shared floats.\n    ind: secret-shared integer array (0 or 1)\n    a: secret-shared float array\n    b: secret-shared float array\n    \"\"\"\n    # Use the sbits type for the condition and the sfloat type for the arrays\n    result = sfloat.Array(len(a))\n    for i in range(len(a)):\n        result[i] = ind[i].if_else(a[i], b[i])\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return y * (y > 0)\n", "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    return if_else(y < 0, 0, y)\n", "model_name": "deepseek-v3"}
{"test_name": "cost_matrix", "response_0": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    # Determine the shape of the matrix\n    rows = len(profit_matrix)\n    cols = len(profit_matrix[0]) if rows > 0 else 0\n    \n    # Find the maximum value in the profit matrix\n    max_value = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if profit_matrix[i][j] > max_value:\n                max_value = profit_matrix[i][j]\n    \n    # Create the cost matrix by subtracting each element from the max value\n    cost_matrix = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            cost_matrix[i][j] = max_value - profit_matrix[i][j]\n    \n    return cost_matrix\n", "response_1": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    # Determine the shape of the matrix\n    rows, cols = profit_matrix.shape\n\n    # Find the maximum value in the profit matrix\n    max_value = profit_matrix[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if profit_matrix[i][j] > max_value:\n                max_value = profit_matrix[i][j]\n\n    # Create an offset matrix filled with the maximum value\n    offset_matrix = [[max_value for _ in range(cols)] for _ in range(rows)]\n\n    # Compute the cost matrix by subtracting the profit matrix from the offset matrix\n    cost_matrix = [[offset_matrix[i][j] - profit_matrix[i][j] for j in range(cols)] for i in range(rows)]\n\n    return cost_matrix\n", "model_name": "deepseek-v3"}
{"test_name": "np_zeros", "response_0": "n = 10\na = Array(n, sint)\nfor i in range(n):\n    a[i] = sint(0)\n", "response_1": "n = 10\na = Array(n, sint)  # Create an array of size n with secure integers (sint)\n@for_range(n)\ndef _(i):\n    a[i] = sint(0)  # Initialize each element to 0\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index]\n    return array\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from a 2-D array.\n    \"\"\"\n    # Assuming ndarray is a list of lists (2D array)\n    # and row_index is a secret integer representing the row index\n    array = ndarray[row_index]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_zeros_2", "response_0": "def zeros(n):\n    arr = Array(n, sint)\n    @for_range(n)\n    def _(i):\n        arr[i] = sint(0)\n    return arr\n", "response_1": "def zeros(n):\n    # Create an array of size n initialized to 0\n    arr = Array(n, sint)\n    for i in range(n):\n        arr[i] = sint(0)\n    return arr\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_slicing_stride", "response_0": "# Define a function to concatenate elements from two 1-D arrays\ndef array_concate(ndarrayA, ndarrayB):\n    # Initialize empty arrays to store the even and odd index elements\n    even_elements = Array(len(ndarrayA) // 2, sint)\n    odd_elements = Array(len(ndarrayB) // 2, sint)\n    \n    # Collect even index elements from the first array\n    @for_range(len(ndarrayA) // 2)\n    def _(i):\n        even_elements[i] = ndarrayA[2 * i]\n    \n    # Collect odd index elements from the second array\n    @for_range(len(ndarrayB) // 2)\n    def _(i):\n        odd_elements[i] = ndarrayB[2 * i + 1]\n    \n    # Concatenate the two arrays\n    result = Array(len(even_elements) + len(odd_elements), sint)\n    @for_range(len(even_elements))\n    def _(i):\n        result[i] = even_elements[i]\n    \n    @for_range(len(odd_elements))\n    def _(i):\n        result[len(even_elements) + i] = odd_elements[i]\n    \n    return result\n", "response_1": "from Compiler import types\n\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 1-D arrays. \n    Collect all the even index elements from the first array and \n    collect all the odd index elements from the second array.\n    \"\"\"\n    # Get even index elements from the first array\n    viewA = ndarrayA.get_slice(0, len(ndarrayA), 2)\n    \n    # Get odd index elements from the second array\n    viewB = ndarrayB.get_slice(1, len(ndarrayB), 2)\n    \n    # Concatenate the two views\n    array = types.Array(len(viewA) + len(viewB), ndarrayA.value_type)\n    array.assign_part_vector(viewA, 0)\n    array.assign_part_vector(viewB, len(viewA))\n    \n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "QR_decomposition", "response_0": "from Compiler import types\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix using the Gram-Schmidt process.\n    \"\"\"\n    n_rows = len(mat)\n    n_cols = len(mat[0])\n    \n    # Initialize Q as a zero matrix\n    Q = [[types.sint(0) for _ in range(n_cols)] for _ in range(n_rows)]\n    \n    for j in range(n_cols):\n        # Start with the j-th column of the original matrix\n        v = [mat[i][j] for i in range(n_rows)]\n        \n        # Subtract the projection of v onto all previous columns of Q\n        for k in range(j):\n            q_k = [Q[i][k] for i in range(n_rows)]\n            dot_product = sum(v[i] * q_k[i] for i in range(n_rows))\n            q_norm_squared = sum(q_k[i] * q_k[i] for i in range(n_rows))\n            scale = dot_product / q_norm_squared\n            for i in range(n_rows):\n                v[i] = v[i] - scale * q_k[i]\n        \n        # Normalize v to get the j-th column of Q\n        norm = types.sint(0)\n        for i in range(n_rows):\n            norm = norm + v[i] * v[i]\n        norm = norm.sqrt()\n        for i in range(n_rows):\n            Q[i][j] = v[i] / norm\n    \n    return Q\n", "response_1": "from Compiler.types import sfix, Matrix\nfrom Compiler.library import do_while, if_, break_loop\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    n = len(mat)\n    m = len(mat[0])\n    \n    Q = Matrix(n, m, sfix)\n    R = Matrix(m, m, sfix)\n    \n    for j in range(m):\n        v = [mat[i][j] for i in range(n)]\n        \n        for k in range(j):\n            R[k][j] = sum(Q[i][k] * mat[i][j] for i in range(n))\n            v = [v[i] - Q[i][k] * R[k][j] for i in range(n)]\n        \n        R[j][j] = sfix.sqrt(sum(v[i] * v[i] for i in range(n)))\n        \n        for i in range(n):\n            Q[i][j] = v[i] / R[j][j]\n    \n    return Q\n", "model_name": "deepseek-v3"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    min_diff = abs(array[0] - value)\n    min_idx = 0\n    for i in range(1, len(array)):\n        diff = abs(array[i] - value)\n        if diff < min_diff:\n            min_diff = diff\n            min_idx = i\n    return min_idx\n", "response_1": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of the nearest value in an array to the given value.\n    \"\"\"\n    min_diff = abs(array[0] - value)\n    min_index = 0\n    \n    for i in range(1, len(array)):\n        current_diff = abs(array[i] - value)\n        if current_diff < min_diff:\n            min_diff = current_diff\n            min_index = i\n    \n    return min_index\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_simple_row", "response_0": "from Compiler.types import Array, Matrix\n\ndef array_simple_concate_rows(matrixA, matrixB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Get the dimensions of the input matrices\n    rowsA = len(matrixA)\n    colsA = len(matrixA[0]) if rowsA > 0 else 0\n    rowsB = len(matrixB)\n    colsB = len(matrixB[0]) if rowsB > 0 else 0\n    \n    # Ensure the matrices have the same number of columns\n    if colsA != colsB:\n        raise ValueError(\"Matrices must have the same number of columns\")\n    \n    # Create a new matrix to hold the concatenated result\n    result = Matrix(rowsA + rowsB, colsA)\n    \n    # Copy elements from matrixA to the result\n    for i in range(rowsA):\n        for j in range(colsA):\n            result[i][j] = matrixA[i][j]\n    \n    # Copy elements from matrixB to the result\n    for i in range(rowsB):\n        for j in range(colsA):\n            result[rowsA + i][j] = matrixB[i][j]\n    \n    return result\n", "response_1": "def array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are lists of lists (2D arrays)\n    # Get the number of rows in each array\n    rowsA = len(ndarrayA)\n    rowsB = len(ndarrayB)\n    \n    # Create a new array to hold the concatenated result\n    result = [[None for _ in range(len(ndarrayA[0]))] for _ in range(rowsA + rowsB)]\n    \n    # Copy elements from ndarrayA to the result\n    for i in range(rowsA):\n        for j in range(len(ndarrayA[0])):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from ndarrayB to the result\n    for i in range(rowsB):\n        for j in range(len(ndarrayB[0])):\n            result[rowsA + i][j] = ndarrayB[i][j]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    # Create a new array with the same size as the input array\n    array = Array(len(ndarray), ndarray.value_type)\n    \n    # Copy each element from the input array to the new array\n    for i in range(len(ndarray)):\n        array[i] = ndarray[i]\n    \n    return array\n", "response_1": "from Compiler import types\n\ndef array_copy(array):\n    # Create a new array of the same size and type as the input array\n    copied_array = types.Array(len(array), array.value_type)\n    \n    # Copy each element from the original array to the new array\n    for i in range(len(array)):\n        copied_array[i] = array[i]\n    \n    return copied_array\n", "model_name": "deepseek-v3"}
{"test_name": "max_pooling", "response_0": "# MP-SPDZ code for max_pooling\nfrom util import if_else\nfrom Compiler import types\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-pooling in MP-SPDZ.\n    x: sfix Tensor of shape (batch_size, height, width)\n    stride: int, the stride for pooling\n    \"\"\"\n    batch_size = x.shape[0]\n    height = x.shape[1]\n    width = x.shape[2]\n    \n    # Calculate output dimensions\n    out_height = height // stride\n    out_width = width // stride\n    \n    # Initialize output tensor\n    out = types.sfix.Tensor([batch_size, out_height, out_width])\n    \n    for b in range(batch_size):\n        for i in range(0, height, stride):\n            for j in range(0, width, stride):\n                # Initialize max_value with the first element in the window\n                max_value = x[b][i][j]\n                \n                # Iterate over the window to find the maximum value\n                for di in range(stride):\n                    for dj in range(stride):\n                        if i + di < height and j + dj < width:\n                            current_value = x[b][i + di][j + dj]\n                            max_value = if_else(current_value > max_value, current_value, max_value)\n                \n                # Store the maximum value in the output tensor\n                out[b][i // stride][j // stride] = max_value\n    \n    return out\n", "response_1": "# Define the max_pooling function\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max pooling.\n    \"\"\"\n    # Determine the output dimensions\n    out_shape = [x.shape[0], x.shape[1] / stride, x.shape[2] / stride]\n    \n    # Initialize the output array\n    out = Array(out_shape, sfix)\n    \n    # Iterate over the batches\n    for b in range(x.shape[0]):\n        # Iterate over the height with stride\n        for i in range(0, x.shape[1], stride):\n            # Iterate over the width with stride\n            for j in range(0, x.shape[2], stride):\n                # Compute the max value in the current window\n                window = x[b, i:i+stride, j:j+stride]\n                out[b, i / stride, j / stride] = max(window)\n    \n    return out\n", "model_name": "deepseek-v3"}
{"test_name": "array_reshape", "response_0": "# Create a list of integers from 0 to 14\na = [i for i in range(15)]\n\n# Reshape the list into a 3x5 matrix\na_reshaped = [[a[i * 5 + j] for j in range(5)] for i in range(3)]\n", "response_1": "# Define the dimensions of the array\nrows = 3\ncols = 5\n\n# Initialize a 2D array\na = Array(rows, cols)\n\n# Fill the array with values from 0 to 14\nfor i in range(rows):\n    for j in range(cols):\n        a[i][j] = i * cols + j\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_simple_column", "response_0": "from Compiler import types\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    # Assuming ndarrayA and ndarrayB are of type Matrix\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n    \n    # Create a new array with the combined number of columns\n    result = types.Matrix(rows, colsA + colsB, types.sint)\n    \n    # Copy elements from ndarrayA to the result\n    for i in range(rows):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Copy elements from ndarrayB to the result\n    for i in range(rows):\n        for j in range(colsB):\n            result[i][colsA + j] = ndarrayB[i][j]\n    \n    return result\n", "response_1": "# Define the function to concatenate two 2-D arrays along axis 1\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    # Get the number of rows and columns in the first array\n    rowsA = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    \n    # Get the number of rows and columns in the second array\n    rowsB = len(ndarrayB)\n    colsB = len(ndarrayB[0])\n    \n    # Check if the number of rows in both arrays is the same\n    if rowsA != rowsB:\n        raise ValueError(\"The number of rows in both arrays must be the same for concatenation along axis 1.\")\n    \n    # Initialize the result array with the same number of rows and combined columns\n    result = [[sint(0) for _ in range(colsA + colsB)] for _ in range(rowsA)]\n    \n    # Fill the result array with elements from the first array\n    for i in range(rowsA):\n        for j in range(colsA):\n            result[i][j] = ndarrayA[i][j]\n    \n    # Fill the result array with elements from the second array\n    for i in range(rowsB):\n        for j in range(colsB):\n            result[i][colsA + j] = ndarrayB[i][j]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    ndarray: a 2D secret-shared array\n    column_index: the index of the column to be extracted\n    \"\"\"\n    # Initialize an empty array to store the column\n    column_array = Array(len(ndarray), sfix)\n    \n    # Iterate over each row and extract the column_index element\n    for i in range(len(ndarray)):\n        column_array[i] = ndarray[i][column_index]\n    \n    return column_array\n", "response_1": "def array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Determine the number of rows in the 2-D array\n    num_rows = len(ndarray)\n    \n    # Initialize an array to store the column values\n    column_array = Array(num_rows, sfix)\n    \n    # Loop through each row and extract the column_index-th element\n    for i in range(num_rows):\n        column_array[i] = ndarray[i][column_index]\n    \n    return column_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    # Assuming array is a 2D list of secret integers\n    n = len(array)\n    diag_elements = Array(n, sint)  # Create an array to store the diagonal elements\n    for i in range(n):\n        diag_elements[i] = array[i][i]  # Extract the diagonal element\n    return diag_elements\n", "response_1": "def diag(array):\n    # Assuming array is a 2D array represented as a list of lists\n    n = len(array)\n    diag_elements = Array(n, sint)  # Create an array to store diagonal elements\n    for i in range(n):\n        diag_elements[i] = array[i][i]  # Extract the diagonal element\n    return diag_elements\n", "model_name": "deepseek-v3"}
{"test_name": "np_concat_special", "response_0": "# Function to concatenate even columns from the first array and odd columns from the second array\ndef array_special_concate(ndarrayA, ndarrayB):\n    # Get the number of rows and columns in the input arrays\n    rows = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    colsB = len(ndarrayB[0])\n    \n    # Initialize the result array\n    result = [[0 for _ in range((colsA // 2) + (colsB // 2))] for _ in range(rows)]\n    \n    # Collect even columns from the first array\n    for i in range(rows):\n        for j in range(0, colsA, 2):\n            result[i][j // 2] = ndarrayA[i][j]\n    \n    # Collect odd columns from the second array\n    for i in range(rows):\n        for j in range(1, colsB, 2):\n            result[i][(colsA // 2) + (j // 2)] = ndarrayB[i][j]\n    \n    return result\n", "response_1": "from util import if_else\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D arrays along axis 1.\n    Collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Get the dimensions of the input arrays\n    rowsA = len(ndarrayA)\n    colsA = len(ndarrayA[0])\n    rowsB = len(ndarrayB)\n    colsB = len(ndarrayB[0])\n    \n    # Initialize the result array\n    result = [[0 for _ in range(colsA // 2 + colsB // 2)] for _ in range(rowsA)]\n    \n    # Fill the result array with even columns from ndarrayA\n    for i in range(rowsA):\n        k = 0\n        for j in range(0, colsA, 2):\n            result[i][k] = ndarrayA[i][j]\n            k += 1\n    \n    # Fill the result array with odd columns from ndarrayB\n    for i in range(rowsB):\n        k = colsA // 2\n        for j in range(1, colsB, 2):\n            result[i][k] = ndarrayB[i][j]\n            k += 1\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_arange", "response_0": "from util import Array\nfrom Compiler.types import cint\n\ndef arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-dimensional array similar to numpy.arange.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Calculate the number of elements in the array\n    length = (stop - start + step - 1) // step\n\n    # Initialize the array\n    array = Array(length, cint)\n\n    # Fill the array with values\n    @for_range(length)\n    def _(i):\n        array[i] = start + i * step\n\n    return array\n", "response_1": "def arange(start, stop=None, step=1):\n    \"\"\"\n    Create a 1-dimensional array similar to numpy.arange.\n    \"\"\"\n    if stop is None:\n        stop = start\n        start = 0\n\n    # Calculate the number of elements in the array\n    size = (stop - start) // step\n    if (stop - start) % step != 0:\n        size += 1\n\n    # Initialize an array with the calculated size\n    array = Array(size, sint)\n\n    # Fill the array with values starting from 'start' with step 'step'\n    for i in range(size):\n        array[i] = start + i * step\n\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_eye_2", "response_0": "m = 3\nn = 5\na = [[1 if i == j else 0 for j in range(n)] for i in range(m)]\n", "response_1": "m = 3\nn = 5\na = [[sint(1) if i == j else sint(0) for j in range(n)] for i in range(m)]\n", "model_name": "deepseek-v3"}
{"test_name": "third_smallest", "response_0": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    # Bubble sort implementation\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                # Swap arr[j] and arr[j+1]\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    # Return the third smallest element\n    return arr[2]\n", "response_1": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    n = len(arr)\n    # Bubble sort to sort the array\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                # Swap arr[j] and arr[j+1]\n                temp = arr[j]\n                arr[j] = arr[j+1]\n                arr[j+1] = temp\n    # Return the third element (index 2)\n    return arr[2]\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "program array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array and row_index is a valid index\n    # We will create a new array to store the i-th row\n    array = ndarray[row_index]\n    return array\n", "response_1": "from Compiler import types\n\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from a 2-D array.\n    \"\"\"\n    # Assuming ndarray is a 2D array (matrix) in MP-SPDZ\n    # and row_index is an integer index\n    row = ndarray[row_index]\n    return row\n", "model_name": "deepseek-v3"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = Array(n, sint)\n\nfor i in range(n):\n    a[i] = sint(i)\n", "response_1": "n = 10\na = Array(n, sint)\n\nfor i in range(n):\n    a[i] = sint(i)\n", "model_name": "deepseek-v3"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array (matrix) in MP-SPDZ\n    # Extract the row at the given index\n    array_row = ndarray[row_index]\n    return array_row\n", "response_1": "def array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    # Assuming ndarray is a 2D array and row_index is a valid index\n    array = Array(ndarray.sizes[1], ndarray.value_type)\n    for i in range(ndarray.sizes[1]):\n        array[i] = ndarray[row_index][i]\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler.types import Array, sint\n\n# Create a list of values\na_l = [0, 10, 20, 30, 40]\n\n# Convert the list to an MP-SPDZ Array\na = Array(len(a_l), sint)\nfor i in range(len(a_l)):\n    a[i] = sint(a_l[i])\n", "response_1": "# Define the array length\narray_length = 5\n\n# Initialize the array with the given values\na = Array(array_length, sint)\na[0] = sint(0)\na[1] = sint(10)\na[2] = sint(20)\na[3] = sint(30)\na[4] = sint(40)\n", "model_name": "deepseek-v3"}
{"test_name": "np_reshape", "response_0": "from Compiler import types\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape an array.\n    \"\"\"\n    # Assuming ndarray is a 1D array of sfix or sint types\n    # Reshape the array to the desired dimensions\n    reshaped_array = types.Array2D(m, n, ndarray.value_type)\n    \n    # Flatten the input array to copy values into the reshaped array\n    flat_array = ndarray.get_vector()\n    \n    # Copy values into the reshaped array\n    for i in range(m):\n        for j in range(n):\n            reshaped_array[i][j] = flat_array[i * n + j]\n    \n    return reshaped_array\n", "response_1": "def array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a numpy array.\n    \"\"\"\n    reshaped_array = Array(m, n, sfix)\n    for i in range(m):\n        for j in range(n):\n            reshaped_array[i][j] = ndarray[i * n + j]\n    return reshaped_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ones", "response_0": "# Define the length of the array\nn = 10\n\n# Initialize an array with zeros\na = Array(n, sint)\n\n# Fill the array with ones\n@for_range(n)\ndef _(i):\n    a[i] = 1\n", "response_1": "n = 10\na = Array(n, sint)\n@for_range(n)\ndef _(i):\n    a[i] = sint(1)\n", "model_name": "deepseek-v3"}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    # Assuming y is an array of secret-shared integers\n    for i in range(len(y)):\n        # If y[i] is 1, set it to 0; otherwise, keep it as is\n        y[i] = y[i] * (1 - (y[i] == 1))\n    return y\n", "response_1": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    for i in range(len(y)):\n        if y[i] == 1:\n            y[i] = 0\n    return y\n", "model_name": "deepseek-v3"}
{"test_name": "np_eye", "response_0": "n = 10\na = Array(n, Array(n, sgf2n))\n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sgf2n(1)\n        else:\n            a[i][j] = sgf2n(0)\n", "response_1": "n = 10\na = Array(n, Array(n, sint))\n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sint(1)\n        else:\n            a[i][j] = sint(0)\n", "model_name": "deepseek-v3"}
{"test_name": "np_diag", "response_0": "# Define the list of diagonal elements\na_l = [1, 3, 5, 2, 4, 6]\nn = len(a_l)\n\n# Initialize a 2D array (matrix) with zeros\na = Array(n, n, sint)\n\n# Set the diagonal elements\nfor i in range(n):\n    a[i][i] = a_l[i]\n\n# Now 'a' is the diagonal matrix with the elements from 'a_l'\n", "response_1": "# Define the list of diagonal elements\na_l = [1, 3, 5, 2, 4, 6]\n\n# Initialize the matrix with zeros\nsize = len(a_l)\na = [[0] * size for _ in range(size)]\n\n# Set the diagonal elements\nfor i in range(size):\n    a[i][i] = a_l[i]\n", "model_name": "deepseek-v3"}
{"test_name": "np_advanced_integer_indexing", "response_0": "# MP-SPDZ program for integer array indexing\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing an array from an integer array.\n    \"\"\"\n    # Initialize the return array\n    ret_array = Array(len(indices), sint)\n\n    # Loop through the indices and populate the return array\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n\n    return ret_array\n", "response_1": "# MP-SPDZ program for integer array indexing\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing a secret-shared array from a secret-shared integer array.\n    \"\"\"\n    # Initialize the return array\n    ret_array = Array(len(indices), sfix)\n    \n    # Loop through the indices and assign the corresponding values from the array\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    \n    return ret_array\n", "model_name": "deepseek-v3"}
