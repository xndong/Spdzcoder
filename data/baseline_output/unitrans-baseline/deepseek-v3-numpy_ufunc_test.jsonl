{"test_name": "cross_entropy_loss", "response_0": "from Compiler import types\n\ndef cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss.\n    y: a list of secret-shared fixed-point numbers.\n    \"\"\"\n    result = types.sfix(0)\n    for yi in y:\n        # Compute log(yi) using the fixed-point logarithm function\n        log_yi = types.sfix.log(yi)\n        # Multiply yi by log(yi) and accumulate the result\n        result -= yi * log_yi\n    return result\n", "response_1": "def cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss using secret-shared values.\n    \"\"\"\n    # Compute the natural logarithm of y\n    log_y = sfloat.log(y)\n    \n    # Multiply y with log(y)\n    y_log_y = y * log_y\n    \n    # Sum all elements in y_log_y\n    sum_y_log_y = sfloat.sum(y_log_y)\n    \n    # Return the negative of the sum\n    return -sum_y_log_y\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_square_sqrt", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Calculate the mean of the array\n    mean = types.sint.sum(array) / len(array)\n    \n    # Calculate the deviation from the mean\n    deviation = array - mean\n    \n    # Square the deviations\n    square = deviation * deviation\n    \n    # Calculate the mean of the squared deviations\n    square_mean = types.sint.sum(square) / len(square)\n    \n    # Calculate the square root of the mean of the squared deviations\n    rmsd = types.sint.sqrt(square_mean)\n    \n    return rmsd\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef compute_RMSD(array):\n    \"\"\"This function calculates the root mean square deviation.\"\"\"\n    # Calculate the mean\n    mean = types.sint(0)\n    for value in array:\n        mean += value\n    mean /= len(array)\n    \n    # Calculate the deviation\n    deviation = [value - mean for value in array]\n    \n    # Square the deviations\n    square = [value * value for value in deviation]\n    \n    # Calculate the mean of the squares\n    square_mean = types.sint(0)\n    for value in square:\n        square_mean += value\n    square_mean /= len(square)\n    \n    # Calculate the square root\n    rmsd = square_mean.sqrt()\n    \n    return rmsd\n", "model_name": "deepseek-v3"}
{"test_name": "logsumexp", "response_0": "def logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp in MP-SPDZ\n    \"\"\"\n    # Find the maximum value in the log_probs array\n    _max = max(log_probs)\n    \n    # Subtract the maximum value from each element in log_probs\n    ds = log_probs - _max\n    \n    # Compute the sum of the exponentials of the differences\n    exp_sum = sum(exp(ds))\n    \n    # Return the logsumexp result\n    return _max + log(exp_sum)\n", "response_1": "def logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp\n    \"\"\"\n    # Find the maximum value in the log_probs array\n    _max = max(log_probs)\n    \n    # Subtract the maximum value from each element in log_probs\n    ds = log_probs - _max\n    \n    # Compute the sum of the exponentials of the differences\n    exp_sum = sum(exp(ds))\n    \n    # Return the logsumexp result\n    return _max + log(exp_sum)\n", "model_name": "deepseek-v3"}
{"test_name": "binary_cross_entropy_loss", "response_0": "from Compiler import types\nfrom Compiler import floatingpoint\n\ndef binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss in MP-SPDZ.\n    \"\"\"\n    # Avoid log(0) by clipping y_hat\n    y_hat = types.sfix(y_hat)\n    y_hat = floatingpoint.if_else(y_hat == 0, types.sfix(0.001), y_hat)\n    y_hat = floatingpoint.if_else(y_hat == 1, types.sfix(1 - 0.001), y_hat)\n    \n    # Compute the binary cross-entropy loss\n    log_y_hat = floatingpoint.log2(y_hat)\n    log_one_minus_y_hat = floatingpoint.log2(1 - y_hat)\n    \n    loss = -floatingpoint.mean(y * log_y_hat + (1 - y) * log_one_minus_y_hat)\n    \n    return loss\n", "response_1": "def binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss in MP-SPDZ.\n    \"\"\"\n    # Ensure y_hat is not exactly 0 or 1 to avoid log(0)\n    y_hat = y_hat * (1 - 0.001) + 0.001\n    y_hat = y_hat * (1 - 0.001) + 0.001\n    \n    # Compute the logarithms\n    log_y_hat = log2(y_hat)\n    log_1_minus_y_hat = log2(1 - y_hat)\n    \n    # Compute the loss\n    loss = - (y * log_y_hat + (1 - y) * log_1_minus_y_hat)\n    \n    # Return the mean loss\n    return mean(loss)\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_less_equal", "response_0": "from util import if_else\nfrom Compiler.library import for_range\n\ndef compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is less than or equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of secret-shared values\n    less_eq = []\n    for i in range(len(arrayA)):\n        # Compute whether arrayA[i] <= arrayB[i]\n        less_eq.append(if_else(arrayA[i] <= arrayB[i], 1, 0))\n    return less_eq\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef compute_less_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e., whether arrayA is less than or equal to arrayB.\n    Both arrayA and arrayB are assumed to be lists of secret-shared integers.\n    \"\"\"\n    # Initialize an empty list to store the result\n    less_eq = []\n    \n    # Iterate over the elements of the arrays\n    for a, b in zip(arrayA, arrayB):\n        # Compute whether a is less than or equal to b\n        # In MP-SPDZ, this can be done by checking if b - a is non-negative\n        diff = b - a\n        is_less_equal = (diff >= 0)\n        less_eq.append(is_less_equal)\n    \n    return less_eq\n", "model_name": "deepseek-v3"}
{"test_name": "RMS_prop_step", "response_0": "from util import *\nfrom Compiler import *\n\ndef RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step.\n    \"\"\"\n    alpha = sfix(0.5)\n    beta = sfix(1.0)\n    s = [sfix.Array(len(grad)) for grad in grads]\n    \n    @for_range(len(grads))\n    def _(i):\n        grad = grads[i]\n        layer = layers[i]\n        s[i] = beta * s[i] + (1 - beta) * grad * grad\n        grad = alpha * (grad / (s[i].sqrt()))\n        layers[i] = layer + grad\n    \n    return layers\n", "response_1": "from util import if_else\nfrom Compiler.types import sfix, sfloat, Array\nfrom Compiler.library import for_range\n\ndef RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step.\n    \"\"\"\n    alpha = sfix(0.5)\n    beta = sfix(1.0)\n    s = Array(len(grads), sfix)\n    \n    @for_range(len(grads))\n    def _(i):\n        s[i] = beta * s[i] + (sfix(1) - beta) * grads[i] * grads[i]\n        grads[i] = alpha * (grads[i] / s[i].sqrt())\n        layers[i] = layers[i] + grads[i]\n    \n    return layers\n", "model_name": "deepseek-v3"}
{"test_name": "entropy", "response_0": "def entropy(y):\n    \"\"\"\n    Compute the entropy of the given array\n    \"\"\"\n    n = len(y)\n    sum_ = 0\n    unique_values = Array(n, y[0].type)\n    unique_count = 0\n\n    # Find unique values in the array\n    for i in range(n):\n        is_unique = True\n        for j in range(unique_count):\n            if y[i] == unique_values[j]:\n                is_unique = False\n                break\n        if is_unique:\n            unique_values[unique_count] = y[i]\n            unique_count += 1\n\n    # Calculate entropy\n    for i in range(unique_count):\n        v = 0\n        for j in range(n):\n            if y[j] == unique_values[i]:\n                v += 1\n        p = v / n\n        sum_ += -(p * log2(p))\n\n    return sum_\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef entropy(y):\n    \"\"\"\n    Compute the entropy of the given array\n    \"\"\"\n    n = len(y)\n    unique_values = list(set(y))\n    sum_ = types.sfix(0)\n    \n    for i in unique_values:\n        v = sum(1 for j in y if j == i)\n        p = v / n\n        sum_ += -p * (if_else(p == 0, 0, log2(p)))\n    \n    return sum_\n\ndef log2(x):\n    \"\"\"\n    Compute the base-2 logarithm of x\n    \"\"\"\n    return types.sfix.log2(x)\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_exp", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D array of secret-shared values.\"\"\"\n    # Compute the exponent of each element in the array\n    exp = Array(len(array), sfix)\n    for i in range(len(array)):\n        exp[i] = sfix.exp(array[i])\n    \n    # Compute the summation of the exponentiated values\n    summation = sfix(0)\n    for i in range(len(exp)):\n        summation += exp[i]\n    \n    # Compute the softmax values by dividing each exponentiated value by the summation\n    softmax = Array(len(array), sfix)\n    for i in range(len(exp)):\n        softmax[i] = exp[i] / summation\n    \n    return softmax\n", "response_1": "from util import if_else\nfrom Compiler.library import print_ln, for_range\nfrom Compiler.types import Array, cint, sfix\n\ndef compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D array.\"\"\"\n    # Compute the exponential of each element in the array\n    exp = Array(len(array), sfix)\n    for i in range(len(array)):\n        exp[i] = sfix.exp(array[i])\n    \n    # Compute the summation of the exponential values\n    summation = sfix(0)\n    for i in range(len(exp)):\n        summation += exp[i]\n    \n    # Compute the softmax values\n    softmax = Array(len(array), sfix)\n    for i in range(len(exp)):\n        softmax[i] = exp[i] / summation\n    \n    return softmax\n", "model_name": "deepseek-v3"}
{"test_name": "tanh", "response_0": "from Compiler import types\n\nclass Tanh:\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        return z.tanh()\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        tanh_x = x.tanh()\n        return 1 - tanh_x * tanh_x\n", "response_1": "class Tanh:\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        exp_z = exp(z)\n        exp_neg_z = exp(-z)\n        return (exp_z - exp_neg_z) / (exp_z + exp_neg_z)\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        tanh_x = self.fn(x)\n        return 1 - tanh_x * tanh_x\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_tan", "response_0": "from util import if_else\nfrom Compiler.library import print_ln\n\ndef taylor_tan(x):\n    \"\"\"Approximate tan(x) using Taylor series.\"\"\"\n    # Taylor series approximation for tan(x) around 0\n    # tan(x) \u2248 x + (x^3)/3 + (2x^5)/15 + (17x^7)/315 + ...\n    x_sq = x * x\n    x_cubed = x * x_sq\n    x_fifth = x_cubed * x_sq\n    x_seventh = x_fifth * x_sq\n    \n    tan_approx = x + (x_cubed / 3) + (2 * x_fifth / 15) + (17 * x_seventh / 315)\n    return tan_approx\n\ndef compute_tan(array):\n    \"\"\"This function calculates trigonometric tangent, element-wise.\"\"\"\n    tan_res = [taylor_tan(x) for x in array]\n    return tan_res\n\n# Example usage\narray = [0.1, 0.2, 0.3, 0.4]\ntan_results = compute_tan(array)\nfor res in tan_results:\n    print_ln(\"tan: %s\", res)\n", "response_1": "from math import *\nfrom Compiler.types import *\nfrom Compiler.library import *\n\ndef compute_tan(array):\n    \"\"\"This function calculates trigonometric tangent, element-wise.\"\"\"\n    tan_res = Array(len(array), sfix)\n    \n    @for_range(len(array))\n    def _(i):\n        x = array[i]\n        # Taylor series approximation for tan(x): x + x^3/3 + 2x^5/15 + ...\n        tan_x = x + (x ** 3) / 3 + (2 * x ** 5) / 15\n        tan_res[i] = tan_x\n    \n    return tan_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_greater", "response_0": "from Compiler import types\n\ndef compute_greater(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is greater than arrayB.\"\"\"\n    # Ensure both arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must be of the same length\"\n    \n    # Initialize an array to store the result\n    greater_res = types.Array(len(arrayA), types.sint)\n    \n    # Perform element-wise comparison\n    for i in range(len(arrayA)):\n        greater_res[i] = arrayA[i] > arrayB[i]\n    \n    return greater_res\n", "response_1": "from Compiler.types import Array, sfix\n\ndef compute_greater(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e. whether arrayA is greater than arrayB.\n    Both arrayA and arrayB are assumed to be of the same length and contain sfix values.\n    \"\"\"\n    greater_res = Array(len(arrayA), sbool)\n    for i in range(len(arrayA)):\n        greater_res[i] = arrayA[i] > arrayB[i]\n    return greater_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_maximum", "response_0": "from Compiler import types\n\ndef compute_maximum(arrayA, arrayB):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    # Assuming arrayA and arrayB are of the same length and type\n    max_ones = types.Array(len(arrayA), arrayA[0].__class__)\n    \n    for i in range(len(arrayA)):\n        max_ones[i] = (arrayA[i] > arrayB[i]).if_else(arrayA[i], arrayB[i])\n    \n    return max_ones\n", "response_1": "def compute_maximum(arrayA, arrayB):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    max_ones = Array(len(arrayA), sfix)\n    for i in range(len(arrayA)):\n        # Compute the maximum between arrayA[i] and arrayB[i]\n        max_ones[i] = (arrayA[i] > arrayB[i]).if_else(arrayA[i], arrayB[i])\n    return max_ones\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_log2", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_log2(array):\n    \"\"\"This function calculates the base-2 logarithm of each element in the input array.\"\"\"\n    log2_values = Array(len(array), sfix)\n    \n    for i in range(len(array)):\n        x = array[i]\n        log2 = sfix(0)\n        if x > 0:\n            # Approximate log2 using a series expansion or other method\n            # This is a placeholder for the actual implementation\n            log2 = sfix.log2(x)\n        log2_values[i] = log2\n    \n    return log2_values\n", "response_1": "from Compiler import types, library\n\ndef compute_log2(array):\n    \"\"\"This function calculates the base-2 logarithm of x in the input array.\"\"\"\n    log2_array = types.Array(len(array), types.sfix)\n    \n    for i in range(len(array)):\n        x = array[i]\n        log2 = library.log2(x)\n        log2_array[i] = log2\n    \n    return log2_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_absolute", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef obtain_absolute(array):\n    \"\"\"This function computes the absolute values of elements in a secret array.\"\"\"\n    abs_array = Array(len(array), sfix)\n    \n    for i in range(len(array)):\n        abs_array[i] = (array[i] >= 0).if_else(array[i], -array[i])\n    \n    return abs_array\n", "response_1": "from Compiler import types\n\ndef obtain_absolute(array):\n    \"\"\"\n    This function computes the absolute values of elements in a secret-shared array.\n    \n    Args:\n        array: A secret-shared array of sfix values.\n    \n    Returns:\n        A secret-shared array containing the absolute values of the input array.\n    \"\"\"\n    # Compute the absolute value by checking if the element is less than 0\n    # If true, multiply by -1, otherwise keep the value as is\n    absolute_array = array * (1 - 2 * (array < 0))\n    \n    return absolute_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arctan", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef arctan(x):\n    # This is a placeholder for the arctan implementation.\n    # You can replace this with a more accurate numerical approximation.\n    return x * (1 - x * x / 3)\n\ndef compute_arctan(array):\n    \"\"\"This function calculates the trigonometric inverse tangent, element-wise.\"\"\"\n    arctan_res = types.Array(len(array), types.sfix)\n    for i in range(len(array)):\n        arctan_res[i] = arctan(array[i])\n    return arctan_res\n", "response_1": "from Compiler import types\n\ndef compute_arctan(array):\n    \"\"\"This function calculates the trigonometric inverse tangent, element-wise.\"\"\"\n    # Polynomial approximation for arctan(x) for x in [-1, 1]\n    def arctan_approx(x):\n        # Coefficients for the polynomial approximation\n        a1 = 0.9998660\n        a3 = -0.3302995\n        a5 = 0.1801410\n        a7 = -0.0851330\n        a9 = 0.0208351\n        \n        x_sq = x * x\n        return x * (a1 + x_sq * (a3 + x_sq * (a5 + x_sq * (a7 + x_sq * a9))))\n    \n    # Apply the approximation to each element in the array\n    arctan_res = array.get_type().Array(len(array))\n    for i in range(len(array)):\n        x = array[i]\n        # Use the approximation for |x| <= 1, otherwise use arctan(x) = pi/2 - arctan(1/x)\n        if x < -1:\n            arctan_res[i] = -sfix.pi() / 2 - arctan_approx(1 / x)\n        elif x > 1:\n            arctan_res[i] = sfix.pi() / 2 - arctan_approx(1 / x)\n        else:\n            arctan_res[i] = arctan_approx(x)\n    \n    return arctan_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_log", "response_0": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_log(array):\n    \"\"\"This function calculates the natural logarithm for all elements in the input array.\"\"\"\n    nlog = sfloat.Array(len(array))\n    for i in range(len(array)):\n        nlog[i] = sfloat.log(array[i])\n    return nlog\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_log(array):\n    \"\"\"This function calculates the natural logarithm for all elements in the input array.\"\"\"\n    # Assuming the array is a list of sfix (secure fixed-point numbers)\n    log_array = Array(len(array), sfix)\n    \n    # Iterate over the array and compute the logarithm for each element\n    for i in range(len(array)):\n        log_array[i] = sfix.log(array[i])\n    \n    return log_array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_not_equal", "response_0": "from Compiler import types\n\ndef compute_not_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is not equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are lists of secret-shared integers\n    neq = [a != b for a, b in zip(arrayA, arrayB)]\n    return neq\n", "response_1": "def compute_not_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e., whether arrayA is not equal to arrayB.\n    Both arrayA and arrayB are lists of secret-shared values.\n    The function returns a list of secret-shared bits (0 or 1) indicating inequality.\n    \"\"\"\n    neq = [a != b for a, b in zip(arrayA, arrayB)]\n    return neq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_equal", "response_0": "def compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is equal to arrayB.\"\"\"\n    # Initialize an empty list to store the comparison results\n    eq = []\n    \n    # Iterate over the elements of the arrays\n    for a, b in zip(arrayA, arrayB):\n        # Perform the equality comparison and append the result to the list\n        eq.append(a == b)\n    \n    # Return the list of comparison results\n    return eq\n", "response_1": "from util import if_else\nfrom Compiler.types import sint, Array\n\ndef compute_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is equal to arrayB.\"\"\"\n    # Assuming arrayA and arrayB are of the same length and type\n    eq = Array(len(arrayA), sint)\n    for i in range(len(arrayA)):\n        eq[i] = if_else(arrayA[i] == arrayB[i], sint(1), sint(0))\n    return eq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_true_divide", "response_0": "# Assuming arrayA and arrayB are defined as lists of secret integers or fixed-point numbers\narrayA = [sint(10), sint(20), sint(30)]\narrayB = [sint(2), sint(4), sint(5)]\n\nresult = true_divide(arrayA, arrayB)\nprint_ln(\"Result: %s\", result)\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef true_divide(arrayA, arrayB):\n    \"\"\"\n    True divide between two secret-shared 1-d arrays in MP-SPDZ.\n    \"\"\"\n    # Assuming arrayA and arrayB are of type Array or sfixArray\n    n = len(arrayA)\n    result = types.Array(n, types.sfix)\n    \n    for i in range(n):\n        # Perform element-wise division\n        result[i] = arrayA[i] / arrayB[i]\n    \n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_greater_equal", "response_0": "from util import if_else\nfrom Compiler import types\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"\n    This function calculates the element-wise comparison, i.e., whether arrayA is greater than or equal to arrayB.\n    Both arrayA and arrayB are assumed to be lists of secret-shared integers or fixed-point numbers.\n    \"\"\"\n    # Ensure both arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must be of the same length\"\n    \n    # Initialize an empty list to store the result\n    greater_eq = []\n    \n    # Perform element-wise comparison\n    for a, b in zip(arrayA, arrayB):\n        # Compute whether a >= b\n        result = a >= b\n        greater_eq.append(result)\n    \n    return greater_eq\n", "response_1": "from util import if_else\nfrom Compiler.types import Array\n\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is greater than or equal to arrayB.\"\"\"\n    # Ensure both arrays have the same length\n    assert len(arrayA) == len(arrayB), \"Arrays must be of the same length\"\n    \n    # Initialize an array to store the results\n    greater_eq = Array(len(arrayA), 'b')\n    \n    # Perform element-wise comparison\n    for i in range(len(arrayA)):\n        greater_eq[i] = if_else(arrayA[i] >= arrayB[i], 1, 0)\n    \n    return greater_eq\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_negative", "response_0": "def negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    array = Array(len(arrayA), sfix)\n    for i in range(len(arrayA)):\n        array[i] = -arrayA[i]\n    return array\n", "response_1": "from Compiler import types\n\ndef negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    array = -arrayA\n    return array\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_power", "response_0": "# Assuming arrayA and arrayB are lists of secret integers\ndef power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    result = []\n    for x, y in zip(arrayA, arrayB):\n        # Initialize the result for this pair as 1\n        res = 1\n        # Multiply x by itself y times\n        for _ in range(y.reveal()):  # Reveal y to get the exponent\n            res = res * x\n        result.append(res)\n    return result\n", "response_1": "def power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    # Initialize an empty array to store the results\n    result = Array(len(arrayA), sint)\n\n    # Iterate over the elements of the arrays\n    for i in range(len(arrayA)):\n        x = arrayA[i]\n        y = arrayB[i]\n        # Compute x^y using a loop for exponentiation\n        power_result = sint(1)\n        for _ in range(y.reveal()):\n            power_result *= x\n        result[i] = power_result\n\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_exp2", "response_0": "def compute_exp2(array):\n    \"\"\"This function calculates 2**p for all p in the input array.\"\"\"\n    exp = Array(len(array), sfix)\n    for i in range(len(array)):\n        exp[i] = 2 ** array[i]\n    return exp\n", "response_1": "def compute_exp2(array):\n    \"\"\"This function calculates 2**p for all p in the input array.\"\"\"\n    exp = Array(len(array), sint)\n    for i in range(len(array)):\n        exp[i] = 2 ** array[i]\n    return exp\n", "model_name": "deepseek-v3"}
{"test_name": "cross_entropy_loss_class", "response_0": "# Assuming sfix is the secure fixed-point type in MP-SPDZ\nfrom Compiler.library import sfix, sfloat, sbitint, sbit, print_ln\n\nclass CrossEntropy:\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss securely.\n        y: secret-shared true labels\n        y_pred: secret-shared predicted probabilities\n        \"\"\"\n        # Compute the element-wise product of y and log2(y_pred)\n        log_y_pred = y_pred.log2()\n        cross_entropy = -sfix.sum(y * log_y_pred)\n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross-entropy loss securely.\n        y: secret-shared true labels\n        y_pred: secret-shared predicted probabilities\n        \"\"\"\n        n = len(y)\n        # Compute the gradient\n        grad = y_pred - y\n        # Normalize by the number of samples\n        grad = grad / sfix(n)\n        return grad\n", "response_1": "from Compiler import types\n\nclass CrossEntropy:\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss.\n        \"\"\"\n        # Compute the element-wise log2 of y_pred\n        log_y_pred = y_pred.log2()\n        \n        # Compute the element-wise product of y and log_y_pred\n        y_log_y_pred = y * log_y_pred\n        \n        # Sum the elements and negate the result\n        cross_entropy = -y_log_y_pred.sum()\n        \n        return cross_entropy\n\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross entropy loss.\n        \"\"\"\n        n = len(y)\n        \n        # Compute the gradient\n        grad = y_pred - y\n        \n        # Normalize the gradient by the number of samples\n        grad = grad / n\n        \n        return grad\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arccos", "response_0": "# Custom arccos approximation function\ndef custom_arccos(x):\n    # Implement a polynomial or numerical approximation of arccos(x)\n    # This is a placeholder and should be replaced with an actual approximation\n    return x  # Replace with actual approximation logic\n\ndef compute_arccos(array):\n    \"\"\"This function calculates the trigonometric inverse cosine, element-wise.\"\"\"\n    arccos_res = [custom_arccos(x) for x in array]\n    return arccos_res\n", "response_1": "# MP-SPDZ code for computing arccos of an array\ndef compute_arccos(array):\n    \"\"\"This function calculates the trigonometric inverse cosine, element-wise.\"\"\"\n    arccos_res = []\n    for x in array:\n        # Taylor series approximation for arccos(x)\n        # arccos(x) \u2248 \u03c0/2 - x - x^3/6 - x^5/40 - x^7/112 - ...\n        pi_half = sfix(3.14159265358979323846 / 2)\n        arccos_x = pi_half - x\n        term = x\n        for i in range(1, 10):  # Adjust the number of terms for better precision\n            term = term * x * x\n            arccos_x = arccos_x - term / (2 * i + 1)\n        arccos_res.append(arccos_x)\n    return arccos_res\n", "model_name": "deepseek-v3"}
{"test_name": "r2_score", "response_0": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score.\n    \"\"\"\n    # Compute the mean of y_test\n    mean_y_test = sum(y_test) / len(y_test)\n    \n    # Compute the total sum of squares\n    total_sum_squares = sum((y_test - mean_y_test)**2)\n    \n    # Compute the residual sum of squares\n    residual_sum_squares = sum((y_test - y_hat)**2)\n    \n    # Compute the r2 score\n    r2 = 1 - residual_sum_squares / total_sum_squares\n    \n    return r2\n", "response_1": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score.\n    \"\"\"\n    # Compute the mean of y_test\n    mean_y_test = sum(y_test) / len(y_test)\n    \n    # Compute the total sum of squares\n    total_sum_squares = sum((y_test - mean_y_test) ** 2)\n    \n    # Compute the residual sum of squares\n    residual_sum_squares = sum((y_test - y_hat) ** 2)\n    \n    # Compute the R\u00b2 score\n    r2 = 1 - (residual_sum_squares / total_sum_squares)\n    \n    return r2\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_arcsin", "response_0": "from Compiler.library import *\n\ndef compute_arcsin(array):\n    \"\"\"This function calculates an approximation of the trigonometric inverse sine, element-wise.\"\"\"\n    arcsin_res = Array(len(array), sfix)\n    \n    @for_range(len(array))\n    def _(i):\n        x = array[i]\n        # Polynomial approximation for arcsin(x) in the range [-1, 1]\n        # This is a simple approximation and can be refined for better accuracy\n        arcsin_res[i] = x + x**3 / 6 + 3 * x**5 / 40 + 5 * x**7 / 112\n    \n    return arcsin_res\n", "response_1": "from Compiler.library import *\nfrom Compiler.types import *\n\ndef compute_arcsin(array):\n    \"\"\"Approximate the arcsin function using a polynomial approximation.\"\"\"\n    # Define the polynomial coefficients for arcsin approximation\n    # This is a simple example; you may need a more accurate approximation depending on your use case\n    a0 = 1.0\n    a1 = 0.16666666666666666\n    a2 = 0.075\n    a3 = 0.044642857142857144\n\n    # Initialize the result array\n    arcsin_res = Array(len(array), sfix)\n\n    @for_range(len(array))\n    def _(i):\n        x = array[i]\n        # Compute the polynomial approximation: arcsin(x) \u2248 x + a1*x^3 + a2*x^5 + a3*x^7\n        x2 = x * x\n        x3 = x2 * x\n        x5 = x2 * x3\n        x7 = x2 * x5\n        arcsin_res[i] = x + a1 * x3 + a2 * x5 + a3 * x7\n\n    return arcsin_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_true_divide2", "response_0": "def true_divide(arrayA, arrayB):\n    \"\"\"Perform true division between two lists of secret-shared values.\"\"\"\n    res = []\n    for i in range(len(arrayA)):\n        res.append(arrayA[i] / arrayB[i])\n    return res\n", "response_1": "def true_divide(arrayA, arrayB):\n    \"\"\"True divide between two 1-dimensional arrays in MP-SPDZ.\"\"\"\n    res = Array(len(arrayA), sfix)\n    for i in range(len(arrayA)):\n        res[i] = arrayA[i] / arrayB[i]\n    return res\n", "model_name": "deepseek-v3"}
{"test_name": "square_error_loss", "response_0": "def square_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    # Compute the difference between y_pred and y\n    diff = y_pred - y\n    \n    # Compute the squared norm of the difference\n    squared_norm = diff * diff\n    \n    # Compute the square error loss (0.5 * squared norm)\n    loss = 0.5 * squared_norm\n    \n    return loss\n", "response_1": "def square_error(y, y_pred):\n    \"\"\"\n    Compute the square error loss in MP-SPDZ.\n    \"\"\"\n    # Compute the difference between y_pred and y\n    diff = y_pred - y\n    \n    # Compute the square of the difference\n    squared_diff = diff * diff\n    \n    # Sum the squared differences\n    sum_squared_diff = sum(squared_diff)\n    \n    # Multiply by 0.5 to get the final square error\n    return 0.5 * sum_squared_diff\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_less", "response_0": "def compute_less(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e., whether arrayA is less than arrayB.\"\"\"\n    less_res = []\n    for i in range(len(arrayA)):\n        less_res.append(arrayA[i] < arrayB[i])\n    return less_res\n", "response_1": "from Compiler.types import Array, sfix\nfrom Compiler.library import print_ln\n\ndef compute_less(arrayA, arrayB):\n    \"\"\"This function calculates the element-wise comparison, i.e. whether arrayA is less than arrayB.\"\"\"\n    # Assuming arrayA and arrayB are of the same length\n    less_res = Array(len(arrayA), sfix)\n    \n    for i in range(len(arrayA)):\n        less_res[i] = arrayA[i] < arrayB[i]\n    \n    return less_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_cos", "response_0": "# Define the Taylor series approximation for cosine function\ndef taylor_cos(x, terms=10):\n    \"\"\"Approximate cosine using Taylor series expansion.\"\"\"\n    result = 0\n    for n in range(terms):\n        term = (x ** (2 * n)) / factorial(2 * n)\n        if n % 2 == 0:\n            result += term\n        else:\n            result -= term\n    return result\n\n# Function to compute cosine element-wise on an array\ndef compute_cosine(array):\n    \"\"\"Calculate trigonometric cosine, element-wise.\"\"\"\n    cos_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        cos_res[i] = taylor_cos(array[i])\n    return cos_res\n", "response_1": "from math import cos\n\ndef compute_cosine(array):\n    \"\"\"This function calculates the trigonometric cosine, element-wise.\"\"\"\n    cos_res = Array(len(array), sfix)  # Initialize an array to store the cosine results\n    for i in range(len(array)):\n        cos_res[i] = cos(array[i])  # Compute cosine for each element\n    return cos_res\n", "model_name": "deepseek-v3"}
{"test_name": "np_ufunc_sin", "response_0": "from math import sin\n\ndef compute_sine(array):\n    \"\"\"This function calculates trigonometric sine, element-wise.\"\"\"\n    sin_res = Array(len(array), sfix)\n    for i in range(len(array)):\n        sin_res[i] = sin(array[i])\n    return sin_res\n", "response_1": "from util import if_else\nfrom Compiler import types\n\ndef compute_sine(array):\n    \"\"\"This function calculates the trigonometric sine, element-wise, using a Taylor series approximation.\"\"\"\n    result = types.Array(len(array), types.sfix)\n    for i in range(len(array)):\n        x = array[i]\n        # Taylor series approximation for sin(x): x - x^3/3! + x^5/5! - x^7/7! + ...\n        term1 = x\n        term2 = (x ** 3) / 6\n        term3 = (x ** 5) / 120\n        term4 = (x ** 7) / 5040\n        sin_x = term1 - term2 + term3 - term4\n        result[i] = sin_x\n    return result\n", "model_name": "deepseek-v3"}
{"test_name": "update_weights", "response_0": "def update_weights(m, A, X, Y):\n    \"\"\"\n    Update the weights and return the difference.\n    \"\"\"\n    # Assuming A, X, and Y are matrices represented as lists of lists\n    # and m is a scalar (integer or fixed-point)\n\n    # Initialize the result matrix dw with zeros\n    dw = [[sfix(0) for _ in range(len(X[0]))] for _ in range(len(X))]\n\n    # Perform the matrix multiplication and scalar multiplication\n    for i in range(len(X)):\n        for j in range(len(X[0])):\n            for k in range(len(A[0])):\n                dw[i][j] += X[i][k] * (A[k][j] - Y[k][j])\n            dw[i][j] = dw[i][j] * (1 / m)\n\n    return dw\n", "response_1": "# Assuming that m, A, X, and Y are secret-shared values\ndef update_weights(m, A, X, Y):\n    \"\"\"\n    Update the weights and return the difference securely.\n    \"\"\"\n    # Compute the dot product of X and (A - Y)\n    diff = A - Y\n    dot_product = X * diff\n\n    # Compute the average (1/m) * dot_product\n    dw = (1 / m) * dot_product\n\n    return dw\n", "model_name": "deepseek-v3"}
{"test_name": "toy_layer", "response_0": "from Compiler import types\n\ndef sigmoid(x):\n    return 1 / (1 + (-x).exp())\n\ndef toy_layer(input_data, weights, biases):\n    layer1_input = input_data.dot(weights[0]) + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    layer2_input = layer1_output.dot(weights[1]) + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    return layer2_output\n", "response_1": "from Compiler import types\n\ndef sigmoid(x):\n    return 1 / (1 + sfloat.exp(-x))\n\ndef dot_product(a, b):\n    result = sfloat(0)\n    for i in range(len(a)):\n        result += a[i] * b[i]\n    return result\n\ndef toy_layer(input_data, weights, biases):\n    # Layer 1\n    layer1_input = dot_product(input_data, weights[0]) + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    \n    # Layer 2\n    layer2_input = dot_product(layer1_output, weights[1]) + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    \n    return layer2_output\n", "model_name": "deepseek-v3"}
