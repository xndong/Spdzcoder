{"test_name": "move_to_end", "response_0": "from Compiler.types import sint, Array\n\ndef move_to_end(arr, index):\n    n = len(arr)\n    new_arr = Array(n, sint)\n    # Copy all elements up to 'index'\n    for i in range(index):\n        new_arr[i] = arr[i]\n    # Shift elements from 'index+1' to end down by one\n    for i in range(index, n - 1):\n        new_arr[i] = arr[i + 1]\n    # Move original element 'index' to the last position\n    new_arr[n - 1] = arr[index]\n    # Return the reconstructed array\n    return new_arr\n", "response_1": "def move_to_end(arr, index):\n    # arr is assumed to be an MP-SPDZ Array (or list-like structure) of secure or clear values\n    # index is assumed to be a clear integer within valid range (0 <= index < len(arr))\n\n    n = len(arr)\n    # Create a new Array of the same type and length\n    new_arr = Array(n, arr[0].type)\n\n    # Move all elements except the one at 'index'\n    for i in range(n - 1):\n        if i < index:\n            new_arr[i] = arr[i]\n        else:\n            new_arr[i] = arr[i + 1]\n\n    # Place the element at 'index' in the last position\n    new_arr[n - 1] = arr[index]\n    return new_arr\n", "model_name": "azure-openai-o1"}
{"test_name": "second_largest", "response_0": "def second_largest(arr):\n    n = len(arr)\n    for i in range(2, n):\n        c0 = arr[i] > arr[0]\n        c1 = arr[i] > arr[1]\n        # Secure OR, represented as c0 OR c1 = c0 + c1 - c0 * c1\n        cond = c0 + c1 - c0 * c1\n\n        # Determine which index to replace (0 if arr[0] < arr[1] else 1)\n        c2 = arr[0] < arr[1]\n\n        # Replace only under secure conditions\n        tmp0 = arr[0].if_else(arr[i], arr[0], cond * c2)\n        tmp1 = arr[1].if_else(arr[i], arr[1], cond * (1 - c2))\n\n        arr[0] = tmp0\n        arr[1] = tmp1\n\n    # Return the smaller of the two, which is the second largest overall\n    c3 = arr[0] < arr[1]\n    return arr[0].if_else(arr[0], arr[1], c3)\n", "response_1": "from Compiler.types import sint\n\ndef second_largest(arr):\n    # Loop from the third element, checking if it's larger than either\n    # of the first two, and if so, replace the smaller of those two.\n    for i in range(2, len(arr)):\n        cond1 = arr[i] > arr[0]\n        cond2 = arr[i] > arr[1]\n        # \"or\" in secure form\n        cond = cond1 + cond2 - cond1 * cond2\n\n        # Determine which is smaller vs bigger between arr[0] and arr[1]\n        c = arr[0] < arr[1]\n        smaller = c.if_else(arr[0], arr[1])\n        bigger = c.if_else(arr[1], arr[0])\n\n        # Potentially replace smaller with arr[i]\n        new_smaller = cond.if_else(arr[i], smaller)\n        new_bigger = bigger\n\n        # Reconstruct arr[0], arr[1] in correct order\n        arr_0 = c.if_else(new_smaller, new_bigger)\n        arr_1 = c.if_else(new_bigger, new_smaller)\n\n        # Apply these new arr[0] and arr[1] only when \"cond\" is True\n        arr[0] = cond.if_else(arr_0, arr[0])\n        arr[1] = cond.if_else(arr_1, arr[1])\n\n    # After the loop, return the smaller of the two stored elements\n    c = arr[0] < arr[1]\n    return c.if_else(arr[0], arr[1])\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    sbit ret = sbit(0)\n    for i in range(len(arr)):\n        ret = ret | arr[i]\n    return ret\n", "response_1": "# In MP-SPDZ, we can define a function using secret boolean shares (sbool).\n# This function returns True (as an sbool) if any element in 'arr' is True.\ndef exists_true(arr):\n    result = sbool(0)\n    for x in arr:\n        result = result | x\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_indicator", "response_0": "`\ndef array_indicator(arr):\n    # Assume arr is an Array of a secret type in MP-SPDZ, e.g. sfix or sint\n    # Here we use a specific predicator: (value > 0)\n    n = len(arr)\n    ret = sfix.Array(n)\n    for i in range(n):\n        # Example predicator: returns 1 if arr[i] > 0 else 0\n        # In MP-SPDZ, '>' returns a secret bit which can be converted to 0/1\n        ret[i] = arr[i] > 0\n    return ret\n", "response_1": "def array_indicator(arr, predicator):\n    # Create an empty list to store the result\n    ret = []\n    # For each element in the input array, apply the predicator function\n    # and collect the output into the result list.\n    for e in arr:\n        ret.append(predicator(e))\n    # Return the resulting array\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product", "response_0": "# Compute the inner product of two secure vectors in MP-SPDZ\ndef inner_product(vec1, vec2):\n    s = sint(0)\n    for x, y in zip(vec1, vec2):\n        s += x * y\n    return s\n", "response_1": "# This MP-SPDZ program reads two secure integer vectors of length n and computes their inner product.\n# No usage examples are provided here.\n\ndef inner_product(vec1, vec2):\n    temp_sum = sint(0)\n    for x, y in zip(vec1, vec2):\n        temp_sum += x * y\n    return temp_sum\n\nn = 3\nvec1 = [sint.get_input_from(0) for _ in range(n)]\nvec2 = [sint.get_input_from(0) for _ in range(n)]\n\nresult = inner_product(vec1, vec2)\nprint_ln(\"%s\", result.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift_2", "response_0": "from Compiler.types import sint, Array\n\ndef array_shift(a):\n    n = len(a)\n    shifted_array = Array(n, sint)\n    for i in range(n):\n        shifted_array[i] = a[(i - 1) % n]\n    return shifted_array\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef array_shift(a):\n    n = len(a)\n    shifted = Array(n, type(a[0]))\n    @for_range(n)\n    def _(i):\n        shifted[i] = a[(i - 1) % n]\n    return shifted\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_than_scalar", "response_0": "from Compiler.types import s_bit\nfrom Compiler.library import Array\n\ndef array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    ret = Array(n, s_bit)\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "response_1": "def array_greater_than_scalar(arr, bound):\n    n = len(arr)\n    # Assuming arr[i] and bound are secure types (e.g., sfix).\n    # Comparison returns a secure bit (sbit) in MP-SPDZ.\n    ret = [None] * n\n    for i in range(n):\n        ret[i] = arr[i] > bound\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises_2", "response_0": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    flag = [(arr[i] < arr[i+1]) for i in range(len(arr) - 1)]\n    count = 0\n    for f in flag:\n        count += f\n    return count\n", "response_1": "from Compiler.types import sint\n\ndef count_rises(arr):\n    n = len(arr)\n    count = sint(0)\n    for i in range(n - 1):\n        # Comparison result is a bit. Convert it to sint before adding.\n        count = count + (arr[i] < arr[i+1]).to_sint()\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    for i in range(len(arr)):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef choppy_plus_minus(arr):\n    # This function takes an array of secret or clear integers (arr)\n    # and returns a new array where elements at odd indices are incremented by 1\n    # and elements at even indices are decremented by 1.\n    n = len(arr)\n    res = [sint(0) for _ in range(n)]\n    \n    for i in range(n):\n        if i % 2 == 1:\n            res[i] = arr[i] + 1\n        else:\n            res[i] = arr[i] - 1\n\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_roots", "response_0": "from Compiler.types import sint\n\ndef how_many_roots(a, b, c):\n    # Compare a with 0\n    cond_a = a.equal(0)\n    # Compare b with 0\n    cond_b = b.equal(0)\n    # Compute the discriminant\n    d = b * b - 4 * a * c\n    # Conditions on the discriminant\n    cond_d_pos = d > 0\n    cond_d_zero = d.equal(0)\n    # If a == 0\n    res_if_a0 = cond_b.if_else(0, 1)\n    # If a != 0\n    res_else = cond_d_pos.if_else(2, cond_d_zero.if_else(1, 0))\n    # Combine both cases\n    return cond_a.if_else(res_if_a0, res_else)\n\na = sint.get_input_from(0)\nb = sint.get_input_from(0)\nc = sint.get_input_from(0)\n\nres = how_many_roots(a, b, c)\nprint_ln(\"%s\", res)\n", "response_1": "from Compiler.types import sint\n\ndef how_many_roots(a: sint, b: sint, c: sint) -> sint:\n    a_zero = (a == 0)\n    b_zero = (b == 0)\n    disc = b * b - 4 * a * c\n    disc_pos = (disc > 0)\n    disc_zero = (disc == 0)\n\n    tmp_if_a_zero = sint.if_else(b_zero, sint(0), sint(1))\n    tmp_else = sint.if_else(disc_pos, sint(2), sint.if_else(disc_zero, sint(1), sint(0)))\n\n    return sint.if_else(a_zero, tmp_if_a_zero, tmp_else)\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied", "response_0": "# In MP-SPDZ, functions cannot directly take or return other functions like in Python.\n# Hence, we explicitly define the predicate logic inside the function rather than passing it as an argument.\n\ndef count_satisfied(arr):\n    s = sint(0)\n    for i in range(len(arr)):\n        # Replace the line below with your desired condition:\n        condition = (arr[i] > sint(0))  # Example predicate: arr[i] > 0\n        \n        s = s + condition\n    return s\n", "response_1": "# This MP-SPDZ code illustrates how to replicate the Python function's\n# semantics for counting how many elements satisfy a given condition.\n# Here, arr is assumed to be a list of secure integer (sint) values.\n# The 'predicator' argument should be a function taking a sint and\n# returning a sint in {0, 1} (0 for \"not satisfied\", 1 for \"satisfied\").\n\ndef count_satisfied(arr, predicator):\n    ssum = s_int(0)\n    for e in arr:\n        ssum = ssum + predicator(e)\n    return ssum\n", "model_name": "azure-openai-o1"}
{"test_name": "traverse_and_sum", "response_0": "def traverse_and_sum(arr1, arr2):\n    from Compiler.types import sint\n    result_sum = sint(0)\n    for x, y in zip(arr1, arr2):\n        result_sum += x * y\n    return result_sum\n", "response_1": "def traverse_and_sum(arr1, arr2):\n    n = len(arr1)\n    s = sfix(0)\n    @for_range(n)\n    def _(i):\n        s += arr1[i] * arr2[i]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "array_round", "response_0": "def sfix_round(e):\n    \"\"\"\n    Rounds the secret fixed-point number e to the nearest integer \n    (half away from zero).\n    \"\"\"\n    half = sfix(0.5)\n    round_pos = (e + half).truncate()  # floor(e + 0.5) for non-negative\n    round_neg = (e - half).truncate()  # floor(e - 0.5) for negative\n    is_negative = e < 0\n    return is_negative.if_else(round_neg, round_pos)\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the secret fixed-point list arr \n    to the nearest integer.\n    \"\"\"\n    ret = []\n    for e in arr:\n        ret.append(sfix_round(e))\n    return ret\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import Trunc\n\ndef array_round(arr):\n    \"\"\"\n    Round every element in the secure array to the nearest integer using sfix and return sint values.\n    \"\"\"\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        is_neg = arr[i] < sfix(0)\n        abs_val = -arr[i].if_else(is_neg, arr[i])     # absolute value\n        temp = abs_val + sfix(0.5)                    # offset by 0.5\n        floored = Trunc(temp * 2**sfix.f, 2**sfix.f, sfix.f)\n        ret[i] = is_neg.if_else(-floored, floored)    # reapply original sign\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_greater_eq", "response_0": "def array_greater_eq(arr, brr, n):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i] >= brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = sint.Array(n)\n    for i in range(n):\n        ret[i] = (arr[i] >= brr[i])\n    return ret\n", "response_1": "def array_greater_eq(arr, brr):\n    from Compiler.types import sint\n    n = len(arr)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # (arr[i] >= brr[i]) yields a secret bit; 'if_else' maps that bit to 1 or 0 as a secret integer.\n        ret[i] = (arr[i] >= brr[i]).if_else(sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "indicate_negative", "response_0": "from Compiler.types import sint\n\ndef indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = [sint(0) for _ in arr]\n    for i in range(len(arr)):\n        ret[i] = (arr[i] < 0).if_else(sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.types import sint\nfrom Compiler.comparison import lt_sint\nfrom Compiler.library import if_else\n\ndef indicate_negative(arr):\n    n = len(arr)\n    zero = sint(0)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        cond = lt_sint(arr[i], zero)\n        ret[i] = if_else(cond, sint(1), sint(0))\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract_2", "response_0": "# MP-SPDZ translation for array_subtract\n\n# Note: This snippet assumes 'a' and 'b' are known-length arrays of sints.\n\ndef array_subtract(a, b):\n    la = len(a)\n    lb = len(b)\n    ret_size = max(la, lb)\n    ret = Array(ret_size, sint)\n\n    # Subtract elementwise for the overlapping range\n    common_len = min(la, lb)\n    for i in range(common_len):\n        ret[i] = a[i] - b[i]\n\n    # If there is a leftover in a, copy it\n    #   (this corresponds to padding the result with a's tail)\n    for i in range(common_len, la):\n        ret[i] = a[i]\n\n    # If there is a leftover in b, negate it\n    #   (this corresponds to padding the result negatively with b's tail)\n    for i in range(common_len, lb):\n        ret[i] = -b[i]\n\n    return ret\n", "response_1": "# In MP-SPDZ, we define a function that takes two sInt arrays a, b of known sizes lenA, lenB.\n# The result is an array of length max(lenA, lenB) whose elements are (a[i] - b[i]) if both i < length,\n# or simply the leftover from the longer array (with sign corrected) if i exceeds the shorter array size.\n\ndef array_subtract(a, b, lenA, lenB):\n    # Determine the maximum length (compile-time known).\n    L = max(lenA, lenB)\n    \n    # Create the result array.\n    ret = [sInt(0) for _ in range(L)]\n    \n    # Fill in the result.\n    for i in range(L):\n        # Safely read a[i] if i < lenA otherwise 0.\n        x = a[i] if i < lenA else sInt(0)\n        # Safely read b[i] if i < lenB otherwise 0.\n        y = b[i] if i < lenB else sInt(0)\n        # Elementwise subtraction with padding semantics.\n        ret[i] = x - y\n    \n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process", "response_0": "def array_process(arr, func):\n    \"\"\"\n    Process all elements in the input array of secure values with a given \n    function in MP-SPDZ. Both 'arr' and 'func' must handle secure types \n    (e.g., sints).\n    \"\"\"\n    return [func(e) for e in arr]\n", "response_1": "# CommonFunction.mpc\n\nfrom Compiler.types import sint\nfrom Compiler.library import for_range\n\n# Step 1: Define the operation you want to apply to each element.\ndef process_element(e):\n    # Replace this with the desired transformation, for example: e + 1\n    return e + 1\n\n# Step 2: Define your MP-SPDZ equivalent of the \"array_process\" function.\ndef array_process(arr):\n    \"\"\"\n    Process all elements in the input array using a defined function.\n    \"\"\"\n    length = len(arr)\n    # Step 3: Loop over the array and apply process_element.\n    for i in range(length):\n        arr[i] = process_element(arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift", "response_0": "# MP-SPDZ code translating the Python function 'array_shift'\n# which shifts a given array 'a' by one position to the right.\n# For example, [0,1,2] becomes [1,2,0].\nfrom Compiler.types import sint, Array, for_range\n\ndef array_shift(a):\n    n = len(a)\n    temp = a[n - 1]\n    @for_range(n - 1)\n    def _(i):\n        idx = n - 1 - i\n        a[idx] = a[idx - 1]\n    a[0] = temp\n    return a\n", "response_1": "# In MP-SPDZ, arrays are typically created using the Array class or similarly typed data structures.\n# The following code defines a function that shifts the elements of an array by one position:\n# last element moves to the front, and all other elements get shifted to the right.\n\ndef array_shift(a):\n    n = len(a) \n    # Create a new array of the same length and same type as the input array\n    shifted = Array(n, a[0].type)\n    \n    # Move the elements from a[i+1] to shifted[i]\n    for i in range(n - 1):\n        shifted[i] = a[i + 1]\n    \n    # Put the last element of a into the last element of shifted\n    shifted[n - 1] = a[0]\n    \n    return shifted\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_select", "response_0": "def compare_and_select(a, b):\n    # a and b are assumed to be arrays of secret-shared sint\n    n = len(a)\n    ret_array = [sint(0) for _ in range(n)]\n    for i in range(n):\n        # Compute a secret bit indicating if a[i] > b[i]\n        mask = a[i] > b[i]\n        # Conditionally select a[i] or b[i] based on the mask\n        ret_array[i] = mask.if_else(a[i], b[i])\n    return ret_array\n", "response_1": "from Compiler.types import sfix\n\ndef compare_and_select(a, b):\n    ret_array = []\n    for x, y in zip(a, b):\n        c = x > y\n        ret_array.append(c * x + (1 - c) * y)\n    return ret_array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    # Determine the length difference\n    pad_len = len(a) - len(b)\n    \n    # Pad the shorter array with sfix(0)\n    if pad_len > 0:\n        b += [sfix(0) for _ in range(pad_len)]\n    elif pad_len < 0:\n        a += [sfix(0) for _ in range(-pad_len)]\n    \n    # Perform element-wise subtraction\n    return [x - y for x, y in zip(a, b)]\n", "response_1": "from Compiler.types import sfix\n\ndef array_subtract(a, b, lenA, lenB):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the arrays is shorter than the other,\n    it will be padded with 0.\n    \"\"\"\n    length = max(lenA, lenB)\n    ret = [sfix(0) for _ in range(length)]\n    for i in range(length):\n        A = a[i] if i < lenA else sfix(0)\n        B = b[i] if i < lenB else sfix(0)\n        ret[i] = A - B\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "repeat_array", "response_0": "from Compiler.types import sfix, Array, sint\n\ndef repeat_array(c):\n    n = len(c)\n    repeated = Array(n * 2, sfix)\n    for i in range(n):\n        repeated[i] = c[i]\n        repeated[i + n] = c[i]\n    return repeated\n", "response_1": "from Compiler.types import sint, Array\n\ndef repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    size = len(c)\n    result = Array(2 * size, sint)\n    for i in range(size):\n        result[i] = c[i]\n        result[i + size] = c[i]\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "zeros", "response_0": "from Compiler.types import sfix\n\ndef zeros(num):\n    # Return an all-zero sfix array with length num.\n    return sfix.Array(num, sfix(0))\n", "response_1": "def zeros(num):\n    # Create an array of secret integers in MP-SPDZ\n    zeros_array = Array(num, sint)\n    for i in range(num):\n        zeros_array[i] = sint(0)\n    return zeros_array\n", "model_name": "azure-openai-o1"}
{"test_name": "clip", "response_0": "# We assume arr is an array of sfix, and lower_bound and upper_bound are sfix (or converted to sfix).\n# This function clips each element of arr to the interval [lower_bound, upper_bound].\n\ndef clip_value(x, lower_bound, upper_bound):\n    sbit cond_upper = x.gteq(upper_bound)\n    sbit cond_lower = x.lteq(lower_bound)\n    return cond_upper.if_else(upper_bound, cond_lower.if_else(lower_bound, x))\n\ndef clip(arr, lower_bound, upper_bound):\n    for i in range(len(arr)):\n        arr[i] = clip_value(arr[i], lower_bound, upper_bound)\n    return arr\n", "response_1": "def clip(arr, upper_bound, lower_bound):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = (arr[i] >= upper_bound).if_else(\n            upper_bound,\n            (arr[i] > lower_bound).if_else(arr[i], lower_bound)\n        )\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied_2", "response_0": "def count_satisfied(arr, predicator):\n    length = len(arr)\n    ssum = sfix(0)\n    for i in range(length):\n        ssum += predicator(arr[i])\n    return ssum\n", "response_1": "def count_satisfied(arr, predicator):\n    # Initialize a secure integer accumulator.\n    s = sint(0)\n\n    # Accumulate the result of the predicate application over the array.\n    for x in arr:\n        s += predicator(x)\n\n    # Return the total count of elements that satisfy the condition.\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_order_pair", "response_0": "# reverse_order_pair.mpc\n\n# In MP-SPDZ, we do not have numpy arrays or dynamic typing as in Python.\n# Instead, we rely on fixed-size secure arrays and loops.\n# Here, we assume a fixed length n for the secret-shared array.\n# Each element is provided as secure input (sint).\n\nn = 10\narr = [sint.get_input_from(0) for _ in range(n)]\n\ncount = sint(0)\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Compare secret-shared values; the result is also secret-shared (0 or 1).\n        count += (arr[i] > arr[j])\n\n# Reveal the count (the number of reverse order pairs) to all parties or a designated party.\nprint_ln(\"%s\", count.reveal())\n", "response_1": "from Compiler.types import sint\n\ndef reverse_order_pair(arr):\n    n = len(arr)\n    count = sint(0)\n    for i in range(n):\n        for j in range(i+1, n):\n            count += (arr[i] > arr[j])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_inc", "response_0": "def array_inc(arr, length):\n    # Increment each element in arr by 1\n    for i in range(length):\n        arr[i] += 1\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_inc(arr):\n    # arr is a list of sint\n    n = len(arr)\n    out = [sint(0) for _ in range(n)]\n    for i in range(n):\n        out[i] = arr[i] + 1\n    return out\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises", "response_0": "def count_rises(arr, length):\n    \"\"\"\n    Count the number of rises in the array using MP-SPDZ syntax.\n    \"\"\"\n    s_count = sint(0)\n    for i in range(length - 1):\n        s_count = s_count + (arr[i] < arr[i + 1])\n    return s_count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the secret-shared array arr.\n    \"\"\"\n    from Compiler.types import sint\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        count += (arr[i] < arr[i + 1])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_2", "response_0": "# array_process.mpc\n\ndef func(x):\n    # Example transformation function that increments each element\n    return x + 1\n\ndef array_process(arr):\n    \"\"\"\n    Process all elements in the input array with a predefined function 'func'.\n    Since MP-SPDZ does not support passing functions as parameters,\n    the transformation function is directly defined in this file.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        arr[i] = func(arr[i])\n    return arr\n", "response_1": "# In MP-SPDZ, we must first declare our types, e.g., using sfix or sint (secure integers, etc.).\n# For demonstration, we assume an array of secret integers (sint).\n\n# Define a function to process a single element. In Python, this would be \"func(x)\". \n# Here, we'll demonstrate a simple case such as incrementing x by 1.\ndef process_element(x):\n    return x + 1\n\n# Define a function to process every element in an array with the above operation:\ndef array_process(arr):\n    # Iterate over the array to process each element\n    for i in range(len(arr)):\n        arr[i] = process_element(arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt_fx\n\ndef two_norm(vector):\n    sq_sum = sfix(0)\n    for item in vector:\n        sq_sum += item * item\n    return sqrt_fx(sq_sum)\n", "response_1": "from Compiler.types import sfix\n\ndef two_norm(vec):\n    # Compute sum of squares\n    temp_sum = sfix(0)\n    for val in vec:\n        temp_sum += val * val\n    # Return the square root of the sum of squares\n    return temp_sum.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "totally_dominate", "response_0": "# In MP-SPDZ, secure values require specific handling for comparisons and\n# min/max operations. The following function assumes 'a' and 'b' are lists\n# of secret-shared integers (sint). Each comparison result is itself a\n# secret bit, which can then be used in if_else() to select the min or max.\n\ndef totally_dominate(a, b):\n    # Compute the minimum of array a\n    a_min = a[0]\n    for i in range(1, len(a)):\n        cond_min = a[i] < a_min\n        a_min = cond_min.if_else(a[i], a_min)\n    \n    # Compute the maximum of array b\n    b_max = b[0]\n    for i in range(1, len(b)):\n        cond_max = b[i] > b_max\n        b_max = cond_max.if_else(b[i], b_max)\n    \n    # Determine dominance (returns secure bit indicating True/False)\n    return a_min >= b_max\n", "response_1": "def totally_dominate(a, b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means any element in a is no smaller than any element in b.\n    Both 'a' and 'b' are lists of secure integers (sint).\n    \"\"\"\n    # Compute the minimum of array a in a secure manner\n    amin = a[0]\n    for i in range(1, len(a)):\n        is_less = a[i] < amin\n        amin = is_less.if_else(a[i], amin)\n\n    # Compute the maximum of array b in a secure manner\n    bmax = b[0]\n    for i in range(1, len(b)):\n        is_greater = b[i] > bmax\n        bmax = is_greater.if_else(b[i], bmax)\n\n    # Compare amin >= bmax, which yields a secure bit\n    return amin >= bmax\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product_2", "response_0": "def inner_product(vec1, vec2):\n    \"\"\"\n    Compute the inner product of the two secret-shared arrays.\n    \"\"\"\n    from Compiler.types import sint\n    summation = sint(0)\n    for x, y in zip(vec1, vec2):\n        summation += x * y\n    return summation\n", "response_1": "def inner_product(vec1, vec2):\n    # Initialize the sum as a secure fixed-point number (sfix).\n    summation = sfix(0)\n    # Accumulate the products of corresponding elements.\n    for i in range(len(vec1)):\n        summation += vec1[i] * vec2[i]\n    # Return the result as a secure value.\n    return summation\n", "model_name": "azure-openai-o1"}
{"test_name": "get_subarr_by_indices", "response_0": "def get_subarr_by_indices(a, indices):\n    ret = []\n    for idx in indices:\n        ret.append(a[idx])\n    return ret\n", "response_1": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    n = len(indices)\n    # Here we assume 'a' is an array of secure integers and 'indices' is an array of clear/regint indices\n    # Adjust the type below as needed for your specific MP-SPDZ data types (e.g., sfix, cint, etc.)\n    ret = [sint(0) for _ in range(n)]\n    for i in range(n):\n        ret[i] = a[indices[i]]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_5_or_7", "response_0": "def exists_5_or_7(arr):\n    # arr is assumed to be a list/array of secret shared integers (sint).\n    # The function returns a secret-shared boolean-like value (sbit or equivalent).\n    # It becomes 1 if there's any element equal to 5 or 7, otherwise 0.\n    temp = s_int(0)\n    for x in arr:\n        temp += (x == 5) + (x == 7)\n    return temp != 0\n", "response_1": "def exists_5_or_7(arr):\n    # arr is a list of secret-shared integers (sint).\n    found = sint(0)\n    for x in arr:\n        eq_5 = x.equal(5)  # Returns sbit\n        eq_7 = x.equal(7)  # Returns sbit\n        found = found + eq_5 + eq_7\n    # Returns an sbit indicating whether any element equals 5 or 7.\n    return found > 0\n", "model_name": "azure-openai-o1"}
{"test_name": "remove_by_index", "response_0": "def remove_by_index(arr, index):\n    # Assume arr is an array of sints (or a similar secret/shared type)\n    n = arr.size\n    ret = sint.Array(n - 1)\n    \n    @for_range(index)\n    def _(i):\n        ret[i] = arr[i]\n    \n    @for_range(n - index - 1)\n    def _(j):\n        ret[j + index] = arr[j + index + 1]\n    \n    return ret\n", "response_1": "def remove_by_index(arr, index):\n    n = len(arr)\n    new_array = [sint(0) for _ in range(n - 1)]\n    for i in range(n - 1):\n        if i < index:\n            new_array[i] = arr[i]\n        else:\n            new_array[i] = arr[i + 1]\n    return new_array\n", "model_name": "azure-openai-o1"}
{"test_name": "average", "response_0": "def average(arr):\n    s = sfix(0)\n    for x in arr:\n        s = s + x\n    length = sfix(len(arr))\n    ret = s / length\n    return ret\n", "response_1": "def average(arr):\n    from Compiler.types import sfix\n    summation = sfix(0)\n    for x in arr:\n        summation += x\n    length = sfix(len(arr))\n    ret = summation / length\n    return ret\n", "model_name": "azure-openai-o1"}
