{"test_name": "multiply_first_five", "response_0": "def multiply_first_five(array):\n    from Compiler.types import sint, regint\n\n    n = len(array)\n    prod = sint(1)\n    limit = n\n    if n > 5:\n        limit = 5\n    for i in range(limit):\n        prod *= array[i]\n    return prod\n", "response_1": "# In MP-SPDZ, loops cannot directly break on a secret-dependent condition,\n# and we often must rely on a publicly known limit or use conditionals\n# within fixed loops. A straightforward approach is to assume the length\n# of the array (\"size\") is known as a public integer (regint). Then we\n# determine the loop range in plain Python before entering the secure\n# loop structure.\n\ndef multiply_first_five():\n    # Read the size of the array (public input from party 0 in this example)\n    size = regint.get_input_from(0)\n    \n    # Read the array of secret values (e.g., sfix) from party 0\n    array = [sfix.get_input_from(0) for _ in range(size)]\n    \n    # Determine the actual loop limit in plain Python\n    # (if size < 5, use size, otherwise use 5)\n    loop_limit = 5\n    if size < 5:\n        loop_limit = size\n    \n    # Initialize product as secret-fixed 1\n    prod = sfix(1)\n    \n    # Loop up to the \"loop_limit\" in secure code\n    @for_range(loop_limit)\n    def _(i):\n        nonlocal prod\n        prod = prod * array[i]\n    \n    # Output the final product (secret write)\n    prod.store_out()\n", "model_name": "azure-openai-o1"}
{"test_name": "second_largest", "response_0": "from Compiler.types import sfix, If\n\ndef second_largest(arr):\n    # Initialize largest and second by comparing first two elements\n    largest = If(arr[0] >= arr[1], arr[0], arr[1])\n    second = If(arr[0] >= arr[1], arr[1], arr[0])\n    \n    length = len(arr)\n    # Iterate over the rest of the array\n    for i in range(length):\n        if i > 1:  # i is a public integer, so this check is done at compile time\n            # Check if current element is larger than 'largest'\n            cond_larger = arr[i] >= largest\n            # Update 'second'\n            new_second = If(cond_larger, largest, second)\n            new_second = If(~cond_larger & (arr[i] >= second), arr[i], new_second)\n            # Update 'largest'\n            largest = If(cond_larger, arr[i], largest)\n            # Commit updates\n            second = new_second\n    \n    return second\n", "response_1": "def second_largest(arr):\n    # Use secret comparison operations\n    cond_init = arr[0] >= arr[1]\n    largest = cond_init.if_else(arr[0], arr[1])\n    second = cond_init.if_else(arr[1], arr[0])\n    \n    # Start the loop from index 2\n    for i in range(2, len(arr)):\n        cond1 = arr[i] >= largest\n        temp_second = cond1.if_else(largest, second)\n        temp_largest = cond1.if_else(arr[i], largest)\n\n        # Only update second if arr[i] was NOT >= largest\n        # and arr[i] >= second\n        cond2a = arr[i] >= second\n        cond2 = cond2a * (1 - cond1)\n        new_second = cond2.if_else(arr[i], temp_second)\n\n        largest = temp_largest\n        second = new_second\n    \n    return second\n", "model_name": "azure-openai-o1"}
{"test_name": "partial_sum", "response_0": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of an MP-SPDZ array of secret-shared values.\n    \"\"\"\n    # Assuming arr is an array of secret-shared values (e.g., sfix or sint).\n    partial = arr[0].clear_type(0)  # Initialize partial with zero matching arr's underlying type\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n", "response_1": "def partial_sum(arr):\n    # Initialize a secure integer for accumulating the partial sum\n    partial = sint(0)\n    \n    # Iterate through the array, computing partial sums in place\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    \n    # Return the updated partial sums array\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "max_adjacent_product", "response_0": "def max_adjacent_product(arr):\n    # Initialize the current maximum product using the product of the first two elements\n    cur = arr[0] * arr[1]\n    \n    # Iterate through the array and update the maximum adjacent product\n    for i in range(1, len(arr)):\n        product = arr[i - 1] * arr[i]\n        cur = (product > cur).if_else(product, cur)\n    \n    return cur\n", "response_1": "from Compiler.types import sint, if_else\n\ndef max_adjacent_product(arr):\n    # arr is assumed to be a list/array of sints with length >= 2\n    n = len(arr)\n    cur = arr[0] * arr[1]\n    for i in range(n - 1):\n        product = arr[i] * arr[i + 1]\n        cur = if_else(product > cur, product, cur)\n    return cur\n", "model_name": "azure-openai-o1"}
{"test_name": "argmax", "response_0": "def argmax(a):\n    # Assume 'a' is a list of sfix\n    current = a[0]\n    index = sint(0)\n    for i in range(len(a)):\n        cond = current >= a[i]  # cond is an sbit (secure bit) from the comparison\n        index = cond.if_else(index, i)    # if cond=1 => index stays the same, else i\n        current = cond.if_else(current, a[i])  # if cond=1 => current stays the same, else a[i]\n    return index\n", "response_1": "from Compiler.types import sint\n\ndef argmax(a):\n    \"\"\"\n    Return the index of the max value of an array.\n    a is assumed to be a list of secure integers (sint).\n    \"\"\"\n    n = len(a)\n    index = sint(0)\n    current = a[0]\n    for i in range(1, n):\n        is_greater = (a[i] >= current)\n        index = is_greater.if_else(i, index)\n        current = is_greater.if_else(a[i], current)\n    return index\n", "model_name": "azure-openai-o1"}
{"test_name": "count_distinct", "response_0": "def count_distinct(arr):\n    # arr is a list of s_int\n    # The function returns a secure integer (s_int) representing\n    # the number of distinct values in 'arr'.\n    \n    n = len(arr)\n    counter = s_int(0)\n    for i in range(n):\n        unique = s_int(1)\n        for j in range(i):\n            # 'same' will be an s_bit that is 1 if arr[j] == arr[i], else 0\n            same = (arr[j] == arr[i])\n            # If they are the same, make 'unique' zero; otherwise keep it\n            unique = unique * (1 - same)\n        counter = counter + unique\n    \n    return counter\n", "response_1": "from Compiler.types import sint, Array\nfrom Compiler.library import for_range\n\ndef count_distinct(arr, n):\n    # arr is an Array of secret-shared integers (sint) of length n\n    # n is a public integer representing the length of arr\n    counter = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            # If arr[i] equals arr[j], unique becomes 0\n            unique = unique * (1 - (arr[i] == arr[j]))\n        counter = counter + unique\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_true", "response_0": "def exists_true(arr):\n    # Assume arr is a list of secure boolean bits (e.g., sbit)\n    # We initialize the accumulator to sbit(0) which represents False.\n    ret = sbit(0)\n    # Logical OR in MP-SPDZ can be done by ret + x - ret*x for bits.\n    for item in arr:\n        ret = ret + item - ret * item\n    return ret\n", "response_1": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    # Initialize the return variable as a secret bool 0\n    ret = sbit(0)\n    # Perform a logical OR across all elements in the array\n    for item in arr:\n        ret |= item\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "range", "response_0": "from Compiler.types import sint\n\ndef range(arr):\n    \"\"\"\n    Return the range of the array (list of sints).\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = max_value.max(item)\n        min_value = min_value.min(item)\n    return max_value - min_value\n", "response_1": "def range_spdz(arr):\n    # arr is an array of secret integers (sint)\n    max_val = arr[0]\n    min_val = arr[0]\n    # Iterate through the array to find secret max and min\n    for i in range(1, len(arr)):\n        c1 = (max_val >= arr[i])        # secret comparison result (0 or 1)\n        max_val = max_val * c1 + arr[i] * (1 - c1)\n\n        c2 = (min_val <= arr[i])        # secret comparison result (0 or 1)\n        min_val = min_val * c2 + arr[i] * (1 - c2)\n    # Return the secret range (max - min)\n    return max_val - min_val\n", "model_name": "azure-openai-o1"}
{"test_name": "count_larger_than_5", "response_0": "def count_larger_than_5(arr):\n    n = len(arr)\n    counter = sint(0)\n    for i in range(n):\n        condition = arr[i] > 5\n        counter = counter + condition\n    return counter\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef count_larger_than_5(arr):\n    # arr is assumed to be a list or array of secret integers (sint).\n    counter = sint(0)\n    for i in for_range(len(arr)):\n        condition = arr[i] > 5\n        counter = counter + condition\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_dominator", "response_0": "def exists_dominator(arr):\n    # Initialize secret variables for maximum and sum\n    maximum = sint(0)\n    total_sum = sint(0)\n    \n    # Compute the maximum absolute value and the sum of absolute values\n    for item in arr:\n        abs_val = item.abs()\n        is_bigger = abs_val > maximum\n        maximum = is_bigger.if_else(abs_val, maximum)\n        total_sum = total_sum + abs_val\n    \n    # Return comparison result as a secret bit\n    return (sint(2) * maximum) > total_sum\n", "response_1": "from Compiler.types import sint\n\n# Read the size of the secret-shared array\nn = sint.get_input_from(0)\n\n# Read the array elements as secret-shared inputs\narr = [sint.get_input_from(0) for _ in range(n)]\n\n# Initialize variables with secret-sharing types\nmax_val = sint(0)\nsum_val = sint(0)\n\n# Find the largest absolute value and the sum of absolute values\nfor item in arr:\n    abs_item = (item < 0).if_else(-item, item)\n    cond = abs_item.greater_than(max_val)\n    max_val = cond.if_else(abs_item, max_val)\n    sum_val = sum_val + abs_item\n\n# Check if the largest absolute value is strictly greater than the sum of the rest\nres = (max_val * 2).greater_than(sum_val)\n\n# Reveal the result (e.g., 1 if dominating element exists, otherwise 0)\nres.reveal()\n", "model_name": "azure-openai-o1"}
{"test_name": "greedy_picker", "response_0": "from Compiler.types import sint, sbit\n\ndef greedy_picker(items, captivity):\n    num = sint(0)\n    n = len(items)\n    for i in range(n):\n        can_pick = (items[i] <= captivity)\n        captivity = captivity - items[i] * can_pick\n        num = num + can_pick\n    return num\n", "response_1": "def greedy_picker(items, captivity):\n    \"\"\"\n    Translated MP-SPDZ code from the original Python function.\n    'items' is assumed to be a list/array of s_int.\n    'captivity' is an s_int representing the bag capacity.\n    \"\"\"\n    num = s_int(0)\n    for i in range(len(items)):\n        cond = items[i] <= captivity\n        captivity = cond.if_else(captivity - items[i], captivity)\n        num = cond.if_else(num + s_int(1), num)\n    return num\n", "model_name": "azure-openai-o1"}
{"test_name": "scalar_add_array", "response_0": "def scalar_add_array(s, l):\n    # In MP-SPDZ, \"s\" and elements of \"l\" can be secure types like \"sint\".\n    # We sum all elements of \"l\" into the scalar \"s\" in a loop and return the result.\n    for i in range(len(l)):\n        s = s + l[i]\n    return s\n", "response_1": "from Compiler.types import sint\n\ndef scalar_add_array(s, l):\n    # s is a secure integer, l is a list of secure integers\n    for item in l:\n        s = s + item\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "is_equidistant_seq", "response_0": "def is_equidistant_seq(arr):\n    arr_len = len(arr)\n    if arr_len <= 1:\n        return 1  # True as integer\n    d = 0\n    for i in range(arr_len - 1):\n        diff = arr[i + 1] - arr[i]\n        if i > 0 and diff != d:\n            return 0  # False as integer\n        d = diff\n    return 1  # True as integer\n", "response_1": "from Compiler.types import sfix, sbool\n\ndef is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence.\n    If the array has length 1 or 0, return True.\n    \"\"\"\n    n = len(arr)\n    # Initialize the return as True\n    eq = sbool(True)\n\n    # For arrays of size 0 or 1, no check needed\n    if n < 2:\n        return eq\n\n    d = sfix(0)\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        # Starting from the second difference comparison\n        if i > 0:\n            eq = eq & (diff == d)\n        d = diff\n\n    return eq\n", "model_name": "azure-openai-o1"}
{"test_name": "inner_product", "response_0": "def inner_product(vec1, vec2):\n    n = len(vec1)\n    sum_val = s_int(0)\n    for i in range(n):\n        sum_val += vec1[i] * vec2[i]\n    return sum_val\n", "response_1": "from Compiler.types import sint\n\ndef inner_product(vec1, vec2):\n    result = sint(0)\n    for i in range(len(vec1)):\n        result += vec1[i] * vec2[i]\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "more_distinct_nonnegative", "response_0": "def more_distinct_nonnegative(arr):\n    # MP-SPDZ translation of the logic for counting distinct negative vs nonnegative.\n    # In MP-SPDZ, comparisons produce shares of 0/1 rather than Python booleans.\n    # \"unique\" is tracked as 1 if arr[i] is distinct, otherwise 0.\n\n    n = len(arr)\n\n    # Initialize counters (secure integer shares).\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n\n    # Outer loop over all elements.\n    for i in range(n):\n        unique = sint(1)\n        # Inner loop to check if arr[i] is distinct with respect to any previous element.\n        for j in range(i):\n            is_equal = arr[i] == arr[j]\n            # If any element is equal, unique becomes 0.\n            unique = unique * (sint(1) - is_equal)\n\n        # Check if arr[i] >= 0. This yields a 1-share if true, 0-share if false.\n        is_nonnegative = arr[i] >= 0\n\n        # Add the element to the correct counter if it is unique.\n        nonnegative_counter = nonnegative_counter + unique * is_nonnegative\n        negative_counter = negative_counter + unique * (sint(1) - is_nonnegative)\n\n    # Compare final counters and return the result (secure boolean share).\n    return nonnegative_counter > negative_counter\n", "response_1": "def more_distinct_nonnegative(arr, n):\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n\n    for i in range(n):\n        unique = sint(1)\n        for j in range(i):\n            eq = (arr[i] == arr[j])\n            # If arr[i] equals arr[j], then unique becomes 0\n            unique = unique * (1 - eq)\n        ge0 = (arr[i] >= 0)\n        # Increase nonnegative_counter if unique and arr[i] >= 0; otherwise increase negative_counter\n        nonnegative_counter = nonnegative_counter + (unique * ge0)\n        negative_counter = negative_counter + (unique * (1 - ge0))\n\n    # Returns a secure bit indicating whether nonnegative_counter > negative_counter\n    return nonnegative_counter > negative_counter\n", "model_name": "azure-openai-o1"}
{"test_name": "flip_positives", "response_0": "def flip_positives(array, length):\n    @for_range(length)\n    def _(i):\n        condition = array[i] > 0\n        array[i] = sfix.if_else(condition, -array[i], array[i])\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        condition = array[i] > 0\n        array[i] = condition.if_else(-array[i], array[i])\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "divide_and_plus", "response_0": "from Compiler.types import sfix\n\ndef main():\n    x = sfix.get_input_from(0)\n    for i in range(4):\n        x = x / 2\n        x = x + 1\n    x.print_reveal()\n", "response_1": "from Compiler.types import sfix\n\ndef divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for _ in range(4):\n        x = x / sfix(2)\n        x = x + sfix(1)\n    return x\n", "model_name": "azure-openai-o1"}
{"test_name": "array_log2", "response_0": "from Compiler.types import sfix\n\ndef array_log2(arr):\n    for i in range(len(arr)):\n        arr[i] = arr[i].log2()\n    return arr\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import log_fx\n\ndef array_log2(arr):\n    \"\"\"\n    Securely compute the base-2 logarithm for each sfix element in arr.\n    \"\"\"\n    ln_2 = sfix(0.6931471805599453)  # constant for ln(2)\n    for i in range(len(arr)):\n        arr[i] = log_fx(arr[i]) / ln_2\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_to_ten", "response_0": "def sum_to_ten(a):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    # Using MP-SPDZ secure integer type\n    sum_ = sint(0)\n    done = sint(0)\n\n    # Accumulate until sum_ >= 10\n    for i in range(len(a)):\n        # Only add when not done\n        sum_ = sum_ + a[i] * (1 - done)\n        # Mark done once sum_ >= 10\n        done = done + (sum_ >= 10) * (1 - done)\n\n    return sum_\n", "response_1": "from Compiler.types import sint\nfrom Compiler.types import Array\nfrom Compiler.library import for_range\n\ndef sum_to_ten(array, length):\n    total_sum = sint(0)\n    done = sint(0)\n    for i in for_range(length):\n        cond = 1 - done\n        total_sum = total_sum + (cond * array[i])\n        done = done + (cond * (total_sum >= 10))\n    return total_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_plus_minus", "response_0": "def choppy_plus_minus(arr):\n    for i in range(len(arr)):\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "response_1": "def choppy_plus_minus(arr):\n    n = len(arr)\n    for i in range(n):\n        # i is a compile-time integer, so this check is public.\n        if i % 2 == 1:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "min_element", "response_0": "def min_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    current = a[0]\n    for item in a:\n        cond = item < current\n        current = cond.if_else(item, current)\n    return current\n", "response_1": "def min_element(a):\n    \"\"\"\n    Return the max value of an array.\n    \"\"\"\n    current = a[0]\n    for i in range(1, len(a)):\n        current = (a[i] < current).if_else(a[i], current)\n    return current\n", "model_name": "azure-openai-o1"}
{"test_name": "soft_max", "response_0": "from Compiler.types import sfix, Array\nfrom Compiler.library import exp\n\ndef soft_max(arr):\n    # Compute the sum of e^item over all items\n    denominator = sfix(0)\n    for i in range(len(arr)):\n        denominator += exp(arr[i])\n    \n    # Build the result array for the softmax values\n    brr = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        brr[i] = exp(arr[i]) / denominator\n    \n    return brr\n", "response_1": "from Compiler.types import sfix, Array\nfrom Compiler.library import exp\n\ndef soft_max(arr):\n    denominator = sfix(0)\n    for i in range(len(arr)):\n        denominator += exp(arr[i])\n    brr = Array(len(arr), sfix)\n    for i in range(len(arr)):\n        brr[i] = exp(arr[i]) / denominator\n    return brr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_reverse_pair_with_break", "response_0": "def main():\n    n = regint.get_input_from(0)              # read array length as public integer\n    arr = [regint.get_input_from(0) for _ in range(n)]  # read the array as public integers\n    \n    count = regint(0)\n    for i in range(1, n):\n        if arr[i] > 10:\n            break\n        for j in range(i):\n            if arr[j] > arr[i]:\n                count = count + 1\n\n    print_ln('%s', [count])\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range, if_, do_break, end_if\n\ndef count_reverse_pair_with_break(arr, n):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    arr: an array (list) of sint\n    n: the integer length of the array\n    \"\"\"\n    count = sint(0)\n    @for_range(1, n)\n    def outer_loop(i):\n        with if_(arr[i] > 10):\n            do_break()\n        end_if\n        @for_range(i)\n        def inner_loop(j):\n            with if_(arr[j] > arr[i]):\n                count = count + 1\n            end_if\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_unique", "response_0": "from Compiler.types import sint\n\ndef sum_unique(arr):\n    n = len(arr)\n    s = sint(0)\n    for i in range(n):\n        unique = sint(1)\n        for j in range(n):\n            # Convert secure bit comparison to a secure integer.\n            eq = (arr[i] == arr[j]).if_else(sint(1), sint(0))\n            # Multiply 'unique' by (1 - eq*(i != j)).\n            unique *= (1 - eq * int(i != j))\n        s += arr[i] * unique\n    return s\n", "response_1": "def sum_unique(arr):\n    n = len(arr)\n    sum_val = sfix(0)\n    for i in range(n):\n        unique = sfix(1)\n        for j in range(n):\n            if j != i:  # j and i are public indices, so this check is done in clear\n                eq_val = (arr[j] == arr[i])  # eq_val is secret\n                unique *= (sfix(1) - eq_val) # If arr[j] equals arr[i], make unique=0\n        sum_val += arr[i] * unique         # Add arr[i] only if it's unique\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "check_sum", "response_0": "from Compiler.types import sint\n\ndef check_sum(array, target):\n    sum_val = sint(0)\n    for num in array:\n        sum_val = sum_val + num\n    return sum_val == target\n", "response_1": "def check_sum(array, target):\n    # Initialize a secret integer variable to accumulate the sum\n    temp_sum = sint(0)\n\n    # Iterate over the secret integer list\n    for num in array:\n        temp_sum = temp_sum + num\n\n    # Compare secret-sum with the secret target, yielding a secret bit\n    return temp_sum == target\n", "model_name": "azure-openai-o1"}
{"test_name": "prod", "response_0": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array.\n    \"\"\"\n    # Initialize a secure integer product as 1\n    product = sint(1)\n\n    # Multiply each element into the product\n    for num in array:\n        product *= num\n\n    # Return the final product\n    return product\n", "response_1": "def prod(array):\n    # MP-SPDZ function to multiply all secret-shared integers in an array\n    p = sint(1)\n    for num in array:\n        p = p * num\n    return p\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_till_negative", "response_0": "from Compiler.types import sfix\n\ndef sum_till_negative(array):\n    n = len(array)\n    done = sfix(1)\n    total_sum = sfix(0)\n    for i in range(n):\n        negative = array[i] < sfix(0)\n        total_sum += array[i] * done\n        done = done * (1 - negative)\n    return total_sum\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef sum_till_negative(array):\n    # sum from the first element in the array until a negative one occurs\n    s = sint(0)\n    flag = sint(1)\n    for i in range(len(array)):\n        cond = array[i] < 0\n        cond_int = cond.if_else(sint(1), sint(0))\n        not_cond_int = 1 - cond_int\n        s = s + array[i] * flag * not_cond_int\n        flag = flag * not_cond_int\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "count_satisfied", "response_0": "def count_satisfied(arr, predicator):\n    \"\"\"\n    Count the number of elements in the array that satisfies the predicator \n    in MP-SPDZ code.\n    \"\"\"\n    count_s = sint(0)\n    for i in range(len(arr)):\n        count_s = count_s + predicator(arr[i])\n    return count_s\n", "response_1": "from Compiler.types import sint\n\ndef count_satisfied(arr, predicator):\n    \"\"\"\n    Counts how many elements in 'arr' satisfy 'predicator'.\n    'arr' should be a list/array of secure types (e.g., sint),\n    and 'predicator' is a function returning a secure boolean (0 or 1).\n    \"\"\"\n    count = sint(0)\n    for x in arr:\n        count += predicator(x)\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "standard_deviation", "response_0": "from Compiler.types import sfix, cfix\n\ndef standard_deviation(arr):\n    length = cfix(len(arr))\n    average = sfix(0)\n    for item in arr:\n        average += item / length\n    variance = sfix(0)\n    for item in arr:\n        diff = item - average\n        variance += (diff * diff) / length\n    return variance.sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef standard_deviation(arr):\n    length = sfix(len(arr))\n    average = sfix(0)\n    for item in arr:\n        average += item / length\n\n    variance = sfix(0)\n    for item in arr:\n        diff = item - average\n        variance += (diff * diff) / length\n\n    return variance.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "dominate", "response_0": "def dominate(a, b):\n    # 'a' and 'b' are secure arrays of the same length\n    # We use 'sbit(1)' to initialize the return value as 'True' in secure form.\n    ret = sbit(1)\n    for i in range(len(a)):\n        # Compare a[i] and b[i] in secure form.\n        # The expression (a[i] >= b[i]) produces a secure bit.\n        # We combine it with the accumulated 'ret' using bitwise AND.\n        ret = ret & (a[i] >= b[i])\n    # 'ret' is 1 if a[i] >= b[i] for all positions i, otherwise 0.\n    return ret\n", "response_1": "def dominate(a, b, n):\n    # a and b are arrays of secure integers (sint)\n    # n is their length\n    # This function returns an sbit that indicates (1/True) if\n    # a dominates b and (0/False) otherwise.\n    ret = sbit(1)\n    for i in range(n):\n        ret = ret & (a[i] >= b[i])\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "rescale", "response_0": "def rescale(brr):\n    from Compiler.types import sfix\n    from Compiler.library import if_else\n    \n    max_abs = sfix(0)\n    # Find the maximum absolute value\n    for i in range(len(brr)):\n        abs_val = if_else(brr[i] < 0, -brr[i], brr[i])\n        is_bigger = abs_val > max_abs\n        max_abs = if_else(is_bigger, abs_val, max_abs)\n\n    # Rescale each element by the maximum absolute value\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n\n    return brr\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else, abs_sfix\n\ndef rescale(brr):\n    \"\"\"\n    Rescales the secure array brr to fit into [-1, 1].\n    Assumes brr contains sfix elements and is non-empty with no zero element.\n    \"\"\"\n    max_abs = sfix(0)\n    # Find the maximum absolute value\n    for i in range(len(brr)):\n        current_abs = abs_sfix(brr[i])\n        condition = current_abs > max_abs\n        max_abs = if_else(condition, current_abs, max_abs)\n    # Divide each element by the maximum absolute value\n    for i in range(len(brr)):\n        brr[i] = brr[i] / max_abs\n    return brr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_minus7", "response_0": "from Compiler.library import for_range\n\ndef array_minus7(arr, size):\n    @for_range(size)\n    def _(i):\n        arr[i] = arr[i] - 7\n    return arr\n", "response_1": "# In MP-SPDZ, arrays typically use secure integer types (e.g., sint), \n# and loops are often expressed with decorators such as @for_range.\n# Below is a direct translation of the Python function logic into MP-SPDZ style:\n\ndef array_minus7(arr, size):\n    @for_range(size)\n    def subtract_seven(i):\n        arr[i] = arr[i] - 7\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "traverse_and_sum", "response_0": "# Step-by-step MP-SPDZ translation of the Python function:\n\n# Step 1: Import the secure integer type\nfrom Compiler.types import sint\n\n# Step 2: Define the function that sums all pairwise products of two arrays\ndef traverse_and_sum(arr1, arr2):\n    # Initialize sum as secret integer zero (instead of a plain Python integer)\n    total = sint(0)\n    \n    # Step 3: Loop through each element in the first secret-shared array\n    for x in arr1:\n        # Step 4: Nested loop through each element in the second secret-shared array\n        for y in arr2:\n            # Step 5: Update the total with the product of the current pair\n            total = total + x * y\n    \n    # Step 6: Return the final secret-shared sum\n    return total\n", "response_1": "from Compiler.types import sint\n\ndef traverse_and_sum(arr1, arr2):\n    # Initialize the secret-shared sum\n    total = sint(0)\n    \n    # Nested loops to accumulate the product of all pairwise elements\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            total = total + arr1[i] * arr2[j]\n            \n    # Return the secret-shared sum\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "longest_nondec_subseq", "response_0": "# longest_nondec_subseq.mpc\n# This MP-SPDZ program reads secret-shared integers from Player 0 and\n# computes the length of the longest non-decreasing subsequence.\n\nfrom Compiler.types import sint, regint, if_statement, if_ELSE\n\ndef main():\n    # Read the length of the input array (public integer).\n    n = regint.get_input_from(0)\n\n    # Read the array of secret-shared integers from Player 0.\n    a = [sint.get_input_from(0) for _ in range(n)]\n\n    max_length = sint(0)\n    cur_length = sint(0)\n\n    # Loop over the array, replicating the same logic with secure conditionals.\n    for i in range(n):\n        with if_statement(i == 0):\n            # For the first element, just set current length to 1.\n            cur_length = sint(1)\n        with if_statement(i > 0):\n            # Compare a[i] with a[i-1] in secure form.\n            comp = (a[i] >= a[i - 1])  # Secret boolean (0/1).\n            \n            # If a[i] >= a[i - 1], increment cur_length.\n            # Else, update max_length and reset cur_length to 1.\n            new_cur_if_true = cur_length + 1\n            new_cur_if_false = sint(1)\n            updated_cur_length = if_ELSE(comp, new_cur_if_true, new_cur_if_false)\n\n            # For the max_length update:\n            # If comp is false, we first compare max_length with the old cur_length.\n            cond_max = (max_length >= cur_length)\n            max_len_if_false = if_ELSE(cond_max, max_length, cur_length)\n            max_len_if_true  = max_length\n\n            # Use comp to conditionally choose whether we update max_length now or not.\n            updated_max_length = if_ELSE(comp, max_len_if_true, max_len_if_false)\n\n            # Apply the new values to our tracking variables.\n            cur_length = updated_cur_length\n            max_length = updated_max_length\n\n    # After the loop, compare once more to finalize the maximum.\n    cond_final = (max_length >= cur_length)\n    max_length = if_ELSE(cond_final, max_length, cur_length)\n\n    # Print the result in the clear.\n    max_length.print_reg()\n", "response_1": "from Compiler.types import sint\n\ndef longest_nondec_subseq(a):\n    # a is a list/array of sints\n    n = len(a)\n\n    max_length = sint(0)\n    cur_length = sint(0)\n\n    for i in range(n):\n        # The check i == 0 is made at compile time, hence a plain Python if is okay here\n        if i == 0:\n            cur_length = sint(1)\n        else:\n            # cond is a secure condition indicating whether a[i] >= a[i-1]\n            cond = a[i] >= a[i - 1]\n\n            # Choose the next value for cur_length based on cond\n            next_cur_length = cond.if_else(cur_length + sint(1), sint(1))\n\n            # If cond is false (0), need to update max_length before resetting cur_length\n            update_cond = sint(1) - cond  # 1 if a[i] < a[i-1], else 0\n            bigger = max_length >= cur_length\n            new_max_length = bigger.if_else(max_length, cur_length)\n            max_length = update_cond.if_else(new_max_length, max_length)\n\n            # Finally assign the new value of cur_length\n            cur_length = next_cur_length\n\n    # Final update of max_length after the loop\n    bigger = max_length >= cur_length\n    max_length = bigger.if_else(max_length, cur_length)\n\n    return max_length\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_but_skip_biggest", "response_0": "# Step 1: Read the size of the array\nn = cint.input()\n\n# Step 2: Create the array of sfix\narray = sfix.Array(n)\nfor i in range(n):\n    array[i] = sfix.input()\n\n# Step 3: Initialize sum_val and biggest\nsum_val = sfix(0)\nbiggest = array[0]\n\n# Step 4: Loop through the array and update sum or biggest\nfor i in range(n):\n    is_bigger = array[i] >= biggest\n    @if is_bigger:\n        biggest = array[i]\n    @else:\n        sum_val += array[i]\n\n# Step 5: Output the result\nsum_val.output()\n", "response_1": "from Compiler.types import sfix, if_else\n\ndef sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element encountered so far.\n    \"\"\"\n    n = len(array)\n    sum_val = sfix(0)\n    biggest = array[0]\n    for i in range(n):\n        cond = array[i] >= biggest\n        biggest = if_else(cond, array[i], biggest)\n        sum_val = sum_val + if_else(cond, sfix(0), array[i])\n    return sum_val\n", "model_name": "azure-openai-o1"}
{"test_name": "second_test", "response_0": "def second_test(arr):\n    ssum = sint(0)\n    for i in range(1, len(arr)):\n        ssum = ssum + (arr[0] < arr[i])\n    return ssum.equal(1)\n", "response_1": "from Compiler.types import sint\n\ndef second_test(arr):\n    count = sint(0)\n    for i in range(1, len(arr)):\n        count += (arr[0] < arr[i]).if_else(sint(1), sint(0))\n    return (count == 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "Manhattan_distance", "response_0": "def Manhattan_distance(a, b):\n    ret = sfix(0)\n    for i in range(len(a)):\n        diff = a[i] - b[i]\n        ret = ret + diff.abs()\n    return ret\n", "response_1": "def Manhattan_distance(a, b, n):\n    # a and b should be arrays (or lists) of secure type (e.g., sint or sfix).\n    # n is the length of the arrays.\n    ret = sint(0)\n    for i in range(n):\n        diff = a[i] - b[i]\n        ret += diff.abs()\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "deal_with_only_positive", "response_0": "# MP-SPDZ code translating the Python function \"deal_with_only_positive\"\n\nfrom Compiler.types import sfix\n\ndef deal_with_only_positive(arr):\n    \"\"\"\n    Add and subtract the positive elements in arr to produce a partial sum.\n    Non-positive elements are skipped.\n    \"\"\"\n    n = len(arr)\n    sign = sfix(1)\n    s = sfix(0)\n    for i in range(n):\n        cond = arr[i] > sfix(0)\n        s = s + cond * (sign * arr[i])\n        sign = (1 - cond) * sign + cond * (-sign)\n    return s\n", "response_1": "def deal_with_only_positive(array):\n    # array is expected to be a list or vector of sfix\n    s = sfix(0)\n    sign = sfix(1)\n    for i in range(len(array)):\n        is_positive = array[i] > 0\n        s = s + is_positive * sign * array[i]\n        sign = sign * (1 - 2 * is_positive)\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "compare_and_return", "response_0": "from Compiler.types import sint\n\ndef compare_and_return(arr, brr):\n    n = len(arr)\n    ret = sint(-1)\n    found = sint(0)\n    for i in range(n):\n        eq_i = arr[i].equal(brr[i])        # eq_i is an sbit representing if arr[i] == brr[i]\n        eq_i_sint = eq_i.cast_sint()       # cast sbit to sint (0 or 1)\n        update = eq_i_sint * (sint(1) - found)\n        # If still not found (found==0) and eq_i==1, set ret = i\n        ret = ret + (sint(i) - ret) * update\n        # Mark found as soon as a match is detected\n        found = found + update\n    return ret\n", "response_1": "# In MP-SPDZ, all comparisons and conditional assignments based on secret data\n# must be handled using secure operations without data-dependent control flow.\n# Below is an example translation of the Python compare_and_return function\n# into MP-SPDZ-style pseudocode operating on secret-shared integers (sint).\n\ndef compare_and_return(arr, brr, n):\n    # Initialize return value and a flag indicating whether we've found a match\n    ret = sint(-1)\n    found = sint(0)\n\n    # Loop through indices from 0 to n-1\n    for i in range(n):\n        # Securely check if arr[i] equals brr[i] AND we have not yet found a match\n        cond = arr[i].equal(brr[i]) * (1 - found)\n\n        # Update 'ret' only when cond is 1 (i.e., first match found)\n        ret = ret + cond * (i - ret)\n\n        # Once a match is found, set 'found' to 1 so no further updates occur\n        found = found + cond\n\n    # Return the first matching index (-1 if none matched)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_odd_positive", "response_0": "def sum_odd_positive(arr):\n    s = sint(0)\n    for item in arr:\n        cond_odd = item & 1\n        cond_positive = item > 0\n        s = s + item * cond_odd * cond_positive\n    return s\n", "response_1": "def sum_odd_positive(arr):\n    s = sint(0)\n    n = len(arr)\n    for i in range(n):\n        item = arr[i]\n        is_odd = (item % 2).equal(sint(1))\n        is_positive = item > 0\n        s += item * is_odd * is_positive\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "two_sum", "response_0": "def two_sum(secret_arr, secret_target):\n    n = len(secret_arr)\n    # 'found' is initialized to secret bit 0 (False).\n    found = sbit(0)\n    # Double nested loop to check all pairs for matching sum.\n    for i in range(n):\n        for j in range(n):\n            # Check if secret_arr[i] + secret_arr[j] equals the secret_target.\n            eq = (secret_arr[i] + secret_arr[j]).equal(secret_target)\n            # Update the 'found' bit with an OR operation.\n            found = found.or_(eq)\n    return found\n", "response_1": "# This MP-SPDZ program replicates the two_sum functionality from the given Python code.\n# It reads a secret-shared array 'arr' of size n, reads a secret-shared target,\n# and then checks whether any two elements in 'arr' (allowing the same element twice)\n# sum up to the target. It finally reveals the result (0/1).\n\nn = 4\narr = [sfix.get_input_from(i) for i in range(n)]\ntarget = sfix.get_input_from(n)\n\nfound = sbit(0)\nfor i in range(n):\n    for j in range(n):\n        eq = (arr[i] + arr[j]) == target\n        found = found.bit_or(eq)\n\nresult = found.reveal()\nprint_ln(\"Result: %s\", result)\n", "model_name": "azure-openai-o1"}
{"test_name": "seq_search", "response_0": "# seq_search.mpc\n# MP-SPDZ translation of the seq_search function.\n\nfrom Compiler.types import sint\n\ndef seq_search(arr, target):\n    # Initialize found_index to -1\n    found_index = sint(-1)\n    # Iterate through arr\n    for i in range(len(arr)):\n        # Compare arr[i] with target\n        cond = (arr[i] == target)\n        # If equal, update found_index to i\n        found_index = cond.if_else(i, found_index)\n    # Return the index if found, -1 otherwise\n    return found_index\n", "response_1": "# seq_search.mpc\n\nn = sint.get_input_from(0)\narr = [sint.get_input_from(0) for _ in range(n)]\ntarget = sint.get_input_from(0)\n\nindex = sint(0)\nfound = sint(0)\n\nfor i in range(n):\n    check = arr[i].equal(target)\n    update_mask = 1 - found\n    index = index + i * check * update_mask\n    found = found + check\n\nminus_one = cint(-1)\nresult = found.if_else(index, minus_one)\nresult.reveal().print_ln(\"%s\", result.reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "choppy_array", "response_0": "def choppy_array(arr):\n    # arr is a list of secure types (e.g., sfix) in MP-SPDZ\n    n = len(arr)\n    # res will hold our overall \"choppy array\" check (1 for True, 0 for False)\n    # if using sbit for Boolean operations, initialize to sbit(1)\n    res = 1\n    for i in range(n):\n        # i % 2 is a public integer, so we can branch in plain Python\n        parity = i % 2\n        for j in range(n - i):\n            if parity == 1:\n                # Check (arr[i] >= arr[i+j]) if i is odd\n                cond_ij = arr[i] >= arr[i+j]\n            else:\n                # Check (arr[i] <= arr[i+j]) if i is even\n                cond_ij = arr[i] <= arr[i+j]\n            # cond_ij is a secure bit; multiply or bitwise-AND to keep track of overall validity\n            res = res * cond_ij\n    # Result is 1 if \"choppy\", 0 otherwise; may be revealed or used as needed\n    return res\n", "response_1": "from Compiler.types import sint, sbit\nfrom Compiler.library import comparisons\n\ndef choppy_array(arr):\n    n = len(arr)\n    result = sint(1)\n    for i in range(n):\n        if i % 2 == 1:\n            # i is odd \u2192 arr[i] must be the largest of the remaining\n            for j in range(n - i):\n                check_bit = comparisons.gt(arr[i + j], arr[i])  # sbit indicates if arr[i+j] > arr[i]\n                result = result * (1 - check_bit)               # multiply by 1 if no violation, 0 if violation\n        else:\n            # i is even \u2192 arr[i] must be the smallest of the remaining\n            for j in range(n - i):\n                check_bit = comparisons.lt(arr[i + j], arr[i])  # sbit indicates if arr[i+j] < arr[i]\n                result = result * (1 - check_bit)\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process", "response_0": "def array_process(sarr, func):\n    # This function processes each element of sarr with a user-defined function func.\n    n = len(sarr)\n    for i in range(n):\n        sarr[i] = func(sarr[i])\n    return sarr\n", "response_1": "# In MP-SPDZ, functions cannot be passed as arguments in the same way as Python.\n# Below is an example MP-SPDZ translation resembling the Python code:\n# def array_process(arr, func):\n#     ...\n# but we embed the desired operation (\"func\") within the code itself.\n\ndef example_func(x):\n    # Example transformation; adjust as needed\n    return x * x\n\ndef array_process(arr):\n    \"\"\"\n    Process all elements in the input array with the example function.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = example_func(arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "normalize", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef normalize(vec):\n    # Accumulate square of elements\n    sum_val = sfix(0)\n    for item in vec:\n        sum_val += item * item\n\n    # Compute square root\n    base = sqrt(sum_val)\n\n    # Divide each element by the sqrt of the sum of squares\n    for i in range(len(vec)):\n        vec[i] = vec[i] / base\n\n    return vec\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef normalize(vec):\n    # sum of squares\n    s = sfix(0)\n    for item in vec:\n        s += item * item\n    # compute the square root\n    b = sqrt(s)\n    # normalize each element\n    for i in range(len(vec)):\n        vec[i] = vec[i] / b\n    return vec\n", "model_name": "azure-openai-o1"}
{"test_name": "impatient_merchant", "response_0": "from Compiler.types import cint\nfrom Compiler.library import for_range\n\ndef impatient_merchant(days, length):\n    can_buy = True\n    net = cint(0)\n    orig_price = cint(0)\n    for i in range(length):\n        if can_buy:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = False\n        else:\n            if days[i] > orig_price:\n                net = net + days[i]\n                can_buy = True\n    return net\n", "response_1": "from Compiler.types import regint, sint\n\ndef main():\n    # Read the number of days (private input from party 0). \n    n = regint.get_private_input_from(0)\n    # Reveal n in order to allow looping in Python.\n    n_clear = n.reveal()\n    \n    # Read each day's price (private input from party 0).\n    days = []\n    for _ in range(n_clear):\n        price_clear = regint.get_private_input_from(0)\n        days.append(sint(price_clear))\n\n    # Initialize variables\n    can_buy = 1  # This is a clear flag for simplicity\n    net = sint(0)\n    orig_price = sint(0)\n\n    # Core logic\n    for i in range(n_clear):\n        if can_buy:  # uses a clear flag for demonstration\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = 0\n        else:\n            # Compare current day's price with original price, \n            # revealing the result of comparison for branching.\n            cond = days[i] > orig_price\n            if cond.reveal():\n                net = net + days[i]\n                can_buy = 1\n\n    # Reveal and print final net result\n    net.reveal().print_reg()\n", "model_name": "azure-openai-o1"}
{"test_name": "array_shift", "response_0": "def array_shift(a):\n    n = len(a)\n    temp = a[n - 1]\n    for i in range(n - 1):\n        a[n - i - 1] = a[n - i - 2]\n    a[0] = temp\n    return a\n", "response_1": "def array_shift(a):\n    # a is an array of secret-shared integers (sint) in MP-SPDZ\n    n = len(a)\n    temp = a[n - 1]\n    for i in range(n - 1):\n        a[n - 1 - i] = a[n - 2 - i]\n    a[0] = temp\n    return a\n", "model_name": "azure-openai-o1"}
{"test_name": "array_double", "response_0": "def array_double_sint(arr):\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "response_1": "from Compiler.types import sint\n\ndef array_double(arr):\n    \"\"\"\n    Double all elements in the input array using MP-SPDZ.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "stop_at_zero", "response_0": "from Compiler.types import sint\n\ndef stop_at_zero(array):\n    # This function adds 1 to each element in the array until\n    # it encounters the first zero, after which it stops modifying\n    # remaining elements.\n    n = len(array)\n    stopped = sint(0)\n    for i in range(n):\n        is_zero = array[i].equal(0)\n        is_active = 1 - stopped\n        array[i] = array[i] + is_active * (sint(1) - is_zero)\n        stopped = stopped + is_zero * is_active\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef stop_at_zero(array):\n    stop = sint(0)\n    n = len(array)\n    for i in range(n):\n        is_zero = array[i].equal(0)\n        to_execute = sint(1) - stop\n        stop = stop + to_execute * is_zero\n        inc = to_execute * (sint(1) - is_zero)\n        array[i] = array[i] + inc\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_not", "response_0": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    In MP-SPDZ, we can simulate the logical NOT for bits\n    by computing (1 - arr[i]).\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = 1 - arr[i]\n    return arr\n", "response_1": "def array_not(arr):\n    n = len(arr)\n    for i in range(n):\n        # In MP-SPDZ, flipping a boolean (0/1) can be done by 1 - arr[i].\n        arr[i] = 1 - arr[i]\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_then_clip", "response_0": "def array_process_then_clip(arr, func):\n    n = len(arr)\n    for i in range(n):\n        # apply the processing function\n        arr[i] = func(arr[i])\n        # clip to upper bound of 10\n        arr[i] = (arr[i] > cfix(10)).if_else(cfix(10), arr[i])\n        # clip to lower bound of -10\n        arr[i] = (arr[i] < cfix(-10)).if_else(cfix(-10), arr[i])\n    return arr\n", "response_1": "def array_process_then_clip(arr, func):\n    from Compiler.types import sfix\n    n = len(arr)\n    for i in range(n):\n        arr[i] = func(arr[i])\n        gt_flag = arr[i] > sfix(10)\n        arr[i] = gt_flag.if_else(sfix(10), arr[i])\n        lt_flag = arr[i] < sfix(-10)\n        arr[i] = lt_flag.if_else(sfix(-10), arr[i])\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "add_and_count_positive", "response_0": "def add_and_count_positive(array, k):\n    count = sint(0)\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        count = count + (array[i] > 0)\n    return array, count\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef add_and_count_positive(array, k):\n    n = len(array)\n    # Add k to each element\n    @for_range(n)\n    def add_k_loop(i):\n        array[i] = array[i] + k\n\n    # Compute mask for positive elements\n    mask = sint.Array(n)\n    @for_range(n)\n    def mask_loop(i):\n        mask[i] = array[i] > 0\n\n    # Sum mask to get count of positive numbers\n    count = sum(mask)\n\n    return array, count\n", "model_name": "azure-openai-o1"}
{"test_name": "array_subtract", "response_0": "def array_subtract(a, b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    if len(a) > len(b):\n        ret = [sint(0) for i in range(len(a))]\n        for i in range(len(b)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(a) - len(b)):\n            ret[len(b) + i] = a[len(b) + i]\n        return ret\n    else:\n        ret = [sint(0) for i in range(len(b))]\n        for i in range(len(a)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(b) - len(a)):\n            ret[len(a) + i] = sint(0) - b[len(a) + i]\n        return ret\n", "response_1": "from Compiler.types import sint\n\ndef array_subtract(a, b):\n    A = len(a)\n    B = len(b)\n    ret_length = max(A, B)\n    ret = [sint(0) for _ in range(ret_length)]\n\n    if A > B:\n        for i in range(B):\n            ret[i] = a[i] - b[i]\n        for i in range(A - B):\n            ret[B + i] = a[B + i]\n    else:\n        for i in range(A):\n            ret[i] = a[i] - b[i]\n        for i in range(B - A):\n            ret[A + i] = -b[A + i]\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "lower_bound", "response_0": "# MP-SPDZ code translating the Python lower_bound function. \n# Assumes 'arr' is a list of s_int, 'x' is an s_int, and we want to return an s_int.\n# Returns the index of the largest element not bigger than x in arr.\n# If no valid element exists, returns -1 (mod the ring).\n\nfrom Compiler.types import s_int\n\ndef lower_bound(arr, x):\n    ret = s_int(-1)        # Stores the result index\n    distance = s_int(0)    # Stores the closest distance found so far (x - arr[i])\n    found = s_int(0)       # Indicates whether a valid element has been found (0 or 1)\n    n = len(arr)\n\n    for i in range(n):\n        i_s = s_int(i)\n        element_leq_x = (arr[i] <= x)                    # 1 if arr[i] <= x, else 0\n        current_distance = x - arr[i]\n        not_found = (found == 0)                         # 1 if nothing found yet, else 0\n        better_distance = (current_distance < distance)  # 1 if we found a smaller distance\n        # Combine conditions: we update if arr[i] <= x AND (found == 0 OR current_distance < distance)\n        update_cond = element_leq_x * (not_found + better_distance - not_found * better_distance)\n\n        # Update 'ret' if condition holds\n        ret = ret * (1 - update_cond) + i_s * update_cond\n        # Update 'distance' if condition holds\n        distance = distance * (1 - update_cond) + current_distance * update_cond\n        # Update 'found' if condition holds\n        found = found * (1 - update_cond) + s_int(1) * update_cond\n\n    return ret\n", "response_1": "def lower_bound(arr, x):\n    # Return the index of the largest element not bigger than x in arr.\n    # If such element does not exist, return -1.\n    from Compiler.types import sint\n    \n    ret = sint(-1)\n    distance = sint(0)\n    found = sint(0)\n    n = len(arr)\n\n    for i in range(n):\n        cond1 = arr[i] <= x\n        cond2 = (1 - found) + found * ((x - arr[i]) < distance)\n        update_cond = cond1 * cond2\n\n        ret = ret * (1 - update_cond) + sint(i) * update_cond\n        distance = distance * (1 - update_cond) + (x - arr[i]) * update_cond\n        found = found * (1 - update_cond) + sint(1) * update_cond\n\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "argmin", "response_0": "def argmin(a):\n    index = sint(0)\n    current = a[0]\n    for i in range(1, len(a)):\n        cond = current <= a[i]\n        index = cond.if_else(index, sint(i))\n        current = cond.if_else(current, a[i])\n    return index\n", "response_1": "from Compiler.types import sint\n\ndef argmin(a):\n    n = len(a)\n    current = a[0]\n    index = sint(0)\n    for i in range(1, n):\n        c = current > a[i]\n        index = c * i + (1 - c) * index\n        current = c * a[i] + (1 - c) * current\n    return index\n", "model_name": "azure-openai-o1"}
{"test_name": "independent_robbery", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_else, Array\n\ndef independent_robbery(houses):\n    n = len(houses)\n    dp = Array(n, sfix)\n    \n    # Initialize dp array\n    for i in range(n):\n        dp[i] = sfix(0)\n    \n    dp[0] = houses[0]\n    \n    # dp[1] = dp[1] if dp[1]>=dp[0] else dp[0]\n    cond1 = dp[1] >= dp[0]\n    dp[1] = if_else(cond1, dp[1], dp[0])\n    \n    # for i in range(2, len(houses)):\n    #     if dp[i-2]+houses[i] >= dp[i-1]:\n    #         dp[i] = dp[i-2]+houses[i]\n    #     else:\n    #         dp[i] = dp[i-1]\n    for i in range(2, n):\n        cond2 = (dp[i-2] + houses[i]) >= dp[i-1]\n        dp[i] = if_else(cond2, dp[i-2] + houses[i], dp[i-1])\n    \n    return dp[n-1]\n", "response_1": "def independent_robbery(houses):\n    # houses is assumed to be an Array of secure integers (sint)\n    n = len(houses)\n    dp = Array(n, sint)\n\n    # Initialize dp[0]\n    dp[0] = houses[0]\n\n    # Equivalent of: dp[1] = max(houses[1], dp[0]) \n    bit = (houses[1] >= dp[0])\n    dp[1] = bit.if_else(houses[1], dp[0])\n\n    # Fill up dp with secure conditional assignments \n    for i in range(2, n):\n        candidate = dp[i - 2] + houses[i]\n        bit = (candidate >= dp[i - 1])\n        dp[i] = bit.if_else(candidate, dp[i - 1])\n\n    # Return the maximum amount of money robber can get\n    return dp[n - 1]\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_odd_and_odd", "response_0": "def sum_odd_and_odd(arr):\n    res = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if (i % 2) == 0:\n            continue\n        for j in range(i):\n            if (j % 2) == 0:\n                continue\n            res += arr[j]\n    return res\n", "response_1": "from Compiler.types import sint\n\ndef sum_odd_and_odd(arr):\n    # A strange sum function\n    s = sint(0)\n    n = len(arr)\n    for i in range(n):\n        if i % 2 == 0:\n            continue\n        for j in range(i):\n            if j % 2 == 0:\n                continue\n            s += arr[j]\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "is_monotonous", "response_0": "# This MP-SPDZ program checks whether a list of secret-shared integers is strictly monotonous.\n# It reads the size of the list \"n\" (public integer) and then reads \"n\" secret integers.\n# The output is a public integer 1 (if strictly monotonous) or 0 (otherwise).\n\nn = int(input())  # public input for the size of the array\narr = [sint.get_input_from(0) for _ in range(n)]  # secret-shared array of size n\n\nd = sint(0)\nis_mono = sint(1)\nfor i in range(n - 1):\n    difference = arr[i + 1] - arr[i]\n    if i > 0:\n        product = difference * d\n        cond = (product <= 0)  # secret boolean indicating a non-strict-monotonic break\n        is_mono = is_mono * (1 - cond)\n    d = difference\n\nprint_ln('%s', is_mono.reveal())\n", "response_1": "def is_monotonous(arr):\n    # We use sint to represent secure integers in MP-SPDZ\n    d = sint(0)\n    # res will hold the final result, initialized as True (1)\n    res = sint(1)\n\n    # Loop through the array indices (statically known in MP-SPDZ)\n    for i in range(len(arr) - 1):\n        # Compute the difference between consecutive elements\n        new_diff = arr[i + 1] - arr[i]\n\n        # i>0 is public, so we can branch on it in standard Python\n        if i > 0:\n            # Compare new_diff * d to 0 in a secure manner:\n            cond = (new_diff * d).less_equal(0)\n\n            # Reveal cond to determine if the array is not strictly monotonic\n            if cond.reveal() == 1:\n                res = 0\n\n        # Update d for the next iteration\n        d = new_diff\n\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "positive_count_negative_sum", "response_0": "from Compiler.types import sint\n\ndef positive_count_negative_sum(arr):\n    count = sint(0)\n    neg_sum = sint(0)\n    for item in arr:\n        is_positive = (item > 0)\n        is_negative = (item < 0)\n        count = count + is_positive\n        neg_sum = neg_sum + (item * is_negative)\n    return count, neg_sum\n", "response_1": "# This MP-SPDZ program reads an array length from player 0, then reads that many array elements from player 0,\n# counts the number of items greater than zero, sums the items less than zero, and finally reveals the results.\n\ndef positive_count_negative_sum(arr):\n    # Both count and summ are initialized to zero shares\n    count = sint(0)\n    summ = sint(0)\n\n    # Iterate over each secret-shared element\n    for x in arr:\n        # Compare with zero, resulting in secret bits (0 or 1)\n        is_positive = x > 0\n        is_negative = x < 0\n\n        # Update count by adding the bit indicating positivity\n        count = count + is_positive\n\n        # Incorporate x into summ only if negative\n        summ = summ + (is_negative * x)\n\n    return count, summ\n\n\n# Example usage within an MP-SPDZ program\n# Read the number of elements from player 0\nn = sint.get_input_from(0)\n\n# Prepare an array of secret shares read from player 0\narr = [sint.get_input_from(0) for _ in range(n)]\n\n# Call the function\ncount, summ = positive_count_negative_sum(arr)\n\n# Reveal the results\nprint_ln(\"Count of positives: %s, Sum of negatives: %s\", [count.reveal(), summ.reveal()])\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_even", "response_0": "from Compiler.types import sint\n\ndef sum_even(arr):\n    \"\"\"\n    Return the secure sum of all the even numbers in the secure array.\n    \"\"\"\n    sum_val = sint(0)\n    for item in arr:\n        # item % 2 will be 0 if item is even, 1 otherwise\n        is_even = 1 - (item % 2)\n        sum_val += item * is_even\n    return sum_val\n", "response_1": "def sum_even(arr):\n    # Initialize a secure integer to accumulate the sum\n    s = s_int(0)\n    \n    # Iterate over each element in the array\n    for item in arr:\n        # item % 2 is 0 if item is even, 1 if item is odd\n        # Multiplying item by (1 - (item % 2)) ensures we add the item only if it's even\n        s = s + item * (1 - (item % 2))\n    \n    # Return the secure sum of even elements\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "one_norm", "response_0": "def one_norm(vec):\n    # Assume each element of vec is a secret fixed-point number (sfix)\n    total = sfix(0)\n    for item in vec:\n        total = total + item.absolute_value()\n    return total\n", "response_1": "# MP-SPDZ code translating the Python function one_norm(vec)\n# Here, we assume vec is a list/array of secret shared fixed-point or integer values (e.g., sfix).\n\n# First define a helper function to compute absolute value:\ndef sfix_abs(x):\n    return x - 2 * x * (x < 0)\n\ndef one_norm(vec):\n    # Initialize sum in the secret type (e.g., sfix)\n    s_sum = sfix(0)\n    # Accumulate absolute values\n    for i in range(len(vec)):\n        s_sum += sfix_abs(vec[i])\n    return s_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "array_floor", "response_0": "from Compiler.types import sfix\n\ndef array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function (truncation) to all elements \n    in the input array (arr is a list of sfix).\n    \"\"\"\n    n = len(arr)\n    ret = [sfix(0) for _ in range(n)]\n    for i in range(n):\n        # Trunc() chops off the fractional part of the sfix\n        ret[i] = arr[i].Trunc()\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef array_floor(arr):\n    # array_floor applies the floor function to each sfix number in arr.\n    # The sfix type trunc() method discards any fractional part (rounds toward zero).\n    # For negative numbers with a non-zero fractional part, we subtract 1 to emulate math.floor().\n    ret = [sfix(0) for _ in range(len(arr))]\n    for i in range(len(arr)):\n        truncated_value = arr[i].Trunc()           # Discard fractional part\n        frac = arr[i] - truncated_value            # Fractional part\n        adjust = frac < sfix(0)                    # True (1) if negative fractional part, else False (0)\n        ret[i] = truncated_value - adjust          # Subtract 1 only when negative fraction exists\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "three_five", "response_0": "# MP-SPDZ code translating the Python function \"three_five\"\n\nfrom Compiler.types import sint, sbit\nfrom Compiler.library import print_ln\n\ndef three_five(arr):\n    has3 = sbit(0)\n    has5 = sbit(0)\n    for item in arr:\n        eq3 = (item == 3)\n        eq5 = (item == 5)\n        has3 = has3.or_bit(eq3)\n        has5 = has5.or_bit(eq5)\n    both = has3.and_bit(has5)\n    neither = has3.neg().and_bit(has5.neg())\n    result = both.or_bit(neither)\n    return result\n\n# Example usage within an MP-SPDZ environment might involve creating \"arr\" as follows:\n# arr_length = 5\n# arr = [sint.get_input_from(0) for _ in range(arr_length)]\n# final_result = three_five(arr)\n# print_ln(\"%s\", final_result.reveal())\n", "response_1": "from Compiler.types import sint, sbit\nfrom Compiler.library import for_range\n\ndef three_five(arr, length):\n    # arr is a list/array of secure integers (sint)\n    # length is the number of elements in arr\n    has3 = sbit(0)\n    has5 = sbit(0)\n    \n    @for_range(length)\n    def _(i):\n        eq3 = arr[i].equal(3)    # This yields a sint with value 1 if arr[i] == 3, otherwise 0\n        eq5 = arr[i].equal(5)    # This yields a sint with value 1 if arr[i] == 5, otherwise 0\n        \n        # Convert the sint comparison results to sbit for logical operations\n        has3_bit = eq3.if_else(sbit(1), sbit(0))\n        has5_bit = eq5.if_else(sbit(1), sbit(0))\n        \n        # Accumulate presence of 3 and 5\n        has3 = has3 | has3_bit\n        has5 = has5 | has5_bit\n\n    both = has3 & has5\n    neither = (~has3) & (~has5)\n    return both | neither\n", "model_name": "azure-openai-o1"}
{"test_name": "num_above_average", "response_0": "from Compiler.types import sfix, sint\n\ndef num_above_average(arr):\n    sum_val = sfix(0)\n    count = sint(0)\n    length = len(arr)\n    for i in range(length):\n        sum_val = sum_val + arr[i]\n    avg = sum_val / sfix(length)\n    for i in range(length):\n        count = count + (arr[i] >= avg)\n    return count\n", "response_1": "from Compiler.types import sfix, sbit\n\n# Example array length\nn = 10\n\n# Allocate a secure array\narr = sfix.Array(n)\n\n# Initialize the secure array (optional: you can set specific logic here to read inputs)\nfor i in range(n):\n    arr[i] = sfix(0)   # Or sfix.get_input_from(player)\n\n# Compute sum of elements\nsum_val = sfix(0)\nfor i in range(n):\n    sum_val = sum_val + arr[i]\n\n# Compute average\navg = sum_val / sfix(n)\n\n# Count how many elements are >= average\ncount = sfix(0)\nfor i in range(n):\n    cond = arr[i] >= avg  # cond is a secure bit (sbit)\n    count = count + cond  # cond is promoted to sfix when added\n\n# Here you could optionally print or store the count\n# e.g., count.store_in_mem(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "clip", "response_0": "from Compiler.types import sfix, if_else\n\ndef clip(arr, upper_bound=sfix(1), lower_bound=sfix(-1)):\n    \"\"\"\n    For the given array of sfix values, clip the elements to the range [lower_bound, upper_bound].\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = sfix.if_else(arr[i] < lower_bound, lower_bound, arr[i])\n        arr[i] = sfix.if_else(arr[i] > upper_bound, upper_bound, arr[i])\n    return arr\n", "response_1": "def clip(arr, upper_bound, lower_bound):\n    n = len(arr)\n    i = 0\n    while i < n:\n        arr[i] = (arr[i] < lower_bound).if_else(lower_bound, arr[i])\n        arr[i] = (arr[i] > upper_bound).if_else(upper_bound, arr[i])\n        i = i + 1\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_with_certain_element_skipped", "response_0": "def sum_with_certain_element_skipped(array):\n    # MP-SPDZ typically uses secure integer types (e.g., sint) and comparison methods.\n    # Here, we use placeholders to illustrate the secure computations of comparisons.\n    # \"sum_val\" is initialized as a secure integer with value 0.\n    sum_val = sint(0)\n    \n    for i in range(len(array)):\n        # Compute candidate sum as secure addition.\n        sum_candidate = sum_val + array[i]\n        \n        # Compare sum_candidate with 5 and 10 using greater_equal() and less_equal() for secure comparison.\n        cond_lower = sum_candidate.greater_equal(5)\n        cond_upper = sum_candidate.less_equal(10)\n        \n        # \"skip\" becomes 1 if sum_candidate is in [5,10], otherwise 0.\n        skip = cond_lower * cond_upper\n        \n        # Update sum_val by skipping array[i] if skip=1, or adding array[i] if skip=0.\n        sum_val = sum_val + array[i] * (1 - skip)\n\n    return sum_val\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import for_range\n\ndef sum_with_certain_element_skipped(array):\n    # Initialize sum as a secure fixed-point value\n    partial_sum = sfix(0)\n    # For each element in the array\n    for i in range(len(array)):\n        # Secure computation to check if adding array[i] would keep partial_sum in [5,10]\n        cond1 = (partial_sum + array[i]) >= 5\n        cond2 = (partial_sum + array[i]) <= 10\n        cond = cond1 * cond2\n        # Only update partial_sum if cond==0 (meaning sum+array[i] not in [5,10])\n        partial_sum = partial_sum + array[i] * (1 - cond)\n    return partial_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_of_odd_and_even", "response_0": "from Compiler.types import s_int\n\ndef sum_of_odd_and_even(arr):\n    odd_sum = s_int(0)\n    even_sum = s_int(0)\n    for item in arr:\n        # Extract the least significant bit to determine if 'item' is odd.\n        odd_flag = item & 1\n        # Add to odd_sum if odd, else add to even_sum.\n        odd_sum += item * odd_flag\n        even_sum += item * (1 - odd_flag)\n    return odd_sum, even_sum\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the secure array arr.\n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    for item in arr:\n        # Compute 'item % 2' securely to determine if it's odd (1) or even (0)\n        is_odd = item % 2\n        # Accumulate into odd_sum if item is odd, else into even_sum\n        odd_sum = odd_sum + is_odd * item\n        even_sum = even_sum + (1 - is_odd) * item\n    return odd_sum, even_sum\n", "model_name": "azure-openai-o1"}
{"test_name": "distance", "response_0": "def distance(vec1, vec2):\n    # Computes the Euclidean distance between two vectors in MP-SPDZ.\n    s = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        s += diff * diff\n    return s.sqrt()\n", "response_1": "# mp-spdz translation of the distance function\n\nfrom Compiler.types import sfix\n\ndef distance(vec1, vec2):\n    ssum = sfix(0)\n    for i in range(len(vec1)):\n        diff = vec1[i] - vec2[i]\n        ssum += diff * diff\n    return ssum.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "num_occurrence", "response_0": "def num_occurrence(arr, target):\n    count = sint(0)\n    for i in range(len(arr)):\n        count = count + (arr[i] == target)\n    return count\n", "response_1": "def num_occurrence(arr, target):\n    count = sint(0)\n    for item in arr:\n        count = count + (item == target)\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "palindrome", "response_0": "def palindrome(arr):\n    n = len(arr)\n    flag = sbit(1)\n    for i in range(n):\n        eq = (arr[i] == arr[n - 1 - i])\n        flag = flag & eq\n    return flag\n", "response_1": "from Compiler.types import sint\n\n# Define the array length as needed (must be known at compile time).\nn = 5  \n\n# Secret-shared array input from player 0 (adjust as needed).\narr = [sint.get_input_from(0) for _ in range(n)]\n\n# Initialize the flag as 1 (True).\nflag = sint(1)\n\n# Compare symmetric elements, multiply their equality checks into flag.\nfor i in range(n):\n    condition = (arr[i] == arr[n - 1 - i])\n    flag = flag * condition\n\n# Reveal and print the result (1 means palindrome, 0 otherwise).\nfinal_result = flag.reveal()\nfinal_result.print_ln(\"%s\")\n", "model_name": "azure-openai-o1"}
{"test_name": "reverse_order_pair", "response_0": "def reverse_order_pair(arr):\n    n = len(arr)\n    num = sint(0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            num += (arr[i] > arr[j]).if_else(sint(1), sint(0))\n    return num\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef reverse_order_pair(arr):\n    # Count the number of reverse order pairs in the array. \n    num = sint(0)\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            num += (arr[i] > arr[j])\n    return num\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_of_cubes", "response_0": "def sum_of_cubes(arr):\n    # arr is a list of secret integers (sint)\n    ret = sint(0)\n    for item in arr:\n        ret = ret + (item * item * item)\n    return ret\n", "response_1": "from Compiler.types import sint\n\ndef sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array.\n    \"\"\"\n    ret = sint(0)\n    for item in arr:\n        ret = ret + (item * item * item)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "max_element", "response_0": "def max_element(a):\n    # Initialize current with the first element of a\n    current = a[0]\n\n    # Securely iterate through items in a \n    for i in range(1, len(a)):\n        is_bigger = a[i] > current\n        current = is_bigger * a[i] + (1 - is_bigger) * current\n\n    # Return the maximum value\n    return current\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef max_element(a):\n    n = len(a)\n    current = a[0]\n    for i in range(1, n):\n        cond = a[i] >= current\n        current = cond * a[i] + (1 - cond) * current\n    return current\n", "model_name": "azure-openai-o1"}
{"test_name": "array_if_else", "response_0": "def array_if_else(arr, predicator, if_func, else_func):\n    \"\"\"\n    For each element in the input array 'arr',\n    we evaluate 'predicator' on it as a secret boolean-like condition,\n    then use 'if_else' from MP-SPDZ to choose either the result of 'if_func'\n    or 'else_func' on that element in place.\n    \"\"\"\n    for i in range(len(arr)):\n        condition = predicator(arr[i])\n        arr[i] = condition.if_else(if_func(arr[i]), else_func(arr[i]))\n    return arr\n", "response_1": "# array_if_else.mpc\n\n# In MP-SPDZ, 'if/else' on secret data is usually achieved by using 'if_else'\n# on a secret bit. The 'predicator' here must return an sbit, and 'if_func'\n#/'else_func' perform operations consistent with our secret data type (e.g., sfix).\n\ndef array_if_else(arr, predicator, if_func, else_func):\n    length = len(arr)\n    for i in range(length):\n        condition = predicator(arr[i])            # Returns sbit\n        arr[i] = condition.if_else(if_func(arr[i]), \n                                   else_func(arr[i]))\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "inf_norm", "response_0": "def inf_norm(vec):\n    res = sfix(0)\n    for item in vec:\n        abs_val = item.abs()\n        cond = (res >= abs_val)\n        res = cond.if_else(res, abs_val)\n    return res\n", "response_1": "# mp-spdz code for computing the infinity norm of a vector\nfrom Compiler.types import sfix\n\ndef inf_norm(vec):\n    infv = sfix(0)\n    for item in vec:\n        abs_item = item.abs()  # Take absolute value in MP-SPDZ\n        infv = (infv >= abs_item).if_else(infv, abs_item)\n    return infv\n", "model_name": "azure-openai-o1"}
{"test_name": "array_inc", "response_0": "def array_inc(arr):\n    # arr is a list of sint\n    # Increment all elements in the input array by 1\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "response_1": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "count_rises", "response_0": "from Compiler.types import sint\n\ndef count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array using MP-SPDZ.\n    \"\"\"\n    n = len(arr)\n    count = sint(0)\n    for i in range(n - 1):\n        count = count + (arr[i] < arr[i + 1])\n    return count\n", "response_1": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array in MP-SPDZ.\n    'arr' should be an array of secure integers (sint).\n    \"\"\"\n    from Compiler.types import sint\n    count = sint(0)\n    for i in range(len(arr) - 1):\n        count += (arr[i] < arr[i + 1])\n    return count\n", "model_name": "azure-openai-o1"}
{"test_name": "skip_at_zero", "response_0": "from Compiler.types import sint\nfrom Compiler.library import comparison\n\ndef skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array (a list of sints),\n    but skip if an element is equal to 0 (represented by a used mask).\n    \"\"\"\n    for i in range(len(array)):\n        # Generate a boolean mask indicating if array[i] == 0\n        mask = comparison.eq(array[i], sint(0))\n        # Add 1 only if array[i] is not zero\n        array[i] = array[i] + (sint(1) - mask)\n    return array\n", "response_1": "from Compiler.types import sint\n\ndef skip_at_zero(array):\n    # Add 1 to all elements in 'array', but skip any element equal to 0\n    for i in range(len(array)):\n        is_zero = (array[i] == 0)\n        # If is_zero is 1, it means array[i] was 0; otherwise 0\n        not_zero = 1 - is_zero\n        # Only add 1 when the element was not zero\n        array[i] += not_zero\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "array_intersect", "response_0": "def array_intersect(p, q):\n    \"\"\"\n    Return whether the two arrays share any common element in MP-SPDZ.\n    Both p and q should be arrays of secure types (e.g., sint).\n    \"\"\"\n    found = sbit(0)\n    for i in range(len(p)):\n        for j in range(len(q)):\n            eq = p[i].equal(q[j])\n            found = found | eq\n    return found\n", "response_1": "from Compiler.types import sint, sbit\n\ndef array_intersect(p, q):\n    # p and q are assumed to be lists of sints\n    # eq will be set to 1 if a common element is found, otherwise remains 0\n    eq = sbit(0)\n    for i in range(len(p)):\n        for j in range(len(q)):\n            eq = eq | (p[i] == q[j])\n    return eq\n", "model_name": "azure-openai-o1"}
{"test_name": "two_norm", "response_0": "from Compiler.types import sfix\n\ndef two_norm(vec):\n    s = sfix(0)\n    for item in vec:\n        s += item * item\n    return s.sqrt()\n", "response_1": "def two_norm(vec):\n    sum_val = sfix(0)\n    for item in vec:\n        sum_val += item * item\n    return sum_val.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_between", "response_0": "def sum_between(arr, l, u):\n    s = sint(0)\n    for item in arr:\n        cond_l = (item >= l)\n        cond_u = (item <= u)\n        s = s + (cond_l * cond_u) * item\n    return s\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import for_range\n\ndef main():\n    n = sint.get_input_from(0)\n    arr = [sint.get_input_from(0) for _ in range(n)]\n    l = sint.get_input_from(0)\n    u = sint.get_input_from(0)\n\n    total = sint(0)\n    for i in range(n):\n        cond = (arr[i] >= l) * (arr[i] <= u)\n        total += arr[i] * cond\n\n    total.output()\n", "model_name": "azure-openai-o1"}
{"test_name": "largest_gap", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef largest_gap(arr):\n    n = len(arr)\n    cur = sint(0)\n    for i in range(n - 1):\n        diff = arr[i+1] - arr[i]\n        abs_diff = diff.sabs()\n        condition = abs_diff > cur\n        cur = if_else(condition, abs_diff, cur)\n    return cur\n", "response_1": "from Compiler.types import sint\n\ndef largest_gap(arr):\n    cur = sint(0)\n    for i in range(len(arr) - 1):\n        diff = arr[i+1] - arr[i]\n        negative_diff = diff < sint(0)\n        abs_diff = negative_diff.if_else(-diff, diff)\n        larger = abs_diff > cur\n        cur = larger.if_else(abs_diff, cur)\n    return cur\n", "model_name": "azure-openai-o1"}
{"test_name": "totally_dominate", "response_0": "def totally_dominate(a, b):\n    # Assume a and b are lists of secure integer shares (e.g., sint).\n    amin = a[0]\n    for i in range(1, len(a)):\n        cond = a[i] < amin\n        amin = cond.if_else(a[i], amin)\n    bmax = b[0]\n    for i in range(1, len(b)):\n        cond = b[i] > bmax\n        bmax = cond.if_else(b[i], bmax)\n    return amin >= bmax\n", "response_1": "def totally_dominate(a, b):\n    # We assume a and b are lists of secure integers of the same type (e.g., sint).\n    len_a = len(a)\n    len_b = len(b)\n    \n    # Initialize 'amin' to the first element of 'a'\n    amin = a[0]\n    # Compute the minimum in 'a'\n    for i in range(1, len_a):\n        is_less = a[i] < amin\n        amin = is_less.if_else(a[i], amin)\n    \n    # Initialize 'bmax' to the first element of 'b'\n    bmax = b[0]\n    # Compute the maximum in 'b'\n    for i in range(1, len_b):\n        is_greater = b[i] > bmax\n        bmax = is_greater.if_else(b[i], bmax)\n    \n    # Return secure comparison result\n    return amin >= bmax\n", "model_name": "azure-openai-o1"}
{"test_name": "element_count", "response_0": "from Compiler.types import sint\n\ndef element_count(arr, target):\n    ret = sint(0)\n    for item in arr:\n        eq_flag = (item == target)              # yields a secret bit (sbit)\n        ret = ret + eq_flag.if_else(sint(1), sint(0))\n    return ret\n", "response_1": "from Compiler.types import s_int\n\ndef element_count(arr, target):\n    ret = s_int(0)\n    for item in arr:\n        ret = ret + (item == target)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "is_subarray", "response_0": "# MP-SPDZ code for is_subarray, using sints to store array elements\n# and arithmetic for boolean logic. No usage examples are included\n# in this code block.\n\ndef is_subarray(c, d):\n    # c and d are lists (arrays) of sints.\n    # We assume c_len and d_len are known at compile time or\n    # determined from len(c) and len(d) as Python integers.\n    c_len = len(c)\n    d_len = len(d)\n\n    # res will be 1 if subarray is found, 0 otherwise.\n    res = sint(0)\n\n    # Outer loop - similar to 'for i in range(len(d)):' in Python\n    for i in range(d_len):\n        # We will only try to match if there's enough space to fit array c\n        if c_len <= (d_len - i):\n            # Start with flag = 1 (true), set to 0 if mismatch occurs.\n            flag = sint(1)\n            for j in range(c_len):\n                # Compare elements: eq = 1 if equals, 0 otherwise\n                eq = c[j].equal(d[i + j])\n                flag = flag * eq  # Equivalent to logical AND\n            # Combine into res via arithmetic \"OR\":\n            # new_res = old_res OR flag = old_res + flag - old_res*flag\n            res = res + flag - res * flag\n\n    return res\n", "response_1": "from Compiler.types import sint\n\ndef is_subarray(c, d):\n    len_c = len(c)\n    len_d = len(d)\n    found = sint(0)\n    # Loop over potential start indices for subarray\n    for i in range(len_d):\n        # Check if c fits in d starting from index i\n        if i + len_c <= len_d:\n            flag = sint(1)\n            # Compare each element in c against slice of d\n            for j in range(len_c):\n                flag = flag * (c[j] == d[i + j])\n            found = found + flag\n    # Return whether subarray was found at least once\n    return found.greater_than(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "exists_5_or_7", "response_0": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    found = sint(0)\n    for item in arr:\n        eq_five = (item == 5)\n        eq_seven = (item == 7)\n        found = found + eq_five + eq_seven\n    return found > 0\n", "response_1": "from Compiler.types import sint\n\ndef exists_5_or_7(arr):\n    found = sint(0)\n    for item in arr:\n        is_five = (item == 5)\n        is_seven = (item == 7)\n        # Accumulate matches\n        found = found + (is_five + is_seven)\n    # Return secure comparison result (1 if found, else 0)\n    return found > 0\n", "model_name": "azure-openai-o1"}
{"test_name": "variance", "response_0": "from Compiler.types import sfix\n\ndef variance(arr):\n    \"\"\"\n    Return the variance of the array arr which is an array of sfix.\n    \"\"\"\n    n = len(arr)\n    average = sfix(0)\n    for item in arr:\n        average += item / n\n    var = sfix(0)\n    for item in arr:\n        diff = item - average\n        var += diff * diff / n\n    return var\n", "response_1": "from Compiler.types import sfix\n\ndef variance(arr):\n    n = len(arr)\n    average = sfix(0)\n    for item in arr:\n        average = average + item / sfix(n)\n    var_ = sfix(0)\n    for item in arr:\n        diff = item - average\n        var_ = var_ + (diff * diff) / sfix(n)\n    return var_\n", "model_name": "azure-openai-o1"}
{"test_name": "is_ascending", "response_0": "def is_ascending(arr):\n    n = arr.length\n    if n == 1:\n        # If there's only one element, consider it ascending (return 1).\n        return sint(1)\n    is_asc = sint(1)\n    for i in range(n - 1):\n        # Compare adjacent elements in a secret manner.\n        cond = arr[i] < arr[i + 1]\n        # Update the tracking variable by multiplying with the comparison bit.\n        is_asc = is_asc * cond\n    # is_asc will be 1 if strictly ascending, and 0 otherwise.\n    return is_asc\n", "response_1": "# MP-SPDZ code translating the given Python 'is_ascending' function.\n\n# We assume the input array is provided as secret integers (sint).\n# This code checks whether the array is in strictly ascending order.\n# If the array has length 1, it returns True (represented as sbit(1)).\n\nfrom Compiler.types import sint, sbit\n\ndef is_ascending(arr):\n    \"\"\"\n    Return a secret bit (sbit) indicating whether the array of sints\n    is in strictly ascending order. If the array length is 1, return sbit(1).\n    \"\"\"\n    result = sbit(1)\n    for i in range(len(arr) - 1):\n        result = result & (arr[i] < arr[i + 1])\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "xor_all", "response_0": "from Compiler.types import sbit\n\ndef xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is assumed to contain secure bits.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret ^= arr[i]\n    return ret\n", "response_1": "from Compiler.types import sbit\n\ndef xor_all(arr):\n    ret = arr[0]\n    for i in range(1, len(arr)):\n        ret ^= arr[i]\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "upper_bound", "response_0": "from Compiler.types import sint, sbool\nfrom Compiler.library import if_, or_\n\ndef upper_bound(arr, x):\n    # arr is a list/array of sints, x is a sint\n    length = len(arr)\n    ret = sint(-1)\n    distance = sint(0)\n    found = sbool(False)\n\n    for i in range(length):\n        with if_(arr[i] > x):\n            cond2 = or_(found == sbool(False), (arr[i] - x) < distance)\n            with if_(cond2):\n                ret = sint(i)\n                distance = arr[i] - x\n                found = sbool(True)\n\n    return ret\n", "response_1": "from Compiler.types import sint, sfix\n\ndef upper_bound(arr, x):\n    length = len(arr)\n    ret = sint(-1)\n    distance = sfix(0)\n    found = sint(0)\n    \n    for i in range(length):\n        cond1 = arr[i] > x\n        cond21 = (found == 0)\n        cond22 = (arr[i] - x) < distance\n        combined_cond = cond21 + cond22 - (cond21 * cond22)\n        update_cond = cond1 * combined_cond\n        \n        ret = update_cond.if_else(i, ret)\n        distance = update_cond.if_else(arr[i] - x, distance)\n        found = update_cond.if_else(sint(1), found)\n    \n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_process_then_sum", "response_0": "from Compiler.types import sint\n\ndef secure_func(x):\n    # Replace this with any secure processing you need\n    return x * x\n\ndef array_process_then_sum(arr):\n    \"\"\"\n    MP-SPDZ equivalent of:\n    def array_process_then_sum(arr, func):\n        sum_val = 0\n        for i in range(len(arr)):\n            arr[i] = func(arr[i])\n            sum_val = sum_val + arr[i]\n        return sum_val\n    \"\"\"\n    sum_val = sint(0)\n    for i in range(len(arr)):\n        arr[i] = secure_func(arr[i])\n        sum_val = sum_val + arr[i]\n    return sum_val\n", "response_1": "from Compiler.types import sint\n\ndef array_process_then_sum(arr, func):\n    \"\"\"\n    Process all elements in the input array with given function,\n    then sum up the processed elements.\n    \"\"\"\n    sum_value = sint(0)\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        sum_value = sum_value + arr[i]\n    return sum_value\n", "model_name": "azure-openai-o1"}
{"test_name": "average", "response_0": "def average(arr):\n    # Initialize a secure fixed-point accumulator\n    sum_val = sfix(0)\n    \n    # Determine the number of elements in the array\n    length = len(arr)\n    \n    # Compute the sum of all elements in the array\n    for i in range(length):\n        sum_val = sum_val + arr[i]\n    \n    # Compute the average by dividing the sum by the array length\n    ret = sum_val / sfix(length)\n    \n    # Return the average as a secure fixed-point value\n    return ret\n", "response_1": "from Compiler.types import sfix\n\ndef average(arr):\n    \"\"\"\n    Compute the average value of a secret-shared array.\n    \"\"\"\n    sum_val = sfix(0)\n    length = len(arr)\n    for i in range(length):\n        sum_val += arr[i]\n    ret = sum_val / sfix(length)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "array_filter", "response_0": "def array_filter(arr, predicator):\n    n = len(arr)\n    for i in range(n):\n        # Replace arr[i] with 0 if the predicator is False (0), or keep arr[i] if the predicator is True (1)\n        arr[i] = predicator(arr[i]).if_else(arr[i], 0)\n    return arr\n", "response_1": "def array_filter(arr, predicator):\n    n = len(arr)\n    for i in range(n):\n        arr[i] = predicator(arr[i]).if_else(arr[i], sfix(0))\n    return arr\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_up", "response_0": "from Compiler.types import sint\n\ndef sum_up(array):\n    # The sum_up function\n    sum_val = sint(0)\n    for i in range(len(array)):\n        sum_val = sum_val + array[i]\n    return sum_val\n", "response_1": "def sum_up(arr):\n    total = sint(0)\n    for num in arr:\n        total = total + num\n    return total\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_to_zero", "response_0": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(len(array)):\n        cond = array[i] >= 0\n        array[i] = if_else(cond, array[i], sint(0))\n    return array\n", "response_1": "def negative_to_zero(array):\n    n = len(array)\n    for i in range(n):\n        array[i] = array[i] * (array[i] >= 0)\n    return array\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_only_positive_to_ten", "response_0": "# In MP-SPDZ, variables are secret-shared types rather than plain Python variables.\n# Below is an example translation of the Python function into MP-SPDZ code using sint:\n\n# Declare number of elements (secret-shared input)\nn = sint.get_input_from(0)\n\n# Read the array elements (secret-shared inputs)\narr = [sint.get_input_from(0) for _ in range(n)]\n\n# Initialize partial sum and a flag indicating we have not reached 10 yet\npartial_sum = sint(0)\nactive = sint(1)\n\n# Loop over the array\nfor i in range(n):\n    # Check whether current element is positive (secret comparison)\n    is_pos = arr[i] > 0\n    \n    # Add to partial sum only if element is positive and we are still active\n    partial_sum = partial_sum + arr[i] * is_pos * active\n    \n    # Disable further additions once partial_sum >= 10\n    active = active * (partial_sum < 10)\n\n# Output the partial sum as the final result\npartial_sum.print_reveal()\n", "response_1": "from Compiler.types import sint, cint\n\ndef sum_only_positive_to_ten(array):\n    s = sint(0)\n    carryon = sint(1)\n    for i in range(len(array)):\n        is_pos = array[i].greater_than(cint(0))\n        add_val = is_pos * carryon * array[i]\n        s = s + add_val\n        carryon = carryon * s.less_than(cint(10))\n    return s\n", "model_name": "azure-openai-o1"}
{"test_name": "bubble_sort", "response_0": "# Step 1: Define or load the size of the array (n)\n# Step 2: Initialize the secure array (arr), for example of sint type\n\n# Bubble sort implementation\nfor i in range(n - 1):\n    for j in range(n - 1 - i):\n        # Secure comparison\n        cond = (arr[j] >= arr[j + 1])\n        \n        # Secure swap: move larger element to index j+1 if cond is 1\n        temp = cond * (arr[j] - arr[j + 1])\n        arr[j]     = arr[j]     - temp\n        arr[j + 1] = arr[j + 1] + temp\n\n# The array arr is now sorted in ascending order\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort on the array of secret-shared integers.\n    \"\"\"\n    for i in range(len(arr)-1):\n        for j in range(len(arr)-1-i):\n            # c becomes 1 if arr[j] >= arr[j+1], else 0\n            c = arr[j] >= arr[j+1]\n            new_j  = if_else(c, arr[j+1], arr[j])\n            new_j1 = if_else(c, arr[j],   arr[j+1])\n            arr[j] = new_j\n            arr[j+1] = new_j1\n    return arr\n", "model_name": "azure-openai-o1"}
