{"test_name": "sin_or_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    cond = x >= sfix(0)\n    return if_else(cond, x.sin(), x.cos())\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef sin_or_cos(x):\n    # In MP-SPDZ, comparisons and conditional branching must be done securely.\n    # Here, we use x >= sfix(0) to securely determine whether x is nonnegative and\n    # if_else() to select sin(x) or cos(x) without revealing x's value.\n    cond = (x >= sfix(0))\n    return if_else(cond, x.sin(), x.cos())\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_relu", "response_0": "# MP-SPDZ translation of the negative ReLU function\n# Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n\ndef negative_relu(x):\n    cond = x < 0\n    return x * cond\n", "response_1": "from Compiler.types import sfix\n\ndef negative_relu(x):\n    is_neg = (x < sfix(0))\n    return x * is_neg\n", "model_name": "azure-openai-o1"}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close:\n    their absolute difference is no larger than 1.\n    \"\"\"\n    difference = a - b\n    return (difference.abs() <= 1)\n", "response_1": "def is_close(a: sfix, b: sfix):\n    difference = a - b\n    abs_difference = difference.abs()\n    return abs_difference <= sfix(1)\n", "model_name": "azure-openai-o1"}
{"test_name": "hardswish", "response_0": "def hardswish(x):\n    tmp_less_than_neg3 = (x < sfix(-3))\n    tmp_greater_than_3 = (x > sfix(3))\n    tmp_middle_value = x * (x + sfix(3)) / sfix(6)\n    return sfix.if_else(tmp_less_than_neg3, sfix(0),\n                        sfix.if_else(tmp_greater_than_3, x, tmp_middle_value))\n", "response_1": "def hardswish(x):\n    # Assume x is an sfix (or appropriate MP-SPDZ numeric type)\n    temp_neg = (x < -3)\n    temp_pos = (x > 3)\n    return temp_neg.if_else(0, temp_pos.if_else(x, x * (x + 3) / 6))\n", "model_name": "azure-openai-o1"}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6, 6].\n    This function expects x to be a secure type such as sfix, and uses\n    MP-SPDZ conditional operations to return the clipped result.\n    \"\"\"\n    six = sfix(6)\n    neg_six = sfix(-6)\n    temp = (x > six).if_else(six, x)\n    return (temp < neg_six).if_else(neg_six, temp)\n", "response_1": "from Compiler.types import sfix\n\ndef clip_at_6(x):\n    upper_clipped = (x > sfix(6)) * sfix(6) + (x <= sfix(6)) * x\n    final_clipped = (upper_clipped < sfix(-6)) * sfix(-6) + (upper_clipped >= sfix(-6)) * upper_clipped\n    return final_clipped\n", "model_name": "azure-openai-o1"}
{"test_name": "piecewise_function", "response_0": "from Compiler.types import sfix\n\ndef piecewise_function(x):\n    cond1 = x > sfix(1)\n    cond2 = x < sfix(-1)\n    cond3 = x > sfix(0)\n    cond4 = x < sfix(0)\n\n    ret1 = cond1.if_else(x, sfix(0))\n    not_cond1 = 1 - cond1\n\n    ret2 = cond2.if_else(x, sfix(0))\n    not_cond2 = 1 - cond2\n\n    ret3 = cond3.if_else(sfix(1), sfix(0))\n    not_cond3 = 1 - cond3\n\n    ret4 = cond4.if_else(sfix(-1), sfix(0))\n\n    ret = (ret1 \n           + not_cond1 * ret2 \n           + not_cond1 * not_cond2 * ret3 \n           + not_cond1 * not_cond2 * not_cond3 * ret4)\n    return ret\n", "response_1": "def piecewise_function(x):\n    is_gt1 = x > 1\n    is_ltneg1 = x < -1\n    is_gt0 = x > 0\n    is_lt0 = x < 0\n\n    ret = is_gt1.if_else(x, 0)\n    ret = ret + (1 - is_gt1) * is_ltneg1.if_else(x, 0)\n    ret = ret + (1 - is_gt1)*(1 - is_ltneg1) * is_gt0.if_else(1, 0)\n    ret = ret + (1 - is_gt1)*(1 - is_ltneg1)*(1 - is_gt0) * is_lt0.if_else(-1, 0)\n    return ret\n", "model_name": "azure-openai-o1"}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    cond1 = a >= b\n    temp = a\n    a = cond1 * b + (1 - cond1) * a\n    b = cond1 * temp + (1 - cond1) * b\n\n    cond2 = b >= c\n    temp = b\n    b = cond2 * c + (1 - cond2) * b\n    c = cond2 * temp + (1 - cond2) * c\n\n    cond3 = a >= b\n    temp = a\n    a = cond3 * b + (1 - cond3) * a\n    b = cond3 * temp + (1 - cond3) * b\n\n    return b\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import if_else\n\ndef middle(a, b, c):\n    # Swap a and b if a >= b\n    cond = a >= b\n    tmp_a = if_else(cond, b, a)\n    tmp_b = if_else(cond, a, b)\n    a, b = tmp_a, tmp_b\n\n    # Swap b and c if b >= c\n    cond = b >= c\n    tmp_b = if_else(cond, c, b)\n    tmp_c = if_else(cond, b, c)\n    b, c = tmp_b, tmp_c\n\n    # Swap a and b if a >= b (again)\n    cond = a >= b\n    tmp_a = if_else(cond, b, a)\n    tmp_b = if_else(cond, a, b)\n    a, b = tmp_a, tmp_b\n\n    return b\n", "model_name": "azure-openai-o1"}
{"test_name": "indicated_sin_or_cos", "response_0": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_else\n\ndef indicated_sin_or_cos(x, ind):\n    # x is an sfix\n    # ind is a sint (0 or 1)\n    return if_else(ind, x.sin(), x.cos())\n", "response_1": "from Compiler.types import sfix, sint\n\ndef indicated_sin_or_cos(x, ind):\n    sin_val = x.sin()\n    cos_val = x.cos()\n    return sin_val * ind + cos_val * (1 - ind)\n", "model_name": "azure-openai-o1"}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    tmp = x - 2\n    cond = tmp >= 0\n    return cond.if_else(tmp, x)\n", "response_1": "# minus2_if_else.mpc\n\n# This MP-SPDZ program reads a secret-shared integer from party 0,\n# then computes x-2 if x-2>=0, otherwise x.\n\ndef minus2_if_else(x):\n    tmp = x - 2\n    c = tmp.gtz()             # Compare tmp with 0 => produces secret bit (sbit)\n    return c.if_else(tmp, x)  # Return tmp if c=1 else x\n\ndef main():\n    from Compiler.types import sint\n    x = sint.get_input_from(0)\n    res = minus2_if_else(x)\n    res.print_ln()\n", "model_name": "azure-openai-o1"}
{"test_name": "relu6", "response_0": "def relu6(x):\n    # ReLU6 function\n    cond_neg = x < 0\n    cond_gt6 = x > 6\n    return cond_neg.if_else(0, cond_gt6.if_else(6, x))\n", "response_1": "# In MP-SPDZ, we typically work with secure data types (e.g., sfix for fixed-point).\n# Below is a possible translation of the ReLU6 function into MP-SPDZ style Python code.\n\ndef relu6(x):\n    # First clamp x to at least 0\n    zero_clamped = (x < sfix(0)).if_else(sfix(0), x)\n    # Then clamp zero_clamped to at most 6\n    return (zero_clamped > sfix(6)).if_else(sfix(6), zero_clamped)\n", "model_name": "azure-openai-o1"}
{"test_name": "exp_slide", "response_0": "from Compiler.types import sfix\n\ndef exp_slide(x):\n    cond = (x >= 0)\n    return cond.if_else(x.exp(), x + sfix(1))\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef exp_slide(x):\n    zero = sfix(0)\n    condition = (x >= zero)\n    return if_else(condition, x.exp(), x + 1)\n", "model_name": "azure-openai-o1"}
{"test_name": "pass_or_not", "response_0": "# In MP-SPDZ, we define a function that takes in a secure integer \"score\",\n# then conditionally sets the final score to \"score\" if it is >= 60,\n# or 59 otherwise, and returns both the final score and the pass bit (True/False).\ndef pass_or_not(score):\n    pass_bit = score >= sint(60)\n    final_score = pass_bit.if_else(score, sint(59))\n    return final_score, pass_bit\n", "response_1": "from Compiler.types import sint\n\ndef pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating she has passed). \n    If not, you should return that her score is 59 and False.\n    \"\"\"\n    new_score = (score >= 60).if_else(score, sint(59))\n    passed = (new_score >= 60)\n    return new_score, passed\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    # a, b, c are secure data types (e.g. sfix) in MP-SPDZ context.\n    # We use boolean expressions and arithmetic in a data-oblivious way.\n    \n    is_a_zero = (a == 0)\n    is_b_zero = (b == 0)\n    \n    # Case when a == 0:\n    case1_subcase1 = is_b_zero * 0  # (a == 0 and b == 0) => 0 roots\n    case1_subcase2 = (1 - is_b_zero) * 1  # (a == 0 and b != 0) => 1 root\n    res_case1 = is_a_zero * (case1_subcase1 + case1_subcase2)\n    \n    # Case when a != 0:\n    discriminant = b * b - 4 * a * c\n    is_discriminant_positive = (discriminant > 0)\n    is_discriminant_zero = (discriminant == 0)\n    # 2 roots if > 0, 1 root if == 0, otherwise 0.\n    res_case2 = (1 - is_a_zero) * (\n        is_discriminant_positive * 2 \n        + is_discriminant_zero * 1 \n        + (1 - is_discriminant_positive - is_discriminant_zero) * 0\n    )\n    \n    return res_case1 + res_case2\n", "response_1": "def how_many_roots(a, b, c):\n    # This function assumes a, b, c are read as clear integers (cint).\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    disc = b * b - 4 * a * c\n    if disc > 0:\n        return 2\n    elif disc == 0:\n        return 1\n    else:\n        return 0\n\ndef main():\n    # Reading clear integer inputs from party 0 (public inputs).\n    a = cint.get_input_from(0)\n    b = cint.get_input_from(0)\n    c = cint.get_input_from(0)\n\n    # Compute the number of roots.\n    result = how_many_roots(a, b, c)\n\n    # Output the result.\n    print_ln(\"%s\", [result])\n", "model_name": "azure-openai-o1"}
{"test_name": "elu", "response_0": "from Compiler.types import sfix\n\ndef elu(x):\n    is_positive = (x > sfix(0))\n    return is_positive * x + (1 - is_positive) * (x.exp() - sfix(1))\n", "response_1": "from Compiler.types import sfix\n\ndef elu(x):\n    # x is an sfix value\n    # return x if x > 0 else exp(x) - 1\n    ispos = x > sfix(0)\n    return ispos.if_else(x, x.exp() - sfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "relu", "response_0": "def relu(x):\n    # In MP-SPDZ, 'x > 0' returns a secret boolean value indicating if x is positive.\n    # Multiplying x by this boolean effectively zeroes out non-positive values, \n    # thus implementing the ReLU operation.\n    return x * (x > 0)\n", "response_1": "from Compiler.types import sfix\n\ndef relu(x):\n    return sfix.if_else(x > 0, x, sfix(0))\n", "model_name": "azure-openai-o1"}
{"test_name": "leaky_relu", "response_0": "from Compiler.types import sfix\n\ndef leaky_relu(x, alpha):\n    pos_mask = x > sfix(0)\n    return pos_mask * x + (1 - pos_mask) * alpha * x\n", "response_1": "from Compiler.types import sfix\n\ndef leaky_relu(x, alpha):\n    # 'cond' becomes a secure bit indicating whether x > 0\n    cond = x > sfix(0)\n    # Conditionally select x if cond is true, or x * alpha if cond is false\n    return sfix.if_else(cond, x, x * alpha)\n", "model_name": "azure-openai-o1"}
{"test_name": "max", "response_0": "def max_sint(a, b):\n    # a and b are secure MP-SPDZ integer types (sint)\n    # cond will be 1 if a > b, else 0\n    cond = a.gth(b)\n    # Return the maximum using secure arithmetic\n    return cond * a + (1 - cond) * b\n", "response_1": "# MP-SPDZ code translating the Python max function \n# for secure integer (sint) comparison \ndef max_sint(a, b):\n    # 'bit' is a secure bit (0 or 1) resulting from the comparison\n    bit = a >= b  \n    # Return a * bit + b * (1 - bit)\n    return a * bit + b * (1 - bit)\n", "model_name": "azure-openai-o1"}
{"test_name": "bowl_shape", "response_0": "from Compiler.types import sfix, cfix\nfrom Compiler.library import if_else\n\ndef bowl_shape(x):\n    # Compare x with 1 and -1\n    cond_gt = x > cfix(1)\n    cond_lt = x < cfix(-1)\n\n    # Compute possible branches\n    res_if_gt = x - cfix(1)\n    res_if_lt = -x - cfix(1)\n    res_if_else = cfix(0)\n\n    # Return bowl-shape result\n    return if_else(cond_gt, res_if_gt, if_else(cond_lt, res_if_lt, res_if_else))\n", "response_1": "from Compiler.types import sfix, cfix, if_else\n\ndef bowl_shape(x):\n    b1 = x > cfix(1)\n    b2 = x < cfix(-1)\n    return if_else(b1, x - cfix(1), if_else(b2, -x - cfix(1), cfix(0)))\n", "model_name": "azure-openai-o1"}
{"test_name": "rounded_kinetic_energy", "response_0": "from Compiler.types import sfix\n\ndef rounded_kinetic_energy(m, v):\n    k = m * v * v / 2\n    k_int = k.round_to_int()\n    frac = k - sfix(k_int)\n    should_increment = frac >= 0.5\n    return k_int + should_increment\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import floor\n\ndef rounded_kinetic_energy(m: sfix, v: sfix) -> sfix:\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    k = m * v * v / 2\n    k_int = floor(k)\n    diff = k - k_int\n    c = diff >= 0.5\n    return k_int + c.if_else(1, 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "danger_test", "response_0": "from Compiler.types import sint\n\ndef main():\n    # Read inputs as secret integers from party 0\n    origin = sint.get_input_from(0)\n    damage = sint.get_input_from(0)\n\n    # Calculate health difference\n    difference = origin - damage\n\n    # Compare with 10\n    is_dangerous = difference.less_equal(10)\n\n    # Store the result in memory (e.g., location 0)\n    is_dangerous.store_in_mem(0)\n", "response_1": "from Compiler.types import sint, cint\n\ndef danger_test(origin, damage):\n    # Compare (origin - damage) with 10 in secret-shared form\n    return (origin - damage) <= cint(10)\n\ndef main():\n    # Securely input two secret shared values\n    origin = sint.get_input_from(0)\n    damage = sint.get_input_from(1)\n\n    # Call the danger_test function\n    result = danger_test(origin, damage)\n\n    # Reveal the result (1 for True, 0 for False)\n    result = result.reveal()\n    print_ln('Danger: %s', [result])\n", "model_name": "azure-openai-o1"}
{"test_name": "indicated_sum_or_multiply", "response_0": "# In MP-SPDZ, booleans are typically represented as secure integers (0 or 1). \n# Hence, 'ind' is treated as a secure integer here rather than a standard Python boolean.\n\nfrom Compiler.types import sint\n\ndef indicated_sum_or_multiply(x: sint, y: sint, ind: sint) -> sint:\n    one = sint(1)\n    # If 'ind' is 1, compute x + y; if 'ind' is 0, compute x * y.\n    # The expression below uses secure arithmetic without branching.\n    return (ind * (x + y)) + ((one - ind) * (x * y))\n", "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    # Assume x, y are secure numeric types (e.g. sfix) and ind is a secure bit type (e.g. sbit)\n    # This returns x + y if ind is 1, and x * y otherwise\n    return x.if_else(ind, x + y, x * y)\n", "model_name": "azure-openai-o1"}
{"test_name": "median", "response_0": "# In MP-SPDZ, secure data is typically stored in secure types such as sfix or sfloat.\n# Below is a direct translation of the Python median function into MP-SPDZ style.\n\n# We assume \"arr\" is a list of sfix values.\n\ndef median(arr):\n    l = arr.length()   # MP-SPDZ method to get secure array length\n    # Check if empty\n    if l == 0:\n        # In MP-SPDZ, raising a runtime error is one possible way to handle errors\n        runtime_error(\"ValueError: The length of the array is 0!\")\n\n    # Sort the array securely (MP-SPDZ provides a .sort() method for arrays of sfix)\n    arr.sort()\n    ret = sfix(0)\n    \n    # If length is odd\n    if (l % 2) == 1:\n        ret = arr[l // 2]\n    else:\n        # If length is even\n        ret = (arr[l // 2] + arr[l // 2 - 1]) * cfix(0.5)\n\n    return ret\n", "response_1": "# In MP-SPDZ, we cannot simply raise a Python ValueError, \n# but we can print a message or exit. Here, we show printing an error \n# and returning 0 if the array is empty.\n\n# A simple bubble sort for secret-shared values (sfix or sint) \n# because MP-SPDZ does not have a built-in sorting method by default.\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            cond = arr[j] > arr[j + 1]\n            tmp = arr[j]\n            # if_else(x, cond) returns x if cond is 0, otherwise the original\n            arr[j] = arr[j + 1].if_else(arr[j], cond)\n            arr[j + 1] = tmp.if_else(arr[j + 1], cond)\n    return arr\n\ndef median(arr):\n    # Check for empty array in the clear length\n    if len(arr) == 0:\n        print_ln(\"The length of the array is 0!\")\n        return sfix(0)\n\n    # Sort the array using bubble_sort\n    sorted_arr = bubble_sort(arr)\n\n    # Compute the median\n    mid = len(sorted_arr) // 2\n    if len(sorted_arr) % 2 == 1:\n        return sorted_arr[mid]\n    else:\n        return (sorted_arr[mid] + sorted_arr[mid - 1]) / 2\n", "model_name": "azure-openai-o1"}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    sum_val = a + b               # Secure addition\n    cond = sum_val > 10           # Secure comparison\n    return cond.if_else(10, sum_val)   # Conditional selection\n", "response_1": "def add_upto_10(a, b):\n    sum_val = a + b\n    cond = sum_val > 10\n    return cond.if_else(10, sum_val)\n", "model_name": "azure-openai-o1"}
{"test_name": "taxi_fare", "response_0": "from Compiler.types import sfix\n\ndef taxi_fare(m):\n    cond1 = (m <= 5)\n    cond2 = (m > 5) * (m <= 10)\n    cond3 = (m > 10)\n    return 5 * cond1 + (5 + 1.2 * (m - 5)) * cond2 + (11 + 1.5 * (m - 10)) * cond3\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef taxi_fare(m):\n    # Define conditions for each interval\n    cond1 = m.less_equal(5)\n    cond2 = (m.greater_than(5)) * (m.less_equal(10))\n    \n    # Define the three fare calculations\n    fare1 = sfix(5)\n    fare2 = sfix(5) + sfix(1.2) * (m - sfix(5))\n    fare3 = sfix(11) + sfix(1.5) * (m - sfix(10))\n\n    # Combine results using secure conditional selection\n    return if_else(cond1, fare1, if_else(cond2, fare2, fare3))\n", "model_name": "azure-openai-o1"}
{"test_name": "round", "response_0": "# MP-SPDZ code translating the Python round(x) function.\n# This code assumes x is an sfix value.\n# It returns x rounded to the nearest integer within the secure computation.\n\ndef sfix_round(x):\n    x_int = x.trunc()                 # Floor operation on x\n    difference = x - x_int            # Fractional part of x\n    c = difference < 0.5              # Secure comparison returning sbit\n    return x_int + c.if_else(0, 1)    # If c==1 then x < x_int+0.5 => return x_int, else x_int+1\n", "response_1": "from Compiler.types import sfix, if_else\n\ndef round_sfix(x):\n    \"\"\"\n    Round x (sfix) to the nearest integer (sfix).\n    \"\"\"\n    x_int = x.floor()\n    diff = x - x_int\n    condition = diff < sfix(0.5)\n    return if_else(condition, x_int, x_int + sfix(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "gpa_calculator", "response_0": "# gpa_calculator.mpc\n\nfrom Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score in secure manner using MP-SPDZ.\n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    \"\"\"\n    cond_90 = (score >= sfix(90))\n    cond_85 = (score >= sfix(85))\n    cond_80 = (score >= sfix(80))\n    cond_75 = (score >= sfix(75))\n    cond_70 = (score >= sfix(70))\n    \n    return if_else(cond_90,\n                   sfix(4.0),\n                   if_else(cond_85,\n                           sfix(3.6),\n                           if_else(cond_80,\n                                   sfix(3.3),\n                                   if_else(cond_75,\n                                           sfix(3.0),\n                                           if_else(cond_70,\n                                                   sfix(2.6),\n                                                   sfix(2.3)\n                                                  )\n                                          )\n                                  )\n                          )\n                  )\n                 )\n", "response_1": "from Compiler.types import sfix\n\ndef gpa_calculator(score):\n    cond_4 = score >= sfix(90)\n    cond_3_6 = score >= sfix(85)\n    cond_3_3 = score >= sfix(80)\n    cond_3_0 = score >= sfix(75)\n    cond_2_6 = score >= sfix(70)\n    return cond_4.if_else(sfix(4.0),\n              cond_3_6.if_else(sfix(3.6),\n              cond_3_3.if_else(sfix(3.3),\n              cond_3_0.if_else(sfix(3.0),\n              cond_2_6.if_else(sfix(2.6), sfix(2.3))))))\n", "model_name": "azure-openai-o1"}
{"test_name": "sign", "response_0": "from Compiler.types import sint\n\ndef sign(x: sint) -> sint:\n    # sign(x) = 1 if x > 0, -1 if x < 0, 0 if x = 0\n    return x.gtz() - x.ltz()\n", "response_1": "from Compiler.types import sint\n\ndef sign(x: sint) -> sint:\n    return (x > 0) - (x < 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "sum_or_difference", "response_0": "# In MP-SPDZ, secret-shared values are typically stored in data types such as 'sint' or 'sfix'.\n# Here, we define a function 'sum_or_difference' mirroring the Python logic:\ndef sum_or_difference(a, b):\n    cond = (a <= b)\n    return cond.if_else(a + b, a - b)\n", "response_1": "from Compiler.types import sint\n\ndef sum_or_difference(a: sint, b: sint):\n    return (a <= b).if_else(a + b, a - b)\n", "model_name": "azure-openai-o1"}
{"test_name": "CNOT", "response_0": "from Compiler.types import sbit\n\ndef CNOT(control_bit: sbit, flip_bit: sbit) -> sbit:\n    return flip_bit ^ control_bit\n", "response_1": "# MP-SPDZ code snippet for simulating the CNOT gate logic.\n# control_bit and flip_bit should be secret-shared bits (e.g., sbit).\n# The return value is (NOT flip_bit) when control_bit is 1, otherwise flip_bit.\n\ndef CNOT(control_bit, flip_bit):\n    return flip_bit + control_bit * (1 - 2 * flip_bit)\n", "model_name": "azure-openai-o1"}
{"test_name": "negative_plus1", "response_0": "# Return y+1 if y is negative, otherwise return y\ndef negative_plus1(y):\n    cond = y < 0\n    return cond.if_else(y + 1, y)\n", "response_1": "from Compiler.types import sint\n\ndef negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    return y + (y < 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "is_a_parallelogram", "response_0": "# MP-SPDZ translation of the Python function is_a_parallelogram\n\n# Secure comparison helper\ndef same(x0, x1, y0, y1):\n    ex = (x0 - y0).is_zero()\n    ey = (x1 - y1).is_zero()\n    return ex * ey\n\ndef is_a_parallelogram(a0, a1, b0, b1, c0, c1, d0, d1):\n    # Check for repeated points\n    same_ab = same(a0, a1, b0, b1)\n    same_ac = same(a0, a1, c0, c1)\n    same_ad = same(a0, a1, d0, d1)\n    same_bc = same(b0, b1, c0, c1)\n    same_bd = same(b0, b1, d0, d1)\n    same_cd = same(c0, c1, d0, d1)\n\n    repeated_points = (same_ab + same_ac + same_ad + same_bc + same_bd + same_cd).greater_than(0)\n\n    # Summation checks for parallelogram conditions\n    cond1 = ((a0 + b0) - (c0 + d0)).is_zero() * ((a1 + b1) - (c1 + d1)).is_zero()\n    cond2 = ((a0 + c0) - (b0 + d0)).is_zero() * ((a1 + c1) - (b1 + d1)).is_zero()\n    cond3 = ((a0 + d0) - (b0 + c0)).is_zero() * ((a1 + d1) - (b1 + c1)).is_zero()\n    is_parallel = (cond1 + cond2 + cond3).greater_than(0)\n\n    # If there are repeated points, return 0; otherwise, return if it's a parallelogram\n    return (1 - repeated_points) * is_parallel\n\ndef main():\n    # Reading points from party 0 (example input mechanism)\n    a0 = sint.get_input_from(0)\n    a1 = sint.get_input_from(0)\n    b0 = sint.get_input_from(0)\n    b1 = sint.get_input_from(0)\n    c0 = sint.get_input_from(0)\n    c1 = sint.get_input_from(0)\n    d0 = sint.get_input_from(0)\n    d1 = sint.get_input_from(0)\n    \n    result = is_a_parallelogram(a0, a1, b0, b1, c0, c1, d0, d1)\n    result.print_reg()\n", "response_1": "# Step 1: Define secure inputs for the coordinates of vertices a, b, c, d\n# Each coordinate is a secure integer (sint).\na0 = sint.get_input_from(0)\na1 = sint.get_input_from(0)\nb0 = sint.get_input_from(0)\nb1 = sint.get_input_from(0)\nc0 = sint.get_input_from(0)\nc1 = sint.get_input_from(0)\nd0 = sint.get_input_from(0)\nd1 = sint.get_input_from(0)\n\n# Step 2: Define a function to check if two points are the same\n# Returning a secure bit (sbit) indicating equality of both coordinates.\ndef same(x0, x1, y0, y1):\n    eq_x = (x0 == y0)\n    eq_y = (x1 == y1)\n    return eq_x & eq_y\n\n# Step 3: Check if any pair of given points (a, b, c, d) coincide.\neq_ab = same(a0, a1, b0, b1)\neq_ac = same(a0, a1, c0, c1)\neq_ad = same(a0, a1, d0, d1)\neq_bc = same(b0, b1, c0, c1)\neq_bd = same(b0, b1, d0, d1)\neq_cd = same(c0, c1, d0, d1)\n\nany_same = eq_ab | eq_ac | eq_ad | eq_bc | eq_bd | eq_cd\n\n# Step 4: Compute the parallelogram conditions as secure bits.\n# A parallelogram can be identified by checking:\n#  (p1.x + p2.x) == (p3.x + p4.x) AND (p1.y + p2.y) == (p3.y + p4.y),\n#  where (p1, p2, p3, p4) is one of the permutations that form two pairs of opposite vertices.\ncond1 = ((a0 + b0) == (c0 + d0)) & ((a1 + b1) == (c1 + d1))\ncond2 = ((a0 + c0) == (b0 + d0)) & ((a1 + c1) == (b1 + d1))\ncond3 = ((a0 + d0) == (b0 + c0)) & ((a1 + d1) == (b1 + c1))\n\nparallelogram_check = cond1 | cond2 | cond3\n\n# Step 5: Combining conditions:\n# We must ensure that no pair of vertices is identical AND the parallelogram check is true.\n# This yields an sbit where 1 represents \"True\" and 0 represents \"False\".\nis_parallelogram = (1 - any_same) & parallelogram_check\n\n# (Optional) Reveal the secret bit as output (e.g., 0 or 1).\n# is_parallelogram can now be processed further or printed, for example:\n# is_parallelogram.print_reg()\n", "model_name": "azure-openai-o1"}
{"test_name": "min", "response_0": "from Compiler.types import sint\n\ndef min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    cond = a <= b\n    return cond.if_else(a, b)\n", "response_1": "def min_sint(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    cmp_res = (a <= b)\n    return cmp_res.if_else(a, b)\n", "model_name": "azure-openai-o1"}
{"test_name": "choice_of_the_knight", "response_0": "from Compiler.types import sint\n\ndef legal(a, b):\n    cond_a_lower = a.gte(0)\n    cond_a_upper = (sint(7) - a).gte(0)\n    cond_b_lower = b.gte(0)\n    cond_b_upper = (sint(7) - b).gte(0)\n    # Multiplying these secure bits gives 1 if all are true, 0 otherwise\n    return cond_a_lower * cond_a_upper * cond_b_lower * cond_b_upper\n\ndef choice_of_the_knight(x, y):\n    counter = sint(0)\n    counter = counter + legal(x + 1, y + 2)\n    counter = counter + legal(x - 1, y + 2)\n    counter = counter + legal(x + 1, y - 2)\n    counter = counter + legal(x - 1, y - 2)\n    counter = counter + legal(x + 2, y + 1)\n    counter = counter + legal(x - 2, y + 1)\n    counter = counter + legal(x + 2, y - 1)\n    counter = counter + legal(x - 2, y - 1)\n    return counter\n", "response_1": "from Compiler.types import sint\n\ndef choice_of_the_knight(x, y):\n    def legal(a, b):\n        # legal is 1 if 0 <= a <= 7 and 0 <= b <= 7, else 0\n        return (a >= 0) * (a <= 7) * (b >= 0) * (b <= 7)\n    counter = sint(0)\n    counter = counter + legal(x + 1, y + 2)\n    counter = counter + legal(x - 1, y + 2)\n    counter = counter + legal(x + 1, y - 2)\n    counter = counter + legal(x - 1, y - 2)\n    counter = counter + legal(x + 2, y + 1)\n    counter = counter + legal(x - 2, y + 1)\n    counter = counter + legal(x + 2, y - 1)\n    counter = counter + legal(x - 2, y - 1)\n    return counter\n", "model_name": "azure-openai-o1"}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    tmp_sum = a + b\n    tmp_diff = a - b\n    return (tmp_sum > tmp_diff).if_else(tmp_sum, tmp_diff)\n", "response_1": "from Compiler.types import sint\n\ndef max_sum_different(a: sint, b: sint):\n    ab = a + b\n    am = a - b\n    cond = ab > am\n    return cond.if_else(ab, am)\n", "model_name": "azure-openai-o1"}
