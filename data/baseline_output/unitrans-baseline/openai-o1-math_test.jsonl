{"test_name": "next_integer", "response_0": "# next_integer.mpc\n\n# This function returns the minimum integer strictly bigger than a given\n# secret fixed-point number t using MP-SPDZ syntax.\n# Internally, we compute floor(t) by truncating t down to its integer part\n# and then add 1 to ensure the result is strictly greater than t.\n\ndef next_integer(t):\n    temp = t.floor()  # Truncate t to its integer part\n    return temp + 1\n", "response_1": "from Compiler.types import sfix\n\ndef next_integer(t):\n    \"\"\"\n    Return the minimum integer strictly bigger than the input value.\n    \"\"\"\n    return t.Trunc() + 1\n", "model_name": "azure-openai-o1"}
{"test_name": "father_and_son", "response_0": "# father_and_son.mpc\n\n# Import necessary types from the MP-SPDZ compiler\nfrom Compiler.types import sint\n\n# Secret inputs (s_father_age from party 0, s_son_age from party 1, for example)\ns_father_age = sint.get_input_from(0)\ns_son_age = sint.get_input_from(1)\n\n# Compute the difference father_age - 2 * son_age\ns_diff = s_father_age - s_son_age * 2\n\n# Compute the absolute value of the difference\ns_abs_diff = s_diff.abs()\n\n# Reveal and print the result\nprint_ln(\"%s\", s_abs_diff.reveal())\n", "response_1": "# father_and_son.mpc\n\n# In MP-SPDZ, we need to handle the absolute value using secure operations.\n# This example shows how to translate the logic of abs(father_age - 2*son_age)\n# into corresponding MP-SPDZ operations on secret integers.\n\nfrom Compiler.types import sint\n\ndef father_and_son(father_age: sint, son_age: sint) -> sint:\n    difference = father_age - son_age * 2\n    sign = difference < 0  # Secret comparison, results in 1 if difference < 0, else 0\n    # Construct the absolute value:\n    # If sign is 1 => difference is negative => output is -difference\n    # If sign is 0 => difference is non-negative => output is difference\n    absolute_value = difference * (1 - sign) - difference * sign\n    return absolute_value\n", "model_name": "azure-openai-o1"}
{"test_name": "triangle_area", "response_0": "from Compiler.types import sfix\n\ndef triangle_area(side: sfix, height: sfix) -> sfix:\n    \"\"\"\n    Given the length of one side and the corresponding height, \n    compute the size of the triangle as a secret-shared fixed-point value.\n    \"\"\"\n    return side * height / 2\n", "response_1": "from Compiler.types import sfix\n\ndef triangle_area(side, height):\n    # Given the length of one side and the corresponding height, compute the size of the triangle.\n    return side * height / sfix(2)\n", "model_name": "azure-openai-o1"}
{"test_name": "sin_plus_cos", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sin, cos\n\ndef sin_plus_cos(a):\n    # a is an MP-SPDZ sfix or sfloat type\n    # sin() and cos() are implemented in the MP-SPDZ library\n    return sin(a) + cos(a)\n", "response_1": "# sin_plus_cos.mpc\n\nfrom Compiler.types import sfix\nfrom library.FixFunctions import Sine, Cosine\n\ndef sin_plus_cos(a):\n    # Returns sin(a) + cos(a) using approximate fixed-point operations\n    return Sine(a) + Cosine(a)\n\ndef main():\n    # Read secret input from player 0\n    a = sfix.get_input_from(0)\n    # Compute result\n    result = sin_plus_cos(a)\n    # Reveal and print\n    result.print_reveal()\n", "model_name": "azure-openai-o1"}
{"test_name": "sigmoid", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef sigmoid(x):\n    # This function computes the sigmoid value of secure sfix 'x'\n    return sfix(1) / (sfix(1) + exp(-x))\n", "response_1": "from Compiler.types import sfix\n\ndef sigmoid(x):\n    \"\"\"\n    sigmoid function in MP-SPDZ\n    \"\"\"\n    return sfix(1) / (sfix(1) + (-x).exp())\n", "model_name": "azure-openai-o1"}
{"test_name": "self_exponent", "response_0": "from Compiler.types import sfix\n\ndef self_exponent(k):\n    # k^k = e^(k * ln(k))\n    return (k.log() * k).exp()\n", "response_1": "from Compiler.types import cint, sint\n\ndef self_exponent(k):\n    # Convert the public integer input k to a secret integer\n    s_k = sint(k)\n    result = sint(1)\n    # Perform repeated multiplication for k times\n    for _ in range(k):\n        result *= s_k\n    return result\n\ndef main():\n    # Get public input k from player 0\n    k = cint.get_input_from(0)\n    # Compute k^k and reveal the result to player 0\n    output = self_exponent(k)\n    output.reveal_to(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "silu", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import exp\n\ndef silu(x):\n    # SiLU function in MP-SPDZ\n    return x / (sfix(1) + exp(-x))\n", "response_1": "from Compiler.types import sfix\n\ndef silu(x: sfix) -> sfix:\n    return x / (sfix(1) + sfix.exp(-x))\n", "model_name": "azure-openai-o1"}
{"test_name": "Gaussian_bracket", "response_0": "# In MP-SPDZ, there is no direct \"floor()\" for sfix, so we implement it.\n# We use trunc() that rounds toward zero and then compensate for negative values.\n\ndef floor_sfix(x):\n    x_int = x.trunc()            # integer part via rounding toward zero\n    is_negative = (x < 0)        # boolean check\n    is_exact_integer = (x == x_int)\n    # For strictly negative non-integers, floor is trunc(x) - 1.\n    return x_int - is_negative * (1 - is_exact_integer)\n\ndef Gaussian_bracket(x):\n    x_int = floor_sfix(x)\n    return x - x_int\n", "response_1": "from Compiler.types import sfix\n\ndef Gaussian_bracket(x):\n    x_int = sfix(x.floor())\n    return x - x_int\n", "model_name": "azure-openai-o1"}
{"test_name": "asin_and_square", "response_0": "# MP-SPDZ does not provide a built-in arcsin function, so here we use\n# a truncated power-series approximation to implement asin and then square it.\n# This approximation is valid for x in [-1, 1].\n# Note that better approximations can be used for higher accuracy.\n\nfrom Compiler.types import sfix\n\ndef asin_and_square(x):\n    # Polynomial approximation of asin(x) up to x^5:\n    # asin(x) \u2248 x + x^3/6 + 3*x^5/40\n    term1 = x\n    term3 = x**3 * sfix(1.0/6.0)\n    term5 = x**5 * sfix(3.0/40.0)\n    approx_asin = term1 + term3 + term5\n    return approx_asin * approx_asin\n", "response_1": "from Compiler.types import sfix\n\n# A short polynomial approximation of arcsin(x) for x in [-1,1].\n# Using the Taylor series expansion around 0:\n# arcsin(x) \u2248 x + (x^3)/6 + 3(x^5)/40 + 5(x^7)/112\ndef _approx_arcsin_sfix(x):\n    x3 = x * x * x\n    x5 = x3 * x * x\n    x7 = x5 * x * x\n    return x + (x3 / sfix(6.0)) + (x5 * (sfix(3.0) / sfix(40.0))) + (x7 * (sfix(5.0) / sfix(112.0)))\n\ndef asin_and_square(x):\n    # x is expected to be an sfix (secret fixed-point) value.\n    val_asin = _approx_arcsin_sfix(x)\n    return val_asin * val_asin\n", "model_name": "azure-openai-o1"}
{"test_name": "cylinder_surface", "response_0": "from Compiler.types import sfix\n\n# Define pi as a secret-fixed constant\npi = sfix(3.141592653589793)\n\n# Define the cylinder surface function\ndef cylinder_surface(r: sfix, h: sfix) -> sfix:\n    return 2 * pi * r * r + 2 * pi * r * h\n", "response_1": "def cylinder_surface(r, h):\n    # Define a constant for \u03c0 as an sfix or sfloat value\n    pi = sfix(3.141592653589793)\n    # Compute the surface area using MP-SPDZ operations\n    return 2 * pi * r * r + 2 * pi * r * h\n", "model_name": "azure-openai-o1"}
{"test_name": "radian_to_degree", "response_0": "from Compiler.types import sfix\n\nPI = sfix(3.141592653589793)\n\ndef radian_to_degree(r):\n    # Converting radian to degree in MP-SPDZ\n    return r / PI * sfix(180)\n", "response_1": "from Compiler.types import sfix\n\n# Define a constant for pi as an sfix\nPI = sfix(3.141592653589793)\n\ndef radian_to_degree(r):\n    # Convert radian to degree by multiplying by 180 and dividing by pi\n    return r * sfix(180) / PI\n", "model_name": "azure-openai-o1"}
{"test_name": "square_root", "response_0": "from Compiler.types import sfix\n\ndef square_root(a):\n    \"\"\"\n    return the square root of the input as an MP-SPDZ secure float\n    \"\"\"\n    return a.sqrt()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef square_root(a):\n    # 'a' is expected to be a secure fixed-point value (sfix)\n    # This function returns the square root of a secure fixed-point value.\n    return sqrt(a)\n", "model_name": "azure-openai-o1"}
{"test_name": "cosine_theorem", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import cos_fx, sqrt_fx\n\ndef cosine_theorem(a, b, rad):\n    # a, b, and rad are secret-shared variables of type sfix\n    return sqrt_fx(a*a + b*b - 2*a*b * cos_fx(rad))\n\ndef main():\n    # Code for reading inputs or further usage can be placed here\n    pass\n", "response_1": "def cosine_theorem(a, b, rad):\n    c = rad.cos()        # sfix method to approximate cosine\n    return (a * a + b * b - 2 * a * b * c).sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "lights_states", "response_0": "from Compiler.types import cint\nfrom Compiler.library import print_ln\n\ndef lights_states(num):\n    return 2 ** num\n\ndef main():\n    # Example: set num as a public integer constant\n    num = cint(5)\n    result = lights_states(num)\n    print_ln(\"%s\", result)\n", "response_1": "from Compiler.types import cint\n\ndef lights_states(num):\n    \"\"\"\n    Given the number of lights (all different), compute the total number of possible states.\n    (Each light has two states: on/off)\n    \"\"\"\n    # In MP-SPDZ, one way to compute 2^num is by shifting 1 to the left num times.\n    return 1 << num\n\ndef main():\n    # Read 'num' as a public integer from party 0\n    num = cint.get_input_from(0)\n    \n    # Compute the total number of possible states\n    total_states = lights_states(num)\n    \n    # Reveal the result\n    total_states.print_reveal()\n", "model_name": "azure-openai-o1"}
{"test_name": "degree_to_radian", "response_0": "def degree_to_radian(d):\n    # Converting degree to radian in MP-SPDZ\n    return (d / cfix(180.0)) * cfix(3.141592653589793)\n", "response_1": "from Compiler.types import sfix\n\nPI = sfix(3.141592653589793)\n\ndef degree_to_radian(d):\n    # d is assumed to be of type sfix, representing a secret fixed-point number\n    return d * (PI / sfix(180))\n", "model_name": "azure-openai-o1"}
{"test_name": "Fah_to_Cel", "response_0": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F):\n    # Convert Fahrenheit temperature to Celsius temperature.\n    return (F - sfix(32)) / sfix(1.8)\n", "response_1": "from Compiler.types import sfix\n\ndef Fah_to_Cel(F: sfix) -> sfix:\n    \"\"\"\n    Convert Fahrenheit temperature to Celsius temperature in MP-SPDZ.\n    \"\"\"\n    return (F - sfix(32)) / sfix(1.8)\n", "model_name": "azure-openai-o1"}
{"test_name": "elliptic_area", "response_0": "from Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    # Approximate pi\n    pi = sfix(3.141592653589793)\n    return pi * a * b\n", "response_1": "# elliptic_area.mpc\n\nfrom Compiler.types import sfix\n\ndef elliptic_area(a, b):\n    # Define pi as a sfix constant and multiply with a and b\n    return sfix(3.141592653589793) * a * b\n", "model_name": "azure-openai-o1"}
{"test_name": "floor", "response_0": "from Compiler.types import sfix\n\ndef floor(z):\n    # Compute the truncated integer part.\n    int_part = z.v >> z.f\n    int_part_sfix = sfix(int_part, z.k, z.f)\n    \n    # Compute the fractional part.\n    frac = z - int_part_sfix\n    \n    # Determine whether z is negative.\n    is_negative = z < 0\n    \n    # Determine whether z has a non-zero fractional part.\n    has_fraction = frac != 0\n    \n    # Subtract one from the truncated part if negative and fractional part is non-zero.\n    return int_part_sfix - (is_negative & has_fraction)\n", "response_1": "# floor.mpc\n\nfrom Compiler.types import sfix, sint\n\ndef floor(z):\n    \"\"\"\n    Return the maximum integer no bigger than the input.\n    \"\"\"\n    # Convert z to sfix if it isn't already\n    z_sfix = sfix.conv(z)\n    \n    # Get integer part by truncating towards zero\n    truncated = z_sfix.trunc()\n    \n    # Check if the value is negative\n    is_neg = (z_sfix < 0)\n    \n    # Determine whether there is a nonzero fractional part\n    fraction = z_sfix - sfix.from_sint(truncated)\n    has_fraction = (fraction != 0)\n    \n    # Subtract 1 if negative and has a fractional part, ensuring floor behavior\n    subtract_one = is_neg * has_fraction\n    return truncated - subtract_one\n", "model_name": "azure-openai-o1"}
{"test_name": "log_and_cube", "response_0": "from Compiler.types import sfix\n\ndef log_and_cube(x):\n    tmp = x.log2()\n    return tmp * tmp * tmp\n", "response_1": "from Compiler.types import sfix\n\ndef log_and_cube(x: sfix) -> sfix:\n    # approximate log base-2 by multiplying natural log(x) with 1 / ln(2)\n    log2_x = sfix(1.4426950408889634) * x.log()\n    return log2_x * log2_x * log2_x\n", "model_name": "azure-openai-o1"}
{"test_name": "floor_and_square", "response_0": "from Compiler.types import sfix\n\ndef floor_and_square(z):\n    \"\"\"\n    Calculate the maximum integer no bigger than the input. \n    Then return the square of the previous outcome. \n    \"\"\"\n    z_floor = z.Trunc()\n    return z_floor * z_floor\n", "response_1": "# We import the relevant functionality from MP-SPDZ\nfrom Compiler.types import sfix\n\n# Define the function to floor z and then square it.\ndef floor_and_square(z):\n    # TruncPr(a, k, f, compute_remainder=False, nearest=False) will\n    # truncate a to an integer (floor if a >= 0).\n    # k is the total bit length and f is the number of fractional bits.\n    \n    # Adjust k and f based on the implementation details of your protocol.\n    floor_z = z.TruncPr(k=31, f=16, compute_remainder=False, nearest=False)\n    return floor_z * floor_z\n", "model_name": "azure-openai-o1"}
{"test_name": "meters_to_feet", "response_0": "from Compiler.types import sfix\n\ndef meters_to_feet(m):\n    # Convert the length in meters to the length in feet.\n    return m * sfix(3.2808)\n", "response_1": "from Compiler.types import sfix\n\ndef meters_to_feet(m: sfix) -> sfix:\n    # Convert the length in meters to the length in feet using secure fixed-point arithmetic\n    return m * sfix(3.2808)\n", "model_name": "azure-openai-o1"}
{"test_name": "sphere_area", "response_0": "from Compiler.types import sfix\n\ndef sphere_area(r):\n    # Define a constant for \u03c0\n    pi = sfix(3.141592653589793)\n    # Calculate 4 \u00d7 \u03c0 \u00d7 r\u00b2\n    return 4 * pi * (r * r)\n", "response_1": "def sphere_area(r):\n    # Define pi as a secret fixed-point number\n    pi = sfix(3.141592653589793)\n    # Calculate the area of a sphere surface: 4 * pi * r^2\n    return 4 * pi * r * r\n", "model_name": "azure-openai-o1"}
{"test_name": "coarse_abs", "response_0": "from Compiler.types import sfix\n\ndef coarse_abs(x):\n    # x is a secret fixed-point number (sfix)\n    # Take the absolute value of x\n    abs_val = x.abs()\n    # Truncate (floor) the result to remove any fractional part\n    return abs_val.Trunc()\n", "response_1": "from Compiler.types import sfix\n\ndef coarse_abs(x):\n    # x is expected to be an sfix input\n    return x.abs().floor()\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_chickens", "response_0": "from Compiler.types import sint\nfrom Compiler.library import print_ln\n\ndef how_many_chickens(heads, legs):\n    return heads - (legs - heads * 2).div(2)\n\ndef main():\n    heads = sint.get_input_from(0)\n    legs = sint.get_input_from(0)\n    result = how_many_chickens(heads, legs)\n    print_ln('%s', result.reveal())\n", "response_1": "def main():\n    # Read input values (heads and legs) from party 0\n    heads = sint.get_input_from(0)\n    legs = sint.get_input_from(0)\n\n    # Compute chickens = heads - ((legs - 2 * heads) // 2)\n    temp = (legs - heads * 2).div(2)\n    chickens = heads - temp\n\n    # Print the result\n    chickens.print_ln(\"%s\", [chickens])\n", "model_name": "azure-openai-o1"}
{"test_name": "interest_calculator", "response_0": "# interest_calculator.mpc\n\n# This function calculates the interest you can get,\n# given the initial capital, interest ratio, and number of months.\n\ndef interest_calculator(capital, ratio, months):\n    one = sfix(1)\n    interest_factor = (one + ratio).pow_i(months) - one\n    return interest_factor * capital\n", "response_1": "def interest_calculator(capital, ratio, months):\n    # capital, ratio, months can be sfix or a combination of sfix and sint \n    return ((sfix(1) + ratio).pow(months) - sfix(1)) * capital\n", "model_name": "azure-openai-o1"}
{"test_name": "circle_area", "response_0": "from Compiler.types import cfix\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    \"\"\"\n    pi = cfix(3.141592653589793)\n    return pi * r * r\n", "response_1": "from Compiler.types import sfix\n\ndef circle_area(r):\n    \"\"\"\n    Return the area of the circle with given radius.\n    This function takes a secure fixed-point number \"r\" and returns a secure fixed-point result.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return pi * r * r\n", "model_name": "azure-openai-o1"}
{"test_name": "cube_and_square_root", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef cube_and_square_root(x: sfix):\n    # Compute x^3\n    x_cubed = x * x * x\n    # Return the square root of x^3\n    return sqrt(x_cubed)\n", "response_1": "from Compiler.library import sqrt\nfrom Compiler.types import sfix\n\ndef cube_and_square_root(x: sfix) -> sfix:\n    \"\"\"\n    take cube to the input, then compute the square root of the outcome\n    \"\"\"\n    return sqrt(x * x * x)\n", "model_name": "azure-openai-o1"}
{"test_name": "round", "response_0": "def mpc_round(x):\n    # x is expected to be an sfix in MP-SPDZ\n    x_int = x.floor()                        # Step 1: Get the floor of x\n    fraction = x - x_int                     # Step 2: Compute the fractional part\n    compare_fraction = fraction < 0.5        # Step 3: Compare fractional part to 0.5\n    return compare_fraction.if_else(x_int, x_int + 1)  # Step 4: Select the rounded value\n", "response_1": "# MP-SPDZ code translating the Python round function logic\n\n# This file assumes that x is an sfix or sfloat variable holding\n# the secret/shared real number value to be rounded.\n\ndef round(x):\n    \"\"\"\n    Round x to the nearest integer.\n    \"\"\"\n    x_int = x.floor()\n    fractional_part = x - x_int\n    condition_bit = (fractional_part >= 0.5)\n    return x_int + condition_bit\n", "model_name": "azure-openai-o1"}
{"test_name": "cryptic_adjustment", "response_0": "# mp_spdz_cryptic_adjustment.mpc\nfrom Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef cryptic_adjustment(origin):\n    \"\"\"\n    The professor wants to adjust the pessimistic score of his students:\n    The adjustment formula is 10 * sqrt(10 * sqrt(origin))\n    \"\"\"\n    return sfix(10) * sqrt(sfix(10) * sqrt(origin))\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt_sfix\n\ndef cryptic_adjustment(origin):\n    # The adjustment formula is: 10 * sqrt(10 * sqrt(origin))\n    return 10 * sqrt_sfix(10 * sqrt_sfix(origin))\n\n# Example usage in MP-SPDZ context:\n# 1) Securely receive secret-shared input 'origin' from player 0\n# 2) Compute the cryptic_adjustment\n# 3) Reveal and print the result\norigin = sfix.get_input_from(0)\nadjusted_score = cryptic_adjustment(origin)\nadjusted_score.reveal().print_ln(\"%s\")\n", "model_name": "azure-openai-o1"}
{"test_name": "specific_pow", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef specific_pow(x):\n    # Equivalent to x^(2.5), using the identity x^(2.5) = x^2 * sqrt(x).\n    return x * x * sqrt(x)\n", "response_1": "from Compiler.types import sfix\n\ndef specific_pow(x):\n    # x is an sfix variable\n    # x^(2.5) = x^2 * (sqrt(x))\n    return (x * x) * x.sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "soft_plus", "response_0": "from Compiler.types import sfix\n\n# Softplus function in MP-SPDZ\ndef soft_plus(x):\n    return (1 + x.exp()).log()\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import exp, log\n\ndef soft_plus(x):\n    return log(sfix(1) + exp(x))\n", "model_name": "azure-openai-o1"}
{"test_name": "ball_volume", "response_0": "from Compiler.types import sfix, cfix\n\ndef ball_volume(r):\n    # Approximate \u03c0 as a compile-time constant\n    pi = cfix(3.141592653589793)\n    # Compute volume = (4/3) * \u03c0 * r^3\n    volume = (cfix(4) / cfix(3)) * pi * (r * r * r)\n    return volume\n", "response_1": "# ball_volume.mpc\n\nfrom Compiler.types import sfix\n\ndef ball_volume(r):\n    \"\"\"\n    Return the volume of the ball with given radius,\n    where r is a secure value of type sfix.\n    \"\"\"\n    pi_val = sfix(3.141592653589793)\n    return (pi_val * (r * r * r) * sfix(4)) / sfix(3)\n", "model_name": "azure-openai-o1"}
{"test_name": "Heron", "response_0": "from Compiler.types import sfix\n\ndef Heron(a: sfix, b: sfix, c: sfix):\n    # Compute the semi-perimeter\n    p = (a + b + c) / sfix(2)\n    # Apply Heron's formula\n    return (p * (p - a) * (p - b) * (p - c)).sqrt()\n", "response_1": "from Compiler.types import sfix\n\ndef Heron(a, b, c):\n    p = (a + b + c) / sfix(2)\n    return (p * (p - a) * (p - b) * (p - c)).sqrt()\n", "model_name": "azure-openai-o1"}
{"test_name": "next_perfect_square", "response_0": "def next_perfect_square(x):\n    # x is assumed to be an 'sfix', carrying a secret-shared positive integer\n    sqrt_x = x.sqrt()                 # Secure square root operation\n    floor_sqrt_x = sqrt_x.trunc()     # Truncation behaves like floor for positive values\n    next_val = floor_sqrt_x + cfix(1) # Secure constant for integer 1\n    return next_val * next_val        # Square of (floor(sqrt(x)) + 1)\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import print_ln\n\ndef next_perfect_square(x):\n    i = sint(1)\n    # simple loop that increments i until i*i > x\n    while (i * i <= x):\n        i = i + 1\n    return i * i\n\ndef main():\n    x = sint.get_input_from(0)  # Reads x as secure input from player 0\n    result = next_perfect_square(x)\n    print_ln(\"%s\", result.reveal())  # Reveal and print the result\n", "model_name": "azure-openai-o1"}
{"test_name": "pi_to_the_x", "response_0": "from Compiler.types import sfix\nfrom Compiler.library import print_ln\n\ndef pi_to_the_x(x):\n    # Approximate pi.\n    PI = sfix(3.14159265359)\n    return PI.pow(x)\n\ndef main():\n    x = sfix.get_input_from(0)\n    result = pi_to_the_x(x)\n    print_ln(\"%s\", result)\n", "response_1": "def pi_to_the_x(x):\n    from Compiler.types import cfix\n    PI = cfix(3.141592653589793)\n    return PI ** x\n", "model_name": "azure-openai-o1"}
{"test_name": "spring_rocket", "response_0": "# This MP-SPDZ program computes the minimum compression length of a spring\n# that can launch a mass m to a specified height, given spring stiffness k.\n# We use g = 9.8 in the calculation.\n\n# Import the types\nfrom Compiler.types import sfix\n\n# Read inputs as secure fixed-point values\nheight = sfix.get_input_from(0)\nm = sfix.get_input_from(0)\nk = sfix.get_input_from(0)\n\n# Define gravity as a constant\ng = sfix(9.8)\n\n# Compute the required spring compression\n# formula: sqrt(2*m*g*height/k)\ncompression = (2 * m * g * height / k).sqrt()\n\n# Reveal the result (if needed)\nprint_ln(\"Minimum compression: %s\", compression.reveal())\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef spring_rocket(height, m, k):\n    g = sfix(9.8)\n    two = sfix(2)\n    return sqrt((two * m * g * height) / k)\n\ndef main():\n    height = sfix.get_input_from(0)\n    m = sfix.get_input_from(1)\n    k = sfix.get_input_from(2)\n    compression = spring_rocket(height, m, k)\n    compression.print_ln(\"Minimum compression: %s\")\n", "model_name": "azure-openai-o1"}
{"test_name": "cone_volume", "response_0": "from Compiler.types import sfix\n\ndef cone_volume(r, h):\n    \"\"\"\n    Given the radius and height, compute the volume of the cone.\n    \"\"\"\n    pi = sfix(3.141592653589793)\n    return pi * r * r * h / sfix(3)\n", "response_1": "from Compiler.types import sfix\n\nPI = sfix(3.141592653589793)\n\ndef cone_volume(r, h):\n    return PI * r * r * h / sfix(3)\n", "model_name": "azure-openai-o1"}
{"test_name": "how_many_rabbits", "response_0": "def how_many_rabbits(heads, legs):\n    # heads and legs are secure integer types (e.g., sint) in MP-SPDZ\n    return (legs - (heads * 2)) // 2\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import print_ln\n\ndef how_many_rabbits(heads: sint, legs: sint):\n    # Compute the number of rabbits in the rabbit-chicken problem.\n    # Equivalent to: (legs - heads * 2) // 2 in Python\n    return (legs - heads * 2).int_div(2)\n", "model_name": "azure-openai-o1"}
