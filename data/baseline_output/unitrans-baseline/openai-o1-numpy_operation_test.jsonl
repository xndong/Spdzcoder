{"test_name": "array_from_intrinsic_linspace", "response_0": "from Compiler.types import sfix, Array\n\n# Define the parameters as sfix (secure fixed-point).\nstart = sfix(0)\nend = sfix(99)\nnum = 10  # Treated as a Python integer for the loop size.\n\n# Compute the step as (end - start) / (num - 1).\nstep = (end - start) / sfix(num - 1)\n\n# Create an array of sfix elements.\na = Array(num, sfix)\n\n# Fill each position in the array to replicate np.linspace.\nfor i in range(num):\n    a[i] = start + step * sfix(i)\n", "response_1": "def main():\n    start = sfix(0)\n    end = sfix(99)\n    num = 10\n    step = (end - start) / sfix(num - 1)\n    a = Array(num, sfix)\n    for i in range(num):\n        a[i] = start + sfix(i) * step\n", "model_name": "azure-openai-o1"}
{"test_name": "more_positive", "response_0": "def more_positive(arr):\n    # arr is expected to be a list of secure integers (sint)\n    sum_signs = sint(0)\n    for x in arr:\n        # Each comparison returns a secure bit (0 or 1)\n        is_positive = x > 0\n        is_negative = x < 0\n        # Convert the two bits into -1, 0, or 1\n        sign_value = is_positive - is_negative\n        sum_signs += sign_value\n\n    # Compare the sum to zero; the result is a secure bit\n    return sum_signs > sint(0)\n", "response_1": "# more_positive.mpc\n\ndef more_positive(arr):\n    # 'arr' is expected to be a list of s_int values.\n    count = s_int(0)\n    for x in arr:\n        # Equivalent of numpy.sign() for each element x\n        sign_x = (x > 0) - (x < 0)\n        count += sign_x\n    # Return whether the sum of signs is greater than 0\n    return (count > 0)\n", "model_name": "azure-openai-o1"}
{"test_name": "select", "response_0": "# mp-spdz code translation of the Python select function\n# The function below demonstrates how to select elements from two arrays\n# based on a condition array (each entry is a secret bit).\n# It's assumed that ind[i], a[i], b[i] are secure types of compatible length.\n\nfrom Compiler.types import sbit, sfix\n\ndef select(ind, a, b):\n    n = len(a)\n    res = []\n    for i in range(n):\n        # sbit.if_else(x, y) will return x if the bit is 1, else y\n        res.append(ind[i].if_else(a[i], b[i]))\n    return res\n", "response_1": "def select(ind, a, b):\n    n = len(a)\n    result = sfix.Array(n)\n    for i in range(n):\n        result[i] = ind[i] * a[i] + (sfix(1) - ind[i]) * b[i]\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "np_relu", "response_0": "from Compiler.types import sfix\n\ndef relu(y):\n    # The ReLU of y is y if y>0, else 0\n    return y * (y > 0)\n", "response_1": "# In MP-SPDZ, we assume 'y' is an sfix (secure fixed-point) type.\n# This function returns y if y > 0, and 0 otherwise.\n\ndef relu(y):\n    condition = y > sfix(0)\n    return y * condition\n", "model_name": "azure-openai-o1"}
{"test_name": "cost_matrix", "response_0": "# cost_matrix.mpc\n# Translates the given Python function into MP-SPDZ code that computes a cost matrix\n# from a profit matrix by subtracting each element from the global maximum.\n\ndef cost_matrix(profit_matrix):\n    # Determine matrix dimensions\n    n = profit_matrix.sizes[0]\n    m = profit_matrix.sizes[1]\n\n    # Initialize a very small secret value for tracking the maximum\n    max_val = sfix(-9999999999)\n\n    # Find the maximum value in profit_matrix\n    for i in range(n):\n        for j in range(m):\n            bigger = profit_matrix[i][j] > max_val\n            max_val = bigger.if_else(profit_matrix[i][j], max_val)\n\n    # Create a new matrix for the result\n    result = sfix.Matrix(n, m)\n\n    # Compute cost_matrix = max_val - profit_matrix element-wise\n    for i in range(n):\n        for j in range(m):\n            result[i][j] = max_val - profit_matrix[i][j]\n\n    return result\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import if_else\n\ndef cost_matrix(profit_matrix):\n    # Determine matrix dimensions\n    n_rows = len(profit_matrix)\n    n_cols = len(profit_matrix[0])\n\n    # Find the maximum value in the profit matrix\n    max_val = profit_matrix[0][0]\n    for i in range(n_rows):\n        for j in range(n_cols):\n            max_val = if_else(profit_matrix[i][j] > max_val, profit_matrix[i][j], max_val)\n\n    # Create the cost matrix by subtracting each element from the max value\n    cost_mat = []\n    for i in range(n_rows):\n        row = []\n        for j in range(n_cols):\n            row.append(max_val - profit_matrix[i][j])\n        cost_mat.append(row)\n\n    return cost_mat\n", "model_name": "azure-openai-o1"}
{"test_name": "np_zeros", "response_0": "n = 10\na = sfix.Array(n)\nfor i in range(n):\n    a[i] = sfix(0)\n", "response_1": "n = 10\na = sfix.Array(n)\nfor i in range(n):\n    a[i] = sfix(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "def array_dimensional_indexing(array, row_index):\n    \"\"\"\n    MP-SPDZ function to index the i-th row from a 2-D secret-shared or clear matrix.\n    row_index is assumed to be a public (regint) index.\n    \"\"\"\n    row = array[row_index]\n    return row\n", "response_1": "from Compiler.types import sint, Array\n\ndef array_dimensional_indexing(ndarray, row_index, row_length):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D arrays.\n    \"\"\"\n    selected_row = Array(row_length, sint)\n    for j in range(row_length):\n        selected_row[j] = ndarray[row_index][j]\n    return selected_row\n", "model_name": "azure-openai-o1"}
{"test_name": "np_zeros_2", "response_0": "from Compiler.types import sint\n\ndef zeros(n):\n    zero_array = [sint(0) for _ in range(n)]\n    return zero_array\n\ndef main():\n    n = 10  # plain text variable\n    result = zeros(n)\n", "response_1": "from Compiler.types import sfix, Array\n\ndef zeros(n):\n    res = Array(n, sfix)\n    for i in range(n):\n        res[i] = sfix(0)\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_slicing_stride", "response_0": "from Compiler.types import sfix, Array\n\ndef array_concate(ndarrayA, ndarrayB):\n    # Determine lengths of the input arrays\n    lengthA = len(ndarrayA)\n    lengthB = len(ndarrayB)\n\n    # Prepare containers for even-indexed elements from the first array\n    halfCountA = (lengthA + 1) // 2\n    evenA = Array(halfCountA, sfix)\n    indexA = 0\n    for i in range(lengthA):\n        if i % 2 == 0:\n            evenA[indexA] = ndarrayA[i]\n            indexA += 1\n\n    # Prepare containers for odd-indexed elements from the second array\n    halfCountB = lengthB // 2\n    oddB = Array(halfCountB, sfix)\n    indexB = 0\n    for i in range(lengthB):\n        if i % 2 == 1:\n            oddB[indexB] = ndarrayB[i]\n            indexB += 1\n\n    # Concatenate the two sub-arrays\n    result_length = halfCountA + halfCountB\n    concatenated_array = Array(result_length, sfix)\n    for i in range(halfCountA):\n        concatenated_array[i] = evenA[i]\n    for j in range(halfCountB):\n        concatenated_array[halfCountA + j] = oddB[j]\n\n    return concatenated_array\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import Array\n\ndef array_concate(A, B, sizeA, sizeB):\n    \"\"\"\n    MP-SPDZ program replicating the functionality:\n    Collect all even-index elements from A and all odd-index elements from B,\n    then return their concatenation.\n    \"\"\"\n    viewA_len = (sizeA + 1) // 2\n    viewA = Array(viewA_len, sint)\n    for i in range(viewA_len):\n        viewA[i] = A[2 * i]\n\n    # Compute length of elements taken from B (odd indices start at 1),\n    # ensuring it doesn't go negative.\n    viewB_len = (sizeB - 1 + 1) // 2 if sizeB > 1 else 0\n    viewB = Array(viewB_len, sint)\n    for i in range(viewB_len):\n        viewB[i] = B[1 + 2 * i]\n\n    # Concatenate viewA and viewB\n    C_len = viewA_len + viewB_len\n    C = Array(C_len, sint)\n    for i in range(viewA_len):\n        C[i] = viewA[i]\n    for i in range(viewB_len):\n        C[viewA_len + i] = viewB[i]\n\n    return C\n", "model_name": "azure-openai-o1"}
{"test_name": "QR_decomposition", "response_0": "def dot_product(a, b):\n    # Assumes a and b have the same length\n    s = sfix(0)\n    for i in range(len(a)):\n        s += a[i] * b[i]\n    return s\n\ndef norm(a):\n    # Secure norm using sfix.sqrt()\n    return sfix.sqrt(dot_product(a, a))\n\ndef QR_decomposition(mat):\n    # Assumes mat is a list of lists of sfix\n    n = len(mat)      # number of rows\n    m = len(mat[0])   # number of columns\n\n    # Initialize Q with zeros\n    Q = [[sfix(0) for _ in range(m)] for _ in range(n)]\n\n    for j in range(m):\n        # Copy the j-th column of mat into v_j\n        v_j = [mat[i][j] for i in range(n)]\n\n        # Subtract projections of v_j onto previously computed columns of Q\n        for i in range(j):\n            # Build the i-th column of Q\n            q_i = [Q[row][i] for row in range(n)]\n            # Compute dot product\n            r_ij = dot_product(v_j, q_i)\n            # Subtract projection from v_j\n            for row in range(n):\n                v_j[row] -= r_ij * q_i[row]\n\n        # Compute norm of v_j\n        norm_vj = norm(v_j)\n\n        # Normalize v_j to become the j-th column of Q\n        for row in range(n):\n            Q[row][j] = v_j[row] / norm_vj\n\n    return Q\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.library import sqrt\n\ndef QR_decomposition(mat):\n    \"\"\"\n    Returns the Q matrix of the QR-decomposition (via classical Gram-Schmidt)\n    of an input matrix 'mat' (list of lists of sfix).\n    \"\"\"\n    m = len(mat)\n    n = len(mat[0])\n\n    # Initialize Q\n    Q = [[sfix(0) for _ in range(n)] for _ in range(m)]\n\n    def dot_product(a, b):\n        acc = sfix(0)\n        for i in range(len(a)):\n            acc += a[i] * b[i]\n        return acc\n\n    def get_column(A, col):\n        return [A[i][col] for i in range(len(A))]\n\n    def set_column(A, col, vec):\n        for i in range(len(A)):\n            A[i][col] = vec[i]\n\n    # Classical Gram-Schmidt\n    for j in range(n):\n        v_j = get_column(mat, j)\n        for k in range(j):\n            u_k = get_column(Q, k)\n            r_kj = dot_product(u_k, v_j)\n            for i in range(m):\n                v_j[i] = v_j[i] - r_kj * u_k[i]\n        r_jj = sqrt(dot_product(v_j, v_j))\n        for i in range(m):\n            Q[i][j] = v_j[i] / r_jj\n\n    return Q\n", "model_name": "azure-openai-o1"}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of the nearest value in a secure or public array\n    to the given value.\n    \"\"\"\n    n = len(array)\n    # Compute initial minimum difference and corresponding index\n    min_diff = (array[0] - value).abs()\n    min_idx = 0\n\n    # Loop over each element to find the minimal absolute difference\n    for i in range(1, n):\n        diff = (array[i] - value).abs()\n        # Use secure if-else to update min_diff and min_idx\n        cond = diff < min_diff\n        min_diff = cond.if_else(diff, min_diff)\n        min_idx = cond.if_else(i, min_idx)\n\n    return min_idx\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import if_else\n\ndef find_nearest_index(array, value):\n    # Initialize best_val to a large number and best_idx to 0\n    best_val = sfix(1e37)\n    best_idx = sint(0)\n    \n    # Iterate over elements in the array\n    for i in range(len(array)):\n        diff = array[i] - value\n        abs_diff = if_else(diff < 0, -diff, diff)\n        \n        # Compare the current absolute difference with the best_val\n        update_condition = abs_diff < best_val\n        \n        # Update the best_val and best_idx\n        best_val = if_else(update_condition, abs_diff, best_val)\n        best_idx = if_else(update_condition, sint(i), best_idx)\n    \n    return best_idx\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_simple_row", "response_0": "from Compiler.types import sfix, Array\n\ndef array_simple_concate_rows(A, B):\n    \"\"\"\n    MP-SPDZ program to concatenate elements from two 2-D secret-shared arrays along the first dimension.\n    A and B are assumed to be 2-D arrays of secret type (e.g., Array(lenA, Array(width, sfix))).\n    \"\"\"\n    lenA = len(A)\n    lenB = len(B)\n    width = len(A[0])\n\n    # Create output array\n    C = Array(lenA + lenB, lambda: Array(width, sfix))\n\n    # Copy rows from A\n    for i in range(lenA):\n        for j in range(width):\n            C[i][j] = A[i][j]\n\n    # Copy rows from B\n    for i in range(lenB):\n        for j in range(width):\n            C[lenA + i][j] = B[i][j]\n\n    return C\n", "response_1": "# MP-SPDZ code translating the array_simple_concate_rows function\n# that concatenates two 2D arrays along axis 0.\n\nfrom Compiler.types import sfix\nfrom Compiler.library import *\n\ndef array_simple_concate_rows(A, B, nA, nB, p):\n    # A is a matrix of size nA x p\n    # B is a matrix of size nB x p\n    # We create a result matrix of size (nA + nB) x p\n    res = Matrix(sfix, nA + nB, p)\n    \n    for i in range(nA):\n        for j in range(p):\n            res[i][j] = A[i][j]\n    \n    for i in range(nB):\n        for j in range(p):\n            res[nA + i][j] = B[i][j]\n    \n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    length = len(ndarray)\n    new_array = sfix.Array(length)\n    for i in range(length):\n        new_array[i] = ndarray[i]\n    return new_array\n", "response_1": "def array_copy(ndarray):\n    n = len(ndarray)\n    copied_array = Array(n, typeof(ndarray[0]))\n    for i in range(n):\n        copied_array[i] = ndarray[i]\n    return copied_array\n", "model_name": "azure-openai-o1"}
{"test_name": "max_pooling", "response_0": "def max_pooling(x, stride):\n    n = x.sizes[0]\n    h = x.sizes[1]\n    w = x.sizes[2]\n    oh = h // stride\n    ow = w // stride\n\n    out = sfix.Matrix(n, oh, ow)\n\n    for b in range(n):\n        for i in range(0, h, stride):\n            for j in range(0, w, stride):\n                max_val = x[b][i][j]\n                for p in range(stride):\n                    for q in range(stride):\n                        candidate = x[b][i + p][j + q]\n                        max_val = sfix.if_else(candidate > max_val, candidate, max_val)\n                out[b][i // stride][j // stride] = max_val\n\n    return out\n", "response_1": "def max_pooling(x, stride):\n    # Determine dimensions of x.\n    N = x.sizes[0]\n    H = x.sizes[1]\n    W = x.sizes[2]\n\n    # Compute output dimensions.\n    out_dim1 = N\n    out_dim2 = H // stride\n    out_dim3 = W // stride\n\n    # Allocate output tensor.\n    out = sfix.Tensor([out_dim1, out_dim2, out_dim3])\n\n    # Nested loop for max pooling.\n    for b in range(N):\n        for i in range(0, H, stride):\n            for j in range(0, W, stride):\n                val = x[b][i][j]\n                # Compute the maximum over the stride x stride window.\n                for p in range(stride):\n                    for q in range(stride):\n                        comparison = x[b][i+p][j+q] > val\n                        val = sfix.if_else(comparison, x[b][i+p][j+q], val)\n                # Assign the maximum value to the correct position.\n                out[b][i // stride][j // stride] = val\n\n    return out\n", "model_name": "azure-openai-o1"}
{"test_name": "array_reshape", "response_0": "a = Matrix(3, 5, sint)\nfor i in range(3):\n    for j in range(5):\n        a[i][j] = sint(i * 5 + j)\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import *\n\ndef main():\n    a = Matrix(3, 5, sint)\n    for i in range(3):\n        for j in range(5):\n            a[i][j] = sint(5 * i + j)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_simple_column", "response_0": "def array_simple_concate_column(A, B, rows, colsA, colsB):\n    # A and B are lists (2-D) of secure types, for example sfix or sint\n    # rows, colsA, colsB are integer sizes\n    # This function creates a new 2-D list (rows x (colsA + colsB)) by \n    # concatenating A and B along their second dimension.\n    C = [[sfix(0) for _ in range(colsA + colsB)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(colsA):\n            C[i][j] = A[i][j]\n        for j in range(colsB):\n            C[i][colsA + j] = B[i][j]\n    return C\n", "response_1": "# This MP-SPDZ program demonstrates a function to concatenate two 2-D secret-shared arrays (A, B)\n# along axis=1 (column-wise) and return the result.\n\nfrom Compiler.types import sfix, Matrix\n\ndef array_simple_concate_column(A, B):\n    # Get the dimensions of the secret-shared arrays\n    n = len(A)           # number of rows in A\n    cA = len(A[0])       # number of columns in A\n    cB = len(B[0])       # number of columns in B\n    \n    # Initialize the output matrix with sfix type\n    C = Matrix(n, cA + cB, sfix)\n    \n    # Copy elements of A into the output matrix\n    for i in range(n):\n        for j in range(cA):\n            C[i][j] = A[i][j]\n            \n    # Copy elements of B into the output matrix (to the right of A)\n    for i in range(n):\n        for j in range(cB):\n            C[i][cA + j] = B[i][j]\n    \n    # Return the new concatenated matrix\n    return C\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "# MP-SPDZ translation of array_dimensional_indexing.\n# This function extracts the i-th column from a 2D array of secure integers.\n# ndarray: a 2D array of sint elements\n# column_index: an integer specifying the column to extract\n\ndef array_dimensional_indexing(ndarray, column_index):\n    row_count = len(ndarray)\n    column_data = [None] * row_count\n    for i in range(row_count):\n        column_data[i] = ndarray[i][column_index]\n    return column_data\n", "response_1": "from Compiler.types import sfix, sint, Array, pubint\n\ndef array_dimensional_indexing_2D(matrix, col_index):\n    \"\"\"\n    MP-SPDZ function to index the i-th column from a 2-D secret-shared array.\n    matrix     : a list of lists (2-D) of sfix values, e.g. [ [sfix, sfix,...], [sfix, sfix, ...], ... ]\n    col_index  : a public integer (pubint) indicating the index of the desired column\n\n    Returns a 1-D list of sfix values corresponding to matrix[:, col_index].\n    \"\"\"\n    num_rows = len(matrix)\n    # Create a result array for the column\n    result_column = [sfix(0) for _ in range(num_rows)]\n    \n    # Copy the col_index-th element from each row into result_column\n    for i in range(num_rows):\n        # Because col_index is public, direct indexing is possible\n        result_column[i] = matrix[i][col_index]\n    \n    return result_column\n", "model_name": "azure-openai-o1"}
{"test_name": "np_diagonal", "response_0": "from Compiler.types import sfix, Array\n\ndef diag(matrix, n):\n    diag_res = Array(n, sfix)\n    for i in range(n):\n        diag_res[i] = matrix[i][i]\n    return diag_res\n", "response_1": "def diag(matrix):\n    n = len(matrix)\n    diagonal = Array(n, sfix)\n    for i in range(n):\n        diagonal[i] = matrix[i][i]\n    return diagonal\n", "model_name": "azure-openai-o1"}
{"test_name": "np_concat_special", "response_0": "# array_special_concate.mpc\n\nfrom Compiler.types import sint, sfix\nfrom Compiler.library import for_range\nfrom Compiler.library import print_ln\n\ndef array_special_concate(A, B, n, mA, mB):\n    # Calculate number of output columns when concatenating\n    # even-indexed columns from A and odd-indexed columns from B\n    out_m = (mA + 1) // 2 + (mB // 2)\n    out = sfix.Matrix(n, out_m)\n\n    # Fill in even-indexed columns from A\n    for c in range((mA + 1) // 2):\n        col_in_A = 2 * c\n        if col_in_A < mA:\n            for r in range(n):\n                out[r][c] = A[r][col_in_A]\n\n    # Fill in odd-indexed columns from B\n    offset = (mA + 1) // 2\n    for c in range(mB // 2):\n        col_in_B = 2 * c + 1\n        if col_in_B < mB:\n            for r in range(n):\n                out[r][offset + c] = B[r][col_in_B]\n\n    return out\n\ndef main():\n    # Read matrix dimensions\n    n = sint.get_input_from(0)\n    mA = sint.get_input_from(0)\n    mB = sint.get_input_from(0)\n\n    # Read input matrices A and B (both of size n x mA/n x mB respectively)\n    A = sfix.Matrix(n, mA)\n    B = sfix.Matrix(n, mB)\n    for i in range(n):\n        for j in range(mA):\n            A[i][j] = sfix.get_input_from(0)\n    for i in range(n):\n        for j in range(mB):\n            B[i][j] = sfix.get_input_from(0)\n\n    # Perform special concatenation\n    out = array_special_concate(A, B, n, mA, mB)\n\n    # Reveal and print result\n    for i in range(n):\n        for j in range((mA + 1) // 2 + (mB // 2)):\n            out[i][j].reveal().print_ln()\n", "response_1": "# MP-SPDZ code translating the array_special_concate function from Python/NumPy.\n# This version uses matrix slicing logic in MP-SPDZ to replicate the idea of\n# taking every other row from A, and every other row (starting from row 1) from B,\n# then concatenating the two results horizontally (axis=1).\n\nfrom Compiler.library import *\n\ndef array_special_concate(A, B, n, m):\n    \"\"\"\n    Replicates the slicing and concatenation behavior:\n      viewA = A[:][::2]\n      viewB = B[:][1:][::2]\n      return concatenation of viewA and viewB along axis=1\n    Here, A and B are both n x m matrices of secret-shared data (e.g. sfix).\n    \"\"\"\n    # Extract rows with indices 0, 2, 4, ...\n    viewA = Matrix(sfix, n//2, m)\n    row_idx_A = 0\n    for i in range(0, n, 2):\n        for j in range(m):\n            viewA[row_idx_A][j] = A[i][j]\n        row_idx_A += 1\n\n    # Extract rows with indices 1, 3, 5, ...\n    viewB = Matrix(sfix, n//2, m)\n    row_idx_B = 0\n    for i in range(1, n, 2):\n        for j in range(m):\n            viewB[row_idx_B][j] = B[i][j]\n        row_idx_B += 1\n\n    # Concatenate the two results along axis=1\n    result = Matrix(sfix, n//2, 2*m)\n    for i in range(n//2):\n        for j in range(m):\n            result[i][j] = viewA[i][j]\n        for j in range(m):\n            result[i][j + m] = viewB[i][j]\n\n    return result\n", "model_name": "azure-openai-o1"}
{"test_name": "np_arange", "response_0": "def arange(start, stop=None, step=1):\n    \"\"\"\n    create a 1-d array (plain text) similar to numpy.arange\n    \"\"\"\n    from Compiler.types import Array, cint\n\n    if stop is None:\n        stop = start\n        start = 0\n\n    length = (stop - start + step - 1) // step\n    res = Array(length, cint)\n    for i in range(length):\n        res[i] = cint(start + i * step)\n    return res\n", "response_1": "def arange(start, stop=None, step=1):\n    from Compiler.types import cint\n    # When translating to MP-SPDZ, we cannot rely on numpy.arange or 'None' checks directly.\n    # Here is an adapted version using plain Python logic and producing a list of cints.\n    \n    if stop is None:\n        stop = start\n        start = 0\n    \n    # Compute the integer length of the resulting range\n    length = 0\n    if step > 0:\n        length = (stop - start + (step - 1)) // step\n    else:\n        length = (stop - start + (step + 1)) // step\n    \n    # Build the array of cints\n    array_cint = []\n    for i in range(length):\n        array_cint.append(cint(start + i * step))\n    \n    return array_cint\n", "model_name": "azure-openai-o1"}
{"test_name": "np_eye_2", "response_0": "m = 3\nn = 5\n\n# Create a 3x5 matrix of secure integers\na = Matrix(sint, m, n)\n\n# Set each entry to 1 if it's on the diagonal, otherwise 0\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = 1\n        else:\n            a[i][j] = 0\n", "response_1": "from Compiler.types import sfix\nfrom Compiler.matrix import Matrix\n\nm = 3\nn = 5\n\na = Matrix(sfix, m, n)\n\nfor i in range(m):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sfix(1)\n        else:\n            a[i][j] = sfix(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "third_smallest", "response_0": "from Compiler.types import sint, sbit\nfrom Compiler.library import if_else\n\ndef third_smallest(arr):\n    n = len(arr)\n    # Perform a simple bubble sort\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            # Compare arr[j] and arr[j+1]\n            cond = arr[j] > arr[j+1]  # cond is a sbit\n            # Conditionally swap\n            temp = arr[j]\n            arr[j]   = if_else(cond, arr[j+1], arr[j])\n            arr[j+1] = if_else(cond, temp, arr[j+1])\n    # Return the third smallest element\n    return arr[2]\n", "response_1": "# This code reads a fixed number of secret-shared inputs (arr),\n# applies a bubble sort, and then reveals the third-smallest element.\n\n# Declare that we will use secure fixed-point variables (sfix) or integers (sint) as needed.\n# The example below uses sfix, but sint could be used directly for integers.\n\n# Bubble sort function\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(n - i - 1):\n            swap_cond = arr[j] > arr[j + 1]\n            # Secure swap\n            bigger = swap_cond.if_else(arr[j], arr[j + 1])\n            smaller = swap_cond.if_else(arr[j + 1], arr[j])\n            arr[j] = smaller\n            arr[j + 1] = bigger\n\ndef main():\n    # For demonstration, suppose we have n = 5 inputs.\n    n = 5\n    arr = [sfix.get_input_from(0) for _ in range(n)]\n\n    # Sort the array\n    bubble_sort(arr)\n\n    # Reveal and print the third smallest element\n    # (index 2 after sorting assumes at least 3 inputs)\n    print_ln(\"Third smallest element: %s\", arr[2].reveal())\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "from Compiler.types import regint, sfix\nfrom Compiler.matrix import Matrix\n\ndef array_dimensional_indexing(array2d, row_index):\n    \"\"\"\n    MP-SPDZ code to index the i-th row from 2-D arrays.\n    'array2d' is a 2D Matrix of sfix.\n    'row_index' should be a regint (public integer).\n    \"\"\"\n    return array2d[row_index]\n", "response_1": "# MP-SPDZ does not support NumPy, so we work with MP-SPDZ lists instead.\n# Below is a simple translation of the Python function using MP-SPDZ types\n# to index the i-th row from a 2-D secure array.\n\nfrom Compiler.types import sfix, sint, cint\n\ndef array_dimensional_indexing(ndarray, row_index):\n    # 'ndarray' is assumed to be a 2-D list of secure types (e.g. sfix).\n    # 'row_index' is a clear or secure integer index (cint or sint).\n    # Return the row_index-th row of the array.\n    return ndarray[row_index]\n", "model_name": "azure-openai-o1"}
{"test_name": "array_from_intrinsic_arange", "response_0": "n = 10\na = Array(n, cint)\nfor i in range(n):\n    a[i] = i\n", "response_1": "n = 10\na = Array(n, cint)\nfor i in range(n):\n    a[i] = cint(i)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "from Compiler.types import sint, regint, Array\n\ndef array_dimensional_indexing(ndarray, row_index):\n    rows = len(ndarray)\n    cols = len(ndarray[0])\n    result_row = Array(cols, sint)\n    for j in range(cols):\n        result_row[j] = ndarray[row_index][j]\n    return result_row\n", "response_1": "# array_dimensional_indexing.mpc\n\n# This MP-SPDZ code demonstrates how to index the i-th row from a 2D array\n# represented in row-major order. The function returns all elements from\n# the specified row.\n\n# Suppose the 2D array has M rows and N columns and is stored in a\n# linear 1D MP-SPDZ array. row_index is expected to be an integer within [0, M-1].\n\n# Declare known dimensions (substitute M, N with actual values).\nM = 2\nN = 3\n\n# Example: If ndarray is sfix.Array(M * N), we can index the row in row-major order.\n# row 'i' starts at offset i*N and spans N elements.\ndef array_dimensional_indexing(ndarray, row_index):\n    res = sfix.Array(N)\n    base = row_index * N\n    for j in range(N):\n        res[j] = ndarray[base + j]\n    return res\n", "model_name": "azure-openai-o1"}
{"test_name": "array_from_python_structure", "response_0": "from Compiler.types import Array, sint\n\na_l = [0,10,20,30,40]\na = Array(len(a_l), sint)\nfor i in range(len(a_l)):\n    a[i] = a_l[i]\n", "response_1": "from Compiler.types import sint, Array\n\na_l = [0, 10, 20, 30, 40]\na = Array(len(a_l), sint)\n\nfor i in range(len(a_l)):\n    a[i] = sint(a_l[i])\n", "model_name": "azure-openai-o1"}
{"test_name": "np_reshape", "response_0": "# mp-spdz code snippet\n\n# Declaration of array_reshape in MP-SPDZ style\ndef array_reshape(A, m, n):\n    # Create a matrix of dimensions m x n using secret or clear type as needed\n    # For example, using sfix for secret fixed-point numbers:\n    reshaped = sfix.Matrix(m, n)\n    \n    # Fill the new matrix by mapping elements in row-major order\n    idx = 0\n    for i in range(m):\n        for j in range(n):\n            reshaped[i][j] = A[idx]\n            idx += 1\n    \n    return reshaped\n", "response_1": "# MP-SPDZ code snippet for reshaping a secret-shared 1D array into a 2D matrix.\n# This assumes 'ndarray' is a secret-shared array of length (m*n).\n\nfrom Compiler.types import sfix, Matrix\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a secret-shared 1D array into a 2D matrix.\n    \"\"\"\n    # Create a Matrix of size m x n\n    reshaped_matrix = Matrix(m, n, sfix)\n    # Fill the matrix row by row\n    for i in range(m):\n        for j in range(n):\n            reshaped_matrix[i][j] = ndarray[i * n + j]\n    return reshaped_matrix\n", "model_name": "azure-openai-o1"}
{"test_name": "np_ones", "response_0": "from Compiler.types import sfix, Array\n\nn = 10\na = sfix.Array(n)\n\nfor i in range(n):\n    a[i] = sfix(1)\n", "response_1": "from Compiler.types import sint, Array\n\nn = 10\na = Array(n, sint)\na.assign_all(sint(1))\n", "model_name": "azure-openai-o1"}
{"test_name": "set_one_to_zero", "response_0": "from Compiler.types import sint, Array\n\ndef set_one_to_zero(y):\n    n = len(y)\n    for i in range(n):\n        eq = y[i].equal(1)\n        y[i] = y[i] * (1 - eq)\n    return y\n", "response_1": "def set_one_to_zero(y, n):\n    # y is an array of secret integers (e.g., sint)\n    # n is the length of array y\n    for i in range(n):\n        cond = (y[i] == 1)\n        y[i] = cond.if_else(0, y[i])\n    return y\n", "model_name": "azure-openai-o1"}
{"test_name": "np_eye", "response_0": "n = 10\n\n# Set the precision for sfix if needed\nsfix.set_precision(40)\n\n# Create a 10x10 identity matrix using secure types\na = Matrix(sfix, n, n)\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sfix(1)\n        else:\n            a[i][j] = sfix(0)\n", "response_1": "from Compiler.types import sfix\n\nn = 10\na = sfix.Array([n, n])\n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i][j] = sfix(1)\n        else:\n            a[i][j] = sfix(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_diag", "response_0": "# Input array as secret-shared values\na_l = Array(6, sfix)\na_l[0] = sfix(1)\na_l[1] = sfix(3)\na_l[2] = sfix(5)\na_l[3] = sfix(2)\na_l[4] = sfix(4)\na_l[5] = sfix(6)\n\n# Create a 6x6 matrix for the diagonal\na = Matrix(6, 6, sfix)\nfor i in range(6):\n    for j in range(6):\n        if i == j:\n            a[i][j] = a_l[i]\n        else:\n            a[i][j] = sfix(0)\n", "response_1": "from Compiler.types import sint\nfrom Compiler.library import Matrix\n\n# Initialize the list of secret-shared integers\na_l = [sint(1), sint(3), sint(5), sint(2), sint(4), sint(6)]\n\n# Create a matrix 'a' with diagonal elements set from 'a_l'\nn = len(a_l)\na = Matrix(sint, n, n)\nfor i in range(n):\n    for j in range(n):\n        a[i][j] = a_l[i] if i == j else sint(0)\n", "model_name": "azure-openai-o1"}
{"test_name": "np_advanced_integer_indexing", "response_0": "# In MP-SPDZ, array and indices would typically be lists of secret or clear integers.\n# This function returns a new list \"ret_array\" such that return_array[i] = array[indices[i]].\n\ndef integer_array_indexing(array, indices):\n    # Initialize return array of appropriate length\n    ret_array = [None]*len(indices)\n    # Perform element-wise secure array indexing\n    for i in range(len(indices)):\n        ret_array[i] = array[indices[i]]\n    return ret_array\n", "response_1": "from Compiler.types import sfix, sint\nfrom Compiler.library import for_range\n\ndef integer_array_indexing(array, indices):\n    n = len(array)\n    k = len(indices)\n    ret_array = sfix.Array(k)\n    @for_range(k)\n    def _(i):\n        temp = sfix(0)\n        @for_range(n)\n        def _(j):\n            temp.assign(temp + array[j] * indices[i].equal(j))\n        ret_array[i] = temp\n    return ret_array\n", "model_name": "azure-openai-o1"}
