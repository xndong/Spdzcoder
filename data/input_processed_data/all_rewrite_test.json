{"test_name": "move_to_end", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    array = arr[:index] + arr[index+1:]\n    array.append(arr[index])\n    return array\n\n", "annotation": "`arr` is an array.\nThis function return the array obtained by taking out `arr[index]` and concatenate it to the end of the original array.\n\n", "output": "def move_to_end(arr, index):\n    \"\"\"\n    Move the element with given index in the array to the end of the array.\n    The index is guaranteed to be legal.\n    \"\"\"\n    def retrieve(arr,index):\n        \"\"\"\n        Retrieve the element in the array by index.\n        \"\"\"\n        ret = sfix(0)\n        @for_range(len(arr))\n        def _(i):\n            ret.update((index==i).if_else(arr[i],ret))\n        return ret\n    temp = retrieve(arr, index)\n    @for_range(1,len(arr))\n    def _(i):\n        arr[i-1] = (i>=index+1).if_else(arr[i],arr[i-1])\n    arr[len(arr)-1] = temp\n    return arr\n"}
{"test_name": "second_largest", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    for i in range(2, len(arr)):\n        if arr[i] > arr[0] or arr[i] > arr[1]:\n            idx = 0 if arr[0] < arr[1] else 1\n            arr[idx] = arr[i]\n    return arr[0] if arr[0] < arr[1] else arr[1]\n\n", "annotation": "Return the second largest element in the array.\n\n", "output": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array.\n    \"\"\"\n    largest = (arr[0]>=arr[1]).if_else(arr[0],arr[1])\n    second = (arr[0]>=arr[1]).if_else(arr[1],arr[0])\n    @for_range(len(arr))\n    def update(i):\n        proceed = i>1\n        largest_updated = (arr[i]>=largest).bit_and(proceed)\n        second_updated = largest_updated.bit_not().bit_and(arr[i]>=second).bit_and(proceed)\n        second.update(largest_updated.if_else(largest,second))\n        largest.update(largest_updated.if_else(arr[i],largest))\n        second.update(second_updated.if_else(arr[i],second))\n\n    return second\n"}
{"test_name": "exists_true", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = any(arr)\n    return ret\n\n", "annotation": "No annotation.", "output": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sint(0)\n    @for_range(0,len(arr))\n    def _(i):\n        ret.update(ret.bit_or(arr[i]))\n    return ret\n"}
{"test_name": "array_indicator", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_indicator(arr,predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    ret = [predicator(e) for e in arr]\n    return ret\n\n", "annotation": "No annotation.", "output": "def array_indicator(arr,predicator):\n    \"\"\"\n    Return an array with the same size of the input array.\n    For each element in the input array,\n    the corresponding value in the returned array is set to be the value of the predicator.\n    \"\"\"\n    lst = [predicator(e) for e in arr]\n    ret = Array.create_from(iter(lst))\n    return ret\n"}
{"test_name": "inner_product", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def inner_product(vec1,vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    lst = [x*y for x,y in zip(vec1, vec2)]\n    summation = sum(lst)\n    return summation\n\n", "annotation": "No annotation.", "output": "def inner_product(vec1,vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(vec1))\n    def _(i):\n        sum.update(sum+vec1[i]*vec2[i])\n    return sum\n"}
{"test_name": "array_shift_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    array = [a[(i-1)%len(a)] for i in range(len(a))]\n    return array\n\n", "annotation": "No annotation.", "output": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    temp = a[len(a)-1]\n    @for_range(len(a)-1)\n    def _(i):\n        a[len(a)-i-1] = a[len(a)-i-2]\n    a[0] = temp\n    return a\n"}
{"test_name": "array_greater_than_scalar", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n    ret = [arr[i] > bound for i in range(len(arr))]\n    return ret\n\n", "annotation": "No annotation.", "output": "def array_greater_than_scalar(arr, bound):\n    \"\"\"\n    Given an input array and a bound,\n    return an array indicating whether each element is greater than the bound.\n    \"\"\"\n\n    lst = [arr[i] > bound for i in range(len(arr))]\n    ret = Array.create_from(iter(ret))\n    return ret\n"}
{"test_name": "count_rises_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    flag = [1 if arr[i]<arr[i+1] else 0 for i in range(len(arr)-1)]\n    count = sum(flag)\n    return count\n\n", "annotation": "No annotation.", "output": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)\n    @for_range(len(arr)-1)\n    def _(i):\n        count.update((arr[i]<arr[i+1]).if_else(count+1,count))\n    return count\n"}
{"test_name": "choppy_plus_minus", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    arr = [e+1 if i%2 else e-1 for i,e in enumerate(arr)]\n    return arr\n\n", "annotation": "No annotation.", "output": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1,\n    for the element with even index, decrement the element by 1.\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = (i%2).if_else(arr[i]+1,arr[i]-1)\n    return arr\n"}
{"test_name": "how_many_roots", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def how_many_roots(a,b,c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    if a==0:\n        return 0 if b==0 else 1\n    else:\n        return 2 if b**2-4*a*c > 0 else (1 if b**2-4*a*c == 0 else 0)\n    \n", "annotation": "Return the number of roots of quadratic function ax^2+bx+c=0.\n\n", "output": "def how_many_roots(a,b,c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function,\n    return the number of its roots.\n    a, b and c can be zero, but they will not all be zero.\n    \"\"\"\n    return (a==0).if_else((b==0).if_else(0,1),(b**2-4*a*c>0).if_else(2,(b**2-4*a*c==0).if_else(1,0)))\n"}
{"test_name": "count_satisfied", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_satisfied(arr,predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    flag = [1 if predicator(e) else 0 for e in arr]\n    summmation = sum(flag)\n    return summmation\n\n", "annotation": "No annotation.", "output": "def count_satisfied(arr,predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    sum = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        sum.update(predicator(arr[i]).if_else(sum+1,sum))\n    return sum\n"}
{"test_name": "traverse_and_sum", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    ret = [x*y for x,y in zip(arr1, arr2)]\n    return sum(ret)\n\n", "annotation": "Traverse all pairs of elements from the two inputs,\ncompute the product of the two elements and sum all of them up.\n\n", "output": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs,\n    compute the product of the two elements and sum all of them up.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(arr1))\n    def _(i):\n        @for_range(len(arr2))\n        def _(j):\n            sum.update(sum+arr1[i]*arr2[j])\n    return sum\n"}
{"test_name": "array_round", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    ret = [round(e) for e in arr]\n    return ret\n\n", "annotation": "No annotation.", "output": "def array_round(arr):\n    \"\"\"\n    Round every element in the array to the nearest integer.\n    \"\"\"\n    from Compiler import mpc_math\n    ret = sfix.Array(len(arr))\n    @for_range(len(arr))\n    def _(i):\n        int_part = mpc_math.floor_fx(arr[i])\n        ret[i] = (arr[i]-int_part<0.5).if_else(int_part,int_part+1)\n    return ret\n"}
{"test_name": "array_greater_eq", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_greater_eq(arr,brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i]>b=rr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = [0 for i in range(len(arr))]\n    for i in range(len(arr)):\n        ret[i] = 1 if arr[i]>=brr[i] else 0\n    return ret\n\n", "annotation": "No annotation.", "output": "def array_greater_eq(arr,brr):\n    \"\"\"\n    For the two input arrays arr and brr, return an array ret with the same size.\n    For index i, if arr[i]>=brr[i], ret[i] will be set to 1, otherwise ret[i] will be set to 0.\n    The two input arrays are guaranteed to have the same length.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    arr_vector = arr.get_vector()\n    brr_vector = brr.get_vector()\n    ret.assign_vector(arr_vector >= brr_vector)\n    return ret\n\n"}
{"test_name": "indicate_negative", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = [1 if e < 0 else 0 for e in arr]\n    return ret\n\n", "annotation": "No annotation.", "output": "def indicate_negative(arr):\n    \"\"\"\n    For the given array, return an array with the same size.\n    If one element in the input array is negative,\n    then the corresponding element in the returned array will be 1,\n    otherwise the element in the returned array will be 0.\n    \"\"\"\n    ret = sint.Array(len(arr))\n    @for_range(len(arr))\n    def _(i):\n        ret[i] = (arr[i]<0).if_else(1,0)\n    return ret\n"}
{"test_name": "array_subtract_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_subtract(a,b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    pad_length = abs(len(a)-len(b))\n    pad = [] if len(a) == len(b) else (b[-pad_length:] if len(a)<len(b) else a[-pad_length:])\n    pad = [-e for e in pad] if len(a)<=len(b) else [e for e in pad]\n    ret = [ x-y for x,y in zip(a,b) ] + pad\n    return ret\n\n", "annotation": "No annotation.", "output": "def array_subtract(a,b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    if len(a)>len(b):\n        ret = sfix.Array(len(a))\n        @for_range(len(b))\n        def _(i):\n            ret[i] = a[i] - b[i]\n        @for_range(len(a)-len(b))\n        def _(i):\n            ret[len(b)+i] = a[len(b)+i]\n        return ret\n    else:\n        ret = sfix.Array(len(b))\n        @for_range(len(a))\n        def _(i):\n            ret[i] = a[i] - b[i]\n        @for_range(len(b)-len(a))\n        def _(i):\n            ret[len(a)+i] = -b[len(a)+i]\n        return ret\n"}
{"test_name": "array_process", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_process(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    arr = [func(e) for e in arr]\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_process(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    lst = [func(e) for e in arr]\n    arr = Array.create_from(iter(lst))\n    return arr\n"}
{"test_name": "array_shift", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    a = a[-1:] + a[:-1]\n    return a\n\n", "annotation": "No annotation.", "output": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1.\n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    temp = a[len(a)-1]\n    @for_range(len(a)-1)\n    def _(i):\n        a[len(a)-i-1] = a[len(a)-i-2]\n    a[0] = temp\n    return a\n"}
{"test_name": "compare_and_select", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def compare_and_select(a,b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    ret_array = [x if x > y else y for x,y in zip(a,b)]\n    return ret_array\n\n", "annotation": "No annotation.", "output": "def compare_and_select(a,b):\n    \"\"\"\n    Compare the two arrays elementwise,\n    and save the larger value into the returned array.\n    \"\"\"\n    lst = [ (a[i]>b[i]).if_else(a[i],b[i]) for i in range(len(a))]\n    output = Array.create_from(iter(lst))\n\n    return output\n"}
{"test_name": "array_subtract", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_subtract(a,b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    pad = [0.0] * abs(len(a)-len(b))\n    if len(a)<len(b):\n        a = a + pad\n    else:\n        b = b + pad\n    ret = [ x-y for x,y in zip(a,b) ]\n    return ret\n\n", "annotation": "No annotation.", "output": "def array_subtract(a,b):\n    \"\"\"\n    Subtract the first array by the second one elementwise.\n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    if len(a)>len(b):\n        ret = sfix.Array(len(a))\n        @for_range(len(b))\n        def _(i):\n            ret[i] = a[i] - b[i]\n        @for_range(len(a)-len(b))\n        def _(i):\n            ret[len(b)+i] = a[len(b)+i]\n        return ret\n    else:\n        ret = sfix.Array(len(b))\n        @for_range(len(a))\n        def _(i):\n            ret[i] = a[i] - b[i]\n        @for_range(len(b)-len(a))\n        def _(i):\n            ret[len(a)+i] = -b[len(a)+i]\n        return ret\n"}
{"test_name": "repeat_array", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c*2\n\n", "annotation": "`c` is a list, this function return the list obtained by concatenating the input list to itself.\n\n", "output": "def repeat_array(c):\n    \"\"\"\n    Repeat the input array by concatenating it to itself.\n    \"\"\"\n    return c.concat(c)\n"}
{"test_name": "zeros", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    import numpy\n    array = numpy.zeros(num)\n    return array\n\n", "annotation": "No annotation.", "output": "def zeros(num):\n    \"\"\"\n    Return the all-zero array with length num.\n    \"\"\"\n    ret = sfix.Array(num)\n    return ret\n"}
{"test_name": "clip", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    def helper_func(x):\n        return upper_bound if x >= upper_bound else (x if x > lower_bound else lower_bound)\n\n    arr = list(map(helper_func, arr))\n    return arr\n\n", "annotation": "`arr` is an array. \nThis function clip the elements of `arr` into the scope of `[lower_bound, upper_bound]` and return the result array.\n\n", "output": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    @for_range(len(arr))\n    def clip(i):\n        arr[i] = (arr[i]<lower_bound).if_else(lower_bound,arr[i])\n        arr[i] = (arr[i]>upper_bound).if_else(upper_bound,arr[i])\n    return arr\n"}
{"test_name": "count_satisfied_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_satisfied(arr,predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    flag = map(predicator, arr)\n    summmation = sum(flag)\n    return summmation\n\n", "annotation": "No annotation.", "output": "def count_satisfied(arr,predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator.\n    \"\"\"\n    sum = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        sum.update(predicator(arr[i]).if_else(sum+1,sum))\n    return sum\n"}
{"test_name": "reverse_order_pair", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    import numpy\n    count = 0\n    cmparr = numpy.array(arr)\n    for i in range(len(arr)):\n        ndarray = numpy.full(len(arr)-i, arr[i])\n        count += numpy.sum(ndarray > cmparr[i:])\n    return count\n\n", "annotation": "Count the number of reverse order pairs in the array.\n\n", "output": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array.\n    \"\"\"\n    num = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        @for_range(i+1,len(arr))\n        def _(j):\n            num.update((arr[i]>arr[j]).if_else(num+1,num))\n    return num\n"}
{"test_name": "array_inc", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    arr = [arr[i] + 1 for i in range(len(arr))]\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    vec = arr.get_vector() + 1\n    arr.assin_vector(vec)\n    return arr\n"}
{"test_name": "count_rises", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = 0\n    brr = arr[1:]\n    for x,y in zip(arr, brr):\n        count+=1 if x<y else 0\n    return count\n\n", "annotation": "No annotation.", "output": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array.\n    \"\"\"\n    count = sint(0)\n    @for_range(len(arr)-1)\n    def _(i):\n        count.update((arr[i]<arr[i+1]).if_else(count+1,count))\n    return count\n"}
{"test_name": "array_process_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_process(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    arr = list(map(func,arr))\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_process(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    lst = [func(e) for e in arr]\n    arr = Array.create_from(iter(lst))\n    return arr\n"}
{"test_name": "two_norm", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    import math\n    vec = [item**2 for item in vec]\n    return math.sqrt(sum(vec))\n\n", "annotation": "No annotation.", "output": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    from Compiler import mpc_math\n    sum = sfix(0)\n    @for_range(len(vec))\n    def _(i):\n        sum.update(sum+vec[i]**2)\n    return mpc_math.sqrt_simplified_fx(sum)\n"}
{"test_name": "totally_dominate", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def totally_dominate(a,b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    amin = min(a)\n    bmax = max(b)\n    return True if amin >= bmax else False\n\n", "annotation": "No annotation.", "output": "def totally_dominate(a,b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b,\n    which means, any element in a is no smaller than any element in b.\n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    @for_range(len(a))\n    def _(i):\n        amin.update((a[i]<amin).if_else(a[i],amin))\n    @for_range(len(b))\n    def _(i):\n        bmax.update((b[i]>bmax).if_else(b[i],bmax))\n    return amin>=bmax\n"}
{"test_name": "inner_product_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def inner_product(vec1,vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    summation = 0\n    for x,y in zip(vec1, vec2):\n        summation += x*y\n    return summation\n\n", "annotation": "No annotation.", "output": "def inner_product(vec1,vec2):\n    \"\"\"\n    Compute the inner product of the two arrays.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(vec1))\n    def _(i):\n        sum.update(sum+vec1[i]*vec2[i])\n    return sum\n"}
{"test_name": "get_subarr_by_indices", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    ret = [a[i] for i in indices]\n    return ret\n\n", "annotation": "No annotation.", "output": "def get_subarr_by_indices(a, indices):\n    \"\"\"\n    Get the subarray of the input array indicated by the indices.\n    The inputs are guaranteed to be legal.\n    \"\"\"\n    def retrieve(arr,index):\n        \"\"\"\n        Retrieve the element in the array by index.\n        \"\"\"\n        ret = sfix(0)\n        @for_range(len(arr))\n        def _(i):\n            ret.update((index==i).if_else(arr[i],ret))\n        return ret\n\n    ret = sfix.Array(len(indices))\n    @for_range(len(indices))\n    def _(i):\n        ret[i] = retrieve(a,indices[i])\n    return ret\n"}
{"test_name": "exists_5_or_7", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    flag = [True if item == 5 or item == 7 else False for item in arr]\n    return any(flag)\n\n", "annotation": "No annotation.", "output": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    ret = sint(0)\n    @for_range(0,len(arr))\n    def _(i):\n        ret.update(ret.bit_or((arr[i]==5).bit_or(arr[i]==7)))\n    return ret\n"}
{"test_name": "remove_by_index", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def remove_by_index(arr,index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    ret = arr[:index] + arr[index+1:]\n    return ret\n\n", "annotation": "Remove the element in the array by index and return the remaining array.\n\n", "output": "def remove_by_index(arr,index):\n    \"\"\"\n    Remove the element in the array by index and return the remaining array.\n    The input index is guaranteed to be legal.\n    \"\"\"\n    ret = sfix.Array(len(arr))\n    @for_range(len(arr)-1)\n    def _(i):\n        ret[i] = (i<index).if_else(arr[i],arr[i+1])\n    return ret\n"}
{"test_name": "average", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    summmation = sum(arr)\n    length = len(arr)\n    ret = summmation/length\n    return ret\n\n", "annotation": "No annotation.", "output": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(length)\n    def add(i):\n        sum.update(sum+arr[i])\n    ret = sum/length\n    return ret\n"}
