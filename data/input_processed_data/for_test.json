{"test_name": "multiply_first_five", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = 1\n    for i in range(len(array)):\n        prod *= array[i]\n        if i>=4:\n            break\n    return prod\n\n", "annotation": "No annotation.", "output": "def multiply_first_five(array):\n    \"\"\"\n    Multiply the first five elements in the array (if len(array)<5 then multiply all)\n    \"\"\"\n    prod = sint(1)\n    @for_range(len(array))\n    def _(i):\n        prod.update((i<=5).if_else(prod*array[i],prod))\n    return prod\n"}
{"test_name": "second_largest", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array. \n    \"\"\"\n    largest = arr[0] if arr[0]>=arr[1] else arr[1]\n    second = arr[1] if arr[0]>=arr[1] else arr[0]\n    for i in range(len(arr)):\n        if i>1:\n            if arr[i] >= largest:\n                second = largest\n                largest = arr[i]\n            else:\n                if arr[i]>=second:\n                    second = arr[i]\n    \n    return second\n\n", "annotation": "No annotation.", "output": "def second_largest(arr):\n    \"\"\"\n    Return the second largest element in the array. \n    \"\"\"\n    largest = (arr[0]>=arr[1]).if_else(arr[0],arr[1])\n    second = (arr[0]>=arr[1]).if_else(arr[1],arr[0])\n    @for_range(len(arr))\n    def update(i):\n        proceed = i>1\n        largest_updated = (arr[i]>=largest).bit_and(proceed)\n        second_updated = largest_updated.bit_not().bit_and(arr[i]>=second).bit_and(proceed)\n        second.update(largest_updated.if_else(largest,second))\n        largest.update(largest_updated.if_else(arr[i],largest))\n        second.update(second_updated.if_else(arr[i],second))\n    \n    return second\n"}
{"test_name": "partial_sum", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array. \n    \"\"\"\n    partial = 0\n    for i in range(len(arr)):\n        partial = partial + arr[i]\n        arr[i] = partial\n    return arr\n\n", "annotation": "No annotation.", "output": "def partial_sum(arr):\n    \"\"\"\n    Compute the partial sum of the array. \n    \"\"\"\n    partial = sfix(0)\n    @for_range(len(arr))\n    def _(i):\n        partial.update(partial+arr[i])\n        arr[i] = partial\n    return arr\n"}
{"test_name": "max_adjacent_product", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def max_adjacent_product(arr):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2. \n    \"\"\"\n    cur = arr[0]*arr[1]\n    for i in range(len(arr)-1):\n        if arr[i]*arr[i+1] > cur:\n            cur = arr[i]*arr[i+1]\n    return cur\n\n", "annotation": "No annotation.", "output": "def max_adjacent_product(arr):\n    \"\"\"\n    Return the max product of adjacent elements in the array.\n    The input array is guaranteed to have length at least 2. \n    \"\"\"\n    cur = arr[0]*arr[1]\n    @for_range(len(arr)-1)\n    def _(i):\n        cur.update((arr[i]*arr[i+1]>cur).if_else(arr[i]*arr[i+1],cur))\n    return cur\n"}
{"test_name": "argmax", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def argmax(a):\n    \"\"\"\n    Return the index of the max velue of an array. \n    \"\"\"\n    current = a[0]\n    index = 0\n    for i in range(len(a)):\n        index = index if current>=a[i] else i\n        current = current if current>=a[i] else a[i]\n    return index\n\n", "annotation": "No annotation.", "output": "def argmax(a):\n    \"\"\"\n    Return the index of the max value of an array. \n    \"\"\"\n    current = a[0]\n    index = sint(0)\n    @for_range(len(a))\n    def compare_and_save(i):\n        index.update((current>=a[i]).if_else(index,i))\n        current.update((current>=a[i]).if_else(current,a[i]))\n    return index\n"}
{"test_name": "count_distinct", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = 0\n    for i in range(len(arr)):\n        unique = True\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = False\n        if unique:\n            counter = counter + 1\n    return counter\n\n", "annotation": "No annotation.", "output": "def count_distinct(arr):\n    \"\"\"\n    Return the number of distinct values in the array.\n    \"\"\"\n    counter = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        unique = sint(1)\n        @for_range(i)\n        def _(j):\n            unique.update((arr[j]==arr[i]).if_else(False,unique))\n        counter.update(unique.if_else(counter+1,counter))\n    return counter\n"}
{"test_name": "exists_true", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = False\n    for item in arr:\n        ret = ret or item\n    return ret\n\n", "annotation": "No annotation.", "output": "def exists_true(arr):\n    \"\"\"\n    Check whether the boolean array contains a True.\n    \"\"\"\n    ret = sint(0)\n    @for_range(0,len(arr))\n    def _(i):\n        ret.update(ret.bit_or(arr[i]))\n    return ret\n"}
{"test_name": "range", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    for item in arr:\n        max_value = max_value if max_value>=item else item\n        min_value = min_value if min_value<=item else item\n    return max_value-min_value\n\n", "annotation": "No annotation.", "output": "def range(arr):\n    \"\"\"\n    Return the range of the array.\n    \"\"\"\n    max_value = arr[0]\n    min_value = arr[0]\n    @for_range(len(arr))\n    def _(i):\n        max_value.update((max_value>=arr[i]).if_else(max_value,arr[i]))\n        min_value.update((min_value<=arr[i]).if_else(min_value,arr[i]))\n    return max_value-min_value\n"}
{"test_name": "count_larger_than_5", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5. \n    \"\"\"\n    counter = 0\n    for item in arr:\n        if item > 5:\n            counter = counter + 1\n    return counter\n\n", "annotation": "No annotation.", "output": "def count_larger_than_5(arr):\n    \"\"\"\n    Count the number of elements in the given array larger than 5. \n    \"\"\"\n    counter = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        counter.update((arr[i]>5).if_else(counter+1,counter))\n    return counter\n"}
{"test_name": "exists_dominator", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = 0\n    sum = 0\n    for item in arr:\n        max = abs(item) if abs(item)>max else max\n        sum = sum + abs(item)\n    return 2*max > sum\n\n", "annotation": "No annotation.", "output": "def exists_dominator(arr):\n    \"\"\"\n    Check whether there exists a dominator in the given array, \n    whose absolute value is strictly larger than the sum of the absolute values of all other elements. \n    \"\"\"\n    max = sfix(0)\n    sum = sfix(0)\n    @for_range(len(arr))\n    def _(i):\n        max.update((abs(arr[i])>max).if_else(abs(arr[i]),max))\n        sum.update(sum+abs(arr[i]))\n    return 2*max > sum\n"}
{"test_name": "greedy_picker", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def greedy_picker(items,captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = 0\n    for item in items:\n        if item <= captivity:\n            captivity = captivity - item\n            num = num + 1\n    return num\n\n", "annotation": "No annotation.", "output": "def greedy_picker(items,captivity):\n    \"\"\"\n    There is a greedy picker with a bag picking items. \n    Once the picker sees an item that his bag has space for, he will pick up the item (which will take some space) and put it into his bag. \n    You should compute how many items the greedy picker can finally get with the greedy strategy. \n    \"\"\"\n    num = sint(0)\n    @for_range(len(items))\n    def _(i):\n        num.update((items[i]<=captivity).if_else(num+1,num))\n        captivity.update((items[i]<=captivity).if_else(captivity-items[i],captivity))\n    return num\n"}
{"test_name": "scalar_add_array", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def scalar_add_array(s,l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result. \n    \"\"\"\n    for item in l:\n        s = s + item\n    return s\n\n", "annotation": "No annotation.", "output": "def scalar_add_array(s,l):\n    \"\"\"\n    Add all the elements in the array to the scalar and return the result. \n    \"\"\"\n    @for_range(len(l))\n    def _(i):\n        s.update(s+l[i])\n    return s\n"}
{"test_name": "is_equidistant_seq", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence. \n    If the array has length 1 or 0, return True.\n    \"\"\"\n    d = 0\n    for i in range(len(arr)-1):\n        if i>0 and arr[i+1]-arr[i]!=d:\n            return False\n        d = arr[i+1]-arr[i]\n    return True\n\n", "annotation": "No annotation.", "output": "def is_equidistant_seq(arr):\n    \"\"\"\n    Return whether or not the array is an equidistant sequence. \n    If the array has length 1 or 0, return True.\n    \"\"\"\n    d = sfix(0)\n    ret = sint(1)\n    @for_range(len(arr)-1)\n    def _(i):\n        ret.update(ret.if_else(((i>0).bit_and(arr[i+1]-arr[i]!=d)).bit_not(),ret))\n        d.update(arr[i+1]-arr[i])\n    return ret\n"}
{"test_name": "inner_product", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def inner_product(vec1,vec2):\n    \"\"\"\n    Compute the inner product of the two arrays. \n    \"\"\"\n    sum = 0\n    for i in range(len(vec1)):\n        sum = sum + vec1[i]*vec2[i]\n    return sum\n\n", "annotation": "No annotation.", "output": "def inner_product(vec1,vec2):\n    \"\"\"\n    Compute the inner product of the two arrays. \n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(vec1))\n    def _(i):\n        sum.update(sum+vec1[i]*vec2[i])\n    return sum\n"}
{"test_name": "more_distinct_nonnegative", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    nonnegative_counter = 0\n    negative_counter = 0\n    for i in range(len(arr)):\n        unique = True\n        for j in range(i):\n            if arr[j] == arr[i]:\n                unique = False\n        if unique:\n            if arr[i] >= 0:\n                nonnegative_counter = nonnegative_counter + 1\n            else:\n                negative_counter = negative_counter + 1\n    return nonnegative_counter > negative_counter\n\n", "annotation": "No annotation.", "output": "def more_distinct_nonnegative(arr):\n    \"\"\"\n    Return whether the array has more distinct nonnegative elements than distinct negative elements. \n    \"\"\"\n    nonnegative_counter = sint(0)\n    negative_counter = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        unique = sint(1)\n        @for_range(i)\n        def _(j):\n            unique.update((arr[j]==arr[i]).if_else(False,unique))\n        nonnegative_counter.update((unique.bit_and(arr[i]>=0)).if_else(nonnegative_counter+1,nonnegative_counter))\n        negative_counter.update((unique.bit_and(arr[i]<0)).if_else(negative_counter+1,negative_counter))\n    return nonnegative_counter > negative_counter\n"}
{"test_name": "flip_positives", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    for i in range(len(array)):\n        if array[i]<=0:\n            continue\n        array[i] = -array[i]\n    return array\n\n", "annotation": "No annotation.", "output": "def flip_positives(array):\n    \"\"\"\n    Flip the positive elements in the array\n    \"\"\"\n    @for_range(len(array))\n    def _(i):\n        array[i] = (array[i]<=0).if_else(array[i],-array[i])\n    return array\n"}
{"test_name": "divide_and_plus", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    for i in range(4):\n        x = x/2\n        x = x + 1\n    return x\n\n", "annotation": "No annotation.", "output": "def divide_and_plus(x):\n    \"\"\"\n    Repeat the following to the input for 4 times:\n    divide by 2, then plus 1\n    \"\"\"\n    @for_range(4)\n    def _(i):\n        x.update(x/sfix(2))\n        x.update(x+1)\n    return x\n"}
{"test_name": "array_log2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    import math\n    for i in range(len(arr)):\n        arr[i] = math.log2(arr[i])\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_log2(arr):\n    \"\"\"\n    Take logarithm with base two to all elements in the input array.\n    \"\"\"\n    from Compiler import mpc_math\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = mpc_math.log2_fx(arr[i])\n    return arr\n"}
{"test_name": "sum_to_ten", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = 0\n    for i in range(len(array)):\n        sum += array[i]\n        if sum>=10:\n            break\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    @for_range(len(array))\n    def _(i):\n        sum.iadd((sum<10).if_else(array[i],0))\n    return sum\n"}
{"test_name": "choppy_plus_minus", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    for i in range(len(arr)):\n        if i%2:\n            arr[i] = arr[i] + 1\n        else:\n            arr[i] = arr[i] - 1\n    return arr\n\n", "annotation": "No annotation.", "output": "def choppy_plus_minus(arr):\n    \"\"\"\n    Return the array with the following modification of the input array:\n    For the element with odd index, increment the element by 1, \n    for the element with even index, decrement the element by 1. \n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = (i%2).if_else(arr[i]+1,arr[i]-1)\n    return arr\n"}
{"test_name": "min_element", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def min_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = current if current<=item else item\n    \n    return current\n\n", "annotation": "No annotation.", "output": "def min_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    @for_range(len(a))\n    def compare_and_save(i):\n        current.update((current<=a[i]).if_else(current,a[i]))\n    \n    return current\n"}
{"test_name": "soft_max", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    import math\n    denominator = 0\n    for item in arr:\n        denominator = denominator + math.pow(math.e,item)\n    brr = arr\n    for i in range(len(arr)):\n        brr[i] = math.pow(math.e,arr[i])/denominator\n    return brr\n\n", "annotation": "No annotation.", "output": "def soft_max(arr):\n    \"\"\"\n    Return the array of soft-max of the input array. \n    \"\"\"\n    import math\n    from Compiler import mpc_math\n    denominator = sfix(0)\n    @for_range(len(arr))\n    def _(i):\n        denominator.update(denominator+mpc_math.pow_fx(math.e,arr[i]))\n    brr = arr\n    @for_range(len(arr))\n    def _(i):\n        brr[i] = mpc_math.pow_fx(math.e,arr[i])/denominator\n    return brr\n"}
{"test_name": "count_reverse_pair_with_break", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_reverse_pair_with_break(arr):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    \"\"\"\n    count = 0\n    for i in range(1,len(arr)):\n        if arr[i]>10:\n            break\n        for j in range(i):\n            if arr[j]>arr[i]:\n                count += 1\n    return count\n\n", "annotation": "No annotation.", "output": "def count_reverse_pair_with_break(arr):\n    \"\"\"\n    Count the number of reverse pairs before we find an element bigger than 10\n    \"\"\"\n    count = sint(0)\n    stop = sint(0)\n    @for_range(1,len(arr))\n    def _(i):\n        stop.update(stop.bit_or(arr[i]>10))\n        @for_range(i)\n        def _(j):\n            count.iadd(stop.if_else(0,arr[j]>arr[i]))\n    return count\n"}
{"test_name": "sum_unique", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_unique(arr):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    sum = 0\n    for i in range(len(arr)):\n        unique = True\n        for j in range(len(arr)):\n            if arr[j]==arr[i] and j!=i:\n                unique = False\n                break\n        if unique:\n            sum = sum + arr[i]\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_unique(arr):\n    \"\"\"\n    Return the sum of unique elements in the array.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(arr))\n    def _(i):\n        unique = sint(1)\n        @for_range(len(arr))\n        def _(j):\n            unique.update(unique.bit_and(((arr[j]==arr[i]).bit_and(j!=i)).bit_not()))\n        sum.update(unique.if_else(sum+arr[i],sum))\n    return sum\n"}
{"test_name": "check_sum", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def check_sum(array,target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = 0\n    for num in array:\n        sum = sum + num\n    return sum==target\n\n", "annotation": "No annotation.", "output": "def check_sum(array,target):\n    \"\"\"\n    Check whether the sum of the array equals the target value. \n    \"\"\"\n    sum = sint(0)\n    @for_range(len(array))\n    def add(i):\n        sum.update(sum+array[i])\n    return sum==target\n"}
{"test_name": "prod", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array. \n    \"\"\"\n    prod = 1\n    for num in array:\n        prod = prod * num\n    return prod\n\n", "annotation": "No annotation.", "output": "def prod(array):\n    \"\"\"\n    Multiply together all elements in the array. \n    \"\"\"\n    prod = sint(1)\n    @for_range(len(array))\n    def add(i):\n        prod.update(prod*array[i])\n    return prod\n"}
{"test_name": "sum_till_negative", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = 0\n    for i in range(len(array)):\n        if array[i]<0:\n            break\n        sum += array[i]\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_till_negative(array):\n    \"\"\"\n    Sum from the first element in the array until a negative one occurs\n    \"\"\"\n    sum = sint(0)\n    if_sum = sint(1)\n    @for_range(len(array))\n    def _(i):\n        if_sum.update(if_sum.bit_and(array[i]>=0))\n        sum.iadd(if_sum.if_else(array[i],0))\n    return sum\n"}
{"test_name": "count_satisfied", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_satisfied(arr,predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator. \n    \"\"\"\n    sum = 0\n    for i in range(len(arr)):\n        if predicator(arr[i]):\n            sum = sum + 1\n    return sum\n\n", "annotation": "No annotation.", "output": "def count_satisfied(arr,predicator):\n    \"\"\"\n    Count the number of elements in the array satisfies the predicator. \n    \"\"\"\n    sum = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        sum.update(predicator(arr[i]).if_else(sum+1,sum))\n    return sum\n"}
{"test_name": "standard_deviation", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    import math\n    average = 0\n    variance = 0\n    for item in arr:\n        average = average+item/len(arr)\n    for item in arr:\n        variance = variance + (item-average)**2/len(arr)\n    return math.sqrt(variance)\n\n", "annotation": "No annotation.", "output": "def standard_deviation(arr):\n    \"\"\"\n    Return the standard deviation of the array. \n    \"\"\"\n    from Compiler import mpc_math\n    average = sfix(0)\n    variance = sfix(0)\n    @for_range(len(arr))\n    def compute_average(i):\n        average.update(average+arr[i]/len(arr))\n    @for_range(len(arr))\n    def compute_variance(i):\n        variance.update(variance+(arr[i]-average)**2/len(arr))\n    return mpc_math.sqrt(variance)\n"}
{"test_name": "dominate", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def dominate(a,b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    ret = True\n    for i in range(len(a)):\n        if a[i]<b[i]:\n            return False\n    return ret\n\n", "annotation": "No annotation.", "output": "def dominate(a,b):\n    \"\"\"\n    Return whether array a \"dominates\" array b, \n    which means, every element in a is no smaller than the corresponding element in b. \n    \"\"\"\n    ret = sint(1)\n    @for_range(len(a))\n    def _(i):\n        ret.update((a[i]<b[i]).if_else(False,ret))\n    return ret\n"}
{"test_name": "rescale", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = 0\n    for item in brr:\n        if abs(item)>max_abs:\n            max_abs = abs(item)\n    for i in range(len(brr)):\n        brr[i] = brr[i]/max_abs\n    return brr\n\n", "annotation": "No annotation.", "output": "def rescale(brr):\n    \"\"\"\n    To rescale the array such that the array can be fitted into [-1,1]\n    The input is guaranteed to be nonempty with nonzero element.\n    \"\"\"\n    max_abs = sfix(0)\n    @for_range(len(brr))\n    def _(i):\n        max_abs.update((abs(brr[i])>max_abs).if_else(abs(brr[i]),max_abs))\n    @for_range(len(brr))\n    def _(i):\n        brr[i] = brr[i]/max_abs\n    return brr\n"}
{"test_name": "array_minus7", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] - 7\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_minus7(arr):\n    \"\"\"\n    Subtract all elements in the input array by 7.\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = arr[i] - 7\n    return arr\n"}
{"test_name": "traverse_and_sum", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = 0\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            sum = sum + arr1[i]*arr2[j]\n    return sum\n\n", "annotation": "No annotation.", "output": "def traverse_and_sum(arr1, arr2):\n    \"\"\"\n    Traverse all pairs of elements from the two inputs, \n    compute the product of the two elements and sum all of them up. \n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(arr1))\n    def _(i):\n        @for_range(len(arr2))\n        def _(j):\n            sum.update(sum+arr1[i]*arr2[j])\n    return sum\n"}
{"test_name": "longest_nondec_subseq", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-deceasing subsequence in the input array.\n    \"\"\"\n    max_length = 0\n    cur_length = 0\n    for i in range(len(a)):\n        if i==0:\n            cur_length = 1\n            continue\n        if a[i] >= a[i-1]:\n            cur_length = cur_length + 1\n        else:\n            max_length = max_length if max_length>=cur_length else cur_length\n            cur_length = 1\n    max_length = max_length if max_length>=cur_length else cur_length\n    return max_length\n\n", "annotation": "No annotation.", "output": "def longest_nondec_subseq(a):\n    \"\"\"\n    Return the length of the longest non-deceasing subsequence in the input array.\n    \"\"\"\n    max_length = sint(0)\n    cur_length = sint(0)\n    @for_range(len(a))\n    def _(i):\n        @if_e(i==0)\n        def _():\n            cur_length.update(1)\n        @else_\n        def _():\n            max_length.update((a[i] >= a[i-1]).if_else(max_length,(max_length>=cur_length).if_else(max_length,cur_length)))\n            cur_length.update((a[i] >= a[i-1]).if_else(cur_length+1,1))\n    max_length.update((max_length>=cur_length).if_else(max_length,cur_length))\n    return max_length\n"}
{"test_name": "sum_but_skip_biggest", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = 0\n    biggest = array[0]\n    for i in range(len(array)):\n        if array[i]>=biggest:\n            biggest = array[i]\n            continue\n        sum += array[i]\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_but_skip_biggest(array):\n    \"\"\"\n    Compute partial sum of the array but skip the biggest element in until now every time.\n    \"\"\"\n    sum = sint(0)\n    biggest = array[0]\n    @for_range(len(array))\n    def _(i):\n        skip = array[i]>=biggest\n        biggest.update(skip.if_else(array[i],biggest))\n        sum.iadd(skip.if_else(0,array[i]))\n    return sum\n"}
{"test_name": "second_test", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = 0\n    for i in range(1,len(arr)):\n        if arr[0]<arr[i]:\n            count = count + 1\n    if count == 1:\n        return True\n    else:\n        return False\n\n", "annotation": "No annotation.", "output": "def second_test(arr):\n    \"\"\"\n    Return whether or not the first element in the array is smaller than exactly one element.\n    \"\"\"\n    count = sint(0)\n    @for_range(1,len(arr))\n    def _(i):\n        count.update((arr[0]<arr[i]).if_else(count+1,count))\n    return count==1\n"}
{"test_name": "Manhattan_distance", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def Manhattan_distance(a,b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    ret = 0\n    for i in range(len(a)):\n        ret = ret + abs(a[i]-b[i])\n    return ret\n\n", "annotation": "No annotation.", "output": "def Manhattan_distance(a,b):\n    \"\"\"\n    Compute the Manhattan distance of the two vectors.\n    \"\"\"\n    ret = sfix(0)\n    @for_range(len(a))\n    def _(i):\n        ret.update(ret+abs(a[i]-b[i]))\n    return ret\n"}
{"test_name": "deal_with_only_positive", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and substract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = 1\n    sum = 0\n    for i in range(len(array)):\n        if array[i]<=0:\n            continue\n        sum = sum + sign*array[i]\n        sign = (-1)*sign\n    return sum\n\n", "annotation": "No annotation.", "output": "def deal_with_only_positive(array):\n    \"\"\"\n    Add and substract the positive elements in the array to the partial sum\n    Non-positive elements are skipped\n    \"\"\"\n    sign = sint(1)\n    sum = sint(0)\n    @for_range(len(array))\n    def _(i):\n        sum.iadd((array[i]>0).if_else(sign*array[i],0))\n        sign.update((array[i]>0).if_else((-1)*sign,sign))\n    return sum\n"}
{"test_name": "compare_and_return", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def compare_and_return(arr,brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    ret = -1\n    for i in range(len(arr)):\n        if arr[i]==brr[i]:\n            ret = i\n            break\n    return ret\n\n", "annotation": "No annotation.", "output": "def compare_and_return(arr,brr):\n    \"\"\"\n    Compare the elements in arrays `arr` and `brr`, and return the first index `i` with arr[i]==brr[i]\n    \"\"\"\n    ret = sint(-1)\n    break_sign = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        ret.update(break_sign.if_else(ret,(arr[i]==brr[i]).if_else(i,ret)))\n        break_sign.update(break_sign.bit_or(arr[i]==brr[i]))\n    return ret\n"}
{"test_name": "sum_odd_positive", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = 0\n    for item in arr:\n        if item%2 and item>0:\n            sum = sum + item\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_odd_positive(arr):\n    \"\"\"\n    Return the sum of all the odd positive numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        sum.update(((arr[i]%2).bit_and(arr[i]>0)).if_else(sum+arr[i],sum))\n    return sum\n"}
{"test_name": "two_sum", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value. \n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if arr[i] + arr[j] == target:\n                return True\n    return False\n\n", "annotation": "No annotation.", "output": "def two_sum(arr, target):\n    \"\"\"\n    Return whether the input array contains two elements (can be the same) whose sum equals to the target value. \n    \"\"\"\n    ret = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        @for_range(len(arr))\n        def _(j):\n            ret.update(ret.bit_or(arr[i]+arr[j]==target))\n    return ret\n"}
{"test_name": "seq_search", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i]==target:\n            return i\n    return -1\n\n", "annotation": "No annotation.", "output": "def seq_search(arr, target):\n    \"\"\"\n    Do sequential search in the array for the target. \n    Return the index of the target, return -1 if target not found.\n    The array is guaranteed to have all different elements. \n    \"\"\"\n    ret = sint(-1)\n    @for_range(len(arr))\n    def _(i):\n        ret.update((arr[i]==target).if_else(i,ret))\n    return ret\n"}
{"test_name": "choppy_array", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def choppy_array(arr):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(len(arr)-i):\n            if i%2 and arr[i+j]>arr[i]:\n                return False\n            if (not i%2) and arr[i+j]<arr[i]:\n                return False\n    return True\n\n", "annotation": "No annotation.", "output": "def choppy_array(arr):\n    \"\"\"\n    Return whether or not the input array is a \"choppy array\".\n    A \"choppy array\" is the following array: \n    The first element is the smallest, \n    the second is the largest of the remaining, \n    the third is the smallest of the remaining, \n    the fourth is the largest of the remaining, etc.\n    \"\"\"\n    ret = sint(1)\n    @for_range(len(arr))\n    def outer(i):\n        @for_range(len(arr)-i)\n        def inner(j):\n            ret.update(((i%2).bit_and(arr[i+j]>arr[i])).if_else(False,ret))\n            ret.update(((i%2).bit_not().bit_and(arr[i+j]<arr[i])).if_else(False,ret))\n    return ret\n"}
{"test_name": "array_process", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_process(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_process(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function.\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = func(arr[i])\n    return arr\n"}
{"test_name": "normalize", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def normalize(vec):\n    \"\"\"\n    Normalize the vector.\n    \"\"\"\n    import math\n    sum = 0\n    for item in vec:\n        sum = sum + item**2\n    base = math.sqrt(sum)\n    for i in range(len(vec)):\n        vec[i] = vec[i]/base\n    return vec\n\n", "annotation": "No annotation.", "output": "def normalize(vec):\n    \"\"\"\n    Normalize the vector.\n    \"\"\"\n    from Compiler import mpc_math\n    sum = sfix(0)\n    @for_range(len(vec))\n    def _(i):\n        sum.update(sum+vec[i]**2)\n    base = mpc_math.sqrt_simplified_fx(sum)\n    @for_range(len(vec))\n    def _(i):\n        vec[i] = vec[i]/base\n    return vec\n"}
{"test_name": "impatient_merchant", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def impatient_merchant(days):\n    \"\"\"\n    You are given the prices of some goods in consecutive days. \n    Here's an impatient merchant who will buy the good at the first days, \n    and sell it until its price becomes higher than its original cost. \n    Then he will buy the good in the next day and repeat the above process. \n    The good left in the hand of the merchant in the last day will worth nothing.\n    You should calculate the net value the impatient merchant can earn.\n    \"\"\"\n    can_buy = True\n    net = 0\n    orig_price = 0\n    for i in range(len(days)):\n        if can_buy:\n            net = net - days[i]\n            orig_price = days[i]\n            can_buy = False\n        else:\n            if days[i]>orig_price:\n                net = net + days[i]\n                can_buy = True\n    return net\n\n", "annotation": "No annotation.", "output": "def impatient_merchant(days):\n    \"\"\"\n    You are given the prices of some goods in consecutive days. \n    Here's an impatient merchant who will buy the good at the first days, \n    and sell it until its price becomes higher than its original cost. \n    Then he will buy the good in the next day and repeat the above process. \n    The good left in the hand of the merchant in the last day will worth nothing.\n    You should calculate the net value the impatient merchant can earn.\n    \"\"\"\n    can_buy = sint(1)\n    net = sfix(0)\n    orig_price = sfix(0)\n    @for_range(len(days))\n    def _(i):\n        net.update(can_buy.if_else(net-days[i],(days[i]>orig_price).if_else(net+days[i],net)))\n        orig_price.update(can_buy.if_else(days[i],orig_price))\n        can_buy.update(can_buy.if_else(False,(days[i]>orig_price).if_else(True,can_buy)))\n    return net\n"}
{"test_name": "array_shift", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    temp = a[len(a)-1]\n    for i in range(len(a)-1):\n        a[len(a)-i-1] = a[len(a)-i-2]\n    a[0] = temp\n    return a\n\n", "annotation": "No annotation.", "output": "def array_shift(a):\n    \"\"\"\n    Shift the array on index by 1. \n    For example, [0,1,2] will be shifted to [1,2,0]\n    \"\"\"\n    temp = a[len(a)-1]\n    @for_range(len(a)-1)\n    def _(i):\n        a[len(a)-i-1] = a[len(a)-i-2]\n    a[0] = temp\n    return a\n"}
{"test_name": "array_double", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] * 2\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_double(arr):\n    \"\"\"\n    Double all elements in the input array.\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = arr[i] * 2 \n    return arr\n"}
{"test_name": "stop_at_zero", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    for i in range(len(array)):\n        if array[i]==0:\n            break\n        array[i] += 1\n    return array\n\n", "annotation": "No annotation.", "output": "def stop_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but stop if found an element equal to 0\n    \"\"\"\n    stop = sint(0)\n    @for_range(len(array))\n    def _(i):\n        stop.update(stop.bit_or(array[i]==0))\n        array[i] = array[i] + stop.if_else(0,1)\n    return array\n"}
{"test_name": "array_not", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = not arr[i]\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_not(arr):\n    \"\"\"\n    Take opposite to all elements in the input array.\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = arr[i].bit_not()\n    return arr\n"}
{"test_name": "array_process_then_clip", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_process_then_clip(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome in to range [-10,10]\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        if arr[i] > 10:\n            arr[i] = 10\n        if arr[i] < -10:\n            arr[i] = -10\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_process_then_clip(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then clip the outcome in to range [-10,10]\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = func(arr[i])\n        arr[i] = (arr[i]>10).if_else(10,arr[i])\n        arr[i] = (arr[i]<-10).if_else(-10,arr[i])\n    return arr\n"}
{"test_name": "add_and_count_positive", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def add_and_count_positive(array,k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    count = 0\n    for i in range(len(array)):\n        array[i] = array[i] + k\n        if array[i] > 0:\n            count = count + 1\n    return array, count\n\n", "annotation": "No annotation.", "output": "def add_and_count_positive(array,k):\n    \"\"\"\n    Add k to all elements in the given array, and count the number of positive numbers in the output array. \n    Return both the output array and the count. \n    \"\"\"\n    count = sint(0)\n    @for_range(len(array))\n    def _(i):\n        array[i] = array[i] + k\n        count.update((array[i]>0).if_else(count+1,count))\n    return array, count\n"}
{"test_name": "array_subtract", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_subtract(a,b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    if len(a)>len(b):\n        ret = [0 for i in range(len(a))]\n        for i in range(len(b)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(a)-len(b)):\n            ret[len(b)+i] = a[len(b)+i]\n        return ret\n    else:\n        ret = [0 for i in range(len(b))]\n        for i in range(len(a)):\n            ret[i] = a[i] - b[i]\n        for i in range(len(b)-len(a)):\n            ret[len(a)+i] = -b[len(a)+i]\n        return ret\n\n", "annotation": "No annotation.", "output": "def array_subtract(a,b):\n    \"\"\"\n    Subtract the first array by the second one elementwise. \n    If one of the array is shorter than the other, it will be padded with 0.\n    \"\"\"\n    if len(a)>len(b):\n        ret = sfix.Array(len(a))\n        @for_range(len(b))\n        def _(i):\n            ret[i] = a[i] - b[i]\n        @for_range(len(a)-len(b))\n        def _(i):\n            ret[len(b)+i] = a[len(b)+i]\n        return ret\n    else:\n        ret = sfix.Array(len(b))\n        @for_range(len(a))\n        def _(i):\n            ret[i] = a[i] - b[i]\n        @for_range(len(b)-len(a))\n        def _(i):\n            ret[len(a)+i] = -b[len(a)+i]\n        return ret\n"}
{"test_name": "lower_bound", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def lower_bound(arr,x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = -1\n    distance = 0\n    found = False\n    for i in range(len(arr)):\n        if arr[i]<=x:\n            if not found or x-arr[i]<distance:\n                ret = i\n                distance = x-arr[i]\n                found = True\n    return ret\n\n", "annotation": "No annotation.", "output": "def lower_bound(arr,x):\n    \"\"\"\n    Return the index of the largest element not bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = sint(-1)\n    distance = sfix(0)\n    found = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        first_predicate = arr[i]<=x\n        second_predicate = first_predicate.bit_and((found.bit_not()).bit_or(x-arr[i]<distance))\n        ret.update(second_predicate.if_else(i,ret))\n        distance.update(second_predicate.if_else(x-arr[i],distance))\n        found.update(second_predicate.if_else(True,found))\n    return ret\n"}
{"test_name": "argmin", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def argmin(a):\n    \"\"\"\n    Return the index of the min velue of an array. \n    \"\"\"\n    current = a[0]\n    index = 0\n    for i in range(len(a)):\n        index = index if current<=a[i] else i\n        current = current if current<=a[i] else a[i]\n    return index\n\n", "annotation": "No annotation.", "output": "def argmin(a):\n    \"\"\"\n    Return the index of the min value of an array. \n    \"\"\"\n    current = a[0]\n    index = sint(0)\n    @for_range(len(a))\n    def compare_and_save(i):\n        index.update((current<=a[i]).if_else(index,i))\n        current.update((current<=a[i]).if_else(current,a[i]))\n    return index\n"}
{"test_name": "independent_robbery", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem:\n    The robber wants to rob some houses align a street, each of which has some amount of money in it (guaranteed to be nonnegative). \n    The robber cannot rob two consecutive houses, we want to know the max amount of money he can get. \n    The number of houses is guaranteed to be no smaller than 3.\n    \"\"\"\n    dp = [0 for i in range(len(houses))]\n    dp[0] = houses[0]\n    dp[1] = dp[1] if dp[1]>=dp[0] else dp[0]\n    for i in range(2,len(houses)):\n        if dp[i-2]+houses[i] >= dp[i-1]:\n            dp[i] = dp[i-2]+houses[i]\n        else:\n            dp[i] = dp[i-1]\n    return dp[len(houses)-1]\n\n", "annotation": "No annotation.", "output": "def independent_robbery(houses):\n    \"\"\"\n    Use dynamic programming to solve the \"independent robbery\" problem:\n    The robber wants to rob some houses align a street, each of which has some amount of money in it (guaranteed to be nonnegative). \n    The robber cannot rob two consecutive houses, we want to know the max amount of money he can get. \n    The number of houses is guaranteed to be no smaller than 3.\n    \"\"\"\n    dp = sfix.Array(len(houses))\n    dp[0] = houses[0]\n    dp[1] = (dp[1]>=dp[0]).if_else(dp[1],dp[0])\n    @for_range(2,len(houses))\n    def _(i):\n        dp[i] = (dp[i-2]+houses[i]>=dp[i-1]).if_else(dp[i-2]+houses[i],dp[i-1])\n    return dp[len(houses)-1]\n"}
{"test_name": "sum_odd_and_odd", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    sum = 0\n    for i in range(len(arr)):\n        if i%2==0:\n            continue\n        for j in range(i):\n            if j%2==0:\n                continue\n            sum += arr[j]\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_odd_and_odd(arr):\n    \"\"\"\n    A strange sum function\n    \"\"\"\n    sum = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        outer_skip = i%2==0\n        @for_range(i)\n        def _(j):\n            inner_skip = j%2==0\n            sum.iadd(outer_skip.bit_or(inner_skip).if_else(0,arr[j]))\n    return sum\n"}
{"test_name": "is_monotonous", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    d = 0\n    for i in range(len(arr)-1):\n        if i>0 and (arr[i+1]-arr[i])*d<=0:\n            return False\n        d = arr[i+1]-arr[i]\n    return True\n\n", "annotation": "No annotation.", "output": "def is_monotonous(arr):\n    \"\"\"\n    Return whether or not the array is strictly monotonous.\n    \"\"\"\n    d = sfix(0)\n    ret = sint(1)\n    @for_range(len(arr)-1)\n    def _(i):\n        ret.update(ret.if_else(((i>0).bit_and((arr[i+1]-arr[i])*d<=0)).bit_not(),ret))\n        d.update(arr[i+1]-arr[i])\n    return ret\n"}
{"test_name": "positive_count_negative_sum", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = 0\n    sum = 0\n    for item in arr:\n        if item>0:\n            count = count + 1\n        if item<0:\n            sum = sum + item\n    return count, sum\n\n", "annotation": "No annotation.", "output": "def positive_count_negative_sum(arr):\n    \"\"\"\n    Traverse the array, return the number of all positive elements and the sum of all negative elements.\n    \"\"\"\n    count = sint(0)\n    sum = sfix(0)\n    @for_range(len(arr))\n    def _(i):\n        count.update((arr[i]>0).if_else(count+1,count))\n        sum.update((arr[i]<0).if_else(sum+arr[i],sum))\n    return count, sum\n"}
{"test_name": "sum_even", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = 0\n    for item in arr:\n        if not item%2:\n            sum = sum + item\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_even(arr):\n    \"\"\"\n    Return the sum of all the even numbers in the array.\n    \"\"\"\n    sum = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        sum.update((arr[i]%2).bit_not().if_else(sum+arr[i],sum))\n    return sum\n"}
{"test_name": "one_norm", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = 0\n    for item in vec:\n        sum = sum + abs(item)\n    return sum\n\n", "annotation": "No annotation.", "output": "def one_norm(vec):\n    \"\"\"\n    Return the one-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(vec))\n    def _(i):\n        sum.update(sum+abs(vec[i]))\n    return sum\n"}
{"test_name": "array_floor", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    import math\n    ret = [0 for i in range(len(arr))]\n    for i in range(len(arr)):\n        ret[i] = math.floor(arr[i])\n    return ret\n\n", "annotation": "No annotation.", "output": "def array_floor(arr):\n    \"\"\"\n    Apply Gaussian floor function to all elements in the input array. \n    \"\"\"\n    from Compiler import mpc_math\n    ret = sfix.Array(len(arr))\n    @for_range(len(arr))\n    def _(i):\n        ret[i] = mpc_math.floor_fx(arr[i])\n    return ret\n"}
{"test_name": "three_five", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def three_five(arr):\n    \"\"\"\n    If the input array contain both/neither 3 and/or 5, return True, \n    otherwise return False. \n    \"\"\"\n    has3 = False\n    has5 = False\n    for item in arr:\n        has3 = has3 or item==3\n        has5 = has5 or item==5\n    return (has3 and has5) or ((not has3) and (not has5))\n\n", "annotation": "No annotation.", "output": "def three_five(arr):\n    \"\"\"\n    If the input array contain both/neither 3 and/or 5, return True, \n    otherwise return False. \n    \"\"\"\n    has3 = sint(0)\n    has5 = sint(0)\n    @for_range(0,len(arr))\n    def _(i):\n        has3.update(has3.bit_or(arr[i]==3))\n        has5.update(has5.bit_or(arr[i]==5))\n    return (has3.bit_and(has5)).bit_or((has3.bit_not()).bit_and(has5.bit_not()))\n"}
{"test_name": "num_above_average", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    sum = 0\n    count = 0\n    for i in range(len(arr)):\n        sum = sum + arr[i]\n    avg = sum/len(arr)\n    for item in arr:\n        if item>=avg:\n            count = count + 1\n    return count\n\n", "annotation": "No annotation.", "output": "def num_above_average(arr):\n    \"\"\"\n    Return the number of elements in the array larger than or equal to the average value. \n    \"\"\"\n    sum = sfix(0)\n    count = sint(0)\n    @for_range(len(arr))\n    def add(i):\n        sum.update(sum+arr[i])\n    avg = sum/len(arr)\n    @for_range(len(arr))\n    def judge(i):\n        count.update((arr[i]>=avg).if_else(count+1,count))\n    return count\n"}
{"test_name": "clip", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] < lower_bound:\n            arr[i] = lower_bound\n        if arr[i] > upper_bound:\n            arr[i] = upper_bound\n    return arr\n\n", "annotation": "No annotation.", "output": "def clip(arr, upper_bound=1, lower_bound=-1):\n    \"\"\"\n    For the given array, clip the elements to the range [lower_bound, upper_bound]\n    \"\"\"\n    @for_range(len(arr))\n    def clip(i):\n        arr[i] = (arr[i]<lower_bound).if_else(lower_bound,arr[i])\n        arr[i] = (arr[i]>upper_bound).if_else(upper_bound,arr[i])\n    return arr\n"}
{"test_name": "sum_with_certain_element_skipped", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = 0\n    for i in range(len(array)):\n        if 5<=sum+array[i]<=10:\n            continue\n        sum += array[i]\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_with_certain_element_skipped(array):\n    \"\"\"\n    Compute partial sum of the array with all elements causing the partial sum to be in [5,10] skipped.\n    \"\"\"\n    sum = sint(0)\n    @for_range(len(array))\n    def _(i):\n        temp = sum+array[i]\n        skip = (5<=sum+array[i]).bit_and(sum+array[i]<=10)\n        sum.iadd(skip.if_else(0,array[i]))\n    return sum\n"}
{"test_name": "sum_of_odd_and_even", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers. \n    \"\"\"\n    odd_sum = 0\n    even_sum = 0\n    for item in arr:\n        if item%2:\n            odd_sum = odd_sum + item\n        else:\n            even_sum = even_sum + item\n    return odd_sum, even_sum\n\n", "annotation": "No annotation.", "output": "def sum_of_odd_and_even(arr):\n    \"\"\"\n    Return the sum of odd number and even number in the array.\n    The elements in the input array are guaranteed to be integers. \n    \"\"\"\n    odd_sum = sint(0)\n    even_sum = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        odd_sum.update((arr[i]%2).if_else(odd_sum+arr[i],odd_sum))\n        even_sum.update(((arr[i]%2).bit_not()).if_else(even_sum+arr[i],even_sum))\n    return odd_sum, even_sum\n"}
{"test_name": "distance", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    import math\n    sum = 0\n    for i in range(len(vec1)):\n        sum = sum + (vec1[i]-vec2[i])**2\n    return math.sqrt(sum)\n\n", "annotation": "No annotation.", "output": "def distance(vec1, vec2):\n    \"\"\"\n    Compute the Euclidean distance between the two vectors.\n    \"\"\"\n    from Compiler import mpc_math\n    sum = sfix(0)\n    @for_range(len(vec1))\n    def _(i):\n        sum.update(sum+(vec1[i]-vec2[i])**2)\n    return mpc_math.sqrt_simplified_fx(sum)\n"}
{"test_name": "num_occurrence", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = 0\n    for item in arr:\n        if item == target:\n            count = count + 1\n    return count\n\n", "annotation": "No annotation.", "output": "def num_occurrence(arr, target):\n    \"\"\"\n    Return the number of occurrence of the target in the given array.\n    \"\"\"\n    count = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        count.update((arr[i]==target).if_else(count+1,count))\n    return count\n"}
{"test_name": "palindrome", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    flag = True\n    for i in range(len(arr)):\n        flag = flag and (arr[i]==arr[len(arr)-1-i])\n    return flag\n\n", "annotation": "No annotation.", "output": "def palindrome(arr):\n    \"\"\"\n    Check whether the array is a palindrome.\n    \"\"\"\n    flag = sint(1)\n    @for_range(len(arr))\n    def _(i):\n        flag.update(flag.bit_and(arr[i]==arr[len(arr)-1-i]))\n    return flag\n"}
{"test_name": "reverse_order_pair", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array. \n    \"\"\"\n    num = 0\n    for i in range(len(arr)):\n        for j in range(i+1,len(arr)):\n            if arr[i]>arr[j]:\n                num = num + 1\n    return num\n\n", "annotation": "No annotation.", "output": "def reverse_order_pair(arr):\n    \"\"\"\n    Count the number of reverse order pairs in the array. \n    \"\"\"\n    num = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        @for_range(i+1,len(arr))\n        def _(j):\n            num.update((arr[i]>arr[j]).if_else(num+1,num))\n    return num\n"}
{"test_name": "sum_of_cubes", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = 0\n    for item in arr:\n        ret = ret + item**3\n    return ret\n\n", "annotation": "No annotation.", "output": "def sum_of_cubes(arr):\n    \"\"\"\n    Return the sum of cubes of elements in the array. \n    \"\"\"\n    ret = sfix(0)\n    @for_range(len(arr))\n    def _(i):\n        ret.update(ret+arr[i]**3)\n    return ret\n"}
{"test_name": "max_element", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def max_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    for item in a:\n        current = current if current>=item else item\n    \n    return current\n\n", "annotation": "No annotation.", "output": "def max_element(a):\n    \"\"\"\n    Return the max value of an array. \n    \"\"\"\n    current = a[0]\n    @for_range(len(a))\n    def compare_and_save(i):\n        current.update((current>=a[i]).if_else(current,a[i]))\n    \n    return current\n"}
{"test_name": "array_if_else", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_if_else(arr,predicator,if_func,else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns Ture, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = if_func(arr[i]) if predicator(arr[i]) else else_func(arr[i])\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_if_else(arr,predicator,if_func,else_func):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns Ture, then apply the if-function to the element, \n    otherwise apply the else-function to the element. \n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = (predicator(arr[i])).if_else(if_func(arr[i]),else_func(arr[i]))\n    return arr\n"}
{"test_name": "inf_norm", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    sum = 0\n    for item in vec:\n        sum = sum if sum>=abs(item) else abs(item)\n    return sum\n\n", "annotation": "No annotation.", "output": "def inf_norm(vec):\n    \"\"\"\n    Return the infinite-norm of the vector.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(vec))\n    def _(i):\n        sum.update((sum>=abs(vec[i])).if_else(sum,abs(vec[i])))\n    return sum\n"}
{"test_name": "array_inc", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_inc(arr):\n    \"\"\"\n    Increment all elements in the input array by 1\n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = arr[i] + 1 \n    return arr\n"}
{"test_name": "count_rises", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = 0\n    for i in range(len(arr)-1):\n        if arr[i]<arr[i+1]:\n            count = count + 1\n    return count\n\n", "annotation": "No annotation.", "output": "def count_rises(arr):\n    \"\"\"\n    Count the number of rises in the array. \n    \"\"\"\n    count = sint(0)\n    @for_range(len(arr)-1)\n    def _(i):\n        count.update((arr[i]<arr[i+1]).if_else(count+1,count))\n    return count\n"}
{"test_name": "skip_at_zero", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    for i in range(len(array)):\n        if array[i]==0:\n            continue\n        array[i] += 1\n    return array\n\n", "annotation": "No annotation.", "output": "def skip_at_zero(array):\n    \"\"\"\n    Add 1 to all elements in the array, but skip if found an element equal to 0\n    \"\"\"\n    @for_range(len(array))\n    def _(i):\n        array[i] = array[i] + (array[i]==0).if_else(0,1)\n    return array\n"}
{"test_name": "array_intersect", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_intersect(p,q):\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    for i in range(len(p)):\n        for j in range(len(q)):\n            if p[i] == q[j]:\n                return True\n    return False\n\n", "annotation": "No annotation.", "output": "def array_intersect(p,q):\n    \"\"\"\n    Return whether the two arrays share any common element. \n    \"\"\"\n    ret = sint(0)\n    @for_range(len(p))\n    def _(i):\n        @for_range(len(q))\n        def _(j):\n            ret.update(ret.bit_or(p[i]==q[j]))\n    return ret\n"}
{"test_name": "two_norm", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    import math\n    sum = 0\n    for item in vec:\n        sum = sum + item**2\n    return math.sqrt(sum)\n\n", "annotation": "No annotation.", "output": "def two_norm(vec):\n    \"\"\"\n    Return the two-norm of the vector.\n    \"\"\"\n    from Compiler import mpc_math\n    sum = sfix(0)\n    @for_range(len(vec))\n    def _(i):\n        sum.update(sum+vec[i]**2)\n    return mpc_math.sqrt_simplified_fx(sum)\n"}
{"test_name": "sum_between", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = 0\n    for item in arr:\n        if l<=item<=u:\n            sum = sum + item\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_between(arr, l, u):\n    \"\"\"\n    Return the sum of elements in arr within range [l,u].\n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(arr))\n    def _(i):\n        sum.update(((l<=arr[i]).bit_and(arr[i]<=u)).if_else(sum+arr[i],sum))\n    return sum\n"}
{"test_name": "largest_gap", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = 0\n    for i in range(len(arr)-1):\n        if abs(arr[i+1]-arr[i]) > cur:\n            cur = abs(arr[i+1]-arr[i])\n    return cur\n\n", "annotation": "No annotation.", "output": "def largest_gap(arr):\n    \"\"\"\n    Return the largest gap in the array.\n    The length of the input array is guaranteed to be at least 2.\n    \"\"\"\n    cur = sfix(0)\n    @for_range(len(arr)-1)\n    def _(i):\n        cur.update((abs(arr[i+1]-arr[i])>cur).if_else(abs(arr[i+1]-arr[i]),cur))\n    return cur\n"}
{"test_name": "totally_dominate", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def totally_dominate(a,b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    for i in range(len(a)):\n        if a[i]<amin:\n            amin = a[i]\n    for i in range(len(b)):\n        if b[i]>bmax:\n            bmax = b[i]\n    return amin>=bmax\n\n", "annotation": "No annotation.", "output": "def totally_dominate(a,b):\n    \"\"\"\n    Return whether array a \"totally dominates\" array b, \n    which means, any element in a is no smaller than any element in b. \n    \"\"\"\n    amin = a[0]\n    bmax = b[0]\n    @for_range(len(a))\n    def _(i):\n        amin.update((a[i]<amin).if_else(a[i],amin))\n    @for_range(len(b))\n    def _(i):\n        bmax.update((b[i]>bmax).if_else(b[i],bmax))\n    return amin>=bmax\n"}
{"test_name": "element_count", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def element_count(arr, target):\n    \"\"\"\n    Count the numer of times the target element occurs in the array. \n    \"\"\"\n    ret = 0\n    for item in arr:\n        if item == target:\n            ret = ret + 1\n    return ret\n\n", "annotation": "No annotation.", "output": "def element_count(arr, target):\n    \"\"\"\n    Count the numer of times the target element occurs in the array. \n    \"\"\"\n    ret = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        ret.update((arr[i]==target).if_else(ret+1,ret))\n    return ret\n"}
{"test_name": "is_subarray", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def is_subarray(c,d):\n    \"\"\"\n    Return wether the first array is a continuous subarray of the second array.\n    \"\"\"\n    for i in range(len(d)):\n        if len(c)<=len(d)-i:\n            flag = True\n            for j in range(len(c)):\n                flag = flag and d[i+j]==c[j]\n            if flag:\n                return True\n    return False\n\n", "annotation": "No annotation.", "output": "def is_subarray(c,d):\n    \"\"\"\n    Return wether the first array is a continuous subarray of the second array.\n    \"\"\"\n    ok = sint(0)\n    @for_range(len(d))\n    def _(i):\n        @if_e(len(c)<=len(d)-i)\n        def _():\n            flag = sint(1)\n            @for_range(len(c))\n            def _(j):\n                flag.update(flag.bit_and(d[i+j]==c[j]))\n            ok.update(ok.bit_or(flag))\n        @else_\n        def _():\n            pass\n    return ok\n"}
{"test_name": "exists_5_or_7", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    for item in arr:\n        if item == 5 or item == 7:\n            return True\n    return False\n\n", "annotation": "No annotation.", "output": "def exists_5_or_7(arr):\n    \"\"\"\n    Check whether the array contains 5 or 7.\n    \"\"\"\n    ret = sint(0)\n    @for_range(0,len(arr))\n    def _(i):\n        ret.update(ret.bit_or((arr[i]==5).bit_or(arr[i]==7)))\n    return ret\n"}
{"test_name": "variance", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def variance(arr):\n    \"\"\"\n    Return the variance of the array. \n    \"\"\"\n    average = 0\n    variance = 0\n    for item in arr:\n        average = average+item/len(arr)\n    for item in arr:\n        variance = variance + (item-average)**2/len(arr)\n    return variance\n\n", "annotation": "No annotation.", "output": "def variance(arr):\n    \"\"\"\n    Return the variance of the array. \n    \"\"\"\n    average = sfix(0)\n    variance = sfix(0)\n    @for_range(len(arr))\n    def compute_average(i):\n        average.update(average+arr[i]/len(arr))\n    @for_range(len(arr))\n    def compute_variance(i):\n        variance.update(variance+(arr[i]-average)**2/len(arr))\n    return variance\n"}
{"test_name": "is_ascending", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def is_ascending(arr):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    for i in range(len(arr)-1):\n        if arr[i]>=arr[i+1]:\n            return False\n    return True\n\n", "annotation": "No annotation.", "output": "def is_ascending(arr):\n    \"\"\"\n    Return whether or not the array is in strictly ascending order.\n    If the length of input array is 1, you should return True.\n    \"\"\"\n    ret = sint(1)\n    @for_range(len(arr)-1)\n    def _(i):\n        ret.update((arr[i]>=arr[i+1]).if_else(False,ret))\n    return ret\n"}
{"test_name": "xor_all", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    for i in range(1,len(arr)):\n        ret = ret^arr[i]\n    return ret\n\n", "annotation": "No annotation.", "output": "def xor_all(arr):\n    \"\"\"\n    XOR all elements in the array and return the output.\n    The input array is guaranteed to contain only 0's and 1's.\n    \"\"\"\n    ret = arr[0]\n    @for_range(1,len(arr))\n    def _(i):\n        ret.update(ret.bit_xor(arr[i]))\n    return ret\n"}
{"test_name": "upper_bound", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def upper_bound(arr,x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = -1\n    distance = 0\n    found = False\n    for i in range(len(arr)):\n        if arr[i]>x:\n            if not found or arr[i]-x<distance:\n                ret = i\n                distance = arr[i]-x\n                found = True\n    return ret\n\n", "annotation": "No annotation.", "output": "def upper_bound(arr,x):\n    \"\"\"\n    Return the index of the smallest element bigger than x in arr.\n    If such element does not exist, return -1.\n    \"\"\"\n    ret = sint(-1)\n    distance = sfix(0)\n    found = sint(0)\n    @for_range(len(arr))\n    def _(i):\n        first_predicate = arr[i]>x\n        second_predicate = first_predicate.bit_and((found.bit_not()).bit_or(arr[i]-x<distance))\n        ret.update(second_predicate.if_else(i,ret))\n        distance.update(second_predicate.if_else(arr[i]-x,distance))\n        found.update(second_predicate.if_else(True,found))\n    return ret\n"}
{"test_name": "array_process_then_sum", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_process_then_sum(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = 0\n    for i in range(len(arr)):\n        arr[i] = func(arr[i])\n        sum = sum + arr[i]\n    return sum\n\n", "annotation": "No annotation.", "output": "def array_process_then_sum(arr,func):\n    \"\"\"\n    Process all elements in the input array with given function, \n    then sum up the processed elements.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = func(arr[i])\n        sum.update(sum+arr[i])\n    return sum\n"}
{"test_name": "average", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = 0\n    length = len(arr)\n    for i in range(length):\n        sum = sum + arr[i]\n    ret = sum/length\n    return ret\n\n", "annotation": "No annotation.", "output": "def average(arr):\n    \"\"\"\n    Compute the average value of the array.\n    \"\"\"\n    sum = sfix(0)\n    @for_range(length)\n    def add(i):\n        sum.update(sum+arr[i])\n    ret = sum/length\n    return ret\n"}
{"test_name": "array_filter", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_filter(arr,predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns Ture, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] if predicator(arr[i]) else 0\n    return arr\n\n", "annotation": "No annotation.", "output": "def array_filter(arr,predicator):\n    \"\"\"\n    For each element in the input array, \n    if the predicator returns Ture, then preserve the element, \n    otherwise set the element to 0. \n    \"\"\"\n    @for_range(len(arr))\n    def _(i):\n        arr[i] = (predicator(arr[i])).if_else(arr[i],0)\n    return arr\n"}
{"test_name": "sum_up", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_up(array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    sum = 0\n    for num in array:\n        sum = sum + num\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_up(array):\n    \"\"\"\n    The sum_up function\n    \"\"\"\n    count = sint(0)\n    @for_range(len(array))\n    def add(i):\n        count.update(count+array[i])\n    return count\n"}
{"test_name": "negative_to_zero", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    for i in range(len(array)):\n        if array[i]>=0:\n            continue\n        array[i] = 0\n    return array\n\n", "annotation": "No annotation.", "output": "def negative_to_zero(array):\n    \"\"\"\n    Turn the negative elements in the array to zero\n    \"\"\"\n    @for_range(len(array))\n    def _(i):\n        array[i] = (array[i]>=0).if_else(array[i],0)\n    return array\n"}
{"test_name": "sum_only_positive_to_ten", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = 0\n    for i in range(len(array)):\n        if array[i]<=0:\n            continue\n        if sum >= 10:\n            break\n        sum = sum + array[i]\n    return sum\n\n", "annotation": "No annotation.", "output": "def sum_only_positive_to_ten(array):\n    \"\"\"\n    Compute partial sum of the array with only the positive elements until the sum becomes no smaller than 10.\n    \"\"\"\n    sum = sint(0)\n    @for_range(len(array))\n    def _(i):\n        sum.iadd(((sum<10).bit_and(array[i]>0)).if_else(array[i],0))\n    return sum\n"}
{"test_name": "bubble_sort", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array. \n    \"\"\"\n    for i in range(len(arr)-1):\n        for j in range(len(arr)-1-i):\n            if arr[j]>=arr[j+1]:\n                temp = arr[j]\n                arr[j] = arr[j+1]\n                arr[j+1] = temp\n    return arr\n\n", "annotation": "No annotation.", "output": "def bubble_sort(arr):\n    \"\"\"\n    Perform bubble sort to the array. \n    \"\"\"\n    @for_range(len(arr)-1)\n    def outer(i):\n        @for_range(len(arr)-1-i)\n        def inner(j):\n            temp = arr[j]\n            swap = arr[j]>=arr[j+1]\n            arr[j] = swap.if_else(arr[j+1],arr[j])\n            arr[j+1] = swap.if_else(temp,arr[j+1])\n    return arr\n"}
