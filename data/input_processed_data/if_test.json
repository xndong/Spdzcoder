{"test_name": "sin_or_cos", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    import math\n    if x >= 0:\n        return math.sin(x)\n    return math.cos(x)\n\n", "annotation": "No annotation.", "output": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    from Compiler import mpc_math\n    return (x>=0).if_else(mpc_math.sin(x),mpc_math.cos(x))\n"}
{"test_name": "negative_relu", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise retrun 0.\n    \"\"\"\n    return input if input<0 else 0\n\n", "annotation": "No annotation.", "output": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise retrun 0.\n    \"\"\"\n    return (input<0).if_else(input,0)\n"}
{"test_name": "is_close", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def is_close(a,b):\n    \"\"\"\n    Return wether or not the two inputs are close: \n    their absolute difference is no larger than 1. \n    \"\"\"\n    return abs(a-b)<=1\n\n", "annotation": "No annotation.", "output": "def is_close(a,b):\n    \"\"\"\n    Return wether or not the two inputs are close: \n    their absolute difference is no larger than 1. \n    \"\"\"\n    return abs(a-b)<=1\n"}
{"test_name": "hardswish", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    if x<-3:\n        return 0\n    elif x>3:\n        return x\n    else:\n        return x*(x+3)/6\n\n", "annotation": "No annotation.", "output": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    return (x<-3).if_else(0,(x>3).if_else(x,x*(x+3)/sfix(6)))\n"}
{"test_name": "clip_at_6", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    if x > 6:\n        return 6\n    if x < -6:\n        return -6\n    return x\n\n", "annotation": "No annotation.", "output": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    return (x>6).if_else(6,(x<-6).if_else(-6,x))\n"}
{"test_name": "piecewise_function", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    ret = 0\n    if x>1:\n        ret = x\n    elif x<-1:\n        ret = x\n    elif x>0:\n        ret = 1\n    elif x<0:\n        ret = -1\n    else:\n        ret = 0\n    return ret\n\n", "annotation": "No annotation.", "output": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    return (x>1).if_else(x,(x<-1).if_else(x,(x>0).if_else(1,(x<0).if_else(-1,0))))\n"}
{"test_name": "middle", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def middle(a,b,c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    if a>=b:\n        temp = a\n        a = b\n        b = temp\n    if b>=c:\n        temp = b\n        b = c\n        c = temp\n    if a>=b:\n        temp = a\n        a = b\n        b = temp\n    return b\n\n", "annotation": "No annotation.", "output": "def middle(a,b,c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    first_predicate = a>=b\n    temp = first_predicate.if_else(a,0)\n    a = first_predicate.if_else(b,a)\n    b = first_predicate.if_else(temp,b)\n    second_predicate = b>=c\n    temp = second_predicate.if_else(b,0)\n    b = second_predicate.if_else(c,b)\n    c = second_predicate.if_else(temp,c)\n    third_predicate = a>=b\n    temp = third_predicate.if_else(a,0)\n    a = third_predicate.if_else(b,a)\n    b = third_predicate.if_else(temp,b)\n    return b\n"}
{"test_name": "indicated_sin_or_cos", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def indicated_sin_or_cos(x,ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    import math\n    if ind:\n        return math.sin(x)\n    return math.cos(x)\n\n", "annotation": "No annotation.", "output": "def indicated_sin_or_cos(x,ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    from Compiler import mpc_math\n    return ind.if_else(mpc_math.sin(x),mpc_math.cos(x))\n"}
{"test_name": "minus2_if_else", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    return x-2 if x-2>=0 else x\n\n", "annotation": "No annotation.", "output": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    return (x-2>=0).if_else(x-2,x)\n"}
{"test_name": "relu6", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    if x<0:\n        return 0\n    elif x>6:\n        return 6\n    else:\n        return x\n\n", "annotation": "No annotation.", "output": "def relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    return (x<0).if_else(0,(x>6).if_else(6,x))\n"}
{"test_name": "exp_slide", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    import math\n    if x >= 0:\n        return math.pow(math.e,x)\n    return x+1\n\n", "annotation": "No annotation.", "output": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    import math\n    from Compiler import mpc_math\n    return (x>=0).if_else(mpc_math.pow_fx(math.e,x),x+1)\n"}
{"test_name": "pass_or_not", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    score = score if score>=60 else 59\n    passed = True if score>=60 else False\n    return score, passed\n\n", "annotation": "No annotation.", "output": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    score = (score>=60).if_else(score,59)\n    passed = score>=60\n    return score, passed\n"}
{"test_name": "how_many_roots", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def how_many_roots(a,b,c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    if a == 0:\n        if b == 0:\n            return 0\n        else:\n            return 1\n    if b**2-4*a*c > 0:\n        return 2\n    elif b**2-4*a*c == 0:\n        return 1\n    else:\n        return 0\n\n", "annotation": "No annotation.", "output": "def how_many_roots(a,b,c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    return (a==0).if_else((b==0).if_else(0,1),(b**2-4*a*c>0).if_else(2,(b**2-4*a*c==0).if_else(1,0)))\n"}
{"test_name": "elu", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    import math\n    if x>0:\n        return x\n    else:\n        return math.pow(math.e,x)-1\n\n", "annotation": "No annotation.", "output": "def elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    import math\n    from Compiler import mpc_math\n    return (x>0).if_else(x, mpc_math.pow_fx(math.e,x)-1)\n"}
{"test_name": "relu", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    if x>0:\n        return x\n    else:\n        return 0\n\n", "annotation": "No annotation.", "output": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    return (x>0).if_else(x, 0)\n"}
{"test_name": "leaky_relu", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    if x>0:\n        return x\n    else:\n        return x*alpha\n\n", "annotation": "No annotation.", "output": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    return (x>0).if_else(x, x*alpha)\n"}
{"test_name": "max", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def max(a,b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    if a>=b:\n        return a\n    else:\n        return b\n\n", "annotation": "No annotation.", "output": "def max(a,b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    return (a>=b).if_else(a,b)\n"}
{"test_name": "bowl_shape", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    if x>1:\n        return x-1\n    elif x<-1:\n        return -x-1\n    else:\n        return 0\n\n", "annotation": "No annotation.", "output": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    return (x>1).if_else(x-1,(x<-1).if_else(-x-1,0))\n"}
{"test_name": "rounded_kinetic_energy", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def rounded_kinetic_energy(m,v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    import math\n    k = m*v**2/2\n    k_int = math.floor(k)\n    return k_int if (k-k_int)<0.5 else k_int+1\n\n", "annotation": "No annotation.", "output": "def rounded_kinetic_energy(m,v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    from Compiler import mpc_math\n    k = m*v**2/sfix(2)\n    k_int = mpc_math.floor_fx(k)\n    return ((k-k_int)<0.5).if_else(k_int,k_int+1)\n"}
{"test_name": "danger_test", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def danger_test(origin,damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return origin-damage<=10\n\n", "annotation": "No annotation.", "output": "def danger_test(origin,damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return origin-damage<=10\n"}
{"test_name": "indicated_sum_or_multiply", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def indicated_sum_or_multiply(x,y,ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    if ind:\n        return x+y\n    return x*y\n\n", "annotation": "No annotation.", "output": "def indicated_sum_or_multiply(x,y,ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    return ind.if_else(x+y,x*y)\n"}
{"test_name": "median", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr)==0:\n        raise ValueError(\"The length of the array is 0!\")\n    arr.sort()\n    ret = 0\n    if len(arr)%2: \n        ret = arr[len(arr)//2]\n    else:\n        ret = (arr[len(arr)//2]+arr[len(arr)//2-1])/2\n    return ret\n\n", "annotation": "No annotation.", "output": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr)==0:\n        raise ValueError(\"The length of the array is 0!\")\n    arr.sort()\n    odd_length = sint(len(arr)%2)\n    ret = odd_length.if_else(arr[int(len(arr)-1)//2],(arr[int(len(arr))//2]+arr[int(len(arr))//2-1])/sfix(2))\n    return ret\n"}
{"test_name": "add_upto_10", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def add_upto_10(a,b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    if a+b > 10:\n        return 10\n    return a+b\n\n", "annotation": "No annotation.", "output": "def add_upto_10(a,b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    return (a+b>10).if_else(10,a+b)\n"}
{"test_name": "taxi_fare", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    if m<=5:\n        return 5\n    if 5<=m<=10:\n        return 5 + 1.2*(m-5)\n    return 11 + 1.5*(m-10)\n\n", "annotation": "No annotation.", "output": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    return (m<=5).if_else(5,(m<=10).if_else(5+sfix(1.2)*(m-5),11+sfix(1.5)*(m-10)))\n"}
{"test_name": "round", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    import math\n    x_int = math.floor(x)\n    return x_int if (x-x_int)<0.5 else x_int+1\n\n", "annotation": "No annotation.", "output": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    from Compiler import mpc_math\n    x_int = mpc_math.floor_fx(x)\n    return ((x-x_int)<0.5).if_else(x_int,x_int+1)\n"}
{"test_name": "gpa_calculator", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    if 90<=score:\n        return 4.0\n    elif 85<=score:\n        return 3.6\n    elif 80<=score:\n        return 3.3\n    elif 75<=score:\n        return 3.0\n    elif 70<=score:\n        return 2.6\n    else:\n        return 2.3\n    \n\n", "annotation": "No annotation.", "output": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    return (90<=score).if_else(sfix(4.0),(85<=score).if_else(sfix(3.6),(80<=score).if_else(sfix(3.3),(75<=score).if_else(sfix(3.0),(70<=score).if_else(sfix(2.6),sfix(2.3))))))\n"}
{"test_name": "sign", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    if x==0:\n        return 0\n    else:\n        return 1 if x>0 else -1\n\n", "annotation": "No annotation.", "output": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    zero = x==0\n    ret = zero.if_else(sint(0),(x>0).if_else(sint(1),sint(-1)))\n    return ret\n"}
{"test_name": "sum_or_difference", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def sum_or_difference(a,b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    return a+b if a<=b else a-b\n\n", "annotation": "No annotation.", "output": "def sum_or_difference(a,b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    return (a<=b).if_else(a+b,a-b)\n"}
{"test_name": "CNOT", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit. \n    \"\"\"\n    return (not flip_bit) if control_bit else flip_bit\n\n", "annotation": "No annotation.", "output": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit. \n    \"\"\"\n    return control_bit.if_else(flip_bit.bit_not(),flip_bit)\n"}
{"test_name": "negative_plus1", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    return y+1 if y<0 else y\n\n", "annotation": "No annotation.", "output": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    return (y<0).if_else(y+1,y)\n"}
{"test_name": "is_a_parallelogram", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def is_a_parallelogram(a,b,c,d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x,y):\n        return x[0]==y[0] and x[1]==y[1]\n    if same(a,b) or same(a,c) or same(a,d) or same(b,c) or same(b,d) or same(c,d):\n        return False\n    return (a[0]+b[0]==c[0]+d[0] and  a[1]+b[1]==c[1]+d[1]) or (a[0]+c[0]==b[0]+d[0] and  a[1]+c[1]==b[1]+d[1]) or (a[0]+d[0]==b[0]+c[0] and  a[1]+d[1]==b[1]+c[1])\n\n", "annotation": "No annotation.", "output": "def is_a_parallelogram(a,b,c,d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x,y):\n        return (x[0]==y[0]).bit_and(x[1]==y[1])\n    same_predicate = same(a,b).bit_or(same(a,c)).bit_or(same(a,d)).bit_or(same(b,c)).bit_or(same(b,d)).bit_or(same(c,d))\n    return ((a[0]+b[0]==c[0]+d[0]).bit_and(a[1]+b[1]==c[1]+d[1])).bit_or((a[0]+c[0]==b[0]+d[0]).bit_and(a[1]+c[1]==b[1]+d[1])).bit_or((a[0]+d[0]==b[0]+c[0]).bit_and(a[1]+d[1]==b[1]+c[1])).bit_and(same_predicate.bit_not())\n"}
{"test_name": "min", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def min(a,b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    if a<=b:\n        return a\n    else:\n        return b\n\n", "annotation": "No annotation.", "output": "def min(a,b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    return (a<=b).if_else(a,b)\n"}
{"test_name": "choice_of_the_knight", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def choice_of_the_knight(x,y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = 0\n    def legal(a,b):\n        return 0<=a<=7 and 0<=b<=7\n    counter = counter+1 if legal(x+1,y+2) else counter\n    counter = counter+1 if legal(x-1,y+2) else counter\n    counter = counter+1 if legal(x+1,y-2) else counter\n    counter = counter+1 if legal(x-1,y-2) else counter\n    counter = counter+1 if legal(x+2,y+1) else counter\n    counter = counter+1 if legal(x-2,y+1) else counter\n    counter = counter+1 if legal(x+2,y-1) else counter\n    counter = counter+1 if legal(x-2,y-1) else counter\n    return counter\n\n", "annotation": "No annotation.", "output": "def choice_of_the_knight(x,y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x,y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = sint(0)\n    def legal(a,b):\n        return (0<=a).bit_and(a<=7).bit_and(0<=b).bit_and(b<=7)\n    counter = legal(x+1,y+2).if_else(counter+1,counter)\n    counter = legal(x-1,y+2).if_else(counter+1,counter)\n    counter = legal(x+1,y-2).if_else(counter+1,counter)\n    counter = legal(x-1,y-2).if_else(counter+1,counter)\n    counter = legal(x+2,y+1).if_else(counter+1,counter)\n    counter = legal(x-2,y+1).if_else(counter+1,counter)\n    counter = legal(x+2,y-1).if_else(counter+1,counter)\n    counter = legal(x-2,y-1).if_else(counter+1,counter)\n    return counter\n"}
{"test_name": "max_sum_difference", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def max_sum_different(a,b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    if a+b > a-b:\n        return a+b\n    return a-b\n\n", "annotation": "No annotation.", "output": "def max_sum_different(a,b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    return (a+b>a-b).if_else(a+b,a-b)\n"}
