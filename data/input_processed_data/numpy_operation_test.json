{"test_name": "array_from_intrinsic_linspace", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\nstart = 0\nend = 99\nnum = 10\na = np.linspace(start, end, num)\n\n", "annotation": "Create an evenly-distributed 1-dim array with length num, start value `start` and end value `end`.\n\n", "output": "start = 0\nend = 99\nnum = 10\nstep = (end - start) // (num-1)\na = sint.Array(num)\n@for_range(num)\ndef _(i):\n    a[i] = sint(start+i*step)\n\n"}
{"test_name": "more_positive", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    import numpy as np\n    signs = np.sign(arr)\n    count = sum(signs)\n    return count>0\n\n", "annotation": "Return whether there are more positive numbers in the given 1D array.\n\n", "output": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    arr_vec = arr.get_vector()\n    signs = (arr_vec>0).if_else(1,(arr_vec<0).if_else(-1,0))\n    count = sum(signs)\n    return count>0\n"}
{"test_name": "select", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def select(ind,a,b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    import numpy as np\n    return np.where(ind, a, b)\n\n", "annotation": "No annotation.", "output": "def select(ind,a,b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    ret = sfix.Array(len(ind))\n    ind_vec = ind.get_vector()\n    a_vec = a.get_vector()\n    b_vec = b.get_vector()\n    ret_vec = ret.get_vector()\n    ret_vec = ind_vec.if_else(a_vec,b_vec)\n    ret.assign_vector(ret_vec)\n    return ret\n\n"}
{"test_name": "np_relu", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    import numpy as np\n    return np.clip(y, 0, np.inf)\n\n", "annotation": "No annotation.", "output": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    ret = sfix.Tensor(y.shape)\n    ret_vec = ret.get_vector()\n    y_vec = y.get_vector()\n    ret_vec = (y_vec>0).if_else(y_vec,0)\n    ret.assign_vector(ret_vec)\n    return ret\n\n"}
{"test_name": "cost_matrix", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    import numpy as np\n    matrix_shape = profit_matrix.shape\n    offset_matrix = np.ones(matrix_shape) * profit_matrix.max()\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n\n", "annotation": "No annotation.", "output": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    matrix_shape = profit_matrix.shape\n    offset_matrix = sfix.Tensor(matrix_shape)\n    max_ = profit_matrix[0][0]\n    @for_range(matrix_shape[0])\n    def _(i):\n        @for_range(matrix_shape[1])\n        def _(j):\n            max_.update((profit_matrix[i][j]>max_).if_else(profit_matrix[i][j],max_))\n    offset_matrix.assign_all(max_)\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n\n"}
{"test_name": "np_zeros", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "\"\"\"Create 1-dim all-zero array with length 10.\"\"\"\nn = 10\na = np.zeros(n)\n\n", "annotation": "No annotation.", "output": "n = 10\na = sint.Array(n)\n"}
{"test_name": "np_basic_dimensional_row_indexing", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index][:]\n    return array\n\n", "annotation": "Function to index i-th row from 2-D arrays.\n\n", "output": "def array_dimensional_indexing(spdzArray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D spdz arrays.\n    \"\"\"\n    row, column = spdzArray.sizes\n    array = sint.Array(column)\n    @for_range(column)\n    def _(i):\n        array[i] = spdzArray.get_column(i)[row_index]\n    return array\n"}
{"test_name": "np_zeros_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "# plain text variables: n\ndef zeros(n):\n    import numpy as np\n    return np.zeros(n)\n\n", "annotation": "Create 1-dim all-zero array with length n.\n\n", "output": "def zeros(n):\n    return Array(n, sint)\n"}
{"test_name": "np_basic_slicing_stride", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatnate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    viewA = ndarrayA[::2]\n    viewB = ndarrayB[1:][::2]\n    array = np.concatenate((viewA,viewB)).copy()\n    return array\n\n", "annotation": "No annotation.", "output": "def array_concate(spdzArrayA, spdzArrayB):\n    \"\"\"\n    MP-SPDZ program to concatnate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    vectorA = spdzArrayA[::2]\n    vectorB = spdzArrayB[1:][::2]\n    arrayA = Array.create_from(vectorA)\n    arrayB = Array.create_from(vectorB)\n    array = arrayA.concat(arrayB)\n    return array\n"}
{"test_name": "QR_decomposition", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    import numpy as np\n    q, _ = np.linalg.qr(mat)\n    return q\n\n", "annotation": "No annotation.", "output": "# How to write QR-decomposition under mp-spdz framework?\n\n"}
{"test_name": "find_nearest_index", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    import numpy as np\n    idx = (np.abs(array-value)).argmin()\n    return idx\n\n", "annotation": "No annotation.", "output": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    distance = abs(value-array[0])\n    idx = sint(0)\n    @for_range(len(array))\n    def _(i):\n        new_distance = abs(array[i]-value)\n        smaller = new_distance < distance\n        distance.update(smaller.if_else(new_distance,distance))\n        idx.update(smaller.if_else(i,idx))\n    return idx\n\n"}
{"test_name": "np_concat_simple_row", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatnate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    array = np.concatenate((ndarrayA, ndarrayB), axis=0).copy()\n    return array\n\n", "annotation": "No annotation.", "output": "def array_simple_concate_rows(spdzArrayA, spdzArrayB):\n    \"\"\"\n    MP-SPDZ program to concatnate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    spdzArrayA_t = spdzArrayA.transpose()\n    spdzArrayB_t = spdzArrayB.transpose()\n    array_t = spdzArrayA_t.concat_columns(spdzArrayB_t)\n    array = array_t.transpose()\n    return array\n"}
{"test_name": "np_copy", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def array_copy(ndarray):\n    array = ndarray.copy()\n    return array\n\n", "annotation": "Return the copied version of the input array.\n\n", "output": "def array_copy(spdzarray):\n    \"\"\"\n    copy an array and return a new array.\n    \"\"\"\n    array = spdzarray.get_part(base=0, size=len(spdzarray))\n    return array\n"}
{"test_name": "max_pooling", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "# plain text variables: stride\nimport numpy as np\ndef max_pooling(x,stride):\n    \"\"\"\n    Compute the max-max_pooling.\n    \"\"\"\n    out = np.zeros([x.shape[0], x.shape[1]/stride, x.shape[2]/stride])\n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                out[b, i / stride, j / stride] = np.max(x[b, i:i+stride, j:j+stride])\n    return out\n\n", "annotation": "No annotation.", "output": "def max_pooling(x,stride):\n    \"\"\"\n    Compute the max-max_pooling.\n    \"\"\"\n    out = sfix.Tensor([x.shape[0], x.shape[1]//stride, x.shape[2]//stride])\n    @for_range_opt(x.shape[0])\n    def _(b):\n        @for_range_opt(0,x.shape[1],stride)\n        def _(i):\n            @for_range_opt(0, x.shape[2], stride)\n            def _(j):\n                max_ = x[b][i][j]\n                @for_range_opt(i,i+stride)\n                def _(p):\n                    @for_range_opt(j,j+stride)\n                    def _(q):\n                        max_.update(max_.max(x[b][p][q]))\n                out[b][i//stride][j//stride] = max_\n    return out\n\n"}
{"test_name": "array_reshape", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\na = np.arange(15).reshape(3,5)\n\n", "annotation": "Creating an 3-by-5 array with elements from 0 to 14.\n\n", "output": "a = MultiArray([3,5],sint)\n@for_range(3)\ndef _(i):\n    @for_range(5)\n    def _(j):\n        a[i][j] = sint(i*5+j)\n"}
{"test_name": "np_concat_simple_column", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatnate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    array = np.concatenate((ndarrayA, ndarrayB), axis=1).copy()\n    return array\n\n", "annotation": "No annotation.", "output": "def array_simple_concate_column(spdzArrayA, spdzArrayB):\n    \"\"\"\n    MP-SPDZ program to concatnate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    array =spdzArrayA.concat_columns(spdzArrayB)\n    return array\n"}
{"test_name": "np_basic_dimensional_column_indexing", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    NumPy program to index i-th column from 2-D arrays.\n    \"\"\"\n    array = ndarray[:][column_index]\n    return array\n\n", "annotation": "Function to index i-th column from 2-D arrays.\n\n", "output": "def array_dimensional_indexing(spdzArray, column_index):\n    \"\"\"\n    MP-SPDZ program to index i-th column from 2-D spdz arrays.\n    \"\"\"\n    vector = spdzArray.get_column(column_index)\n    array = Array.create_from(vector)\n    return array\n"}
{"test_name": "np_diagonal", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def diag(array):\n    import numpy as np\n    diag = np.diagonal(array)\n    return diag\n\n", "annotation": "Obtain the diagonal elements in a multiarray or matrix.\nThe input is a matrix and the output should be an array.\n\n", "output": "def diag(array):\n    diag = array.diag()\n    return diag\n"}
{"test_name": "np_concat_special", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatnate elements from two 2-D arrays along axis 1. Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    viewA = ndarrayA[:][::2]\n    viewB = ndarrayB[:][1:][::2]\n    array = np.concatenate((viewA,viewB), axis=1).copy()\n    return array\n\n", "annotation": "No annotation.", "output": "def array_special_concate(spdzArrayA, spdzArrayB):\n    \"\"\"\n    MP-SPDZ program to concatnate elements from two 2-D arrays along axis 1. Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    rowA, colA = spdzArrayA.sizes\n    rowB, colB = spdzArrayB.sizes\n\n    concat_array = spdzArrayA.concat_columns(spdzArrayB)\n    idx_a = [i for i in range(0, colA, 2)]\n    idx_b = [i+colA for i in range(1, colB, 2)]\n    idx_list = idx_a + idx_b\n    idx_list = [regint(e) for e in idx_list]\n    idx_array = Array.create_from(idx_list)\n    array = sfix.Matrix(rowA, len(idx_list))\n\n    @for_range(len(idx_list))\n    def _(i):\n        idx = idx_array[i]\n        vec = concat_array.get_vector_by_indices(None, idx)\n        array.assign_vector_by_indices(vec, None,i)\n\n    return array\n"}
{"test_name": "np_arange", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "# plain text variables: start, stop, step\ndef arange(start, stop=None, step=1):\n    \"\"\"\n    create a 1-d numpy array by calling intrinsic numpy function numpy.arange\n    \"\"\"\n    if stop is None :\n        stop = start\n        start = 0\n\n    import numpy as np\n    array = np.arange(start, stop, step)\n    return array\n\n", "annotation": "No annotation.", "output": "def arange(start, stop=None, step=1): # cint or cfix\n    \"\"\"\n    create a 1-d Array\n    \"\"\"\n    import math\n    if stop is None :\n        stop = start\n        start = 0\n    alist = [cfix(start+step*i) for i in range(round(math.ceil(stop-start)/step))]\n    array = Array.create_from(alist)\n\n    return array\n"}
{"test_name": "np_eye_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "\"\"\"Create a non-square 2-dim array with all one in diagonal.\"\"\"\nm = 3\nn = 5\na = np.eyes(m,n)\n\n", "annotation": "No annotation.", "output": "m = 3\nn = 5\nk = min(m,n)\na = sint.Tensor([m,n]) # a = MultiArray([m,n], sint)\n@for_range(k)\ndef _(i):\n    a[i][i] = sint(1)\n"}
{"test_name": "third_smallest", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    import numpy as np\n    sorted = np.sort(arr)\n    return sorted[2]\n\n", "annotation": "No annotation.", "output": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    brr = sint.Array(len(arr))\n    @for_range(len(arr))\n    def _(i):\n        brr[i] = arr[i]\n    brr.sort()\n    return brr[2]\n\n"}
{"test_name": "np_basic_dimensional_row_indexing_3", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index, ...]\n    return array\n\n", "annotation": "Function to index i-th row from 2-D arrays.\n\n", "output": "def array_dimensional_indexing(spdzArray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D spdz arrays.\n    \"\"\"\n    row, column = spdzArray.sizes\n    array = sint.Array(column)\n    @for_range(column)\n    def _(i):\n        array[i] = spdzArray.get_column(i)[row_index]\n    return array\n"}
{"test_name": "array_from_intrinsic_arange", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\nn = 10\na = np.arange(n)\n\n", "annotation": "Create 1-dim ascending array with length n.\n\n", "output": "n = 10\na = sint.Array(n)\n@for_range(n)\ndef _(i):\n    a[i] = sint(i)\n\n"}
{"test_name": "np_basic_dimensional_row_indexing_2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index, :]\n    return array\n    \n", "annotation": "Function to index i-th row from 2-D arrays.\n\n", "output": "def array_dimensional_indexing(spdzArray, row_index):\n    \"\"\"\n    MP-SPDZ program to index i-th row from 2-D spdz arrays.\n    \"\"\"\n    row, column = spdzArray.sizes\n    array = sint.Array(column)\n    @for_range(column)\n    def _(i):\n        array[i] = spdzArray.get_column(i)[row_index]\n    return array\n"}
{"test_name": "array_from_python_structure", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "\"\"\"Create 1-dim array with length 5 by converting from python built-in strcutures.\"\"\"\na_l = [0,10,20,30,40]\na = np.array(a_l)\n\n", "annotation": "No annotation.", "output": "a_l = sint([0,10,20,30,40])\na = Array.create_from(a_l)\n\n"}
{"test_name": "np_reshape", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    NumPy program to reshape a numpy array.\n    \"\"\"\n    array = ndarray.reshape(m,n)\n    return array\n\n", "annotation": "No annotation.", "output": "def array_reshape(spdzArray, m, n):\n    \"\"\"\n    MP-SPDZ program to reshape a spdz Array.\n    \"\"\"\n    vector = spdzArray[:]\n    array = sfix.Tensor([m,n])\n    array.assign(vector)\n    return array\n"}
{"test_name": "np_ones", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "\"\"\"Create 1-dim all-one array with length 10.\"\"\"\nn = 10\na = np.ones(10)\n\n", "annotation": "No annotation.", "output": "n = 10\na = Array(n, sint)\na.assign_all(1)\n"}
{"test_name": "set_one_to_zero", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    y[y==1] = 0\n    return y\n\n", "annotation": "Set the 1's in the array into 0's.\n\n", "output": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    y_vec = y.get_vector()\n    y_vec = (y_vec==1).if_else(0,y_vec)\n    y.assign_vector(y_vec)\n    return y\n\n"}
{"test_name": "np_eye", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "\"\"\"Create a square 2-dim array with all one in diagonal.\"\"\"\nn = 10\na = np.eyes(10)\n\n", "annotation": "No annotation.", "output": "n = 10\na = MultiArray([n,n], sint) # a = sint.Tensor([n,n])\n@for_range(n)\ndef _(i):\n    a[i][i] = sint(1)\n"}
{"test_name": "np_diag", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "a_l = [1,3,5,2,4,6]\na = np.diag(a_l)\n\n", "annotation": "Create a square 2D diagonal array from a list.\n\n", "output": "a_l = [1,3,5,2,4,6]\n\nsa_l = Array.create_from(sint(a_l))\nn = len(a_l)\na = sint.Tensor([n,n])\n@for_range(n)\ndef _(i):\n    a[i][i] = sint(sa_l[i])\n"}
{"test_name": "np_advanced_integer_indexing", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "# plain text variables: indices\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    indexing a numpy array from an integer array.\n    \"\"\"\n    import numpy as np\n    indices = np.array(indices)\n    ret_array = array(indices)\n    return ret_array\n\n", "annotation": "Indexing an array from an integer array.\nThe return value should be a subarray obtained from the original array by the indices.\n\n", "output": "def integer_array_indexing(spdzarray, indices):\n    \"\"\"\n    indexing an array from an integer array.\n    \"\"\"\n    indices = regint.Array(len(indices)).assign(indices)\n    vector = spdzarray.get(indices)\n    array = spdzarray.get_part(base=0, size=len(indices)).assign(vector)\n    return array\n"}
