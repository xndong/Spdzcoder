{"test_name": "cross_entropy_loss", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss.\n    \"\"\"\n    import numpy as np\n    return -np.sum(y * np.log(y))\n\n", "annotation": "\n\n", "output": "def cross_entropy(y):\n    \"\"\"\n    Compute the cross-entropy loss.\n    \"\"\"\n    import math\n    from Compiler import mpc_math\n    y_vec = y.get_vector()\n    return -sum(y_vec*mpc_math.log_fx(y_vec,math.e))\n\n"}
{"test_name": "np_ufunc_square_sqrt", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_RMSD(array):\n    \"\"\"This function calculate the root mean square deviation.\"\"\"\n    mean = np.mean(array)\n    deviation = array - mean\n    square = np.square(deviation)\n    square_mean = np.mean(square)\n    rmsd = np.sqrt(square_mean)\n    return rmsd\n\n", "annotation": "No annotation.", "output": "import math\nfrom Compiler import mpc_math\nimport operator\nfrom functools import reduce\ndef compute_RMSD(spdzArray):\n    mean = reduce(operator.add, spdzArray.get_vector()) / len(spdzArray)\n    deviation = spdzArray.get_vector() - mean\n    square = deviation.square()\n    square_mean = reduce(operator.add, square) / len(square)\n    rmsd = mpc_math.sqrt(square_mean)\n    return rmsd\n\n"}
{"test_name": "logsumexp", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp\n    \"\"\"\n    _max = np.max(log_probs)\n    ds = log_probs - _max\n    exp_sum = np.exp(ds).sum()\n    return _max + np.log(exp_sum)\n\n", "annotation": "The parameter `log_probs` of the function has the type of 1D array.\nThe function `np.exp` computes the exponential function with base e (2.71828).\nThe function `np.log` computes the natural logarithm with base e (2.71828).\nThe return value of `logsumexp` should be a scalar.\n\n", "output": "def logsumexp(log_probs):\n    \"\"\"\n    Compute the logsumexp\n    \"\"\"\n    import math\n    from Compiler import mpc_math\n    log_probs_vec = log_probs.get_vector()\n    _max = log_probs[0]\n    @for_range(len(log_probs))\n    def _(i):\n        _max.update((log_probs[i]>_max).if_else(log_probs[i],_max))\n    ds = log_probs_vec - _max\n    exp_sum = sum(mpc_math.pow_fx(math.e,ds))\n    return _max + mpc_math.log_fx(exp_sum,math.e)\n\n"}
{"test_name": "binary_cross_entropy_loss", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss.\n    \"\"\"\n    import numpy as np\n    y_hat[y_hat == 0] = 0.001\n    y_hat[y_hat == 1] = 1 - 0.001\n    loss = -np.mean(y*np.log2(y_hat) + (1-y)*np.log2(1 - y_hat))\n    return loss\n\n", "annotation": "No annotation.", "output": "def binary_cross_entropy(y_hat, y):\n    \"\"\"\n    Compute the binary cross-entropy loss.\n    \"\"\"\n    from Compiler import mpc_math\n    y_hat_vec = y_hat.get_vector()\n    y_vec = y.get_vector()\n    y_hat_vec = (y_hat_vec==0).if_else(sfix(0.001),y_hat_vec)\n    y_hat_vec = (y_hat_vec==1).if_else(1-sfix(0.001),y_hat_vec)\n    y_vec = y_vec*mpc_math.log2_fx(y_hat_vec) + (1-y_vec)*mpc_math.log2_fx(1-y_hat_vec)\n    loss = -sum(y_vec)/len(y_vec)\n    return loss\n\n"}
{"test_name": "np_ufunc_less_equal", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_less_equal(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is less than or equal to arrayB.\"\"\"\n    less_eq = numpy.less_equal(arrayA, arrayB)\n    return less_eq\n\n", "annotation": "No annotation.", "output": "def compute_less_equal(spdzarrayA, spdzarrayB):\n    vector_a = spdzarrayA.get_vector()\n    vector_b = spdzarrayB.get_vector()\n    less_eq = vector_a <= vector_b\n    less_eq = Array.create_from(less_eq)\n    return less_eq\n"}
{"test_name": "RMS_prop_step", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step.\n    \"\"\"\n    alpha = 0.5\n    beta = 1.0\n    s = [np.zeros_like(grad) for grad in grads]\n    for i, (grad, layer) in enumerate(zip(grads, layers)):\n        s[i] = beta*s[i] + (1-beta)*grad**2\n        grad = alpha * (grad/(np.sqrt(s[i])))\n        layer = layer+grad\n    return layers\n\n", "annotation": "No annotation.", "output": "def RMS_prop_step(grads, layers):\n    \"\"\"\n    Root mean square propagation step.\n    \"\"\"\n    from Compiler import mpc_math\n\n    alpha = sfix(0.5)\n    beta = sfix(1.0)\n    s = [sfix.Tensor(grad.shape) for grad in grads]\n    for i, (grad, layer) in enumerate(zip(grads, layers)):\n        s_vec = s[i].get_vector()\n        grad_vec = grad.get_vector()\n        layer_vec = layer.get_vector()\n        s_vec = beta*s_vec + (1-beta)*grad_vec**2\n        grad_vec = alpha * (grad_vec/mpc_math.sqrt(s_vec))\n        layer_vec = layer_vec+grad_vec\n        layer.assign_vector(layer_vec)\n    return layers\n\n"}
{"test_name": "entropy", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def entropy(y):\n    \"\"\"\n    Compute the entropy of the given array\n    \"\"\"\n    import numpy as np\n    import math\n    n = len(y)\n    sum_ = 0\n    for i in np.unique(y):\n        v = len(y[y==i])\n        sum_ += -((v/n) * math.log2(v/n))\n    return sum_\n\n", "annotation": "No annotation.", "output": "def entropy(y):\n    \"\"\"\n    Compute the entropy of the given array\n    \"\"\"\n    from Compiler import mpc_math\n    n = len(y)\n    sum_ = sfix(0)\n    @for_range(len(y))\n    def _(i):\n        exist = sint(0)\n        @for_range(i)\n        def _(j):\n            exist.update(exist.bit_or(y[j]==y[i]))\n        count = sfix(0)\n        @for_range(len(y))\n        def _(j):\n            count.update((y[j]==y[i]).if_else(count+1,count))\n        sum_.update(exist.if_else(sum_, sum_-count/n*mpc_math.log2_fx(count/n)))\n    return sum_\n\n"}
{"test_name": "np_ufunc_exp", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_softmax(array):\n    \"\"\"This function computes the softmax values in a 1-D numpy array.\"\"\"\n    exp = numpy.exp(array)\n    summation = numpy.add.reduce(exp)\n    softmax = exp / summation\n    return softmax\n\n", "annotation": "No annotation.", "output": "import math\nfrom Compiler import mpc_math\nimport operator\nfrom functools import reduce\ndef compute_softmax(spdzarray):\n    exp = mpc_math.pow_fx(math.e, spdzarray.get_vector())\n    summation = reduce(operator.add, exp)\n    softmax_vector = exp / summation\n    softmax = Array.create_from(softmax_vector)\n    return softmax\n\n"}
{"test_name": "tanh", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\nclass Tanh():\n\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        return np.tanh(z)\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        return 1 - np.tanh(x) ** 2\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\nclass Tanh():\n    def tanh(self, x):\n        \"\"\"\n        Compute the tanh function\n        \"\"\"\n        import math\n        plus = mpc_math.pow_fx(math.e,x)\n        minus = mpc_math.pow_fx(math.e,-x)\n        return (plus-minus)/(plus+minus)\n\n    def fn(self, z):\n        \"\"\"\n        Compute the tanh function on the elements of input `z`.\n        \"\"\"\n        ret = sfix.Array(len(z))\n        z_vec = z.get_vector()\n        ret_vec = ret.get_vector()\n        ret_vec = self.tanh(z_vec)\n        ret.assign_vector(ret_vec)\n        return ret\n\n    def grad(self, x):\n        \"\"\"\n        Evaluate the first derivative of the tanh function on the elements of input `x`.\n        \"\"\"\n        ret = sfix.Array(len(x))\n        x_vec = x.get_vector()\n        ret_vec = ret.get_vector()\n        ret_vec = 1 - self.tanh(x)**2\n        ret.assign_vector(ret_vec)\n        return ret\n\n"}
{"test_name": "np_ufunc_tan", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_tan(array):\n    \"\"\"This function calculate trigonometric tangent, element-wise.\"\"\"\n    tan_res = numpy.tan(array)\n    return tan_res\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef compute_tan(spdzarray):            # sfix\n    vector = spdzarray.get_vector()\n    tan_res = mpc_math.tan(vector)\n    tan_res = Array.create_from(tan_res)\n    return tan_res\n"}
{"test_name": "np_ufunc_greater", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_greater(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is greater than arrayB.\"\"\"\n    greater_res = numpy.greater(arrayA, arrayB)\n    return greater_res\n\n", "annotation": "No annotation.", "output": "def compute_greater(spdzarrayA, spdzarrayB):\n    vector_a = spdzarrayA.get_vector()\n    vector_b = spdzarrayB.get_vector()\n    greater_res = vector_a > vector_b\n    greater_res = Array.create_from(greater_res)\n    return greater_res\n"}
{"test_name": "np_ufunc_maximum", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_maximum(arrayA, arrayB):\n    \"\"\"Element-wise maximum of array elements.\"\"\"\n    max_ones = numpy.maximum(arrayA, arrayB)\n    return max_ones\n\n", "annotation": "No annotation.", "output": "def compute_maximum(spdzarrayA, spdzarrayB):\n    vector_a = spdzarrayA.get_vector()\n    vector_b = spdzarrayB.get_vector()\n    max_ones = (vector_a > vector_b).if_else(vector_a, vector_b)\n    max_ones = Array.create_from(max_ones)\n    return max_ones\n"}
{"test_name": "np_ufunc_log2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_log2(array):\n    \"\"\"This function calculate base-2 logarithm of x in the input array.\"\"\"\n    log2 = numpy.log2(array)\n    return log2\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef compute_log2(spdzarray):\n    log2 = mpc_math.log2_fx(spdzarray.get_vector())\n    log2 = Array.create_from(log2)\n    return log2\n\n"}
{"test_name": "np_ufunc_absolute", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef obtain_absolute(array):\n    \"\"\"This function computes the absolute values in a numpy array.\"\"\"\n    array = numpy.absolute(array)\n    return array\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef obtain_absolute(spdzarray):\n    abs_res = abs(spdzarray.get_vector())\n    array = Array.create_from(abs_res)\n    return array\n\n"}
{"test_name": "np_ufunc_arctan", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_arctan(array):\n    \"\"\"This function calculate trigonometric inverse tangent, element-wise.\"\"\"\n    arctan_res = numpy.arctan(array)\n    return arctan_res\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef compute_arctan(spdzarray):            # sfix\n    vector = spdzarray.get_vector()\n    arctan_res = mpc_math.atan(vector)\n    arctan_res = Array.create_from(arctan_res)\n    return arctan_res\n"}
{"test_name": "np_ufunc_log", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_log(array):\n    \"\"\"This function calculate natural logarithm for all p in the input array.\"\"\"\n    nlog = numpy.log(array)\n    return nlog\n\n", "annotation": "No annotation.", "output": "import math\nfrom Compiler import mpc_math\ndef compute_log(spdzarray):\n    nlog = mpc_math.log_fx(spdzarray.get_vector(), math.e)\n    nlog = Array.create_from(nlog)\n    return nlog\n\n"}
{"test_name": "np_ufunc_not_equal", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_not_equal(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is not equal to arrayB.\"\"\"\n    neq = numpy.not_equal(arrayA, arrayB)\n    return neq\n\n", "annotation": "No annotation.", "output": "def compute_not_equal(spdzarrayA, spdzarrayB):\n    vector_a = spdzarrayA.get_vector()\n    vector_b = spdzarrayB.get_vector()\n    neq = vector_a != vector_b\n    neq = Array.create_from(neq)\n    return neq\n"}
{"test_name": "np_ufunc_equal", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_equal(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is equal to arrayB.\"\"\"\n    eq = numpy.equal(arrayA, arrayB)\n    return eq\n\n", "annotation": "No annotation.", "output": "def compute_equal(spdzarrayA, spdzarrayB):\n    vector_a = spdzarrayA.get_vector()\n    vector_b = spdzarrayB.get_vector()\n    eq = vector_a == vector_b\n    eq = Array.create_from(eq)\n    return eq\n"}
{"test_name": "np_ufunc_true_divide", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef true_divide(arrayA, arrayB):\n    \"\"\"true divide between two numpy 1-d arrays.\"\"\"\n    array = numpy.true_divide(arrayA, arrayB)\n    return array\n\n", "annotation": "No annotation.", "output": "def true_divide(spdzarrayA, spdzarrayB):\n    \"\"\"true divide between two numpy 1-d arrays.\"\"\"\n    res = spdzarrayA.get_vector() / spdzarrayB.get_vector()\n    array = Array.create_from(res)\n    return array\n"}
{"test_name": "np_ufunc_greater_equal", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_greater_equal(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is greater than or equal to arrayB.\"\"\"\n    greater_eq = numpy.greater_equal(arrayA, arrayB)\n    return greater_eq\n\n", "annotation": "No annotation.", "output": "def compute_greater_equal(spdzarrayA, spdzarrayB):\n    vector_a = spdzarrayA.get_vector()\n    vector_b = spdzarrayB.get_vector()\n    greater_eq = vector_a >= vector_b\n    greater_eq = Array.create_from(greater_eq)\n    return greater_eq\n"}
{"test_name": "np_ufunc_negative", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef negative(arrayA):\n    \"\"\"This function essentially returns a copy of the input array with all its elements being inverse number.\"\"\"\n    array = -arrayA\n    return array\n\n", "annotation": "No annotation.", "output": "def negative(spdzarrayA):\n    array = Array.create_from(-1*spdzarrayA.get_vector())\n    return array\n\n"}
{"test_name": "np_ufunc_power", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef power(arrayA, arrayB):\n    \"\"\"This function computes the power of x^y one by one, where x and y are from two arrays.\"\"\"\n    array = numpy.power(arrayA, arrayB)\n    return array\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef power(spdzarrayA, spdzarrayB):\n    exponential_res = mpc_math.pow_fx(spdzarrayA.get_vector(), spdzarrayB.get_vector())\n    array = Array.create_from(exponential_res)\n    return array\n\n"}
{"test_name": "np_ufunc_exp2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_exp2(array):\n    \"\"\"This function calculate 2**p for all p in the input array.\"\"\"\n    exp = numpy.exp2(array)\n    return exp\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef compute_exp2(spdzarray):\n    exp = mpc_math.exp2_fx(spdzarray.get_vector())\n    exp = Array.create_from(exp)\n    return exp\n\n"}
{"test_name": "cross_entropy_loss_class", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\nclass CrossEntropy():\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss.\n        \"\"\"\n        cross_entropy = -np.sum(y * np.log2(y_pred))\n        return cross_entropy\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross entropy loss\n        \"\"\"\n        n = len(y)\n        grad = y_pred - y\n        grad /= n\n        return grad\n\n", "annotation": "`y` and `y_pred` are 1D arrays\n\n", "output": "class CrossEntropy():\n    def loss(self, y, y_pred):\n        \"\"\"\n        Compute the cross-entropy (log) loss.\n        \"\"\"\n        from Compiler import mpc_math\n        y_vec = y.get_vector()\n        y_pred_vec = y_pred.get_vector()\n        cross_entropy = -sum(y_vec*mpc_math.log2_fx(y_pred_vec))\n        return cross_entropy\n    def grad(self, y, y_pred):\n        \"\"\"\n        Compute the gradient of the cross entropy loss\n        \"\"\"\n        n = len(y)\n        grad = y_pred - y\n        grad /= n\n        return grad\n\n"}
{"test_name": "np_ufunc_arccos", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_arccos(array):\n    \"\"\"This function calculate trigonometric inverse cosine, element-wise.\"\"\"\n    arccos_res = numpy.arccos(array)\n    return arccos_res\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef compute_arccos(spdzarray):\n    vector = spdzarray.get_vector()\n    arccos_res = mpc_math.acos(vector)\n    arccos_res = Array.create_from(arccos_res)\n    return arccos_res\n"}
{"test_name": "r2_score", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score.\n    \"\"\"\n    total_sum_squares = np.sum((y_test - np.mean(y_test))**2)\n    residual_sum_squares = np.sum((y_test - y_hat)**2)\n    return 1 - residual_sum_squares/total_sum_squares\n\n", "annotation": "No annotation.", "output": "def r2_score(y_hat, y_test):\n    \"\"\"\n    Compute the r2 score.\n    \"\"\"\n    y_hat_vec = y_hat.get_vector()\n    y_test_vec = y_test.get_vector()\n    avg = sum(y_test_vec)/len(y_test_vec)\n    total_sum_squares = sum((y_test_vec-avg)**2)\n    residual_sum_squares = sum((y_test_vec - y_hat_vec)**2)\n    return 1 - residual_sum_squares/total_sum_squares\n\n"}
{"test_name": "np_ufunc_arcsin", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_arcsin(array):\n    \"\"\"This function calculate trigonometric inverse sine, element-wise.\"\"\"\n    arcsin_res = numpy.arcsin(array)\n    return arcsin_res\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef compute_arcsin(spdzarray):            # sfix\n    vector = spdzarray.get_vector()\n    arcsin_res = mpc_math.asin(vector)\n    arcsin_res = Array.create_from(arcsin_res)\n    return arcsin_res\n"}
{"test_name": "np_ufunc_true_divide2", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef true_divide(arrayA, arrayB):\n    \"\"\"true divide between two numpy 1-d arrays.\"\"\"\n    res = [a / b for a,b in zip(arrayA, arrayB)]\n    array = numpy.array(res)\n    return array\n\n", "annotation": "No annotation.", "output": "def true_divide(spdzarrayA, spdzarrayB):\n    \"\"\"true divide between two numpy 1-d arrays.\"\"\"\n    res = [a / b for a, b in zip(spdzarrayA, spdzarrayB)]\n    array = Array.create_from(res)\n    return array\n\n"}
{"test_name": "square_error_loss", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def squre_error(y,y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    import numpy as np\n    return 0.5 * np.linalg.norm(y_pred - y) ** 2\n\n", "annotation": "No annotation.", "output": "def squre_error(y,y_pred):\n    \"\"\"\n    Compute the square error loss.\n    \"\"\"\n    import numpy as np\n    return 0.5 * sum((y-y_pred)**2)\n\n"}
{"test_name": "np_ufunc_less", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_less(arrayA, arrayB):\n    \"\"\"This function calculate the element-wise comparison, i.e. whether arrayA is less than arrayB.\"\"\"\n    less_res = numpy.less(arrayA, arrayB)\n    return less_res\n\n", "annotation": "No annotation.", "output": "def compute_less(spdzarrayA, spdzarrayB):\n    vector_a = spdzarrayA.get_vector()\n    vector_b = spdzarrayB.get_vector()\n    less_res = vector_a < vector_b\n    less_res = Array.create_from(less_res)\n    return less_res\n"}
{"test_name": "np_ufunc_cos", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_cosine(array):\n    \"\"\"This function calculate trigonometric cosine, element-wise.\"\"\"\n    cos_res = numpy.cos(array)\n    return cos_res\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef compute_cosine(spdzarray):            # sfix\n    vector = spdzarray.get_vector()\n    cos_res = mpc_math.cos(vector)\n    cos_res = Array.create_from(cos_res)\n    return cos_res\n"}
{"test_name": "np_ufunc_sin", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy\ndef compute_sine(array):\n    \"\"\"This function calculate trigonometric sine, element-wise.\"\"\"\n    sin_res = numpy.sin(array)\n    return sin_res\n\n", "annotation": "No annotation.", "output": "from Compiler import mpc_math\ndef compute_sine(spdzarray):            # sfix\n    vector = spdzarray.get_vector()\n    sin_res = mpc_math.sin(vector)\n    sin_res = Array.create_from(sin_res)\n    return sin_res\n"}
{"test_name": "update_weights", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "def update_weights(m,A,X,Y):\n    \"\"\"\n    Update the weights and return the difference.\n    \"\"\"\n    import numpy as np\n    dw=(1/m)*np.dot(X,(A-Y))\n    return dw\n\n", "annotation": "`A`, `X` and `Y` are all 2D matrices, and `m` is a constant scalar.\n\n", "output": "def update_weights(m,A,X,Y):\n    \"\"\"\n    Update the weights and return the difference.\n    \"\"\"\n    ret_matrix = X.dot(A-Y)\n    ret_vec = ret_matrix.get_vector()\n    ret_vec = (1/m)*ret_vec\n    ret_matrix.assign_vector(ret_vec)\n    return ret_matrix\n\n"}
{"test_name": "toy_layer", "instruction": "Translate the following code snippet from Python/Numpy to MP-SPDZ.", "input": "import numpy as np\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n    \ndef toy_layer(input_data, weights, biases):\n    layer1_input = np.dot(input_data, weights[0]) + biases[0]\n    layer1_output = sigmoid(layer1_input)\n    layer2_input = np.dot(layer1_output, weights[1]) + biases[1]\n    layer2_output = sigmoid(layer2_input)\n    return layer2_output\n\n", "annotation": "The input of function `sigmoid` is a 1D array. \nFor function `toy_layer`, the parameter `input_data` is a 1D array, `weights` and `biases` are two lists of 1D arrays with the same size as `input_data`.\nAfter translation, the 1D array should have type `sfix.Array`.\nThe function `np.exp` called in function `sigmoid` computes the exponential function with base e (2.71828).\n\n", "output": "def sigmoid(x):\n    import math\n    from Compiler import mpc_math\n    return 1/(1+mpc_math.pow_fx(math.e,-x))\n\ndef toy_layer(input_data, weights, biases):\n    def dot(a,b):\n        ret = sfix(0)\n        @for_range(len(a))\n        def _(i):\n            ret.iadd(a[i]*b[i])\n        return ret\n    layer1_input = Array.create_from(dot(input_data,weights[0])+biases[0])\n    layer1_output = Array.create_from(sigmoid(layer1_input))\n    layer2_input = Array.create_from(dot(layer1_output,weights[1])+biases[1])\n    layer2_output = Array.create_from(sigmoid(layer2_input))\n    return layer2_output\n\n"}
