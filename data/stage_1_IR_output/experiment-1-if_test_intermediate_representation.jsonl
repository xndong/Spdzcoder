{"test_name": "sin_or_cos", "response_0": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    import math\n    \n    # Initialize the result variable, but do not set it to a placeholder value.\n\n    # Create a condition variable that is 1 if x is nonnegative and 0 otherwise\n    condition = (x >= 0)\n    # In an oblivious form, we use the condition to select between sin(x) and cos(x)\n    result = condition * math.sin(x) + (1 - condition) * math.cos(x)\n\n    # Return the final result\n    return result\n", "prompt_token_0": 1876, "completion_token_0": 593, "response_1": "def sin_or_cos(x):\n    \"\"\"\n    If x is nonnegative, return sin(x), otherwise return cos(x).\n    \"\"\"\n    import math\n    # Initialize variable to hold result\n    result = None\n    \n    # Define the conditions obliviously\n    condition_nonnegative = x >= 0\n    condition_negative = not condition_nonnegative\n\n    # Compute both sin and cos values\n    sin_value = math.sin(x)\n    cos_value = math.cos(x)\n\n    # Obliviously choose between sin and cos\n    result = condition_nonnegative * sin_value + condition_negative * cos_value\n    \n    # Return the result variable, which now holds the correct value\n    return result\n", "prompt_token_1": 1878, "completion_token_1": 559}
{"test_name": "negative_relu", "response_0": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    # Initialize result with 0, which is the default return value when the condition is not met.\n    result = 0\n\n    # Check if the input is less than 0, and if so, update the result to be the input.\n    if input < 0:\n        result = input\n\n    # Return the result, which will either be the input if it was less than 0, or 0 otherwise.\n    return result\n", "prompt_token_0": 1892, "completion_token_0": 639, "response_1": "def negative_relu(input):\n    \"\"\"\n    Negative ReLU: if the input is less than 0, return the input, otherwise return 0.\n    \"\"\"\n    # Condition for input being less than 0\n    condition = (input < 0)\n\n    # The result is either the input itself if it's less than 0, or 0 otherwise.\n    # Multiplication by a condition acts as an if statement.\n    result = condition * input\n\n    # Return the result\n    return result\n", "prompt_token_1": 1887, "completion_token_1": 542}
{"test_name": "is_close", "response_0": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close: \n    their absolute difference is no larger than 1. \n    \"\"\"\n    return abs(a-b) <= 1\n", "prompt_token_0": 706, "completion_token_0": 231, "response_1": "def is_close(a, b):\n    \"\"\"\n    Return whether or not the two inputs are close: \n    their absolute difference is no larger than 1. \n    \"\"\"\n    return abs(a - b) <= 1\n", "prompt_token_1": 711, "completion_token_1": 238}
{"test_name": "hardswish", "response_0": "def hardswish(x):\n    \"\"\"\n    Hardswish function refactored into an oblivious form.\n    \"\"\"\n    # Initialize result with x for cases where none of the conditions apply directly.\n    result = x\n    \n    # We represent the conditions as binary values\n    condition_1 = (x < -3)                # The condition for `result = 0` is `x < -3`\n    condition_2 = (x >= -3) * (x <= 3)    # The condition for `result = x * (x + 3) / 6` is `-3 <= x <= 3`\n    condition_3 = (x > 3)                 # The condition for `result = x` is `x > 3`, which can be omitted as result is already initialized to x\n    \n    # The result is computed without using any if statements\n    result = condition_1 * 0 + condition_2 * (x * (x + 3) / 6) + condition_3 * result\n    \n    # Return the final result with only one single `return` statement.\n    return result\n    # The code is in an oblivious form since there is no `if` statement (no branch) in the code.\n", "prompt_token_0": 1931, "completion_token_0": 804, "response_1": "def hardswish(x):\n    \"\"\"\n    Hardswish function.\n    \"\"\"\n    \n    # Calculate conditions\n    condition_1 = (x < -3)    # The condition for `return 0` is `x < -3`\n    condition_2 = (x > 3)     # The condition for `return x` is `x > 3`\n    condition_3 = (x >= -3) * (x <= 3)  # The condition for `return x * (x + 3) / 6` is `-3 <= x <= 3`\n    \n    # Apply transformations based on conditions\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition_1 * 0 + condition_2 * x + condition_3 * (x * (x + 3) / 6) \n\n    # Return the computed result.\n    return result\n    # The code is in an oblivious form since there is no `if` statement (no branch) in the code.\n", "prompt_token_1": 1892, "completion_token_1": 630}
{"test_name": "clip_at_6", "response_0": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    # Initialize the result with the value of x\n    result = x\n\n    # Define conditions for clipping\n    condition_greater_than_6 = (x > 6)   # The condition for `result = 6` is `x > 6`\n    condition_less_than_minus_6 = (x < -6)  # The condition for `result = -6` is `x < -6`\n\n    # Oblivious assignments\n    # When condition is True, it multiplies the value (6 or -6) by 1, otherwise by 0.\n    result = condition_greater_than_6 * 6 + (1 - condition_greater_than_6) * (condition_less_than_minus_6 * -6 + (1 - condition_less_than_minus_6) * result)\n\n    # Return the result, which is either x, 6, or -6\n    return result\n", "prompt_token_0": 1937, "completion_token_0": 677, "response_1": "def clip_at_6(x):\n    \"\"\"\n    Return x, and clip the return value into the range [-6,6]\n    \"\"\"\n    # Initialize result with x for cases where -6 <= x <= 6\n    result = x\n\n    condition_1 = (x > 6)   # Condition for clipping at 6\n    condition_2 = (x < -6)  # Condition for clipping at -6\n\n    # Apply transformations based on conditions\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition_1 * 6 + (1 - condition_1) * (condition_2 * -6 + (1 - condition_2) * result)\n    \n    return result\n", "prompt_token_1": 1922, "completion_token_1": 581}
{"test_name": "piecewise_function", "response_0": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    condition_1 = (x > 1)       # Check if x is greater than 1\n    condition_2 = (x < -1)      # Check if x is less than -1\n    condition_3 = (x > 0)       # Check if x is greater than 0\n    condition_4 = (x < 0)       # Check if x is less than 0\n    condition_5 = (x == 0)      # Check if x is equal to 0\n\n    # Apply transformations based on conditions\n    ret = condition_1 * x + condition_2 * x + condition_3 * 1 + condition_4 * (-1) + condition_5 * 0\n\n    return ret\n    # The code is oblivious since there are no `if` statements (no branches) in the code.\n", "prompt_token_0": 1443, "completion_token_0": 561, "response_1": "def piecewise_function(x):\n    \"\"\"\n    A piecewise function. \n    \"\"\"\n    # Conditions for the piecewise function\n    condition_x_gt_1 = (x > 1)\n    condition_x_lt_minus_1 = (x < -1)\n    condition_x_gt_0 = (x > 0)\n    condition_x_lt_0 = (x < 0)\n    condition_x_eq_0 = (x == 0)\n    \n    # Oblivious computation of the function value based on conditions\n    ret = condition_x_gt_1 * x + \\\n          condition_x_lt_minus_1 * x + \\\n          condition_x_gt_0 * 1 + \\\n          condition_x_lt_0 * (-1) + \\\n          condition_x_eq_0 * 0\n          \n    return ret\n", "prompt_token_1": 1443, "completion_token_1": 524}
{"test_name": "middle", "response_0": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs. \n    \"\"\"\n    condition_1 = a >= b\n    condition_2 = b >= c\n    condition_3 = a >= b\n\n    # Swapping `a` and `b` if `a >= b`\n    a, b = condition_1 * b + (1 - condition_1) * a, condition_1 * a + (1 - condition_1) * b\n    \n    # Swapping `b` and `c` if `b >= c`\n    b, c = condition_2 * c + (1 - condition_2) * b, condition_2 * b + (1 - condition_2) * c\n\n    # Re-evaluate condition_3 after the first potential swap\n    condition_3 = a >= b\n    \n    # Swapping `a` and `b` again if `a >= b`\n    a, b = condition_3 * b + (1 - condition_3) * a, condition_3 * a + (1 - condition_3) * b\n\n    return b\n", "prompt_token_0": 1471, "completion_token_0": 606, "response_1": "def middle(a, b, c):\n    \"\"\"\n    Return the value in the middle among the three inputs.\n    \"\"\"\n    condition_a_ge_b = (a >= b)\n    condition_b_ge_c = (b >= c)\n    condition_a_ge_b_after = (a >= b)\n    \n    # Swap a and b if a is greater or equal to b\n    temp_a = a*condition_a_ge_b + b*(1-condition_a_ge_b)\n    temp_b = b*condition_a_ge_b + a*(1-condition_a_ge_b)\n    a, b = temp_a, temp_b\n    \n    # Swap b and c if b is greater or equal to c\n    temp_b = b*condition_b_ge_c + c*(1-condition_b_ge_c)\n    temp_c = c*condition_b_ge_c + b*(1-condition_b_ge_c)\n    b, c = temp_b, temp_c\n    \n    # Swap a and b if a is greater or equal to b after the first swap\n    temp_a = a*condition_a_ge_b_after + b*(1-condition_a_ge_b_after)\n    temp_b = b*condition_a_ge_b_after + a*(1-condition_a_ge_b_after)\n    a, b = temp_a, temp_b\n    \n    return b\n", "prompt_token_1": 1469, "completion_token_1": 632}
{"test_name": "indicated_sin_or_cos", "response_0": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    import math\n    # Initialize result with the cosine value, which is the default case when ind is False.\n    result = math.cos(x)\n\n    # Transform the condition into an oblivious form\n    condition = ind  # The condition is True if ind is True, False otherwise\n\n    # Apply transformations based on conditions\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition * math.sin(x) + (1 - condition) * math.cos(x)  # The result is an combination of sine and cosine based on the indicator\n\n    # Return the result, which will be either the sine or cosine of x.\n    return result\n    # The code is in an oblivious form since there is no `if` statement (no branch) in the code.\n", "prompt_token_0": 1942, "completion_token_0": 648, "response_1": "def indicated_sin_or_cos(x, ind):\n    \"\"\"\n    If the indicator is True, return the sine value of the input, \n    otherwise return the cosine value of the input. \n    \"\"\"\n    from math import sin, cos\n    # Calculate both sine and cosine values\n    sine_value = sin(x)\n    cosine_value = cos(x)\n    \n    # Convert the indicator to an integer if it isn't already\n    ind_int = int(ind)\n\n    # Use the indicator to construct the result obliviously\n    result = ind_int * sine_value + (1 - ind_int) * cosine_value\n    \n    return result\n    # The code is in an oblivious form since there is no `if` statement (no branch) in the code.\n", "prompt_token_1": 1940, "completion_token_1": 605}
{"test_name": "minus2_if_else", "response_0": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    # Compute the condition (x-2 >= 0) and store it as a 0/1 value\n    condition = (x - 2 >= 0)\n\n    # Compute the result as a combination of the original value and the adjusted value\n    result = condition * (x - 2) + (1 - condition) * x\n\n    # Return the final result\n    return result\n", "prompt_token_0": 1881, "completion_token_0": 596, "response_1": "def minus2_if_else(x):\n    \"\"\"\n    Return x-2 if x-2 is no less than 0, otherwise return x\n    \"\"\"\n    # Calculate the condition\n    condition = (x - 2 >= 0)\n\n    # Return x - 2 if condition is true, otherwise return x\n    result = condition * (x - 2) + (1 - condition) * x\n\n    return result\n", "prompt_token_1": 1868, "completion_token_1": 450}
{"test_name": "relu6", "response_0": "def relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    # Initialize the result with x; this will handle the case where 0 <= x <= 6\n    result = x\n    \n    # Define the conditions for the different cases\n    condition_1 = (x < 0)   # The condition for `result = 0` is `x < 0`\n    condition_2 = (x > 6)   # The condition for `result = 6` is `x > 6`\n    condition_3 = (x >= 0) * (x <= 6)  # The condition for `result = x` is `0 <= x <= 6`\n\n    # Apply transformations based on conditions\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition_1 * 0 + condition_2 * 6 + condition_3 * result\n\n    return result\n    # The code is in an oblivious form since there is no `if` statement (no branch) in the code.\n", "prompt_token_0": 1890, "completion_token_0": 675, "response_1": "def relu6(x):\n    \"\"\"\n    ReLU6 function.\n    \"\"\"\n    # Initialize the result with x for cases where 0 <= x <= 6\n    result = x\n\n    # Define the conditions for each case\n    condition_1 = (x < 0)  # The condition when the result should be 0\n    condition_2 = (x > 6)  # The condition when the result should be 6\n    condition_3 = (x >= 0) * (x <= 6)  # The condition when the result should be x\n\n    # Apply transformations based on conditions\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition_1 * 0 + condition_2 * 6 + condition_3 * result\n\n    # Return the result, which is either 0, 6, or the original x\n    return result\n", "prompt_token_1": 1864, "completion_token_1": 622}
{"test_name": "exp_slide", "response_0": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    import math\n\n    # Initialize result with the case where x is negative.\n    result = x + 1\n\n    # The condition for `return e^x` is `x>=0`, otherwise `return x+1`\n    condition = (x >= 0)\n\n    # Apply transformations based on conditions\n    result = condition * math.exp(x) + (1 - condition) * (x + 1)\n\n    # Return the final result.\n    return result\n", "prompt_token_0": 1872, "completion_token_0": 485, "response_1": "def exp_slide(x):\n    \"\"\"\n    If x is nonnegative, return e^x, otherwise x+1.\n    \"\"\"\n    from Compiler.library import exp\n\n    # Initialize result with x+1 for the case where x is negative\n    result = x + 1\n\n    # We use condition as a mask: 1 if the condition is true, 0 otherwise\n    condition = (x >= 0)\n\n    # If x is nonnegative, update the result to e^x\n    # Multiplying by condition will either give us exp(x) if true, or 0 if false\n    result = condition * exp(x) + (1 - condition) * (x + 1)\n\n    # Return the final result\n    return result\n", "prompt_token_1": 1878, "completion_token_1": 570}
{"test_name": "pass_or_not", "response_0": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    passed = score >= 60\n    score = passed * score + (1 - passed) * 59\n    return score, passed\n", "prompt_token_0": 1528, "completion_token_0": 584, "response_1": "def pass_or_not(score):\n    \"\"\"\n    You are a professor, and your student asks you whether she has passed the exam. \n    If she passed (score>=60), you should return her actual score and True (indicating that she has passed). \n    If she did not pass, you should return that her score is 59 and False. \n    \"\"\"\n    # Create conditions for passing or not\n    condition_passed = (score >= 60)\n    condition_failed = (score < 60)\n\n    # Calculate score and passed based on conditions\n    # Multiplication by a condition acts as an if statement\n    score = condition_passed * score + condition_failed * 59\n    passed = condition_passed * True + condition_failed * False\n\n    return score, passed\n", "prompt_token_1": 1533, "completion_token_1": 595}
{"test_name": "how_many_roots", "response_0": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n\n    # Initialize the number of roots with an impossible value\n    num_roots = -1\n\n    # Check the conditions and update the num_roots accordingly\n    if a == 0:\n        if b == 0:\n            num_roots = 0\n        else:\n            num_roots = 1\n    else:\n        discriminant = b*b - 4*a*c\n        if discriminant > 0:\n            num_roots = 2\n        elif discriminant == 0:\n            num_roots = 1\n        else:\n            num_roots = 0\n\n    # Return the number of roots\n    return num_roots\n", "prompt_token_0": 2292, "completion_token_0": 1007, "response_1": "def how_many_roots(a, b, c):\n    \"\"\"\n    Given coefficients a, b and c of a quadratic function, \n    return the number of its roots. \n    a, b and c can be zero, but they will not all be zero. \n    \"\"\"\n    # Initialize roots to 0 since it's the default for multiple cases.\n    roots = 0\n\n    # Define conditions\n    a_is_zero = (a == 0)\n    b_is_not_zero = (b != 0)\n    b_is_zero = (b == 0)\n\n    discriminant = b*b - 4*a*c\n    discriminant_greater_than_zero = (discriminant > 0)\n    discriminant_equal_zero = (discriminant == 0)\n    discriminant_less_than_zero = (discriminant < 0)\n\n    # Calculate roots without using if-statements\n    roots += a_is_zero * b_is_not_zero * 1\n    roots += (1 - a_is_zero) * discriminant_greater_than_zero * 2\n    roots += (1 - a_is_zero) * discriminant_equal_zero * 1\n    # If discriminant < 0, roots remain the same, so no need to add a term for that condition\n\n    # Return the number of roots which is either 0, 1, or 2.\n    return roots\n", "prompt_token_1": 2296, "completion_token_1": 1150}
{"test_name": "elu", "response_0": "def elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    import math\n    # Initialize the result variable to store the output\n    result = x  # By default, we assume x is positive and result is x\n\n    # Check if x is not greater than 0, then compute the ELU value\n    if not x > 0:\n        result = math.exp(x) - 1\n\n    # Return the computed result\n    return result\n", "prompt_token_0": 1846, "completion_token_0": 578, "response_1": "def elu(x):\n    \"\"\"\n    ELU function\n    \"\"\"\n    from Compiler.library import exp\n\n    # Initialize the result with the value for positive x\n    result = x\n\n    condition = (x <= 0)  # The condition for applying the ELU for non-positive x\n\n    # Oblivious transformation\n    # Note: In MP-SPDZ, exp(x) will be used instead of math.exp(x)\n    result = condition * (exp(x) - 1) + (1 - condition) * result\n\n    # Return the computed result\n    return result\n", "prompt_token_1": 1823, "completion_token_1": 576}
{"test_name": "relu", "response_0": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    # Initialize the result to 0, which is the ReLU output for non-positive inputs.\n    result = 0\n\n    # The condition for outputting x is `x > 0`, otherwise the output is 0.\n    condition = (x > 0)\n\n    # Apply transformation based on condition\n    # Multiplication by a condition acts as an if statement.\n    result = condition * x\n\n    # Return the result, which is either x if x > 0, or 0 otherwise.\n    return result\n", "prompt_token_0": 1803, "completion_token_0": 501, "response_1": "def relu(x):\n    \"\"\"\n    ReLU function\n    \"\"\"\n    # Use a condition to represent the ReLU operation without an if statement.\n    # The condition is 1 when x > 0, and 0 otherwise.\n    condition = (x > 0)\n\n    # The result is x when the condition is true (x > 0), and 0 otherwise.\n    # This is done by multiplying x by the condition.\n    result = condition * x\n\n    # Return the result, which is either x when x > 0 or 0 otherwise.\n    return result\n", "prompt_token_1": 1806, "completion_token_1": 554}
{"test_name": "leaky_relu", "response_0": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n    condition_positive = (x > 0)\n    condition_negative = (x <= 0)\n    \n    # Apply transformations based on conditions\n    result = condition_positive * x + condition_negative * x * alpha\n\n    return result\n", "prompt_token_0": 1796, "completion_token_0": 379, "response_1": "def leaky_relu(x, alpha):\n    \"\"\"\n    ReLU function with a leaking factor alpha. \n    \"\"\"\n\n    # Convert the condition to an oblivious form\n    positive_condition = (x > 0)\n    negative_condition = (x <= 0)\n\n    # Apply transformations based on conditions\n    # Note: Multiplication by a condition acts as an if statement\n    result = positive_condition * x + negative_condition * x * alpha\n\n    return result\n", "prompt_token_1": 1812, "completion_token_1": 422}
{"test_name": "max", "response_0": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    # The condition for `result` to be `b` is `b > a`\n    condition = (b > a)\n\n    # Apply transformation based on condition\n    # Multiplication by a condition acts as an if statement\n    result = condition * b + (1 - condition) * a\n\n    # Return the result which will be the maximum of a and b\n    return result\n    # The code is in an oblivious form since there is no `if` statement (no branch) in the code.\n", "prompt_token_0": 1809, "completion_token_0": 460, "response_1": "def max(a, b):\n    \"\"\"\n    Return the maximum value of the two inputs.\n    \"\"\"\n    # Condition for when b is greater than a\n    condition = (b > a)\n\n    # Oblivious assignment: result is a if condition is false (0), else b\n    result = condition * b + (1 - condition) * a\n\n    # Return the result which holds the maximum value\n    return result\n", "prompt_token_1": 1807, "completion_token_1": 421}
{"test_name": "bowl_shape", "response_0": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Initialize the result with 0, which is the default return value for -1 <= x <= 1\n    result = 0\n\n    # Define the conditions for the different cases\n    condition_greater_than_1 = (x > 1)\n    condition_less_than_neg1 = (x < -1)\n\n    # Apply transformations based on conditions\n    # Here we use multiplication by conditions as a branchless way to apply changes\n    result += condition_greater_than_1 * (x - 1) + condition_less_than_neg1 * (-x - 1)\n\n    # Return the computed result\n    return result\n", "prompt_token_0": 2035, "completion_token_0": 786, "response_1": "def bowl_shape(x):\n    \"\"\"\n    Compute the bowl-shape function:\n    if x>1, return x-1;\n    if x<-1, return -x-1;\n    else, return 0.\n    \"\"\"\n    # Initialize result with 0 for the case where -1 <= x <= 1\n    result = 0\n    \n    # Compute conditions\n    condition_1 = (x > 1)       # The condition for `return x-1` is `x>1`\n    condition_2 = (x < -1)      # The condition for `return -x-1` is `x<-1`\n    \n    # Apply transformations based on conditions\n    result = condition_1 * (x - 1) + condition_2 * (-x - 1)\n\n    return result\n", "prompt_token_1": 2031, "completion_token_1": 665}
{"test_name": "rounded_kinetic_energy", "response_0": "def rounded_kinetic_energy(m,v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer. \n    \"\"\"\n    import math\n    k = m*v**2/2\n    k_int = math.floor(k)\n    return k_int if (k-k_int)<0.5 else k_int+1\n", "prompt_token_0": 789, "completion_token_0": 353, "response_1": "def rounded_kinetic_energy(m, v):\n    \"\"\"\n    Compute the kinetic energy, and round the outcome to the nearest integer.\n    \"\"\"\n    k = m * v ** 2 / 2\n    k_int = int(k)\n    return k_int if (k - k_int) < 0.5 else k_int + 1\n", "prompt_token_1": 786, "completion_token_1": 323}
{"test_name": "danger_test", "response_0": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return origin - damage <= 10\n", "prompt_token_0": 805, "completion_token_0": 331, "response_1": "def danger_test(origin, damage):\n    \"\"\"\n    The Dragon Warrior is punched by his enemy! \n    Given the Dragon Warrior's initial health and the damage he receives, \n    decide whether the situation is dangerous. \n    (If the health left is no more than 10, we say that the situation is dangerous)\n    \"\"\"\n    return origin - damage <= 10\n", "prompt_token_1": 805, "completion_token_1": 309}
{"test_name": "indicated_sum_or_multiply", "response_0": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n\n    # Calculate both the sum and the product of x and y\n    sum_xy = x + y\n    product_xy = x * y\n\n    # Use the indicator to select between the sum and the product\n    # Multiplication by a boolean will convert the boolean to an integer (True -> 1, False -> 0)\n    result = ind * sum_xy + (1 - ind) * product_xy\n\n    # Return the final result, ensuring there is only one return statement at the end of the code\n    return result\n", "prompt_token_0": 1934, "completion_token_0": 634, "response_1": "def indicated_sum_or_multiply(x, y, ind):\n    \"\"\"\n    If the indicator is True, return the sum of the two inputs, \n    otherwise return the product of the inputs. \n    \"\"\"\n    # Calculate both sum and product\n    sum_xy = x + y\n    product_xy = x * y\n\n    # Oblivious choice: multiply each option by the indicator or its negation\n    result = ind * sum_xy + (1 - ind) * product_xy\n\n    return result\n", "prompt_token_1": 1933, "completion_token_1": 633}
{"test_name": "median", "response_0": "def median(arr):\n    \"\"\"\n    Return the median of the array. \n    Check first whether the array is empty\n    \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"The length of the array is 0!\")\n    arr.sort()\n    ret = 0\n    if len(arr) % 2: \n        ret = arr[len(arr) // 2]\n    else:\n        ret = (arr[len(arr) // 2] + arr[len(arr) // 2 - 1]) / 2\n    return ret\n", "prompt_token_0": 1535, "completion_token_0": 721, "response_1": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            # Calculate the condition and cast it to an integer (0 or 1)\n            condition = arr[j] > arr[j+1]\n            \n            # Oblivious swapping\n            temp = arr[j] * (1 - condition) + arr[j+1] * condition\n            arr[j+1] = arr[j] * condition + arr[j+1] * (1 - condition)\n            arr[j] = temp\n", "prompt_token_1": 1558, "completion_token_1": 938}
{"test_name": "add_upto_10", "response_0": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    # Initialize result with the sum of a and b.\n    sum_ab = a + b\n\n    # Define condition for clipping\n    condition = (sum_ab > 10)\n\n    # Clip the result to 10 if the condition is true, otherwise keep the sum\n    result = condition * 10 + (1 - condition) * sum_ab\n\n    # Return the result, which is either the sum or clipped to 10.\n    return result\n", "prompt_token_0": 1903, "completion_token_0": 531, "response_1": "def add_upto_10(a, b):\n    \"\"\"\n    Return the value of a+b, if the sum exceeds 10, clip it to 10.\n    \"\"\"\n    # Initialize result with the sum of a and b.\n    result = a + b\n\n    # Calculate condition for when the sum exceeds 10\n    condition = (result > 10)\n\n    # Using the condition, clip the result to 10 if necessary\n    result = condition * 10 + (1 - condition) * result\n\n    # Return the result, ensuring that there's only one return statement.\n    return result\n", "prompt_token_1": 1902, "completion_token_1": 503}
{"test_name": "taxi_fare", "response_0": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 miles.\n    The part in [5,10] is charged with 1.2 dollars per mile.\n    The part in [10,+INF] is charged with 1.5 dollars per mile. \n    \"\"\"\n    # Initialize fare with the base fare\n    fare = 5\n\n    # Calculate additional fare based on the distance\n    if m > 5 and m <= 10:\n        fare += 1.2 * (m - 5)\n    elif m > 10:\n        fare += (5 * 1.2) + 1.5 * (m - 10)\n\n    # There is only one single `return` statement at the end of the code.\n    return fare\n", "prompt_token_0": 2321, "completion_token_0": 1061, "response_1": "def taxi_fare(m):\n    \"\"\"\n    Compute the taxi fare given the miles it covers. \n    The rule is the following:\n    Base fare: 5, which can cover the first 5 files.\n    The part in [5,10] is charged with 1.2 dollar per mile.\n    The part in [10,+INF] is charged with 1.5 dollar per mile. \n    \"\"\"\n    # Initialize the fare with the base fare.\n    fare = 5\n    \n    # Conditions for additional charges\n    condition_1 = (m > 5) and (m <= 10)   # The condition for the charge in [5,10]\n    condition_2 = (m > 10)                # The condition for the charge above 10\n\n    # Calculate the additional charge for each segment\n    additional_charge_1 = condition_1 * 1.2 * (m - 5)\n    additional_charge_2 = condition_2 * (11 + 1.5 * (m - 10) - fare)\n\n    # Calculate the total fare\n    fare += additional_charge_1 + additional_charge_2\n    \n    # Return the computed fare.\n    return fare\n", "prompt_token_1": 2732, "completion_token_1": 1319}
{"test_name": "round", "response_0": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    import math\n    x_int = math.floor(x)\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "prompt_token_0": 727, "completion_token_0": 288, "response_1": "def round(x):\n    \"\"\"\n    Round x to the nearest integer. \n    \"\"\"\n    import math\n    x_int = math.floor(x)\n    return x_int if (x - x_int) < 0.5 else x_int + 1\n", "prompt_token_1": 727, "completion_token_1": 257}
{"test_name": "gpa_calculator", "response_0": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    # Initialize gpa with the lowest possible value, assuming score < 70\n    gpa = 2.3\n\n    # Check the conditions and update the gpa accordingly\n    if 90 <= score:\n        gpa = 4.0\n    elif 85 <= score:\n        gpa = 3.6\n    elif 80 <= score:\n        gpa = 3.3\n    elif 75 <= score:\n        gpa = 3.0\n    elif 70 <= score:\n        gpa = 2.6\n\n    # Return the calculated GPA\n    return gpa\n", "prompt_token_0": 2547, "completion_token_0": 1219, "response_1": "def gpa_calculator(score):\n    \"\"\"\n    Return the GPA according to the score. \n    [90,100]: 4.0\n    [85,90): 3.6\n    [80,85): 3.3\n    [75,80): 3.0\n    [70,75): 2.6\n    [0,70): 2.3\n    The input is guaranteed to be in the range [0,100]\n    \"\"\"\n    # Initialize the GPA with the lowest possible value\n    gpa = 2.3\n\n    # Check the conditions and update the GPA accordingly\n    if score >= 90:\n        gpa = 4.0\n    elif score >= 85:\n        gpa = 3.6\n    elif score >= 80:\n        gpa = 3.3\n    elif score >= 75:\n        gpa = 3.0\n    elif score >= 70:\n        gpa = 2.6\n    # No need for the last condition, since gpa is already initialized to 2.3\n\n    # Return the calculated GPA\n    return gpa\n", "prompt_token_1": 2562, "completion_token_1": 1278}
{"test_name": "sign", "response_0": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    # Initialize result with 0, which is the return value when x is zero.\n    result = 0\n\n    # Define the conditions for returning 1 and -1\n    condition_positive = (x > 0)\n    condition_negative = (x < 0)\n\n    # Apply transformations based on conditions\n    # Multiplication by a condition acts as an if statement\n    result = condition_positive * 1 + condition_negative * (-1)\n\n    # Return the result with only one return statement at the end of the code.\n    return result\n", "prompt_token_0": 1990, "completion_token_0": 605, "response_1": "def sign(x):\n    \"\"\"\n    If x is not zero, return 1 if x>0, and return -1 if x<0. \n    If x is zero, return 0.\n    \"\"\"\n    # Initialize a result variable\n    result = 0\n\n    # Define conditions\n    condition_positive = (x > 0)\n    condition_negative = (x < 0)\n\n    # Update the result based on conditions using oblivious form\n    result = condition_positive * 1 + condition_negative * (-1)\n\n    # Return the result\n    return result\n", "prompt_token_1": 1982, "completion_token_1": 669}
{"test_name": "sum_or_difference", "response_0": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n\n    # The condition for when a is less than or equal to b.\n    condition_leq = (a <= b)\n\n    # The condition for when a is greater than b.\n    condition_gt = (a > b)\n\n    # The result is either the sum or the difference, depending on the condition.\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition_leq * (a + b) + condition_gt * (a - b)\n\n    # Return the final result.\n    return result\n    # The code is in an oblivious form since there is no `if` statement (no branch) in the code.\n", "prompt_token_0": 1910, "completion_token_0": 629, "response_1": "def sum_or_difference(a, b):\n    \"\"\"\n    If the first input is less than or equal to the second input, \n    return their sum, otherwise return their difference. \n    \"\"\"\n    # Initialize condition\n    condition = (a <= b)\n    \n    # Compute both sum and difference\n    sum_values = a + b\n    diff_values = a - b\n    \n    # Use the condition to determine which result to return\n    result = condition * sum_values + (1 - condition) * diff_values\n    \n    # Return the result with a single return statement\n    return result\n", "prompt_token_1": 1901, "completion_token_1": 618}
{"test_name": "CNOT", "response_0": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit. \n    \"\"\"\n    # Calculate the result in an oblivious way without explicit if statements\n    result = (1 - control_bit) * flip_bit + control_bit * (1 - flip_bit)\n    \n    return result\n", "prompt_token_0": 1851, "completion_token_0": 620, "response_1": "def CNOT(control_bit, flip_bit):\n    \"\"\"\n    Simulate the CNOT gate in a quantum circuit. \n    \"\"\"\n    return (not flip_bit) if control_bit else flip_bit\n", "prompt_token_1": 699, "completion_token_1": 249}
{"test_name": "negative_plus1", "response_0": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n    # Initialize the result to y for cases where y is not negative\n    result = y\n\n    # Calculate conditions\n    condition_negative = (y < 0)\n\n    # Apply transformations based on conditions\n    result = condition_negative * (y + 1) + (1 - condition_negative) * y\n\n    # Return the calculated result\n    return result\n", "prompt_token_0": 1820, "completion_token_0": 473, "response_1": "def negative_plus1(y):\n    \"\"\"\n    Return y+1 if y is negative, otherwise return y\n    \"\"\"\n\n    # The condition for `return y+1` is `y < 0`\n    condition = (y < 0)\n\n    # Apply transformation based on the condition\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition * (y + 1) + (1 - condition) * y\n\n    # Return the final result.\n    return result\n", "prompt_token_1": 1820, "completion_token_1": 510}
{"test_name": "is_a_parallelogram", "response_0": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n    \n    # Initialize the result to 0 as a default condition (equivalent to False)\n    result = 0\n\n    # Check if any two points are the same\n    no_same_points = 1 - (same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d))\n    \n    # Check if the sum of the vectors are equal in any combination\n    condition_1 = (a[0] + b[0] == c[0] + d[0] and a[1] + b[1] == c[1] + d[1])\n    condition_2 = (a[0] + c[0] == b[0] + d[0] and a[1] + c[1] == b[1] + d[1])\n    condition_3 = (a[0] + d[0] == b[0] + c[0] and a[1] + d[1] == b[1] + c[1])\n    \n    # Combine the conditions using logical operations\n    result = no_same_points * (condition_1 or condition_2 or condition_3)\n    \n    # Return the result, converting it to Boolean\n    return bool(result)\n", "prompt_token_0": 2789, "completion_token_0": 1699, "response_1": "def is_a_parallelogram(a, b, c, d):\n    \"\"\"\n    Given four vertices, \n    return whether the four vertices can form a parallelogram. \n    \"\"\"\n    def same(x, y):\n        return x[0] == y[0] and x[1] == y[1]\n\n    # Initialize result as False assuming it is not a parallelogram\n    result = False\n\n    # Check if any two vertices are the same, which would mean it cannot be a parallelogram\n    if not (same(a, b) or same(a, c) or same(a, d) or same(b, c) or same(b, d) or same(c, d)):\n        # If no vertices are the same, check if the midpoints of the diagonals are the same\n        result = (a[0] + b[0] == c[0] + d[0] and a[1] + b[1] == c[1] + d[1]) or \\\n                 (a[0] + c[0] == b[0] + d[0] and a[1] + c[1] == b[1] + d[1]) or \\\n                 (a[0] + d[0] == b[0] + c[0] and a[1] + d[1] == b[1] + c[1])\n\n    # Return the result\n    return result\n", "prompt_token_1": 2777, "completion_token_1": 1655}
{"test_name": "min", "response_0": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    # Initialize result with a, it will be returned if a is less than or equal to b.\n    result = a\n    \n    # Calculate the condition for when b is less than a.\n    condition = (b < a)\n    \n    # Update the result to b if the condition is true, otherwise keep it as a.\n    result = condition * b + (1 - condition) * a\n    \n    # Return the result, which is the minimum of a and b.\n    return result\n", "prompt_token_0": 1823, "completion_token_0": 432, "response_1": "def min(a, b):\n    \"\"\"\n    Return the minimum value of the two inputs.\n    \"\"\"\n    # Initialize the result with one of the inputs.\n    result = a\n\n    # Calculate condition for when b is less than a.\n    condition = (a > b)\n\n    # Apply transformations based on conditions\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition * b + (1 - condition) * a\n\n    # Return the result, which is the minimum of a and b.\n    return result\n", "prompt_token_1": 1809, "completion_token_1": 506}
{"test_name": "choice_of_the_knight", "response_0": "def choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x, y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = 0\n\n    def legal(a, b):\n        return ((a >= 0) and (a <= 7) and (b >= 0) and (b <= 7))\n\n    # Calculate conditions for each of the knight's potential moves\n    condition_1 = legal(x + 1, y + 2)\n    condition_2 = legal(x - 1, y + 2)\n    condition_3 = legal(x + 1, y - 2)\n    condition_4 = legal(x - 1, y - 2)\n    condition_5 = legal(x + 2, y + 1)\n    condition_6 = legal(x - 2, y + 1)\n    condition_7 = legal(x + 2, y - 1)\n    condition_8 = legal(x - 2, y - 1)\n\n    # Use conditions to increment counter obliviously\n    # Note: Adding a condition value (0 or 1) is like conditionally incrementing the counter.\n    counter += condition_1\n    counter += condition_2\n    counter += condition_3\n    counter += condition_4\n    counter += condition_5\n    counter += condition_6\n    counter += condition_7\n    counter += condition_8\n\n    # Return the total count of legal moves\n    return counter\n    # The code is in an oblivious form since there is no `if` statement (no branch) in the code.\n", "prompt_token_0": 3317, "completion_token_0": 2049, "response_1": "def choice_of_the_knight(x, y):\n    \"\"\"\n    Use the pair with elements 0-7 to represent the position on the chess board. \n    Here is a knight on position (x, y) of an empty chess board. \n    You should return how many positions on the chess board the knight can reach. \n    \"\"\"\n    counter = 0\n\n    # Define the function 'legal' to check if the position is within the chess board\n    def legal(a, b):\n        return a >= 0 and a <= 7 and b >= 0 and b <= 7\n\n    # Check each possible move of the knight and update the counter if the move is legal\n    counter += legal(x + 1, y + 2)\n    counter += legal(x - 1, y + 2)\n    counter += legal(x + 1, y - 2)\n    counter += legal(x - 1, y - 2)\n    counter += legal(x + 2, y + 1)\n    counter += legal(x - 2, y + 1)\n    counter += legal(x + 2, y - 1)\n    counter += legal(x - 2, y - 1)\n\n    # Return the total counter which represents the number of positions the knight can reach\n    return counter\n", "prompt_token_1": 3438, "completion_token_1": 2004}
{"test_name": "max_sum_difference", "response_0": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n    # Compute both possible outcomes\n    sum_ab = a + b\n    diff_ab = a - b\n\n    # Determine if a + b is greater than a - b\n    condition = (a + b > a - b)\n\n    # The result is the maximum value between a + b and a - b.\n    # Note: Multiplication by a condition acts as an if statement\n    result = condition * sum_ab + (1 - condition) * diff_ab\n\n    # Return the final result, which is the maximum value between a + b and a - b.\n    return result\n", "prompt_token_0": 1863, "completion_token_0": 518, "response_1": "def max_sum_different(a, b):\n    \"\"\"\n    Return the maximum value between a+b and a-b.\n    \"\"\"\n\n    # Compute both possible sums\n    sum_ab = a + b\n    diff_ab = a - b\n\n    # Compute the condition for when sum_ab is greater than diff_ab\n    condition = (sum_ab > diff_ab)\n\n    # Calculate the result based on the condition\n    # If the condition is true, use sum_ab, otherwise use diff_ab\n    result = condition * sum_ab + (1 - condition) * diff_ab\n\n    # Return the result, which is the maximum of a + b and a - b.\n    return result\n", "prompt_token_1": 1857, "completion_token_1": 513}
