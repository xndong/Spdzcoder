{"test_name": "array_from_intrinsic_linspace", "response_0": "import numpy as np\n\nstart = 0\nend = 99\nnum = 10\n\n# Manually create the array that replicates np.linspace functionality\nstep = (end - start) / (num - 1)\na = np.array([start + i * step for i in range(num)])\n", "prompt_token_0": 2473, "completion_token_0": 272, "response_1": "import numpy as np\n\nstart = 0\nend = 99\nnum = 10\n\n# Manually calculate the step size and create the array using a basic Python range and np.array\nstep = (end - start) / (num - 1)\na = np.array([start + i * step for i in range(num)])\n", "prompt_token_1": 2473, "completion_token_1": 292}
{"test_name": "more_positive", "response_0": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    import numpy as np\n    signs = []\n    for value in arr:\n        condition_positive = value > 0\n        condition_negative = value < 0\n        condition_zero = value == 0\n\n        # Using condition multiplication and addition to simulate if-else logic\n        sign_value = condition_positive * 1 + condition_negative * (-1) + condition_zero * 0\n        signs.append(sign_value)\n    \n    count = sum(signs)\n    result = count > 0\n    return result\n\n", "prompt_token_0": 3282, "completion_token_0": 681, "response_1": "def more_positive(arr):\n    \"\"\"\n    Return whether there are more positive numbers in the given array.\n    \"\"\"\n    count = 0\n    for num in arr:\n        condition_positive = (num > 0)\n        condition_negative = (num < 0)\n        \n        # Increment or decrement count based on conditions\n        count += condition_positive * 1 + condition_negative * -1\n\n    result = (count > 0)\n    return result\n\n", "prompt_token_1": 3186, "completion_token_1": 643}
{"test_name": "select", "response_0": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    import numpy as np\n    return np.where(ind, a, b)\n", "prompt_token_0": 2521, "completion_token_0": 310, "response_1": "def select(ind, a, b):\n    \"\"\"\n    Select elements from the two arrays, the array elements are float data.\n    \"\"\"\n    import numpy as np\n    return np.where(ind, a, b)\n\n", "prompt_token_1": 2521, "completion_token_1": 322}
{"test_name": "np_relu", "response_0": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    import numpy as np\n    return np.maximum(y, 0)\n", "prompt_token_0": 2476, "completion_token_0": 184, "response_1": "def relu(y):\n    \"\"\"\n    Compute the ReLU function.\n    \"\"\"\n    import numpy as np\n    return np.maximum(y, 0)\n\n", "prompt_token_1": 2476, "completion_token_1": 232}
{"test_name": "cost_matrix", "response_0": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    import numpy as np\n    matrix_shape = profit_matrix.shape\n    max_profit = profit_matrix.max()\n    offset_matrix = np.full(matrix_shape, max_profit)  # Create an array filled with max_profit\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n", "prompt_token_0": 2609, "completion_token_0": 522, "response_1": "def cost_matrix(profit_matrix):\n    \"\"\"\n    Converts a profit matrix into a cost matrix.\n    \"\"\"\n    import numpy as np\n    matrix_shape = profit_matrix.shape\n    max_value = profit_matrix.max()\n    offset_matrix = np.full(matrix_shape, max_value)\n    cost_matrix = offset_matrix - profit_matrix\n    return cost_matrix\n", "prompt_token_1": 2609, "completion_token_1": 419}
{"test_name": "np_zeros", "response_0": "import numpy as np\n\n\"\"\"Create 1-dim all-zero array with length 10.\"\"\"\nn = 10\na = np.zeros(n)\n\n", "prompt_token_0": 2463, "completion_token_0": 129, "response_1": "\"\"\"Create 1-dim all-zero array with length 10.\"\"\"\nimport numpy as np\n\nn = 10\na = np.zeros(n)\n\n\n", "prompt_token_1": 2463, "completion_token_1": 128}
{"test_name": "np_basic_dimensional_row_indexing", "response_0": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index][:]\n    return array\n\n", "prompt_token_0": 2545, "completion_token_0": 315, "response_1": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index][:]\n    return array\n\n", "prompt_token_1": 2545, "completion_token_1": 375}
{"test_name": "np_zeros_2", "response_0": "# plain text variables: n\ndef zeros(n):\n    import numpy as np\n    return np.zeros(n)\n\n\n", "prompt_token_0": 2445, "completion_token_0": 171, "response_1": "# plain text variables: n\ndef zeros(n):\n    import numpy as np\n    return np.zeros(n)\n\n\n", "prompt_token_1": 2445, "completion_token_1": 152}
{"test_name": "np_basic_slicing_stride", "response_0": "import numpy as np\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatenate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    viewA = ndarrayA[0:len(ndarrayA):2]\n    viewB = ndarrayB[1:len(ndarrayB):2]\n    array = np.concatenate((viewA, viewB))\n    return array\n\n", "prompt_token_0": 2766, "completion_token_0": 512, "response_1": "import numpy as np\ndef array_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatnate elements from two 1-D arrays. Concretely, collect all the even index elements from the first array and collect all the odd index elements from the second array.\n    \"\"\"\n    viewA = ndarrayA[::2]\n    viewB = ndarrayB[1::2]\n    array = np.concatenate((viewA, viewB))\n    return array\n", "prompt_token_1": 2765, "completion_token_1": 489}
{"test_name": "QR_decomposition", "response_0": "def QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    import numpy as np\n    q, _ = np.linalg.qr(mat)\n    return q\n\n", "prompt_token_0": 2537, "completion_token_0": 296, "response_1": "def QR_decomposition(mat):\n    \"\"\"\n    Return the Q matrix of the QR-decomposition of the input matrix\n    \"\"\"\n    import numpy as np\n    qr_result = np.linalg.qr(mat)\n    q = qr_result[0]\n    return q\n\n", "prompt_token_1": 2544, "completion_token_1": 264}
{"test_name": "find_nearest_index", "response_0": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    import numpy as np\n    differences = array - value\n    squared_differences = differences ** 2\n    sqrt_differences = np.sqrt(squared_differences)\n    idx = sqrt_differences.argmin()\n    return idx\n\n", "prompt_token_0": 2591, "completion_token_0": 387, "response_1": "def find_nearest_index(array, value):\n    \"\"\"\n    Return the index of nearest value in an array to the given value\n    \"\"\"\n    import numpy as np\n    min_diff = float('inf')\n    idx = -1\n    for i in range(len(array)):\n        diff = np.abs(array[i] - value)\n        condition = (diff < min_diff)\n        min_diff = condition * diff + (1 - condition) * min_diff\n        idx = condition * i + (1 - condition) * idx\n    return idx\n\n", "prompt_token_1": 3233, "completion_token_1": 558}
{"test_name": "np_concat_simple_row", "response_0": "import numpy as np\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatenate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    array = np.concatenate((ndarrayA, ndarrayB), axis=0)\n    return array\n\n", "prompt_token_0": 2609, "completion_token_0": 376, "response_1": "import numpy as np\ndef array_simple_concate_rows(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatnate elements from two 2-D arrays along axis 0.\n    \"\"\"\n    array = np.concatenate((ndarrayA, ndarrayB), axis=0)\n    return array\n\n", "prompt_token_1": 2613, "completion_token_1": 355}
{"test_name": "np_copy", "response_0": "def array_copy(ndarray):\n    array = ndarray.copy()\n    return array\n\n\n", "prompt_token_0": 2417, "completion_token_0": 126, "response_1": "def array_copy(ndarray):\n    array = ndarray.copy()\n    return array\n\n", "prompt_token_1": 2417, "completion_token_1": 170}
{"test_name": "max_pooling", "response_0": "import numpy as np\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max pooling.\n    \"\"\"\n    out = np.zeros([x.shape[0], x.shape[1] // stride, x.shape[2] // stride])\n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                out[b, i // stride, j // stride] = np.max(x[b, i:i+stride, j:j+stride])\n    return out\n", "prompt_token_0": 2857, "completion_token_0": 618, "response_1": "import numpy as np\n\ndef max_pooling(x, stride):\n    \"\"\"\n    Compute the max-max_pooling.\n    \"\"\"\n    out = np.zeros([x.shape[0], x.shape[1] // stride, x.shape[2] // stride])\n    for b in range(x.shape[0]):\n        for i in range(0, x.shape[1], stride):\n            for j in range(0, x.shape[2], stride):\n                out[b, i // stride, j // stride] = np.max(x[b, i:i+stride, j:j+stride])\n    return out\n\n", "prompt_token_1": 2861, "completion_token_1": 765}
{"test_name": "array_reshape", "response_0": "import numpy as np\n\n# Using np.array to create the array with the desired shape directly\na = np.array([[i + j * 5 for i in range(5)] for j in range(3)])\n", "prompt_token_0": 2426, "completion_token_0": 256, "response_1": "import numpy as np\n\n# Create a 1D array using arange\na_1d = np.arange(15)\n\n# Manually reshape to a 3x5 array using simple array indexing/slicing\na = np.zeros((3, 5))\nfor i in range(3):\n    a[i, :] = a_1d[i*5:(i+1)*5]\n", "prompt_token_1": 2425, "completion_token_1": 266}
{"test_name": "np_concat_simple_column", "response_0": "import numpy as np\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    array = np.concatenate((ndarrayA, ndarrayB), axis=1)\n    return array\n\n", "prompt_token_0": 2609, "completion_token_0": 378, "response_1": "import numpy as np\n\ndef array_simple_concate_column(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatenate elements from two 2-D arrays along axis 1.\n    \"\"\"\n    array = np.concatenate((ndarrayA, ndarrayB), axis=1)\n    return array\n", "prompt_token_1": 2609, "completion_token_1": 438}
{"test_name": "np_basic_dimensional_column_indexing", "response_0": "import numpy as np\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    NumPy program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Correctly indexing the i-th column from the 2-D array\n    array = ndarray[:, column_index]\n    return array\n\n\n", "prompt_token_0": 2579, "completion_token_0": 352, "response_1": "import numpy as np\n\ndef array_dimensional_indexing(ndarray, column_index):\n    \"\"\"\n    NumPy program to index i-th column from 2-D arrays.\n    \"\"\"\n    # Correctly indexing to get the specified column\n    array = ndarray[:, column_index]\n    return array\n\n", "prompt_token_1": 2569, "completion_token_1": 466}
{"test_name": "np_diagonal", "response_0": "def diag(array):\n    import numpy as np\n    # Manually extract the diagonal elements of the array\n    diag = np.array([array[i, i] for i in range(min(array.shape[0], array.shape[1]))])\n    return diag\n", "prompt_token_0": 2441, "completion_token_0": 227, "response_1": "def diag(array):\n    import numpy as np\n    # Manually extracting the diagonal elements\n    length = min(array.shape[0], array.shape[1])\n    diag = np.array([array[i, i] for i in range(length)])\n    return diag\n", "prompt_token_1": 2441, "completion_token_1": 205}
{"test_name": "np_concat_special", "response_0": "import numpy as np\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatenate elements from two 2-D arrays along axis 1. Concretely, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Correcting the slicing to get even index columns from ndarrayA (0, 2, 4, ...) and odd index columns from ndarrayB (1, 3, 5, ...)\n    even_columns_A = ndarrayA[:, ::2]  # even index columns: 0, 2, 4, ...\n    odd_columns_B = ndarrayB[:, 1::2]  # odd index columns: 1, 3, 5, ...\n    \n    # Concatenate the extracted columns along axis 1\n    concatenated_array = np.concatenate((even_columns_A, odd_columns_B), axis=1)\n    \n    return concatenated_array\n\n", "prompt_token_0": 2973, "completion_token_0": 940, "response_1": "import numpy as np\n\ndef array_special_concate(ndarrayA, ndarrayB):\n    \"\"\"\n    NumPy program to concatenate elements from two 2-D arrays along axis 1. Specifically, collect all the even columns from the first array and collect all the odd columns from the second array.\n    \"\"\"\n    # Collect even columns from ndarrayA (0-based index; even columns are 0, 2, 4, ...)\n    viewA = ndarrayA[:, [i for i in range(ndarrayA.shape[1]) if i % 2 == 0]]\n    \n    # Collect odd columns from ndarrayB (0-based index; odd columns are 1, 3, 5, ...)\n    viewB = ndarrayB[:, [i for i in range(ndarrayB.shape[1]) if i % 2 == 1]]\n    \n    # Concatenate the selected columns from both arrays along axis 1\n    array = np.concatenate((viewA, viewB), axis=1)\n    \n    return array\n", "prompt_token_1": 2959, "completion_token_1": 999}
{"test_name": "np_arange", "response_0": "# plain text variables: start, stop, step\ndef arange(start, stop=None, step=1):\n    \"\"\"\n    create a 1-d numpy array by calling intrinsic numpy function numpy.arange\n    \"\"\"\n    # Oblivious handling of 'stop' being None\n    condition = (stop is None)\n    stop = condition * start + (1 - condition) * stop\n    start = condition * 0 + (1 - condition) * start\n\n    import numpy as np\n    array = np.arange(start, stop, step)\n    return array\n\n", "prompt_token_0": 3321, "completion_token_0": 605, "response_1": "# plain text variables: start, stop, step\ndef arange(start, stop=None, step=1):\n    \"\"\"\n    create a 1-d numpy array by calling intrinsic numpy function numpy.arange\n    \"\"\"\n    # Oblivious condition handling\n    stop = (stop is None) * start + (stop is not None) * stop\n    start = (stop is None) * 0 + (stop is not None) * start\n\n    import numpy as np\n    array = np.arange(start, stop, step)\n    return array\n\n", "prompt_token_1": 3318, "completion_token_1": 566}
{"test_name": "np_eye_2", "response_0": "import numpy as np\n\n\"\"\"Create a non-square 2-dim array with all one in diagonal.\"\"\"\nm = 3\nn = 5\n\n# Create a zero-filled array with dimensions m x n\na = np.zeros((m, n))\n\n# Set the diagonal elements to one\nfor i in range(min(m, n)):\n    a[i, i] = 1\n", "prompt_token_0": 2499, "completion_token_0": 360, "response_1": "import numpy as np\n\nm = 3\nn = 5\na = np.zeros((m, n))  # Initialize a 3x5 array filled with zeros\n\nfor i in range(min(m, n)):\n    a[i][i] = 1\n\n", "prompt_token_1": 2533, "completion_token_1": 336}
{"test_name": "third_smallest", "response_0": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Use oblivious swapping\n            condition = arr[i] > arr[j]\n            temp = arr[i]\n            arr[i] = condition * arr[j] + (1 - condition) * arr[i]\n            arr[j] = condition * temp + (1 - condition) * arr[j]\n    return arr[2]\n\n", "prompt_token_0": 3182, "completion_token_0": 610, "response_1": "def third_smallest(arr):\n    \"\"\"\n    Return the third smallest element in the array\n    \"\"\"\n    import numpy as np\n    sorted_arr = sorted(arr)  # Using Python's built-in sorted function\n    return sorted_arr[2]\n", "prompt_token_1": 2509, "completion_token_1": 320}
{"test_name": "np_basic_dimensional_row_indexing_3", "response_0": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index, :]\n    return array\n", "prompt_token_0": 2549, "completion_token_0": 297, "response_1": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index]\n    return array\n\n", "prompt_token_1": 2547, "completion_token_1": 304}
{"test_name": "array_from_intrinsic_arange", "response_0": "import numpy as np\nn = 10\na = np.arange(n)\n\n", "prompt_token_0": 2417, "completion_token_0": 226, "response_1": "import numpy as np\nn = 10\na = np.arange(n)\n\n", "prompt_token_1": 2417, "completion_token_1": 166}
{"test_name": "np_basic_dimensional_row_indexing_2", "response_0": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index, :]\n    return array\n\n", "prompt_token_0": 2546, "completion_token_0": 303, "response_1": "import numpy as np\ndef array_dimensional_indexing(ndarray, row_index):\n    \"\"\"\n    NumPy program to index i-th row from 2-D arrays.\n    \"\"\"\n    array = ndarray[row_index, :]\n    return array\n\n", "prompt_token_1": 2546, "completion_token_1": 412}
{"test_name": "array_from_python_structure", "response_0": "\"\"\"Create 1-dim array with length 5 by converting from python built-in structures.\"\"\"\na_l = [0,10,20,30,40]\na = np.array(a_l)\n\n\n", "prompt_token_0": 2517, "completion_token_0": 214, "response_1": "import numpy as np\n\n# Manually creating a list\na_l = [0, 10, 20, 30, 40]\n\n# Converting list to a numpy array\na = np.array(a_l)\n\n", "prompt_token_1": 2529, "completion_token_1": 193}
{"test_name": "np_reshape", "response_0": "import numpy as as\n\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    NumPy program to reshape a numpy array.\n    \"\"\"\n    # Create a new array of zeros with the desired shape\n    array = np.zeros((m, n))\n\n    # Fill the new array with elements from the original array\n    for i in range(m):\n        for j in range(n):\n            array[i, j] = ndarray[i * n + j]\n\n    return array\n", "prompt_token_0": 2523, "completion_token_0": 321, "response_1": "import numpy as np\ndef array_reshape(ndarray, m, n):\n    \"\"\"\n    NumPy program to reshape a numpy array.\n    \"\"\"\n    # Create a new array with the specified shape (m, n) using basic array creation\n    array = np.zeros((m * n), dtype=ndarray.dtype)\n    array[:len(ndarray)] = ndarray.flat\n    array = array.reshape((m, n))\n    return array\n", "prompt_token_1": 2523, "completion_token_1": 336}
{"test_name": "np_ones", "response_0": "import numpy as np\n\n\"\"\"Create 1-dim all-one array with length 10.\"\"\"\nn = 10\na = np.ones(n)\n\n", "prompt_token_0": 2465, "completion_token_0": 180, "response_1": "import numpy as np\n\n\"\"\"Create 1-dim all-one array with length 10.\"\"\"\nn = 10\na = np.ones(n)\n", "prompt_token_1": 2466, "completion_token_1": 170}
{"test_name": "set_one_to_zero", "response_0": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    for i in range(len(y)):\n        # Oblivious condition: y[i] == 1\n        condition = (y[i] == 1)\n        # If condition is true, replace y[i] with 0\n        y[i] = condition * 0 + (1 - condition) * y[i]\n    return y\n\n", "prompt_token_0": 3129, "completion_token_0": 381, "response_1": "def set_one_to_zero(y):\n    \"\"\"\n    Set the ones in the array into zeros.\n    \"\"\"\n    for i in range(len(y)):\n        condition = (y[i] == 1)  # Condition for y[i] to be set to 0\n        y[i] = condition * 0 + (1 - condition) * y[i]  # Obliviously set the value\n\n    return y\n\n", "prompt_token_1": 3123, "completion_token_1": 423}
{"test_name": "np_eye", "response_0": "import numpy as np\n\nn = 10\na = np.zeros((n, n))  # Create a square matrix of zeros with dimensions n x n\n\n# Manually set the diagonal elements to 1\nfor i in range(n):\n    a[i, i] = 1\n", "prompt_token_0": 2440, "completion_token_0": 350, "response_1": "import numpy as np\n\nn = 10\n# Create a square matrix of zeros with dimensions n x n\na = np.zeros((n, n))\n\n# Fill the diagonal with ones\nfor i in range(n):\n    a[i, i] = 1\n", "prompt_token_1": 2440, "completion_token_1": 192}
{"test_name": "np_diag", "response_0": "import numpy as np\n\na_l = [1, 3, 5, 2, 4, 6]\n\n# Create a square matrix of zeros with dimensions based on the length of a_l\na = np.zeros((len(a_l), len(a_l)))\n\n# Fill the diagonal with values from a_l\nfor i in range(len(a_l)):\n    a[i, i] = a_l[i]\n", "prompt_token_0": 2445, "completion_token_0": 216, "response_1": "import numpy as np\n\na_l = [1, 3, 5, 2, 4, 6]\na = np.zeros((len(a_l), len(a_l)))\nfor i in range(len(a_l)):\n    a[i, i] = a_l[i]\n", "prompt_token_1": 2450, "completion_token_1": 215}
{"test_name": "np_advanced_integer_indexing", "response_0": "# plain text variables: indices\ndef integer_array_indexing(array, indices):\n    \"\"\"\n    indexing a numpy array from an integer array.\n    \"\"\"\n    import numpy as np\n    # Ensuring indices is a numpy array\n    indices = np.array(indices)\n    # Using basic numpy indexing instead of calling array like a function\n    ret_array = array[indices]\n    return ret_array\n\n", "prompt_token_0": 2623, "completion_token_0": 452, "response_1": "def integer_array_indexing(array, indices):\n    \"\"\"\n    Indexing a numpy array from an integer array.\n    \"\"\"\n    import numpy as np\n    indices = np.array(indices)\n    ret_array = array[indices]  # Corrected indexing syntax\n    return ret_array\n\n", "prompt_token_1": 2577, "completion_token_1": 423}
